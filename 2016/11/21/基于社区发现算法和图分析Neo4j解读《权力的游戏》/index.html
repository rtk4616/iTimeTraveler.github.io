<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Someone knock at the door.">
        <link rel="shortcut icon" href="/gallery/avatar/0.svg"/>
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="Mr.Seven" href="/atom.xml">
        <title>基于社区发现算法和图分析Neo4j解读《权力的游戏》 | iTimeTraveler</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    </head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="/gallery/avatar/0.svg" alt="iTimeTraveler" /></a>
            <h1><a href="/">Mr.Seven</a></h1>
            <p></p>
            <div id="follow-icons">
                  <a href="/atom.xml"><i class="fa fa-rss-square fa-2x"></i></a>
  </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  十一月 21, 2016
  
    <span class="taglist">  &middot; 
    
    
      <a href='/tags/Neo4j/'>Neo4j</a> 
    
    </span>
  

  <h1 class="post-title">基于社区发现算法和图分析Neo4j解读《权力的游戏》</h1>
  <section class="post-content article-entry">
    <h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>几个月前，数学家 Andrew Beveridge 和Jie Shan在数学杂志上发表<a href="http://www.maa.org/sites/default/files/pdf/Mathhorizons/NetworkofThrones.pdf" target="_blank" rel="noopener"><strong>《权力的网络》</strong></a>，主要分析畅销小说《冰与火之歌》第三部《冰雨的风暴》中人物关系，其已经拍成电视剧《权力的游戏》系列。他们在论文中介绍了如何通过文本分析和实体提取构建人物关系的网络。紧接着，使用社交网络分析算法对人物关系网络分析找出最重要的角色；应用社区发现算法来找到人物聚类。</p>
<p>其中的分析和可视化是用Gephi做的，Gephi是非常流行的图分析工具。但作者觉得使用Neo4j来实现更有趣。</p>
<h2 id="导入原始数据到Neo4j"><a href="#导入原始数据到Neo4j" class="headerlink" title="导入原始数据到Neo4j"></a>导入原始数据到Neo4j</h2><p>原始数据可<a href="https://www.macalester.edu/~abeverid/data/stormofswords.csv" target="_blank" rel="noopener">从网络上下载</a>，格式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Source,Target,Weight</span><br><span class="line">Aemon,Grenn,5</span><br><span class="line">Aemon,Samwell,31</span><br><span class="line">Aerys,Jaime,18</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面是人物关系的之邻接表以及关系权重。作者使用简单的数据模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(:Character &#123;name&#125;)-[:INTERACTS]-&gt;(:Character &#123;name&#125;)</span><br></pre></td></tr></table></figure>
<p>带有标签Character的节点代表小说中的角色，用单向关系类型INTERACTS代表小说中的角色有过接触。节点属性会存储角色的名字name，两角色间接触的次数作为关系的属性：权重（weight）。</p>
<p>首先创建节点c，并做唯一限制性约束，c.name唯一，保证schema的完整性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONSTRAINT ON (c:Character) ASSERT c.name IS UNIQUE;</span><br></pre></td></tr></table></figure>
<p>一旦约束创建即相应的创建索引，这将有助于通过角色的名字查询的性能。作者使用Neo4j的Cypher（Cypher是一种声明式图查询语言，能表达高效查询和更新图数据库）LOAD CSV语句导入数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;https://www.macalester.edu/~abeverid/data/stormofswords.csv&quot; AS row</span><br><span class="line">MERGE (src:Character &#123;name: row.Source&#125;)</span><br><span class="line">MERGE (tgt:Character &#123;name: row.Target&#125;)</span><br><span class="line">MERGE (src)-[r:INTERACTS]-&gt;(tgt)</span><br><span class="line">SET r.weight = toInt(row.Weight)</span><br></pre></td></tr></table></figure>
<p>这样得到一个简单的数据模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL apoc.meta.graph()</span><br></pre></td></tr></table></figure>
<p><img src="/gallery/game/1.png" alt="图1 ：《权力的游戏》模型的图。Character角色节点由INTERACTS关系联结"></p>
<p>我们能可视化整个图形，但是这并不能给我们很多信息，比如哪些是最重要的人物，以及他们相互接触的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH p=(:Character)-[:INTERACTS]-(:Character)</span><br><span class="line">RETURN p</span><br></pre></td></tr></table></figure>
<p><img src="/gallery/game/2.jpg" alt="图2"></p>
<h2 id="人物网络分析"><a href="#人物网络分析" class="headerlink" title="人物网络分析"></a>人物网络分析</h2><p>作者使用Neo4j的图查询语言Cypher来做《权力的游戏》图分析，应用到了网络分析的一些工具，具体见《网络，人群和市场：关于高度连接的世界》。</p>
<h3 id="人物数量"><a href="#人物数量" class="headerlink" title="人物数量"></a>人物数量</h3><p>万事以简单开始。先看看上图上由有多少人物：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Character) RETURN count(c)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">count(c)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">107</td>
</tr>
</tbody>
</table>
<h3 id="概要统计"><a href="#概要统计" class="headerlink" title="概要统计"></a>概要统计</h3><p>统计每个角色接触的其它角色的数目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Character)-[:INTERACTS]-&gt;()</span><br><span class="line">WITH c, count(*) AS num</span><br><span class="line">RETURN min(num) AS min, max(num) AS max, avg(num) AS avg_characters, stdev(num) AS stdev</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">min</th>
<th style="text-align:center">max</th>
<th style="text-align:center">avg_characters</th>
<th style="text-align:center">stdev</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">24</td>
<td style="text-align:center">4.957746478873241</td>
<td style="text-align:center">6.227672391875085</td>
</tr>
</tbody>
</table>
<h3 id="图（网络）的直径"><a href="#图（网络）的直径" class="headerlink" title="图（网络）的直径"></a>图（网络）的直径</h3><p>网络的直径或者测底线或者最长最短路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Find maximum diameter of network</span><br><span class="line">// maximum shortest path between two nodes</span><br><span class="line">MATCH (a:Character), (b:Character) WHERE id(a) &gt; id(b)</span><br><span class="line">MATCH p=shortestPath((a)-[:INTERACTS*]-(b))</span><br><span class="line">RETURN length(p) AS len, extract(x IN nodes(p) | x.name) AS path</span><br><span class="line">ORDER BY len DESC LIMIT 4</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">len</th>
<th>path</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td>[Illyrio, Belwas, Daenerys, Robert, Tywin, Oberyn, Amory]</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td>[Illyrio, Belwas, Daenerys, Robert, Sansa, Bran, Jojen]</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td>[Illyrio, Belwas, Daenerys, Robert, Stannis, Davos, Shireen]</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td>[Illyrio, Belwas, Daenerys, Robert, Sansa, Bran, Luwin]</td>
</tr>
</tbody>
</table>
<p>我们能看到网络中有许多长度为6的路径。</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>作者使用Cypher 的shortestPath函数找到图中任意两个角色之间的最短路径。让我们找出凯特琳·史塔克（Catelyn Stark ）和卓戈·卡奥（Kahl Drogo）之间的最短路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Shortest path from Catelyn Stark to Khal Drogo</span><br><span class="line">MATCH (catelyn:Character &#123;name: &quot;Catelyn&quot;&#125;), (drogo:Character &#123;name: &quot;Drogo&quot;&#125;)</span><br><span class="line">MATCH p=shortestPath((catelyn)-[INTERACTS*]-(drogo))</span><br><span class="line">RETURN p</span><br></pre></td></tr></table></figure>
<p><img src="/gallery/game/3.jpg" alt="图3"></p>
<h3 id="所有最短路径"><a href="#所有最短路径" class="headerlink" title="所有最短路径"></a>所有最短路径</h3><p>联结凯特琳·史塔克（Catelyn Stark ）和卓戈·卡奥（Kahl Drogo）之间的最短路径可能还有其它路径，我们可以使用Cypher的allShortestPaths函数来查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// All shortest paths from Catelyn Stark to Khal Drogo</span><br><span class="line">MATCH (catelyn:Character &#123;name: &quot;Catelyn&quot;&#125;), (drogo:Character &#123;name: &quot;Drogo&quot;&#125;)</span><br><span class="line">MATCH p=allShortestPaths((catelyn)-[INTERACTS*]-(drogo))</span><br><span class="line">RETURN p</span><br></pre></td></tr></table></figure>
<p><img src="/gallery/game/4.jpg" alt="图4"></p>
<h3 id="关键节点"><a href="#关键节点" class="headerlink" title="关键节点"></a>关键节点</h3><p>在网络中，如果一个节点位于其它两个节点所有的最短路径上，即称为关键节点。下面我们找出网络中所有的关键节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Find all pivotal nodes in network</span><br><span class="line">MATCH (a:Character), (b:Character)</span><br><span class="line">MATCH p=allShortestPaths((a)-[:INTERACTS*]-(b)) WITH collect(p) AS paths, a, b</span><br><span class="line">MATCH (c:Character) WHERE all(x IN paths WHERE c IN nodes(x)) AND NOT c IN [a,b]</span><br><span class="line">RETURN a.name, b.name, c.name AS PivotalNode SKIP 490 LIMIT 10</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">a.name</th>
<th style="text-align:center">b.name</th>
<th style="text-align:center">PivotalNode</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Aegon</td>
<td style="text-align:center">Thoros</td>
<td style="text-align:center">Daenerys</td>
</tr>
<tr>
<td style="text-align:center">Aegon</td>
<td style="text-align:center">Thoros</td>
<td style="text-align:center">Robert</td>
</tr>
<tr>
<td style="text-align:center">Drogo</td>
<td style="text-align:center">Ramsay</td>
<td style="text-align:center">Robb</td>
</tr>
<tr>
<td style="text-align:center">Styr</td>
<td style="text-align:center">Daario</td>
<td style="text-align:center">Daenerys</td>
</tr>
<tr>
<td style="text-align:center">Styr</td>
<td style="text-align:center">Daario</td>
<td style="text-align:center">Jon</td>
</tr>
<tr>
<td style="text-align:center">Styr</td>
<td style="text-align:center">Daario</td>
<td style="text-align:center">Robert</td>
</tr>
<tr>
<td style="text-align:center">Qhorin</td>
<td style="text-align:center">Podrick</td>
<td style="text-align:center">Jon</td>
</tr>
<tr>
<td style="text-align:center">Qhorin</td>
<td style="text-align:center">Podrick</td>
<td style="text-align:center">Sansa</td>
</tr>
<tr>
<td style="text-align:center">Orell</td>
<td style="text-align:center">Theon</td>
<td style="text-align:center">Jon</td>
</tr>
<tr>
<td style="text-align:center">Illyrio</td>
<td style="text-align:center">Bronn</td>
<td style="text-align:center">Belwas</td>
</tr>
</tbody>
</table>
<p>从结果表格中我们可以看出有趣的结果：罗柏·史塔克（Robb）是卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）的关键节点。这意味着，所有联结卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）的最短路径都要经过罗柏·史塔克（Robb）。我们可以通过可视化卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）之间的所有最短路径来验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (a:Character &#123;name: &quot;Drogo&quot;&#125;), (b:Character &#123;name: &quot;Ramsay&quot;&#125;)</span><br><span class="line">MATCH p=allShortestPaths((a)-[:INTERACTS*]-(b))</span><br><span class="line">RETURN p</span><br></pre></td></tr></table></figure>
<p><img src="/gallery/game/5.jpg" alt="图5"></p>
<h3 id="节点中心度"><a href="#节点中心度" class="headerlink" title="节点中心度"></a>节点中心度</h3><p>节点中心度给出网络中节点的重要性的相对度量。有许多不同的方式来度量中心度，每种方式都代表不同类型的“重要性”。</p>
<h3 id="度中心性-Degree-Centrality"><a href="#度中心性-Degree-Centrality" class="headerlink" title="度中心性(Degree Centrality)"></a>度中心性(Degree Centrality)</h3><p>度中心性是最简单度量，即为某个节点在网络中的联结数。在《权力的游戏》的图中，某个角色的度中心性是指该角色接触的其他角色数。作者使用Cypher计算度中心性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Character)-[:INTERACTS]-()</span><br><span class="line">RETURN c.name AS character, count(*) AS degree ORDER BY degree DESC</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">character</th>
<th style="text-align:center">degree</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Tyrion</td>
<td style="text-align:center">36</td>
</tr>
<tr>
<td style="text-align:center">Jon</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">Sansa</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">Robb</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">Jaime</td>
<td style="text-align:center">24</td>
</tr>
<tr>
<td style="text-align:center">Tywin</td>
<td style="text-align:center">22</td>
</tr>
<tr>
<td style="text-align:center">Cersei</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">Arya</td>
<td style="text-align:center">19</td>
</tr>
<tr>
<td style="text-align:center">Joffrey</td>
<td style="text-align:center">18</td>
</tr>
<tr>
<td style="text-align:center">Robert</td>
<td style="text-align:center">18</td>
</tr>
</tbody>
</table>
<p>从上面可以发现，在《权力的游戏》网络中提利昂·兰尼斯特（Tyrion）和最多的角色有接触。鉴于他的心计，我们觉得这是有道理的。</p>
<h3 id="加权度中心性（Weighted-Degree-Centrality）"><a href="#加权度中心性（Weighted-Degree-Centrality）" class="headerlink" title="加权度中心性（Weighted Degree Centrality）"></a>加权度中心性（Weighted Degree Centrality）</h3><p>作者存储一对角色接触的次数作为INTERACTS关系的weight属性。对该角色的INTERACTS关系的所有weight相加得到加权度中心性。作者使用Cypher计算所有角色的这个度量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Character)-[r:INTERACTS]-()</span><br><span class="line">RETURN c.name AS character, sum(r.weight) AS weightedDegree ORDER BY weightedDegree DESC</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">character</th>
<th style="text-align:center">weightedDegree</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Tyrion</td>
<td style="text-align:center">551</td>
</tr>
<tr>
<td style="text-align:center">Jon</td>
<td style="text-align:center">442</td>
</tr>
<tr>
<td style="text-align:center">Sansa</td>
<td style="text-align:center">383</td>
</tr>
<tr>
<td style="text-align:center">Jaime</td>
<td style="text-align:center">372</td>
</tr>
<tr>
<td style="text-align:center">Bran</td>
<td style="text-align:center">344</td>
</tr>
<tr>
<td style="text-align:center">Robb</td>
<td style="text-align:center">342</td>
</tr>
<tr>
<td style="text-align:center">Samwell</td>
<td style="text-align:center">282</td>
</tr>
<tr>
<td style="text-align:center">Arya</td>
<td style="text-align:center">269</td>
</tr>
<tr>
<td style="text-align:center">Joffrey</td>
<td style="text-align:center">255</td>
</tr>
<tr>
<td style="text-align:center">Daenerys</td>
<td style="text-align:center">232</td>
</tr>
</tbody>
</table>
<h3 id="介数中心性（Betweenness-Centrality）"><a href="#介数中心性（Betweenness-Centrality）" class="headerlink" title="介数中心性（Betweenness Centrality）"></a>介数中心性（Betweenness Centrality）</h3><p>介数中心性：在网络中，一个节点的介数中心性是指其它两个节点的所有最短路径都经过这个节点，则这些所有最短路径数即为此节点的介数中心性。介数中心性是一种重要的度量，因为它可以鉴别出网络中的“信息中间人”或者网络聚类后的联结点。</p>
<p><img src="/gallery/game/6.jpg" alt="图6中红色节点是具有高的介数中心性，网络聚类的联结点。"></p>
<p>为了计算介数中心性，作者使用Neo4j 3.x或者apoc库。安装apoc后能用Cypher调用其170+的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Character)</span><br><span class="line">WITH collect(c) AS characters</span><br><span class="line">CALL apoc.algo.betweenness([&apos;INTERACTS&apos;], characters, &apos;BOTH&apos;) YIELD node, score</span><br><span class="line">SET node.betweenness = score</span><br><span class="line">RETURN node.name AS name, score ORDER BY score DESC</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Jon</td>
<td style="text-align:center">1279.7533534055322</td>
</tr>
<tr>
<td style="text-align:center">Robert</td>
<td style="text-align:center">1165.6025171231624</td>
</tr>
<tr>
<td style="text-align:center">Tyrion</td>
<td style="text-align:center">1101.3849724234349</td>
</tr>
<tr>
<td style="text-align:center">Daenerys</td>
<td style="text-align:center">874.8372110508583</td>
</tr>
<tr>
<td style="text-align:center">Robb</td>
<td style="text-align:center">706.5572832464792</td>
</tr>
<tr>
<td style="text-align:center">Sansa</td>
<td style="text-align:center">705.1985623519137</td>
</tr>
<tr>
<td style="text-align:center">Stannis</td>
<td style="text-align:center">571.5247305125714</td>
</tr>
<tr>
<td style="text-align:center">Jaime</td>
<td style="text-align:center">556.1852522889822</td>
</tr>
<tr>
<td style="text-align:center">Arya</td>
<td style="text-align:center">443.01358430043337</td>
</tr>
<tr>
<td style="text-align:center">Tywin</td>
<td style="text-align:center">364.7212195528086</td>
</tr>
</tbody>
</table>
<h3 id="紧度中心性（Closeness-centrality）"><a href="#紧度中心性（Closeness-centrality）" class="headerlink" title="紧度中心性（Closeness centrality）"></a>紧度中心性（Closeness centrality）</h3><p>紧度中心性是指到网络中所有其他角色的平均距离的倒数。在图中，具有高紧度中心性的节点在聚类社区之间被高度联结，但在社区之外不一定是高度联结的。</p>
<p><img src="/gallery/game/7.png" alt="图7 ：网络中具有高紧度中心性的节点被其它节点高度联结"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Character)</span><br><span class="line">WITH collect(c) AS characters</span><br><span class="line">CALL apoc.algo.closeness([&apos;INTERACTS&apos;], characters, &apos;BOTH&apos;) YIELD node, score</span><br><span class="line">RETURN node.name AS name, score ORDER BY score DESC</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Tyrion</td>
<td style="text-align:center">0.004830917874396135</td>
</tr>
<tr>
<td style="text-align:center">Sansa</td>
<td style="text-align:center">0.004807692307692308</td>
</tr>
<tr>
<td style="text-align:center">Robert</td>
<td style="text-align:center">0.0047169811320754715</td>
</tr>
<tr>
<td style="text-align:center">Robb</td>
<td style="text-align:center">0.004608294930875576</td>
</tr>
<tr>
<td style="text-align:center">Arya</td>
<td style="text-align:center">0.0045871559633027525</td>
</tr>
<tr>
<td style="text-align:center">Jaime</td>
<td style="text-align:center">0.004524886877828055</td>
</tr>
<tr>
<td style="text-align:center">Stannis</td>
<td style="text-align:center">0.004524886877828055</td>
</tr>
<tr>
<td style="text-align:center">Jon</td>
<td style="text-align:center">0.004524886877828055</td>
</tr>
<tr>
<td style="text-align:center">Tywin</td>
<td style="text-align:center">0.004424778761061947</td>
</tr>
<tr>
<td style="text-align:center">Eddard</td>
<td style="text-align:center">0.004347826086956522</td>
</tr>
</tbody>
</table>
<h2 id="使用python-igraph"><a href="#使用python-igraph" class="headerlink" title="使用python-igraph"></a>使用python-igraph</h2><p>Neo4j与其它工具（比如，R和Python数据科学工具）完美结合。我们继续使用apoc运行 PageRank和社区发现（community detection）算法。这里接着使用python-igraph计算分析。Python-igraph移植自R的igraph图形分析库。 使用pip install python-igraph安装它。</p>
<h3 id="从Neo4j构建一个igraph实例"><a href="#从Neo4j构建一个igraph实例" class="headerlink" title="从Neo4j构建一个igraph实例"></a>从Neo4j构建一个igraph实例</h3><p>为了在《权力的游戏》的数据的图分析中使用igraph，首先需要从Neo4j拉取数据，用Python建立igraph实例。作者使用 Neo4j 的Python驱动库py2neo。我们能直接传入Py2neo查询结果对象到igraph的TupleList构造器，创建igraph实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> py2neo <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">from</span> igraph <span class="keyword">import</span> Graph <span class="keyword">as</span> IGraph</span><br><span class="line">graph = Graph()</span><br><span class="line"></span><br><span class="line">query = <span class="string">'''</span></span><br><span class="line"><span class="string">MATCH (c1:Character)-[r:INTERACTS]-&gt;(c2:Character)</span></span><br><span class="line"><span class="string">RETURN c1.name, c2.name, r.weight AS weight</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">ig = IGraph.TupleList(graph.run(query), weights=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>现在有了igraph对象，可以运行igraph实现的各种图算法来。</p>
<h3 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h3><p>作者使用igraph运行的第一个算法是<a href="https://en.wikipedia.org/wiki/PageRank" target="_blank" rel="noopener">PageRank</a>。PageRank算法源自Google的网页排名。它是一种<a href="https://en.wikipedia.org/wiki/Centrality#Eigenvector_centrality" target="_blank" rel="noopener">特征向量中心性(eigenvector centrality)</a>算法。</p>
<p><img src="/gallery/game/page-rank.png" alt=""></p>
<p>在igraph实例中运行PageRank算法，然后把结果写回Neo4j，在角色节点创建一个pagerank属性存储igraph计算的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pg = ig.pagerank()</span><br><span class="line">pgvs = []</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> zip(ig.vs, pg):</span><br><span class="line">    print(p)</span><br><span class="line">    pgvs.append(&#123;<span class="string">"name"</span>: p[<span class="number">0</span>][<span class="string">"name"</span>], <span class="string">"pg"</span>: p[<span class="number">1</span>]&#125;)</span><br><span class="line">pgvs</span><br><span class="line"></span><br><span class="line">write_clusters_query = <span class="string">'''</span></span><br><span class="line"><span class="string">UNWIND &#123;nodes&#125; AS n</span></span><br><span class="line"><span class="string">MATCH (c:Character) WHERE c.name = n.name</span></span><br><span class="line"><span class="string">SET c.pagerank = n.pg</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">graph.run(write_clusters_query, nodes=pgvs)</span><br></pre></td></tr></table></figure>
<p>现在可以在Neo4j的图中查询最高PageRank值的节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (n:Character)</span><br><span class="line">RETURN n.name AS name, n.pagerank AS pagerank ORDER BY pagerank DESC LIMIT 10</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">pagerank</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Tyrion</td>
<td style="text-align:center">0.042884981999963316</td>
</tr>
<tr>
<td style="text-align:center">Jon</td>
<td style="text-align:center">0.03582869669163558</td>
</tr>
<tr>
<td style="text-align:center">Robb</td>
<td style="text-align:center">0.03017114665594764</td>
</tr>
<tr>
<td style="text-align:center">Sansa</td>
<td style="text-align:center">0.030009716660108578</td>
</tr>
<tr>
<td style="text-align:center">Daenerys</td>
<td style="text-align:center">0.02881425425830273</td>
</tr>
<tr>
<td style="text-align:center">Jaime</td>
<td style="text-align:center">0.028727587587471206</td>
</tr>
<tr>
<td style="text-align:center">Tywin</td>
<td style="text-align:center">0.02570016262642541</td>
</tr>
<tr>
<td style="text-align:center">Robert</td>
<td style="text-align:center">0.022292016521362864</td>
</tr>
<tr>
<td style="text-align:center">Cersei</td>
<td style="text-align:center">0.022287327589773507</td>
</tr>
<tr>
<td style="text-align:center">Arya</td>
<td style="text-align:center">0.022050209663844467</td>
</tr>
</tbody>
</table>
<p><img src="/gallery/game/8.jpg" alt=""></p>
<p>社区发现算法用来找出图中的社区聚类。作者使用igraph实现的随机游走算法（ walktrap）来找到在社区中频繁有接触的角色社区，在社区之外角色不怎么接触。</p>
<p>在igraph中运行随机游走的社区发现算法，然后把社区发现的结果导入Neo4j，其中每个角色所属的社区用一个整数来表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clusters = IGraph.community_walktrap(ig, weights=<span class="string">"weight"</span>).as_clustering()</span><br><span class="line"></span><br><span class="line">nodes = [&#123;<span class="string">"name"</span>: node[<span class="string">"name"</span>]&#125; <span class="keyword">for</span> node <span class="keyword">in</span> ig.vs]</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">    idx = ig.vs.find(name=node[<span class="string">"name"</span>]).index</span><br><span class="line">    node[<span class="string">"community"</span>] = clusters.membership[idx]</span><br><span class="line"></span><br><span class="line">write_clusters_query = <span class="string">'''</span></span><br><span class="line"><span class="string">UNWIND &#123;nodes&#125; AS n</span></span><br><span class="line"><span class="string">MATCH (c:Character) WHERE c.name = n.name</span></span><br><span class="line"><span class="string">SET c.community = toInt(n.community)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">graph.run(write_clusters_query, nodes=nodes)</span><br></pre></td></tr></table></figure>
<p>我们能在Neo4j中查询有多少个社区以及每个社区的成员数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Character)</span><br><span class="line">WITH c.community AS cluster, collect(c.name) AS  members</span><br><span class="line">RETURN cluster, members ORDER BY cluster ASC</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">cluster</th>
<th style="text-align:center">members</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">[Aemon, Alliser, Craster, Eddison, Gilly, Janos, Jon, Mance, Rattleshirt, Samwell, Val, Ygritte, Grenn, Karl, Bowen, Dalla, Orell, Qhorin, Styr]</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">[Aerys, Amory, Balon, Brienne, Bronn, Cersei, Gregor, Jaime, Joffrey, Jon Arryn, Kevan, Loras, Lysa, Meryn, Myrcella, Oberyn, Podrick, Renly, Robert, Robert Arryn, Sansa, Shae, Tommen, Tyrion, Tywin, Varys, Walton, Petyr, Elia, Ilyn, Pycelle, Qyburn, Margaery, Olenna, Marillion, Ellaria, Mace, Chataya, Doran]</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">[Arya, Beric, Eddard, Gendry, Sandor, Anguy, Thoros]</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">[Brynden, Catelyn, Edmure, Hoster, Lothar, Rickard, Robb, Roose, Walder, Jeyne, Roslin, Ramsay]</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">[Bran, Hodor, Jojen, Luwin, Meera, Rickon, Nan, Theon]</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">[Belwas, Daario, Daenerys, Irri, Jorah, Missandei, Rhaegar, Viserys, Barristan, Illyrio, Drogo, Aegon, Kraznys, Rakharo, Worm]</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">[Davos, Melisandre, Shireen, Stannis, Cressen, Salladhor]</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">[Lancel]</td>
</tr>
</tbody>
</table>
<h3 id="角色“大合影”"><a href="#角色“大合影”" class="headerlink" title="角色“大合影”"></a>角色“大合影”</h3><p><img src="/gallery/game/graph-of-thrones.png" alt="The graph of thrones"></p>
<p>《权力的游戏》的权力图。节点的大小正比于介数中心性，颜色表示社区（由随机游走算法获得），边的厚度正比于两节点接触的次数。<br>现在已经计算好这些图的分析数据，让我们对其进行可视化，让数据看起来更有意义。</p>
<p>Neo4j自带浏览器可以对Cypher查询的结果进行很好的可视化，但如果我们想把可视化好的图嵌入到其它应用中，可以使用Javascript可视化库Vis.js。从Neo4j拉取数据，用Vis.js的neovis.js构建可视化图。Neovis.js提供简单的API配置，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">  container_id: <span class="string">"viz"</span>,</span><br><span class="line">  server_url: <span class="string">"localhost"</span>,</span><br><span class="line">  labels: &#123;    <span class="string">"Character"</span>: <span class="string">"name"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  label_size: &#123;    <span class="string">"Character"</span>: <span class="string">"betweenness"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  relationships: &#123;    <span class="string">"INTERACTS"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  relationship_thickness: &#123;    <span class="string">"INTERACTS"</span>: <span class="string">"weight"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  cluster_labels: &#123;    <span class="string">"Character"</span>: <span class="string">"community"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> viz = <span class="keyword">new</span> NeoVis(config);</span><br><span class="line">viz.render();</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>节点带有标签<code>Character</code>，属性<code>name</code>；</li>
<li>节点的大小正比于<code>betweenness</code>属性；</li>
<li>可视化中包括<code>INTERACTS</code>关系；</li>
<li>关系的厚度正比于<code>weight</code>属性；</li>
<li>节点的颜色是根据网络中社区<code>community</code>属性决定；</li>
<li>从本地服务器<code>localhost</code>拉取Neo4j的数据；</li>
<li>在一个id为<code>viz</code>的DOM元素中展示可视化。</li>
</ul>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li><p>A. Beveridge and J. Shan, <a href="http://www.maa.org/sites/default/files/pdf/Mathhorizons/NetworkofThrones.pdf" target="_blank" rel="noopener">“Network of Thrones”</a> Math Horizons Magazine , Vol. 23, No. 4 (2016), pp. 18-22.</p>
</li>
<li><p>J. Kleinberg and D. Easley, <a href="https://www.cs.cornell.edu/home/kleinber/networks-book/" target="_blank" rel="noopener">Networks, Crowds, and Markets: Reasoning About a Highly Connected World</a>. Cambridge University Press (2010)<br>All code is <a href="https://github.com/johnymontana/graph-of-thrones">available on Github</a>.</p>
</li>
</ul>
<hr>
<p>【参考资料】</p>
<ul>
<li><a href="http://www.lyonwj.com/2016/06/26/graph-of-thrones-neo4j-social-network-analysis/" target="_blank" rel="noopener"><strong>Analyzing the Graph of Thrones</strong> – by William Lyon</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI0MDIxMDM0MQ==&amp;mid=2247483702&amp;idx=2&amp;sn=7a1abd6d129b87150e890b7ae11791aa&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="noopener">基于社区发现算法和图分析Neo4j解读《权力的游戏》上篇</a></li>
<li><a href="http://www.hizher.com/pageContent-1148688-51394.html" target="_blank" rel="noopener">基于社区发现算法和图分析Neo4j解读《权力的游戏》下篇</a></li>
</ul>

  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>Mr.Seven</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="../../30/【Android】APK瘦身记，实现将近一半的压缩效果/">
        ← prev <!--【Android】APK瘦身记，实现将近一半的压缩效果-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="../../18/【D3.js】力导向布局 + 圆形图片展示的人物关系/">
        <!--【D3.js】力导向布局 + 圆形图片展示的人物关系--> next →
    </a>
    
</nav>
<div id="comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'iTimeTraveler';
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a>
</div>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2018 Mr.Seven. All rights reserved. Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. <a href="https://github.com/guolin/crisp-hexo-theme" target="_blank">crisp</a> theme by <a href="guolin.github.io" target="_blank">Guo Lin</a>.</section>
        </footer>
    </body>
</html>


