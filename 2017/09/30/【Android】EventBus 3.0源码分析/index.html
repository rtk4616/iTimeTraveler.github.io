<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  <!-- PACE Progress Bar START -->
  
    <script src="../../../../js/pace.min.js"></script>
    <link rel="stylesheet" href="https://github.com/HubSpot/pace/raw/master/themes/orange/pace-theme-flash.css">
  
  

  <!-- PACE Progress Bar START -->

  
  <title>【android】eventbus 3.0 源码分析 | iTimeTraveler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Android源码分析" />
  
  
  
  
  <meta name="description" content="概述EventBus是Android中一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，主要功能是替代Intent，Handler，BroadCast 在 Fragment，Activity，Service，线程Thread之间传递消息。优点是开销小，使用方便，可以很大程度上降低它们之间的耦合。 类似的库还有Otto ，今天就带大家一起研读 EventBus">
<meta property="og:type" content="article">
<meta property="og:title" content="【Android】EventBus 3.0 源码分析">
<meta property="og:url" content="http://github.com/2017/09/30/【Android】EventBus 3.0源码分析/index.html">
<meta property="og:site_name" content="iTimeTraveler">
<meta property="og:description" content="概述EventBus是Android中一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，主要功能是替代Intent，Handler，BroadCast 在 Fragment，Activity，Service，线程Thread之间传递消息。优点是开销小，使用方便，可以很大程度上降低它们之间的耦合。 类似的库还有Otto ，今天就带大家一起研读 EventBus">
<meta property="og:image" content="http://github.com/gallery/EventBus/android_with_eventbus.png">
<meta property="og:updated_time" content="2017-10-10T03:13:52.115Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Android】EventBus 3.0 源码分析">
<meta name="twitter:description" content="概述EventBus是Android中一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，主要功能是替代Intent，Handler，BroadCast 在 Fragment，Activity，Service，线程Thread之间传递消息。优点是开销小，使用方便，可以很大程度上降低它们之间的耦合。 类似的库还有Otto ，今天就带大家一起研读 EventBus">
<meta name="twitter:image" content="http://github.com/gallery/EventBus/android_with_eventbus.png">
  
    <link rel="alternate" href="/atom.xml" title="iTimeTraveler" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="../../../../css/style.css">

  <script src="../../../../js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../../../css/my.css">

</head>

<script>
var themeMenus = {};

  themeMenus[""] = "首页"; 

  themeMenus["../archives"] = "归档"; 

  themeMenus["../categories"] = "分类"; 

  themeMenus["../tags"] = "标签"; 

  themeMenus["../funnysite"] = "酷站"; 

  themeMenus["../collection"] = "收藏"; 

  themeMenus["../about"] = "关于"; 

  themeMenus["mybooks"] = "🎁"; 

</script>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="iTimeTraveler" rel="home"> iTimeTraveler </a>
            
          </h1>

          
            <div class="site-description">Someone knock at the door.</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="../../../../index.html">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="../../../../archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="../../../../categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="../../../../tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="../../../../funnysite">酷站</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="../../../../collection">收藏</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="../../../../about">关于</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="../../../../mybooks">🎁</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>


  <div id="originBgDiv" style="background: #fff; width: 100%;">

      <div style="max-height:600px; overflow: hidden;  display: flex; display: -webkit-flex; align-items: center;">
        <img id="originBg" width="100%" alt="" src="">
      </div>

  </div>

  <script>
  function setAboutIMG(){
      var imgUrls = "https://source.unsplash.com/collection/954550/1920x1080,gallery/bg/01.jpg,gallery/bg/02.jpg,gallery/bg/03.jpg,gallery/bg/04.jpg,gallery/bg/05.jpg,gallery/bg/06.jpg,gallery/bg/07.jpg,gallery/bg/08.jpg,gallery/bg/09.jpg,gallery/bg/10.jpg,gallery/bg/11.jpg,gallery/bg/12.jpg".split(",");
      var random = Math.floor((Math.random() * imgUrls.length ));
      if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
        document.getElementById("originBg").src=imgUrls[random];
      } else {
        document.getElementById("originBg").src='/' + imgUrls[random];
      }
  }
  bgDiv=document.getElementById("originBgDiv");
  if(location.pathname.match('about')){
    setAboutIMG();
    bgDiv.style.display='block';
  }else{
    bgDiv.style.display='none';
  }
  </script>



  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-【Android】EventBus 3.0源码分析" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="../../../../gallery/EventBus/android_with_eventbus.png" rel="gallery_cjaltewnu002zyomyz3v1dxpt">
        <img src="../../../../gallery/EventBus/android_with_eventbus.png" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      【Android】EventBus 3.0 源码分析
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="" class="article-date">
	  <time datetime="2017-09-30T14:03:00.000Z" itemprop="datePublished">九月 30, 2017</time>
	</a>

      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong><a href="https://github.com/greenrobot/EventBus">EventBus</a></strong>是Android中一个基于<strong>观察者模式</strong>的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，主要功能是替代Intent，Handler，BroadCast 在 Fragment，Activity，Service，线程Thread之间传递消息。优点是开销小，使用方便，可以很大程度上降低它们之间的耦合。 类似的库还有<a href="https://github.com/square/otto">Otto</a> ，今天就带大家一起研读 EventBus 的源码。</p>
<p>这是EventBus源码中的介绍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;<span class="doctag">@link</span> #post(Object)&#125;) to the</div><div class="line"> * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,</div><div class="line"> * subscribers must register themselves to the bus using &#123;<span class="doctag">@link</span> #register(Object)&#125;. Once registered, subscribers</div><div class="line"> * receive events until &#123;<span class="doctag">@link</span> #unregister(Object)&#125; is called. Event handling methods must be annotated by</div><div class="line"> * &#123;<span class="doctag">@link</span> Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter</div><div class="line"> * (the event).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Markus Junginger, greenrobot</div><div class="line"> */</div></pre></td></tr></table></figure>
<blockquote>
<p>EventBus 是Android上的以<strong>发布\订阅事件</strong>为核心的库。事件 (<code>event</code>) 通过 <code>post()</code> 发送到总线，然后再分发到匹配事件类型的订阅者 (<code>subscribers</code>) 。订阅者只有在总线中注册 (<code>register</code>) 了才能收到事件，注销 (<code>unrigister</code>) 之后就收不到任何事件了。事件方法必须带有 <code>Subscribe</code> 的注解，必须是 <code>public</code> ，没有返回类型 <code>void</code> 并且只能有一个参数。</p>
</blockquote>
<p>EventBus3 与之前的相比，其主要差别在于订阅方法可以不再以<code>onEvent</code> 开头了，改为用<strong>注解</strong>。</p>
<a id="more"></a>
<h3 id="一、使用EventBus"><a href="#一、使用EventBus" class="headerlink" title="一、使用EventBus"></a>一、使用EventBus</h3><p><img src="/gallery/EventBus/how_to_use.png" alt=""></p>
<p>在Gradle中添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">compile <span class="string">'org.greenrobot:eventbus:3.0.0'</span></div></pre></td></tr></table></figure>
<h4 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h4><p>EventBus默认有一个单例，可以通过<code>getDefault()</code>获取，也可以通过<code>EventBus.builder()</code>构造自定义的EventBus，比如要应用我们生成好的索引时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBus mEventBus = EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).build();</div></pre></td></tr></table></figure>
<p>如果想把自定义的设置应用到EventBus默认的单例中，则可以用<code>installDefaultEventBus()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).installDefaultEventBus();</div></pre></td></tr></table></figure>
<h4 id="1-2-定义事件"><a href="#1-2-定义事件" class="headerlink" title="1.2 定义事件"></a>1.2 定义事件</h4><p>所有能被实例化为Object的实例都可以作为事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String message;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageEvent</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在最新版的eventbus 3中如果用到了索引加速，事件类的修饰符必须为<strong>public</strong>，不然编译时会报错：<code>Subscriber method must be public</code>。</p>
<h4 id="1-3-监听事件"><a href="#1-3-监听事件" class="headerlink" title="1.3 监听事件"></a>1.3 监听事件</h4><p>订阅者需要在总线上注册和注销自己。只有当订阅者注册了才能接收到事件。在Android中，通常与 Activity 和 Fragment 的生命周期绑定在一起。</p>
<p>之前2.x版本中有四种注册方法，区分了普通注册和粘性事件注册，并且在注册时可以选择接收事件的优先级，这里我们就不对2.x版本做过多的研究了。由于3.0版本将粘性事件以及订阅事件的优先级换成了<strong>注解</strong>的实现方式，所以3.0版本中的注册就变得简单，只有一个register()方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//3.0版本的注册</span></div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line">	   </div><div class="line"><span class="comment">//2.x版本的四种注册方法</span></div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>, <span class="number">100</span>);</div><div class="line">EventBus.getDefault().registerSticky(<span class="keyword">this</span>);</div><div class="line">EventBus.getDefault().registerSticky(<span class="keyword">this</span>, <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>当我们不在需要接收事件的时候需要解除注册unregister，2.x和3.0的解除注册也是相同的。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//取消注册</span></div><div class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>接收到消息之后的处理方式，在2.x版本中，注册这些消息的监听需要区分是否监听黏性（sticky）事件，监听EventBus事件的模块需要实现以onEvent开头的方法。如今3.0改为在方法上添加注解的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//3.0版本</span></div><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING, priority = <span class="number">0</span>, sticky = <span class="keyword">true</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(DriverEvent event)</span> </span>&#123;</div><div class="line">    Log.d(TAG, event.info);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//2.x版本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在2.x版本中只有通过onEvent开头的方法会被注册，而且响应事件方法触发的线程通过<code>onEventMainThread</code>或<code>onEventBackgroundThread</code>这些方法名区分，而在3.0版本中，通过<code>@Subscribe</code>注解，来确定运行的线程threadMode，是否接受粘性事件sticky以及事件优先级priority，而且方法名不在需要<code>onEvent</code>开头，所以又简洁灵活了不少。</p>
<p>我们可以看到注解<code>@Subscribe</code>有三个参数，threadMode为回调所在的线程，priority为优先级，sticky为是否接收黏性事件。调度单位从类细化到了方法，对方法的命名也没有了要求，方便混淆代码。但注册了监听的模块必须有一个标注了Subscribe注解方法，不然在register时会抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Subscriber class XXX and its super classes have no public methods with the @Subscribe annotation</div></pre></td></tr></table></figure>
<h4 id="1-4-发送事件"><a href="#1-4-发送事件" class="headerlink" title="1.4 发送事件"></a>1.4 发送事件</h4><p>可以从代码的任何地方调用post或者postSticky发送事件，此时注册了的且匹配事件的订阅者能够接收到事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(<span class="string">"Hello everyone!"</span>));</div></pre></td></tr></table></figure>
<p>在实际项目的使用中，register和unregister通常与Activity和Fragment的生命周期相关，ThreadMode.MainThread可以很好地解决Android的界面刷新必须在UI线程的问题，不需要再回调后用Handler中转（<strong>EventBus中已经自动用Handler做了处理</strong>），黏性事件可以很好地解决post与register同时执行时的异步问题（这个在原理中会说到），事件的传递也没有序列化与反序列化的性能消耗，足以满足我们大部分情况下的模块间通信需求。</p>
<h3 id="二、EventBus源码跟踪"><a href="#二、EventBus源码跟踪" class="headerlink" title="二、EventBus源码跟踪"></a>二、EventBus源码跟踪</h3><p>我们通过<code>EventBus</code>的使用流程来跟踪分析它的调用流程，通过我们熟悉的使用方法来深入到<code>EventBus</code>的实现内部并理解它的实现原理。</p>
<h4 id="2-1-创建EventBus对象"><a href="#2-1-创建EventBus对象" class="headerlink" title="2.1 创建EventBus对象"></a><strong>2.1 创建EventBus对象</strong></h4><p>先看看 <code>getDefault()</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</div><div class="line"></div><div class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> defaultInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是设计模式里我们常用的<strong>单例模式</strong>，用到了double check。保证了<code>getDefault()</code>得到的都是同一个实例。如果不存在实例，就调用了<code>EventBus</code>的构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造函数可以创建多个不同的EventBus，不同的实例之间可以相互隔离，如果只想使用同一个总线，就直接使用getDefault()方法获取单例</div><div class="line"> * </div><div class="line"> * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</div><div class="line"> * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(DEFAULT_BUILDER);</div><div class="line">&#125;</div><div class="line"></div><div class="line">EventBus(EventBusBuilder builder) &#123;</div><div class="line">	<span class="comment">//key:订阅的事件,value:订阅这个事件的所有订阅者集合</span></div><div class="line">	<span class="comment">//private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span></div><div class="line">	subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//key:订阅者对象,value:这个订阅者订阅的事件集合</span></div><div class="line">	<span class="comment">//private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span></div><div class="line">	typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//粘性事件 key:粘性事件的class对象, value:事件对象</span></div><div class="line">	<span class="comment">//private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span></div><div class="line">	stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//事件主线程处理</span></div><div class="line">	mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</div><div class="line">	<span class="comment">//事件 Background 处理</span></div><div class="line">	backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</div><div class="line">	<span class="comment">//事件异步线程处理</span></div><div class="line">	asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</div><div class="line">	indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</div><div class="line">	<span class="comment">//订阅者响应函数信息存储和查找类</span></div><div class="line">	subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</div><div class="line">	       builder.strictMethodVerification, builder.ignoreGeneratedIndex);</div><div class="line">	logSubscriberExceptions = builder.logSubscriberExceptions;</div><div class="line">	logNoSubscriberMessages = builder.logNoSubscriberMessages;</div><div class="line">	sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</div><div class="line">	sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</div><div class="line">	throwSubscriberException = builder.throwSubscriberException;</div><div class="line">	<span class="comment">//是否支持事件继承</span></div><div class="line">	eventInheritance = builder.eventInheritance;</div><div class="line">	executorService = builder.executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么，既然是单例模式构造函数还是 <code>public</code> ？没错，这样的设计是因为不仅仅可以只有一条总线，还可以有其他的线 (bus) ，订阅者可以注册到不同的线上的 <code>EventBus</code>，通过不同的 <code>EventBus</code> 实例来发送数据，不同的 <code>EventBus</code> 是相互隔离开的，订阅者都只会收到注册到该线上事件。</p>
<p>然后我们说一下构造函数里这三个 <code>HasMap</code>。</p>
<ul>
<li><strong><code>subscriptionsByEventType</code></strong> 是以 <code>event</code> 为 <em>key</em>，<code>subscriber列表</code> 为 <em>value</em>，当发送 <code>event</code> 的时候，都是去这里找对应的订阅者。</li>
<li><strong><code>typesBySubscriber</code></strong> 是以 <code>subscriber</code> 为 <em>key</em>，<code>event列表</code>为 <em>value</em>，当 <code>register()</code> 和 <code>unregister()</code> 的时候都是操作这个map，同时对 <code>subscriptionsByEventType</code> 进行对用操作。</li>
<li><strong><code>stickyEvents</code></strong> 维护的是粘性事件，粘性事件也就是当 <code>event</code> 发送出去之后再注册粘性事件的话，该粘性事件也能收到之前发送出去的 <code>event</code>。</li>
</ul>
<p>同时构造函数中还创建了 3 个 poster ：<strong>HandlerPoster ，BackgroundPoster和AsyncPoster，这 3 个 poster 负责线程间调度</strong>，稍后的事件分发模块我们会详细讲到。我们接着看这个构造函数中，最终运用到了builder设计模式，那么来看看这个 <code>EventBusBuilder</code> 中有哪些参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusBuilder</span> </span>&#123;</div><div class="line">	<span class="comment">//线程池</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</div><div class="line">	<span class="comment">//当调用事件处理函数异常时是否打印异常信息</span></div><div class="line">	<span class="keyword">boolean</span> logSubscriberExceptions = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//当没有订阅者订阅该事件时是否打印日志</span></div><div class="line">	<span class="keyword">boolean</span> logNoSubscriberMessages = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//当调用事件处理函数异常时是否发送 SubscriberExceptionEvent 事件</span></div><div class="line">	<span class="keyword">boolean</span> sendSubscriberExceptionEvent = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//当没有事件处理函数对事件处理时是否发送 NoSubscriberEvent 事件</span></div><div class="line">	<span class="keyword">boolean</span> sendNoSubscriberEvent = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//是否要抛出异常，建议debug开启</span></div><div class="line">	<span class="keyword">boolean</span> throwSubscriberException;</div><div class="line">	<span class="comment">//与event有继承关系的类是否需要发送</span></div><div class="line">	<span class="keyword">boolean</span> eventInheritance = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//是否忽略生成的索引(SubscriberInfoIndex)</span></div><div class="line">	<span class="keyword">boolean</span> ignoreGeneratedIndex;</div><div class="line">	<span class="comment">//是否严格的方法名校验</span></div><div class="line">	<span class="keyword">boolean</span> strictMethodVerification;</div><div class="line">	<span class="comment">//线程池，async 和 background 的事件会用到</span></div><div class="line">	ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;</div><div class="line">	<span class="comment">//当注册的时候会进行方法名的校验(EventBus3之前方法名必须以onEvent开头)，而这个列表是不参加校验的类的列表(EventBus3之后就没用这个参数了)</span></div><div class="line">	List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;</div><div class="line">	<span class="comment">//维护着由EventBus生成的索引(SubscriberInfoIndex)</span></div><div class="line">	List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;</div><div class="line"></div><div class="line">	EventBusBuilder() &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//赋值buidler(可用户自定义的)给单例的EventBus，如果单例的EventBus不为null了，则抛出异常</span></div><div class="line">	<span class="function"><span class="keyword">public</span> EventBus <span class="title">installDefaultEventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">	        <span class="keyword">if</span> (EventBus.defaultInstance != <span class="keyword">null</span>) &#123;</div><div class="line">	            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Default instance already exists."</span> +</div><div class="line">	                    <span class="string">" It may be only set once before it's used the first time to ensure consistent behavior."</span>);</div><div class="line">	        &#125;</div><div class="line">	        EventBus.defaultInstance = build();</div><div class="line">	        <span class="keyword">return</span> EventBus.defaultInstance;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> EventBus <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> EventBus(<span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//...省略其他代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出是通过初始化了一个<code>EventBusBuilder()</code>对象来分别初始化<code>EventBus</code>的一些配置，注释里我标注了大部分比较重要的对象，这里没必要记住，看下面的文章时如果对某个对象不了解，可以再回来看看。</p>
<h4 id="2-2-注册与订阅Register"><a href="#2-2-注册与订阅Register" class="headerlink" title="2.2 注册与订阅Register"></a><strong>2.2 注册与订阅Register</strong></h4><p>EventBus 3.0的注册入口只提供一个<code>register()</code>方法了，所以我们先来看看register()方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    <span class="comment">//首先获得订阅者的class对象</span></div><div class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</div><div class="line">    </div><div class="line">    <span class="comment">//通过subscriberMethodFinder来找到订阅者订阅了哪些事件.返回一个SubscriberMethod对象的List</span></div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">            <span class="comment">//订阅</span></div><div class="line">            subscribe(subscriber, subscriberMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>register()</code>方法很简洁，代码里的注释也很清楚了，我们可以看出通过<code>subscriberMethodFinder.findSubscriberMethods(subscriberClass)</code>方法就能返回一个<code>SubscriberMethod</code>的对象，而<code>SubscriberMethod</code>里包含了所有我们需要的接下来执行<code>subscribe()</code>的信息。</p>
<p>那 <strong><code>SubscriberMethod</code></strong>里包含了什么呢？下面是它的变量和构造函数。可以看到里面包括订阅类里的具体执行方法<code>Method</code>对象，需要在哪个线程执行<code>ThreadMode</code>，事件类型<code>eventType</code>，优先级<code>priority</code>，以及是否接收粘性<code>sticky</code>事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Method method;        <span class="comment">//具体的执行方法</span></div><div class="line">    <span class="keyword">final</span> ThreadMode threadMode; <span class="comment">//执行线程</span></div><div class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;   <span class="comment">//事件类型，也就是执行方法接受的参数类型</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;         <span class="comment">//优先级</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;       <span class="comment">//是否粘性，之后会讲到</span></div><div class="line">    <span class="comment">/** Used for efficient comparison */</span></div><div class="line">    String methodString;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubscriberMethod</span><span class="params">(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, <span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.method = method;</div><div class="line">        <span class="keyword">this</span>.threadMode = threadMode;</div><div class="line">        <span class="keyword">this</span>.eventType = eventType;</div><div class="line">        <span class="keyword">this</span>.priority = priority;</div><div class="line">        <span class="keyword">this</span>.sticky = sticky;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//...省略其他代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们去看看SubscriberMethodFinder类的<code>findSubscriberMethods()</code>是怎么找到订阅方法的，最后我们再去关注<code>subscribe()</code>。</p>
<p><strong>SubscriberMethodFinder的实现</strong></p>
<p>从字面理解，这个类就是订阅者方法发现者。一句话来描述<code>SubscriberMethodFinder</code>类就是用来<strong>查找和缓存订阅者响应函数的信息</strong>的类。所以我们首先要知道怎么能获得订阅者响应函数的相关信息。在3.0版本中，EventBus提供了一个<strong><code>EventBusAnnotationProcessor</code>注解处理器</strong>来在编译期通过读取<code>@Subscribe()</code>注解并解析，处理其中所包含的信息，然后生成java类来保存所有订阅者关于订阅的信息，这样就比在运行时使用反射来获得这些订阅者的信息速度要快。我们可以参考EventBus项目里的<a href="https://github.com/greenrobot/EventBus/tree/master/EventBusPerformance">EventBusPerformance</a>这个例子，编译后我们可以在build文件夹里找到这个类，<a href="https://github.com/greenrobot/EventBus/blob/master/EventBusPerformance/build.gradle#L27">MyEventBusIndex 类</a>，当然类名是可以自定义的。我们大致看一下生成的<code>MyEventBusIndex</code>类是什么样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This class is generated by EventBus, do not edit.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</div><div class="line"></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class,</div><div class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[]&#123;</div><div class="line">                <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventAsync"</span>, TestEvent.class, ThreadMode.ASYNC),</div><div class="line">        &#125;));</div><div class="line"></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(TestRunnerActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[]&#123;</div><div class="line">                <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestFinishedEvent.class, ThreadMode.MAIN),</div><div class="line">        &#125;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</div><div class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</div><div class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出是使用一个静态HashMap即：<code>SUBSCRIBER_INDEX</code>来保存订阅类的信息，其中包括了订阅类的class对象，是否需要检查父类，以及订阅方法的信息<code>SubscriberMethodInfo</code>的数组，<code>SubscriberMethodInfo</code>中又保存了，订阅方法的方法名，订阅的事件类型，触发线程，是否接收sticky事件以及优先级priority。这其中就保存了register()的所有需要的信息，如果再配置EventBus的时候通过<code>EventBusBuilder</code>配置：<code>eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();</code>来将编译生成的<code>MyEventBusIndex</code>配置进去，这样就能在<code>SubscriberMethodFinder</code>类中直接查找出订阅类的信息，就不需要再利用注解判断了，当然这种方法是作为EventBus的可选配置，<code>SubscriberMethodFinder</code>同样提供了通过注解来获得订阅类信息的方法，下面我们就来看<code>findSubscriberMethods()</code>到底是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    <span class="comment">//先从METHOD_CACHE取看是否有缓存, key:保存订阅类的类名,value:保存类中订阅的方法数据,</span></div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</div><div class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//是否忽略注解器生成的MyEventBusIndex类</span></div><div class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</div><div class="line">        <span class="comment">//利用反射来读取订阅类中的订阅方法信息</span></div><div class="line">        subscriberMethods = findUsingReflection(subscriberClass);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息</span></div><div class="line">        subscriberMethods = findUsingInfo(subscriberClass);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</div><div class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//保存进METHOD_CACHE缓存</span></div><div class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看看利用反射来读取订阅类中的订阅方法信息的函数：<code>findUsingReflection()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    <span class="comment">//FindState 用来做订阅方法的校验和保存</span></div><div class="line">    FindState findState = prepareFindState();</div><div class="line">    findState.initForSubscriber(subscriberClass);</div><div class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//通过反射来获得订阅方法信息</span></div><div class="line">        findUsingReflectionInSingleClass(findState);</div><div class="line">        <span class="comment">//查找父类的订阅方法</span></div><div class="line">        findState.moveToSuperclass();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//获取findState中的SubscriberMethod(也就是订阅方法List)并返回</span></div><div class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以及从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息： <code>findUsingInfo()</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    FindState findState = prepareFindState();</div><div class="line">    findState.initForSubscriber(subscriberClass);</div><div class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//得到订阅者信息</span></div><div class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</div><div class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//遍历订阅者方法</span></div><div class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</div><div class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</div><div class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</div><div class="line">                    findState.subscriberMethods.add(subscriberMethod);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果没有订阅者信息就使用反射查找订阅方法</span></div><div class="line">            findUsingReflectionInSingleClass(findState);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//跳转到父类中继续查找</span></div><div class="line">        findState.moveToSuperclass();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进入到<code>getSubscriberInfo()</code> 方法中我们看到了从自定义索引Index获取订阅方法信息的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">    <span class="comment">//判断FindState对象中是否有缓存的订阅方法</span></div><div class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</div><div class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</div><div class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</div><div class="line">            <span class="keyword">return</span> superclassInfo;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息</span></div><div class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</div><div class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</div><div class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> info;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我们可以看到作者使用了<code>FindState</code>类来做<strong>订阅方法的校验和保存</strong>，并通过<code>FIND_STATE_POOL</code>静态数组来保存<code>FindState</code>对象，可以使<code>FindState</code>复用，避免重复创建过多的对象。最终是通过<code>findUsingReflectionInSingleClass()</code>来具体获得相关订阅方法的信息的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在较新的类文件，编译器可能会添加方法。那些被称为BRIDGE或SYNTHETIC方法。EventBus必须忽略两者。有修饰符没有公开，但在Java类文件中有格式定义</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BRIDGE = <span class="number">0x40</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0x1000</span>;</div><div class="line"><span class="comment">//需要忽略的修饰符</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">    Method[] methods;</div><div class="line">    <span class="comment">//通过反射得到方法数组</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></div><div class="line">        methods = findState.clazz.getDeclaredMethods();</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></div><div class="line">        methods = findState.clazz.getMethods();</div><div class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历Method</span></div><div class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</div><div class="line">        <span class="comment">//必须是public的方法</span></div><div class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</div><div class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">            <span class="comment">//保证必须只有一个事件参数</span></div><div class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</div><div class="line">                <span class="comment">//得到注解</span></div><div class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</div><div class="line">                    <span class="comment">//校验是否添加该方法</span></div><div class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</div><div class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">                        <span class="comment">//实例化SubscriberMethod对象并添加</span></div><div class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</div><div class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</div><div class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</div><div class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 <code>BRIDGE</code> 和 <code>SYNTHETIC</code> ，注释写道：</p>
<blockquote>
<p>In newer class files, compilers may add methods. Those are called bridge or synthetic methods. EventBus must ignore both. There modifiers are not public but defined in the Java class file format: <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1" target="_blank" rel="external">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1</a></p>
</blockquote>
<p>在较新的类文件，编译器可能会添加方法。那些被称为 BRIDGE 或 SYNTHETIC 方法，EventBus 必须忽略两者。有修饰符没有公开，但在 Java 类文件中有格式定义。</p>
<p>该<code>findUsingReflectionInSingleClass</code>方法流程是：</p>
<ol>
<li>拿到当前 class 的所有方法；</li>
<li>过滤掉不是 public 和是 abstract、static、bridge、synthetic 的方法；</li>
<li>过滤出方法参数只有一个的方法；</li>
<li>过滤出被Subscribe注解修饰的方法；</li>
<li>将 method 方法和 event 事件添加到 <code>findState</code> 中；</li>
<li>将 EventBus 关心的 method 方法、event 事件、threadMode、priority、sticky 封装成 <code>SubscriberMethod</code> 对象添加到 <code>findState.subscriberMethods</code> 列表中；</li>
</ol>
<p>这里走完，我们订阅类的所有<code>SubscriberMethod</code>都已经被保存了，最后再通过<code>getMethodsAndRelease()</code>返回<code>List&lt;SubscriberMethod&gt;</code>。至此，所有关于如何获得订阅类的订阅方法信息即：<code>SubscriberMethod</code>对象就已经完全分析完了，下面我们来看<code>subscribe()</code>是如何实现的。</p>
<p><strong>subscribe()方法的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//必须在同步代码块里调用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</div><div class="line">    <span class="comment">//获取订阅的事件类型</span></div><div class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">    <span class="comment">//创建Subscription对象</span></div><div class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">    <span class="comment">//从subscriptionsByEventType里检查是否已经添加过该Subscription,如果添加过就抛出异常,也就是每个类只能有一个函数响应同一种事件类型</span></div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</div><div class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">        subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">                    + eventType);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//根据优先级priority来添加Subscription对象</span></div><div class="line">    <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">            subscriptions.add(i, newSubscription);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将订阅者对象以及订阅的事件保存到typesBySubscriber里.</span></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">    &#125;</div><div class="line">    subscribedEvents.add(eventType);</div><div class="line">    <span class="comment">//如果接收sticky事件,立即分发sticky事件</span></div><div class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">        <span class="comment">//eventInheritance 表示是否分发订阅了响应事件类父类事件的方法</span></div><div class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></div><div class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></div><div class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></div><div class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></div><div class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                    Object stickyEvent = entry.getValue();</div><div class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是所有注册过程，现在再来看这张图就会特别清晰<code>EventBus</code>的<code>register()</code>过程了:</p>
<p><img src="/gallery/EventBus/register-flow-chart.png" alt=""></p>
<p>到这里，订阅流程就走完了。接下来我们在看事件分发的流程。</p>
<h4 id="2-3-发送事件Post"><a href="#2-3-发送事件Post" class="headerlink" title="2.3 发送事件Post"></a><strong>2.3 发送事件Post</strong></h4><p>我们知道发送事件是通过<code>post()</code> 方法进行广播的，比如第一节我们例子中提到的<code>EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;));</code> 接下来我们进入这个<code>post()</code>方法一窥究竟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    <span class="comment">//得到当前线程的Posting状态.</span></div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    <span class="comment">//获取当前线程的事件队列</span></div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    eventQueue.add(event);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">        <span class="comment">// 记录当前发送线程是否为主线程</span></div><div class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">        postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//处理队列，一直发送完所有事件</span></div><div class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">                <span class="comment">//发送单个事件</span></div><div class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">            postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是通过<code>currentPostingThreadState.get()</code>方法来得到当前线程<code>PostingThreadState</code>的对象，为什么是说当前线程？我们来看看<code>currentPostingThreadState</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实现是返回一个 <code>PostingThreadState</code> 对象，而 <code>PostingThreadState</code> 类的结构如下，封装的是当前线程的 post 信息，包括事件队列、是否正在分发中、是否在主线程、订阅者信息、事件实例、是否取消。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** For ThreadLocal, much faster to set (and get multiple values). */</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div><div class="line">    <span class="keyword">boolean</span> isPosting;</div><div class="line">    <span class="keyword">boolean</span> isMainThread;</div><div class="line">    Subscription subscription;</div><div class="line">    Object event;</div><div class="line">    <span class="keyword">boolean</span> canceled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综上，<code>currentPostingThreadState</code>的实现是一个包含了<code>PostingThreadState</code>的<code>ThreadLocal</code>对象，关于<code>ThreadLocal</code><a href="http://kymjs.com/code/2015/12/16/01" target="_blank" rel="external">张涛的这篇文章</a>解释的很好：<strong>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。</strong> 其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，通过这样就可以做到每个线程通过<code>get()</code> 方法获取的时候，取到的只能是自己线程所对应的数据。 所以这里取到的就是每个线程的<code>PostingThreadState</code>状态.接下来我们来看<code>postSingleEvent()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</div><div class="line">    Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//是否触发订阅了该事件(eventClass)的父类,以及接口的类的响应方法</span></div><div class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">        <span class="comment">//查找eventClass类所有的父类以及接口</span></div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">        <span class="comment">//循环postSingleEventForEventType</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</div><div class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">            <span class="comment">//只要右边有一个为true,subscriptionFound就为true</span></div><div class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//post单个</span></div><div class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没发现</span></div><div class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</div><div class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</div><div class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</div><div class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">            <span class="comment">//发送一个NoSubscriberEvent事件,如果我们需要处理这种状态,接收这个事件就可以了</span></div><div class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lookupAllEventTypes()</code> 就是查找该事件的所有父类，返回所有的该事件的父类的 class 。它通过循环和递归一起用，将一个类的父类（接口）全部添加到全局静态变量 <code>eventTypes</code> 集合中。跟着上面的代码的注释，我们可以很清楚的发现是在<code>postSingleEventForEventType()</code>方法里去进行事件的分发，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">    <span class="comment">//获取订阅了这个事件的Subscription列表.</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">            postingState.event = event;</div><div class="line">            postingState.subscription = subscription;</div><div class="line">            <span class="comment">//是否被中断</span></div><div class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//分发给订阅者</span></div><div class="line">                postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                aborted = postingState.canceled;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postingState.event = <span class="keyword">null</span>;</div><div class="line">                postingState.subscription = <span class="keyword">null</span>;</div><div class="line">                postingState.canceled = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (aborted) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</div><div class="line">    <span class="comment">//根据接收该事件的订阅方法约定的ThreadMode决定分配到哪个线程执行</span></div><div class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">        <span class="keyword">case</span> POSTING:</div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MAIN:</div><div class="line">            <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mainThreadPoster.enqueue(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BACKGROUND:</div><div class="line">            <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                backgroundPoster.enqueue(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ASYNC:</div><div class="line">            asyncPoster.enqueue(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结上面的代码就是,首先从<code>subscriptionsByEventType</code>里获得所有订阅了这个事件的<code>Subscription</code>列表，然后在通过<code>postToSubscription()</code>方法来分发事件，在<code>postToSubscription()</code>通过不同的<code>threadMode</code>在不同的线程里<code>invoke()</code>订阅者的方法,<code>ThreadMode</code>共有四类：</p>
<ol>
<li><code>PostThread</code>：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：<strong>对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作</strong>；</li>
<li><code>MainThread</code>：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，<code>MainThread</code>类的方法也不能有耗时操作，以避免卡主线程。适用场景：<strong>必须在主线程执行的操作</strong>；</li>
<li><code>BackgroundThread</code>：在后台线程中执行响应方法。如果发布线程<strong>不是</strong>主线程，则直接调用订阅者的事件响应函数，否则启动<strong>唯一的</strong>后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有<code>PostThread</code>类和<code>MainThread</code>类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：<em>操作轻微耗时且不会过于频繁</em>，即一般的耗时操作都可以放在这里；</li>
<li><code>Async</code>：不论发布线程是否为主线程，都使用一个空闲线程来处理。和<code>BackgroundThread</code>不同的是，<code>Async</code>类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：<em>长耗时操作，例如网络访问</em>。</li>
</ol>
<p>这里我们先看看<code>invokeSubscriber(subscription, event);</code>是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">        handleSubscriberException(subscription, event, e.getCause());</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上就是通过反射调用了订阅者的订阅函数并把<code>event</code>对象作为参数传入。然后我们就又遇到了在EventBus构造函数中初始化的3个Poster：<strong>HandlerPoster</strong>（也就是代码中的mainThreadPoster对象） ，<strong>BackgroundPoster</strong>和<strong>AsyncPoster</strong>，这 3 个 poster 负责线程间调度。我们分别来看看：</p>
<p><strong>#  HandlerPoster</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	<span class="comment">//队列，即将执行的Post</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">  	<span class="comment">//一个Post最大的在HandleMessage中的时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line">  	<span class="comment">//handler是否运行起来了</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</div><div class="line"></div><div class="line">    <span class="comment">//EventBus的构造函数中初始化了mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);</span></div><div class="line">    <span class="comment">//注意此处的Looper.getMainLooper()便指定了主线程的Looper</span></div><div class="line">    HandlerPoster(EventBus eventBus, Looper looper, <span class="keyword">int</span> maxMillisInsideHandleMessage) &#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">        <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">        <span class="keyword">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</div><div class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">      	<span class="comment">//PendingPost维护了一个可以复用PendingPost对象的复用池</span></div><div class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">          	<span class="comment">//加入到队列中</span></div><div class="line">            queue.enqueue(pendingPost);</div><div class="line">          	<span class="comment">//如果handleMessage没有运行起来</span></div><div class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</div><div class="line">                handlerActive = <span class="keyword">true</span>;</div><div class="line">              	<span class="comment">//发送一个空消息，让handleMessage运行起来</span></div><div class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> started = SystemClock.uptimeMillis();</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">              	<span class="comment">//从队列中取出PendingPost</span></div><div class="line">                PendingPost pendingPost = queue.poll();</div><div class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                        <span class="comment">// Check again, this time in synchronized</span></div><div class="line">                        pendingPost = queue.poll();</div><div class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                            handlerActive = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">              	<span class="comment">//调用eventBus的方法，分发消息</span></div><div class="line">                eventBus.invokeSubscriber(pendingPost);</div><div class="line">                <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</div><div class="line">              	<span class="comment">//如果再一定时间内都还没有将队列排空，则退出</span></div><div class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</div><div class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</div><div class="line">                    &#125;</div><div class="line">                    rescheduled = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            handlerActive = rescheduled;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们有必要回看EventBus的构造函数中初始化了<code>mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);</code>的代码。注意这行代码中传入的第二个参数<strong>Looper.getMainLooper()</strong>便指定了主线程的Looper，保证了这个HandlerPoster的运行在主线程。</p>
<p>然后<code>PendingPost</code> 的数据结构是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</div><div class="line">    Object event;<span class="comment">//事件</span></div><div class="line">    Subscription subscription;<span class="comment">//订阅</span></div><div class="line">    PendingPost next;<span class="comment">//与队列的数据结构有关，指向下一个节点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>PendingPost</code> 维护着一个可以复用PendingPost对象的复用池，通过 <code>obtainPendingPost(Subscription, Object)</code> 方法复用，通过 <code>releasePendingPost(PendingPost )</code> 方法回收。</p>
<p><code>handleMessage()</code> 中有一个死循环，这个死循环不停的从队列中拿数据，然后通过 <code>EventBus.invokeSubscriber()</code> 分发出去。每分发完一次比对一下时间，如果超过了 <code>maxMillisInsideHandleMessage</code> ，那么发送空 <code>message</code>再次进入到 <code>handlerMessage</code> 中且退出本次循环。</p>
<p><strong># BackgroundPoster</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Posts events in background.</div><div class="line"> * <span class="doctag">@author</span> Markus</div><div class="line"> */</div><div class="line"> <span class="comment">//我们注意到它实现了Runable接口</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</div><div class="line"></div><div class="line">    BackgroundPoster(EventBus eventBus) &#123;</div><div class="line">        <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">//加入到队列中</span></div><div class="line">            queue.enqueue(pendingPost);</div><div class="line">            <span class="keyword">if</span> (!executorRunning) &#123;</div><div class="line">                executorRunning = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//把自己这个Runable抛入线程池开始运行</span></div><div class="line">                eventBus.getExecutorService().execute(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                    <span class="comment">//从队列中取出PendingPost，此处的1000表示如果队列为空就暂停1000毫秒再取</span></div><div class="line">                    PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</div><div class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                            <span class="comment">// Check again, this time in synchronized</span></div><div class="line">                            pendingPost = queue.poll();</div><div class="line">                            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                                executorRunning = <span class="keyword">false</span>;</div><div class="line">                                <span class="keyword">return</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//调用eventBus的方法，分发消息</span></div><div class="line">                    eventBus.invokeSubscriber(pendingPost);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                Log.w(<span class="string">"Event"</span>, Thread.currentThread().getName() + <span class="string">" was interruppted"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            executorRunning = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理 <code>BackgroundPoster</code> ，只不过 <code>HandlerPoster</code> 是在 <code>handlerMessage</code> 中进行分发操作，而 <code>BackgroundPoster</code> 是在 <code>Runnable</code> 的 <code>run</code> 方法中将所有队列中的消息取出进行分发，直到取完为止。</p>
<p><strong># AsyncPoster</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Posts events in background.</div><div class="line"> * <span class="doctag">@author</span> Markus</div><div class="line"> */</div><div class="line"> <span class="comment">//它也实现Runable接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line"></div><div class="line">    AsyncPoster(EventBus eventBus) &#123;</div><div class="line">        <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">        queue.enqueue(pendingPost);</div><div class="line">        eventBus.getExecutorService().execute(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        PendingPost pendingPost = queue.poll();</div><div class="line">        <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</div><div class="line">        &#125;</div><div class="line">        eventBus.invokeSubscriber(pendingPost);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 <code>AsyncPoster</code> 虽然也是在 <code>Runnable</code> 的 <code>run</code> 方法中取出队列中的消息，但是只取一个。不论发布线程是否为主线程，都使用一个空闲线程来处理。和<code>BackgroundThread</code>不同的是，<code>Async</code>类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：<em>长耗时操作，例如网络访问</em>。</p>
<p>可以看到，不同的Poster会在post事件时，调度相应的事件队列PendingPostQueue，让每个订阅者的回调方法收到相应的事件，并在其注册的Thread中运行。而这个事件队列是一个链表，由一个个PendingPost组成，其中包含了事件，事件订阅者，回调方法这三个核心参数，以及需要执行的下一个PendingPost。至此<code>post()</code>流程就结束了，整体流程图如下：</p>
<p><img src="/gallery/EventBus/post-flow-chart.png" alt=""></p>
<h4 id="2-4-解除注册Unregister"><a href="#2-4-解除注册Unregister" class="headerlink" title="2.4 解除注册Unregister"></a>2.4 解除注册Unregister</h4><p>看完了上面的分析，解除注册就相对容易了，解除注册只要调用<code>unregister()</code>方法即可。实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    <span class="comment">//通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型,</span></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//分别解除每个订阅了的事件类型</span></div><div class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">            unsubscribeByEventType(subscriber, eventType);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从typesBySubscriber移除subscriber</span></div><div class="line">        typesBySubscriber.remove(subscriber);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后接着看<code>unsubscribeByEventType()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">    <span class="comment">//subscriptionsByEventType里拿出这个事件类型的订阅者列表.</span></div><div class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">        <span class="comment">//取消订阅</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            Subscription subscription = subscriptions.get(i);</div><div class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</div><div class="line">                subscription.active = <span class="keyword">false</span>;</div><div class="line">                subscriptions.remove(i);</div><div class="line">                i--;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终分别从<code>typesBySubscriber</code>和<code>subscriptions</code>里分别移除订阅者以及相关信息即可。</p>
<h3 id="三、EventBus原理分析"><a href="#三、EventBus原理分析" class="headerlink" title="三、EventBus原理分析"></a>三、EventBus原理分析</h3><p>在平时使用中我们不需要关心EventBus中对事件的分发机制，但要成为能够快速排查问题的老司机，我们还是得熟悉它的工作原理，下面我们就透过UML图来学习一下。</p>
<h4 id="3-1-核心架构"><a href="#3-1-核心架构" class="headerlink" title="3.1 核心架构"></a>3.1 核心架构</h4><p>EventBus的核心工作机制透过作者Blog中的这张图就能很好地理解：</p>
<p><img src="/gallery/EventBus/eventbus_overview.png" alt=""></p>
<p>订阅者模块需要通过EventBus订阅相关的事件，并准备好处理事件的回调方法，而事件发布者则在适当的时机把事件post出去，EventBus就能帮我们搞定一切。在架构方面，EventBus 3.0与之前稍老版本有不同，我们直接看架构图：</p>
<p><img src="/gallery/EventBus/class_overview.png" alt="EventBus 3.0架构图"></p>
<p>为了方便理解或者对比，顺便也放一张2.x老版本的结构图吧：</p>
<p><img src="/gallery/EventBus/class-relation.png" alt="EventBus 2.x老版本结构图"></p>
<p>虽然更新了3.0，但是整体上的设计还是可以用上面的类图来分析，从类图上我们可以看到大部分类都是依赖于EventBus的，上部分主要是订阅者相关信息，中间是 EventBus 类，下面是发布者发布事件后的调用。</p>
<p>根据UML图，我们先看核心类EventBus，其中<code>subscriptionByEventType</code>是以事件的类为key，订阅者的回调方法为value的映射关系表。也就是说EventBus在收到一个事件时，就可以根据这个事件的类型，在<code>subscriptionByEventType</code>中找到所有监听了该事件的订阅者及处理事件的回调方法。而<code>typesBySubscriber</code>则是每个订阅者所监听的事件类型表，在取消注册时可以通过该表中保存的信息，快速删除<code>subscriptionByEventType</code>中订阅者的注册信息，避免遍历查找。注册事件、发送事件和注销都是围绕着这两个核心数据结构来展开。上面的Subscription可以理解为每个订阅者与回调方法的关系，在其他模块发送事件时，就会通过这个关系，让订阅者执行回调方法。</p>
<p>回调方法在这里被封装成了<code>SubscriptionMethod</code>，里面保存了在需要反射invoke方法时的各种参数，包括优先级，是否接收黏性事件和所在线程等信息。而要生成这些封装好的方法，则需要<code>SubscriberMethodFinder</code>，它可以在regster时得到订阅者的所有回调方法，并封装返回给EventBus。而右边的加速器模块，就是为了提高<code>SubscriberMethodFinder</code>的效率，这里就不再啰嗦。</p>
<p>至此EventBus 3.0的架构就分析完了，与之前EventBus老版本最明显的区别在于：分发事件的调度单位从订阅者，细化成了订阅者的回调方法。也就是说每个回调方法都有自己的优先级，执行线程和是否接收黏性事件，提高了事件分发的灵活程度，接下来我们在看核心功能的实现时更能体现这一点。</p>
<h4 id="3-2-register"><a href="#3-2-register" class="headerlink" title="3.2 register"></a>3.2 register</h4><p>简单来说就是：根据订阅者的类来找回调方法，把订阅者和回调方法封装成关系，并保存到相应的数据结构中，为随后的事件分发做好准备，最后处理黏性事件。</p>
<p><img src="/gallery/EventBus/register.png" alt="注册订阅流程"></p>
<ol>
<li>根据订阅者来找到订阅方法和事件，封装成 <code>SubscriberMehod</code></li>
<li>循环每个 <code>SubscriberMethod</code></li>
<li>通过事件得到该事件的所有订阅者列表，再根据优先级插入到 <code>subscriptionsByEventType</code> 的所有订阅者列表中</li>
<li>通过订阅者得到该订阅者的所有事件列表，再将事件添加到 <code>typeBySubscriber</code> 的所以事件列表中</li>
<li>是否是粘性事件</li>
<li>是的话进行分发，post此事件给当前订阅者，不是的话不管</li>
<li>结束本次循环，跳到 2</li>
</ol>
<h4 id="3-3-post"><a href="#3-3-post" class="headerlink" title="3.3 post"></a>3.3 post</h4><p>总的来说就是分析事件，得到所有监听该事件的订阅者的回调方法，并利用反射来invoke方法，实现回调。</p>
<p><img src="/gallery/EventBus/post.png" alt="发送流程"></p>
<ol>
<li>从 <code>currentPostingThreadState</code> 中得到当前线程的 <code>PostThreadState</code> 信息</li>
<li>将此事件添加到 <code>PostPostThreadState</code> 的事件队列中</li>
<li>判断是否再分发</li>
<li>不是的话，循环队列，是的话跳 7</li>
<li>判断是个需要继承关系</li>
<li>是的话，循环得到父类，不是的话跳 7</li>
<li>查找该事件的订阅者，循环订阅者</li>
<li>根据 <code>ThreadMoth</code> 发送事件</li>
<li>结束本次循环订阅者，跳 7</li>
<li>结束本次循环队列，跳 4</li>
</ol>
<p>在源代码中为了保证post执行不会出现死锁，等待和对同一订阅者发送相同的事件，增加了很多线程保护锁和标志位，值得我们每个开发者学习。</p>
<h4 id="3-4-unregister"><a href="#3-4-unregister" class="headerlink" title="3.4 unregister"></a>3.4 unregister</h4><p>注销就比较简单了，把在注册时往两个数据结构中添加的订阅者信息删除即可：</p>
<p><img src="/gallery/EventBus/unregister.png" alt="注销流程"></p>
<p>至此大家对EventBus的运行原理应该有了一定的了解，虽然看起来像是一个复杂耗时的自动机，但大部分时候事件都是一瞬间就能分发到位的，而大家关心的性能问题反而是发生在注册EventBus的时候，因为需要遍历监听者的所有方法去找到回调的方法。作者也提到运行时注解的性能在Android上并不理想，为了解决这个问题，作者才会以索引的方式去生成回调方法表，也就是在EventBus 3.0中引入了<strong>EventBusAnnotationProcessor</strong>（注解分析生成索引）技术，大大提高了EventBus的运行效率。关于索引技术的源码分析，大家可以参考腾讯Bugly的这边文章：<a href="https://segmentfault.com/a/1190000005089229" target="_blank" rel="external">老司机教你 “飙” EventBus 3</a> 。</p>
<h3 id="四、缺点与问题"><a href="#四、缺点与问题" class="headerlink" title="四、缺点与问题"></a>四、缺点与问题</h3><p>一直以来，EventBus被大家吐槽的一大问题就是代码混淆问题。</p>
<h4 id="4-1-混淆问题"><a href="#4-1-混淆问题" class="headerlink" title="4.1 混淆问题"></a>4.1 混淆问题</h4><p>混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。</p>
<p>首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报<code>java.lang.NoSuchFieldError: No static field POSTING</code>。网上给出的解决办法是keep住所有eventbus相关的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">de</span>.<span class="title">greenrobot</span>.** </span>&#123;*;&#125;</div></pre></td></tr></table></figure>
<p>其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-keep <span class="keyword">public</span> <span class="keyword">enum</span> org.greenrobot.eventbus.ThreadMode &#123; <span class="keyword">public</span> <span class="keyword">static</span> *; &#125;</div></pre></td></tr></table></figure>
<p>这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：<code>Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?</code></p>
<p>这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * </span>&#123;</div><div class="line">    <span class="meta">@de</span>.greenrobot.event.Subscribe &lt;methods&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。</p>
<h4 id="4-2-跨进程问题"><a href="#4-2-跨进程问题" class="headerlink" title="4.2 跨进程问题"></a>4.2 跨进程问题</h4><p>目前EventBus只支持跨线程，而<strong>不支持跨进程</strong>。如果一个app的service起到了另一个进程中，那么注册监听的模块则会收不到另一个进程的EventBus发出的事件。这里可以考虑利用IPC做映射表，并在两个进程中各维护一个EventBus，不过这样就要自己去维护register和unregister的关系，比较繁琐，而且这种情况下通常用广播会更加方便，大家可以思考一下有没有更优的解决方案。</p>
<h4 id="4-3-事件环路问题"><a href="#4-3-事件环路问题" class="headerlink" title="4.3 事件环路问题"></a>4.3 事件环路问题</h4><p>在使用EventBus时，通常我们会把两个模块相互监听，来达到一个相互回调通信的目的。但这样一旦出现死循环，而且如果没有相应的日志信息，很难定位问题。所以在使用EventBus的模块，如果在回调上有环路，而且回调方法复杂到了一定程度的话，就要考虑把接收事件专门封装成一个子模块，同时考虑避免出现事件环路。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><code>EventBus</code>不论从使用方式和实现方式上都是非常值得我们学习的开源项目，可以说是目前消息通知里最好用的项目。但是业内对<code>EventBus</code>的主要争论点是在于<code>EventBus</code>使用反射会出现性能问题，实际上在<code>EventBus</code>里我们可以看到不仅可以使用注解处理器预处理获取订阅信息，<code>EventBus</code>也会将订阅者的方法缓存到<code>METHOD_CACHE</code>里避免重复查找，所以只有在最后<code>invoke()</code>方法的时候会比直接调用多出一些性能损耗。</p>
<p>而且相比旧版的2.x，现在新版的EventBus 3.0，订阅者已经没有固定的处理事件的方法了，<code>onEvent</code>、<code>onEventMainThread</code>、<code>onEventBackgroundThread</code>、<code>onEventAsync</code>都没有了，现在支持处理事件的方法名自定义，但必须public，只有一个参数，然后使用注解<code>@Subscribe</code>来标记该方法为处理事件的方法，ThreadMode和priority也通过该注解来定义。在subscriberMethodFinder中，通过反射的方式寻找事件方法。使用注解，用起来才更爽。</p>
<p>当然，EventBus并不是重构代码的唯一之选。作为观察者模式的“同门师兄弟”——RxJava，作为功能更为强大的响应式编程框架，可以轻松实现EventBus的事件总线功能（<a href="http://www.jianshu.com/p/ca090f6e2fe2" target="_blank" rel="external">RxBus</a>）。但毕竟大型项目要接入RxJava的成本高，复杂的操作符需要开发者投入更多的时间去学习。所以想在成熟的项目中快速地重构、解耦模块，EventBus依旧是我们的不二之选。</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://androiddevblog.com/eventbus-3-droidcon/" target="_blank" rel="external">Markus Junginger - EventBus 3 beta announced at droidcon</a></li>
<li><a href="https://segmentfault.com/a/1190000005089229" target="_blank" rel="external">老司机教你 “飙” EventBus 3</a> -  <a href="https://segmentfault.com/u/tencentbugly" target="_blank" rel="external"><strong>腾讯Bugly</strong></a></li>
<li><a href="https://kymjs.com/code/2015/12/12/01/" target="_blank" rel="external">EventBus源码研读(上)</a>，<a href="https://www.kymjs.com/code/2015/12/13/01/" target="_blank" rel="external">(中)</a>，<a href="https://kymjs.com/code/2015/12/16/01/" target="_blank" rel="external">(下)</a> - kymjs张涛</li>
<li><a href="http://yydcdut.com/2016/03/07/eventbus3-code-analyse/" target="_blank" rel="external">EventBus3.0源码解析</a> - yydcdut</li>
<li><a href="http://skykai521.github.io/2016/02/20/EventBus-3-0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">EventBus 3.0 源代码分析</a> - Skykai</li>
<li><a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">EventBus 源码解析</a> - codeKK</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="../../../../categories/源码分析/">源码分析</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/源码分析/">源码分析</a></li></ul>

      
        <div id="donation_div"></div>

<script src="../../../../js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/WeChanQR.png',
  alipayImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/AliPayQR.jpg'
});
</script>
      
            
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>


      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../../10/05/【Android】源码分析 - IntentService机制/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          【Android】源码分析 - IntentService机制
        
      </div>
    </a>
  
  
    <a href="../../20/【Java】try-catch-finally语句中return的执行顺序思考/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">【Java】try-catch-finally语句中return的执行顺序思考</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一、使用EventBus"><span class="nav-number">2.</span> <span class="nav-text">一、使用EventBus</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-初始化"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-定义事件"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 定义事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-监听事件"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 监听事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-发送事件"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 发送事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、EventBus源码跟踪"><span class="nav-number">3.</span> <span class="nav-text">二、EventBus源码跟踪</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-创建EventBus对象"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 创建EventBus对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-注册与订阅Register"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 注册与订阅Register</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-发送事件Post"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 发送事件Post</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-解除注册Unregister"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 解除注册Unregister</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、EventBus原理分析"><span class="nav-number">4.</span> <span class="nav-text">三、EventBus原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-核心架构"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 核心架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-register"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 register</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-post"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 post</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-unregister"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 unregister</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、缺点与问题"><span class="nav-number">5.</span> <span class="nav-text">四、缺点与问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-混淆问题"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 混淆问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-跨进程问题"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 跨进程问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-事件环路问题"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 事件环路问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、总结"><span class="nav-number">6.</span> <span class="nav-text">五、总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2017 iTimeTraveler All Rights Reserved.
          
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var contentdiv = document.getElementById("content");

    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

<!-- Custome JS -->
<script src="../../../../js/my.js"></script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../categories" class="mobile-nav-link">Categories</a>
  
    <a href="../../../../tags" class="mobile-nav-link">Tags</a>
  
    <a href="../../../../funnysite" class="mobile-nav-link">酷站</a>
  
    <a href="../../../../collection" class="mobile-nav-link">收藏</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
    <a href="../../../../mybooks" class="mobile-nav-link">🎁</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">
  <script src="../../../../fancybox/jquery.fancybox.pack.js"></script>


<script src="../../../../js/scripts.js"></script>
<script src="../../../../js/bootstrap.js"></script>
<script src="../../../../js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
