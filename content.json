{"meta":{"title":"iTimeTraveler","subtitle":null,"description":"Someone knock at the door.","author":"Mr.Seven","url":"http://github.com"},"pages":[{"title":"","date":"2017-07-20T08:05:11.191Z","updated":"2017-07-20T08:05:11.191Z","comments":true,"path":"404.html","permalink":"http://github.com/404.html","excerpt":"","text":"404 html body{ background-color: #000; } * { margin: 0; padding: 0; outline: none; font-family: \"Helvetica Neue\",Helvetica,\"Hiragino Sans GB\",\"楷体\",\"Microsoft YaHei\",Arial,sans-serif; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -khtml-user-select: none; user-select: none; cursor: default; font-weight: lighter; } .center { margin: 0 auto; } .whole { width: 100%; height: 100%; line-height: 100%; position: fixed; bottom: 0; left: 0; z-index: -1000; overflow: hidden; background: url(https://source.unsplash.com/collection/954550/1920x1080); background-size: cover; } .mask { width: 100%; height: 100%; position: absolute; top: 0; left: 0; background: #000; opacity: 0.6; filter: alpha(opacity=60); } .b { width: 100%; text-align: center; height: 400px; position: absolute; top: 50%; margin-top: -230px } .a { width: 150px; height: 50px; margin-top: 30px } .a a { display: block; float: left; width: 150px; height: 50px; background: #fff; text-align: center; line-height: 50px; font-size: 18px; border-radius: 25px; color: #333 } .a a:hover { color: #000; box-shadow: #fff 0 0 20px } p { color: #fff; margin-top: 40px; font-size: 30px; } #num { margin: 0 5px; font-weight: bold; } var num=10; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2017-10-11T04:15:44.555Z","comments":true,"path":"about/index.html","permalink":"http://github.com/about/index.html","excerpt":"","text":"That maybe happiness is something that we can only pursue. And maybe we can actually never have it….no matter what. Chris GardnerThe Pursuit of Happyness Profilethis part of my life… this little part, is called happiness 🎁. Bello, guys. I am ： iTimeTraveler I live in Beijing and work as a software developer. I use this site to blog on different topics that I like and hope you find interesting. I’m an Android Developer + prefer Python &amp; Golang + interest in AI(Artificial Intelligence) + Google radicals（Golang+Docker+Kubernetes+AngularJS). Social InfoYou can reach me by : iTime : iTimeTraveler : iTimeTraveler"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2016-08-26T08:58:29.695Z","comments":true,"path":"archives/index.html","permalink":"http://github.com/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2016-10-20T07:28:45.428Z","comments":false,"path":"categories/index.html","permalink":"http://github.com/categories/index.html","excerpt":"","text":""},{"title":"collection","date":"2016-11-25T06:30:53.000Z","updated":"2017-05-15T08:00:47.335Z","comments":true,"path":"collection/index.html","permalink":"http://github.com/collection/index.html","excerpt":"","text":""},{"title":"","date":"2017-07-02T03:30:53.000Z","updated":"2017-07-05T08:18:08.499Z","comments":true,"path":"mybooks/index.html","permalink":"http://github.com/mybooks/index.html","excerpt":"","text":"function setIframeHeight(iframe) { if (iframe) { var iframeWin = iframe.contentWindow || iframe.contentDocument.parentWindow; if (iframeWin.document.body) { iframe.height = iframeWin.document.documentElement.scrollHeight || iframeWin.document.body.scrollHeight; } } }; setIframeHeight(document.getElementsByTagName('iframe')[0]); window.onload = function () { setIframeHeight(document.getElementsByTagName('iframe')[0]); };"},{"title":"","date":"2017-07-10T02:31:58.217Z","updated":"2017-07-10T02:31:58.217Z","comments":true,"path":"mybooks/books.css","permalink":"http://github.com/mybooks/books.css","excerpt":"","text":".clear { clear: both } #main { /*padding-left: 105px; padding-top: 47px; padding-bottom: 30px;*/ clear: both; /* background: url(images/paper.jpg) left top #F2EDB4;*/ position: relative; /* z-index: 11;*/ box-shadow: 5px 5px 8px #888; margin-top: 50px; margin-bottom: 50px; } /* #main h2 { line-height: 30px; font-size: 17px; margin-bottom: 10px; position: relative; } #main h2 em { font-size: 14px; margin-left: 20px; } #main h2 em span,#main h2 em img { vertical-align: text-bottom; } #main h2 em a { color: #000 } #main h2 em a:hover { color: #1C5F8C; text-decoration: underline } #main h2 span.ad { position: absolute; top: -22px; left: 250px }*/ #main .tag { margin-bottom: 20px; height: 30px; line-height: 30px; font-size: 15px } #main .tag a { padding: 4px 12px } #book { /* margin: -47px 0 -30px -105px;*/ display: table; width: 100%; /*background: #F5F0B6*/ } #book h2 { height: 16px; margin: 0; /*padding: 45px 0 0 105px;*/ background: url(images/bookshelftop.jpg) no-repeat left top; color: #000!important; background-size: cover; } #book ul { float: left; height: auto; background: url(images/bookshelfmiddle.jpg) repeat-y left top; margin-bottom: 0; background-size: 100% 196px; -webkit-margin-before: 0em; -webkit-margin-after: 0em; -webkit-padding-start: 0em; padding: 0 5%; width: 90%; } #book ul li { list-style-type: none; /* height: 160px;*/ /* line-height: 160px;*/ vertical-align: bottom; width: 110px; float: left; margin: 17px 14px 0; padding-bottom: 19px; } #book ul li a { display: block; height: 160px; line-height: 160px; position: relative; } #book ul li img { width: 110px; vertical-align: bottom; box-shadow: 5px 0 6px #512301; position: absolute; bottom: 0; -webkit-transition: all .2s linear; transition: all .2s linear; } #book ul li img:hover { -webkit-box-shadow: 0 15px 30px rgba(0,0,0,0.1); box-shadow: 5px 15px 30px rgba(0,0,0,0.4); -webkit-transform: translate3d(0, -2px, 0); transform: translate3d(0, -2px, 0); }"},{"title":"","date":"2016-11-25T06:30:53.000Z","updated":"2017-10-19T11:26:59.868Z","comments":true,"path":"funnysite/index.html","permalink":"http://github.com/funnysite/index.html","excerpt":"人们对于“美”，都有着超乎自己想象的执念。 Website数据结构可视化：Data Structure Visualization 和 VisuAlgo - visualising data structures and algorithms through animation 写代码的猴子 冷淡简洁风格 jsdatav.is fatesinger themeakina html5up Akina theme 淡腾 louie iacool TA4.cn 波浪 EndSkin Wordpress主题 tagDiv &amp; （报纸）NEWSMAG 漂亮的蒙层 漂亮的电影网站 SPOTLIGHT 萨利机长 humaan Philip Walton(Engineer @ Google) Just Good Themes Mirana wordpress DREAMFY 老酒街 BeSteve code123.cc Statamic Hover效果 http://archive.li/A7Ro2 Funny Links ibireme Red Blob Games Joe’s Blog tarikfayad 设计筆記 朱腾鹏（像素癖） CaiCai PHILANTHROPY 2016 tagDiv IGK nerds.company &amp; 404 Oops 404 A Developer Diary 图集 from Dribbble","text":"人们对于“美”，都有着超乎自己想象的执念。 Website数据结构可视化：Data Structure Visualization 和 VisuAlgo - visualising data structures and algorithms through animation 写代码的猴子 冷淡简洁风格 jsdatav.is fatesinger themeakina html5up Akina theme 淡腾 louie iacool TA4.cn 波浪 EndSkin Wordpress主题 tagDiv &amp; （报纸）NEWSMAG 漂亮的蒙层 漂亮的电影网站 SPOTLIGHT 萨利机长 humaan Philip Walton(Engineer @ Google) Just Good Themes Mirana wordpress DREAMFY 老酒街 BeSteve code123.cc Statamic Hover效果 http://archive.li/A7Ro2 Funny Links ibireme Red Blob Games Joe’s Blog tarikfayad 设计筆記 朱腾鹏（像素癖） CaiCai PHILANTHROPY 2016 tagDiv IGK nerds.company &amp; 404 Oops 404 A Developer Diary 图集 from Dribbble from Dribbble from Dribbble from Dribbble"},{"title":"","date":"2017-07-10T02:49:22.650Z","updated":"2017-07-10T02:49:22.650Z","comments":true,"path":"mybooks/library.html","permalink":"http://github.com/mybooks/library.html","excerpt":"","text":"我的书架"},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2016-10-20T07:26:52.010Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-15T05:30:35.517Z","updated":"2017-05-15T05:26:34.739Z","comments":true,"path":"collection/code/jquery.lettering.js","permalink":"http://github.com/collection/code/jquery.lettering.js","excerpt":"","text":"/*global jQuery */ /*! * Lettering.JS 0.6.1 * * Copyright 2010, Dave Rupert http://daverupert.com * Released under the WTFPL license * http://sam.zoy.org/wtfpl/ * * Thanks to Paul Irish - http://paulirish.com - for the feedback. * * Date: Mon Sep 20 17:14:00 2010 -0600 */ (function($){ function injector(t, splitter, klass, after) { var a = t.text().split(splitter), inject = ''; if (a.length) { $(a).each(function(i, item) { inject += ''+item+''+after; }); t.empty().append(inject); } } var methods = { init : function() { return this.each(function() { injector($(this), '', 'char', ''); }); }, words : function() { return this.each(function() { injector($(this), ' ', 'word', ' '); }); }, lines : function() { return this.each(function() { var r = \"eefec303079ad17405c889e092e105b0\"; // Because it's hard to split a tag consistently across browsers, // (*ahem* IE *ahem*), we replaces all instances with an md5 hash // (of the word \"split\"). If you're trying to use this plugin on that // md5 hash string, it will fail because you're being ridiculous. injector($(this).children(\"br\").replaceWith(r).end(), r, 'line', ''); }); } }; $.fn.lettering = function( method ) { // Method calling logic if ( method && methods[method] ) { return methods[ method ].apply( this, [].slice.call( arguments, 1 )); } else if ( method === 'letters' || ! method ) { return methods.init.apply( this, [].slice.call( arguments, 0 ) ); // always pass an array } $.error( 'Method ' + method + ' does not exist on jQuery.lettering' ); return this; }; })(jQuery);"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:21:12.782Z","comments":false,"path":"collection/code/增长的树.html","permalink":"http://github.com/collection/code/增长的树.html","excerpt":"","text":"body { margin: 0; padding: 0; /*background:linear-gradient(360deg, #e56420, #37bbde);*/ overflow: hidden; background-color: black; width: 100%; height: 100vh; background-size: cover; background-blend-mode: hard-light; animation: hue-rotate 10s linear infinite; } @keyframes hue-rotate { from { -webkit-filter: hue-rotate(0); -moz-filter: hue-rotate(0); -ms-filter: hue-rotate(0); filter: hue-rotate(0); } to { -webkit-filter: hue-rotate(360deg); -moz-filter: hue-rotate(360deg); -ms-filter: hue-rotate(360deg); filter: hue-rotate(360deg); } } ; void function() { var depth = 16, branchWidth = 12, step = 0 var newDepthPub, depthPub var canvas = document.getElementById('mycanvas') var ctx = canvas.getContext('2d') canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.globalCompositeOperation = 'lighter'; var drawTree = function(ctx, startX, startY, length, angle, depth, branchWidth) { var rand = Math.random, newDepth, newLength, newAngle, maxBranch = 3, endX, endY, maxAngle = 2 * Math.PI / 4, subBranches, lenShrink; ctx.beginPath() ctx.moveTo(startX, startY) endX = startX + length * Math.cos(angle) endY = startY + length * Math.sin(angle) ctx.lineCap = 'round' ctx.lineWidth = branchWidth ctx.lineTo(endX, endY) if (depth > 0) + ',0)' } else { ctx.strokeStyle = 'rgb(' + (((rand() * 64) + 64) >> 0) + ',50, 25)' } ctx.stroke() newDepth = depth - 1 if (!newDepth) return subBranches = maxBranch - 1 branchWidth *= .7 for (var i = 0; i < subBranches; i++) { newAngle = angle + rand() * maxAngle - maxAngle * .5 newLength = length * (.7 + rand() * .3) setTimeout(function() { drawTree(ctx, endX, endY, newLength, newAngle, newDepth, branchWidth) newDepthPub = newDepth depthPub = depth step++; }, 100) } } var init = function() { step = 0 canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.globalCompositeOperation = 'lighter'; ctx.clearRect(0, 0, window.innerWidth, window.innerHeight) drawTree(ctx, ~~(window.innerWidth / 2), ~~(window.innerHeight / 1.02), 60, -Math.PI / 2, depth, branchWidth) } var regrow = function() { if (step < 65534) return init() } document.querySelector('body').addEventListener('click', function(e) { regrow() }) document.addEventListener('DOMContentLoaded', function() { init() }, false); window.onresize = regrow }();"},{"title":"","date":"2017-05-15T05:52:17.368Z","updated":"2017-05-15T05:52:17.368Z","comments":false,"path":"collection/code/字背景.html","permalink":"http://github.com/collection/code/字背景.html","excerpt":"","text":"Animated Knockout Letters html { background: black; } html, body { overflow: hidden; } #poster { width: 600px; margin: 30px auto; font-family: \"newcomen-1\",\"newcomen-2\"; } #poster h1 { color: white; background: url(img/a1.png) 100% 100% repeat; font-size: 130px; line-height: 0.7; text-align: center; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: -8px; -webkit-transition: all 2.5s; padding-bottom: 40px; } .step-one #poster h1 { padding-top: 130px; } #poster h1 span { -webkit-transition: all 2.5s; -moz-transition: all 2.5s; -o-transition: all 2.5s; } #poster h1 span.char1 { margin-left: -1450px; } #poster h1 span.char2 { margin-left: 200px; } #poster h1 span.char3 { margin-left: 200px; } #poster h1 span.char5 { margin-left: 1450px; } #poster h1 span.char6 { margin-left: 200px; } #poster h1 span.char7 { margin-left: 200px; } #poster h1 span.char8 { margin-left: 200px; } #poster h1 span.char9 { margin-left: 200px; } .step-one #poster h1 span { margin: 0; } #poster p { text-align: center; font-size: 30px; letter-spacing: 20px; } #poster p span { position: relative; -webkit-transition: all 2.5s ease; color: white; } .step-two #poster p span { top: 0 !important; left: 0 !important; } // DOM Ready $(function() { $(\"#poster h1, #poster p\").lettering(); $(\"#poster p span\").each(function() { $(this).css({ top: -(Math.floor(Math.random()*1001)+1500), left: Math.floor(Math.random()*1001)-500, }); }); setTimeout(function() {$('html').addClass(\"step-one\");}, 1000); setTimeout(function() {$('html').addClass(\"step-two\");}, 3000); }); 笔墨伺候 Coming 2011 * { margin: 0; padding: 0; } body { overflow-x: hidden; } .bsa_it_ad { padding: 8px 4px 8px 12px !important; position: relative; border: 0 !important; background: #D6D5D5 !important; border-top: 0 !important; box-shadow: 2px 2px 2px rgba(0, 0, 0, 0.1); font: 11px \"Lucida Grande\", Sans-Serif !important; } .bsa_it_ad:before, .bsa_it_ad:after { content: \"\"; position: absolute; top: 0; left: 6px; width: 100%; height: 100%; background: #989898; border-bottom: 6px solid #989898; z-index: -1; box-shadow: 2px 2px 2px rgba(0, 0, 0, 0.1); } .bsa_it_ad:before { top: 0; left: 12px; z-index: -2; background: #6C6666; border-bottom: 12px solid #6C6666; } .bsa_it_ad a { margin: 0 !important; padding: 0 !important; } .bsa_it_ad a img { border: 0 !important; position: static !important; } .bsa_it_ad a:hover img { margin: 0 !important; } .bsa_it_ad a:hover { background: none !important; } .bsa_it_i { margin: 0 15px 0 0 !important; } .bsa_it_t { font-size: 14px !important; margin: 12px 0 0 0 !important; } .bsa_it_d { padding-right: 10px; } .bsa_it_p{ display: none !important; } #demo-bar-ad { width: 416px; position: absolute; right: 0; top: -20px; font: 11px \"Lucida Grande\", Sans-Serif !important; } #bsap_aplink { position: absolute; color: #999; text-decoration: none; bottom: 8px !important; right: 8px !important; padding: 0 !important; } .bsa_it_p a:hover { background:none !important; }"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:15:36.900Z","comments":false,"path":"collection/code/彩色点点背景.html","permalink":"http://github.com/collection/code/彩色点点背景.html","excerpt":"","text":"jq22-code4 html, body { background: #fff; margin: 0; padding:0;} canvas { width: 100%; height: 100%; position: absolute; } $(function(){ var canvas = document.querySelector('canvas'), ctx = canvas.getContext('2d') canvas.width = window.innerWidth; canvas.height = window.innerHeight; ctx.lineWidth = .3; ctx.strokeStyle = (new Color(150)).style; var mousePosition = { x: 30 * canvas.width / 100, y: 30 * canvas.height / 100 }; var dots = { nb: 150, distance: 50, d_radius: 100, array: [] }; function colorValue(min) { return Math.floor(Math.random() * 255 + min); } function createColorStyle(r,g,b) { return 'rgba(' + r + ',' + g + ',' + b + ', 0.8)'; } function mixComponents(comp1, weight1, comp2, weight2) { return (comp1 * weight1 + comp2 * weight2) / (weight1 + weight2); } function averageColorStyles(dot1, dot2) { var color1 = dot1.color, color2 = dot2.color; var r = mixComponents(color1.r, dot1.radius, color2.r, dot2.radius), g = mixComponents(color1.g, dot1.radius, color2.g, dot2.radius), b = mixComponents(color1.b, dot1.radius, color2.b, dot2.radius); return createColorStyle(Math.floor(r), Math.floor(g), Math.floor(b)); } function Color(min) { min = min || 0; this.r = colorValue(min); this.g = colorValue(min); this.b = colorValue(min); this.style = createColorStyle(this.r, this.g, this.b); } function Dot(){ this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.vx = -.5 + Math.random(); this.vy = -.5 + Math.random(); this.radius = Math.random() * 2; this.color = new Color(); console.log(this); } Dot.prototype = { draw: function(){ ctx.beginPath(); ctx.fillStyle = this.color.style; ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); ctx.fill(); } }; function createDots(){ for(i = 0; i < dots.nb; i++){ dots.array.push(new Dot()); } } function moveDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; if(dot.y < 0 || dot.y > canvas.height){ dot.vx = dot.vx; dot.vy = - dot.vy; } else if(dot.x < 0 || dot.x > canvas.width){ dot.vx = - dot.vx; dot.vy = dot.vy; } dot.x += dot.vx; dot.y += dot.vy; } } function connectDots() { for(i = 0; i < dots.nb; i++){ for(j = 0; j < dots.nb; j++){ i_dot = dots.array[i]; j_dot = dots.array[j]; if((i_dot.x - j_dot.x) < dots.distance && (i_dot.y - j_dot.y) < dots.distance && (i_dot.x - j_dot.x) > - dots.distance && (i_dot.y - j_dot.y) > - dots.distance){ if((i_dot.x - mousePosition.x) < dots.d_radius && (i_dot.y - mousePosition.y) < dots.d_radius && (i_dot.x - mousePosition.x) > - dots.d_radius && (i_dot.y - mousePosition.y) > - dots.d_radius){ ctx.beginPath(); ctx.strokeStyle = averageColorStyles(i_dot, j_dot); ctx.moveTo(i_dot.x, i_dot.y); ctx.lineTo(j_dot.x, j_dot.y); ctx.stroke(); ctx.closePath(); } } } } } function drawDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; dot.draw(); } } function animateDots() { ctx.clearRect(0, 0, canvas.width, canvas.height); moveDots(); connectDots(); drawDots(); requestAnimationFrame(animateDots); } $('canvas').on('mousemove', function(e){ mousePosition.x = e.pageX; mousePosition.y = e.pageY; }); $('canvas').on('mouseleave', function(e){ mousePosition.x = canvas.width / 2; mousePosition.y = canvas.height / 2; }); createDots(); requestAnimationFrame(animateDots); });"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:02:18.871Z","comments":false,"path":"collection/code/圆形荡漾.html","permalink":"http://github.com/collection/code/圆形荡漾.html","excerpt":"","text":"jq22-code4 body { background: #291f34; overflow: hidden; } .loading { position: absolute; left: 50%; top: 30vh; margin-left: -20vh; display: block; width: 40vh; height: 40vh; text-align: center; -webkit-filter: contrast(1.2); filter: contrast(1.2); } .loading span { mix-blend-mode: screen; display: block; position: absolute; border-radius: 50%; -webkit-animation: wave 3s infinite linear; animation: wave 3s infinite linear; } .loading span:nth-child(0) { left: -11%; right: -2%; top: -12%; bottom: -5%; -webkit-transform-origin: 46% 53%; transform-origin: 46% 53%; -webkit-animation-delay: 0; animation-delay: 0; background-color: red; } .loading span:nth-child(1) { left: -4%; right: -4%; top: -9%; bottom: -2%; -webkit-transform-origin: 47% 50%; transform-origin: 47% 50%; -webkit-animation-delay: -1s; animation-delay: -1s; background-color: #ffd500; } .loading span:nth-child(2) { left: -11%; right: -4%; top: -10%; bottom: -11%; -webkit-transform-origin: 49% 53%; transform-origin: 49% 53%; -webkit-animation-delay: -1.5s; animation-delay: -1.5s; background-color: #55ff00; } .loading span:nth-child(3) { left: -7%; right: -9%; top: -11%; bottom: -4%; -webkit-transform-origin: 47% 52%; transform-origin: 47% 52%; -webkit-animation-delay: -2s; animation-delay: -2s; background-color: #00ff80; } .loading span:nth-child(4) { left: -8%; right: -3%; top: -5%; bottom: -11%; -webkit-transform-origin: 47% 52%; transform-origin: 47% 52%; -webkit-animation-delay: -2.5s; animation-delay: -2.5s; background-color: #00aaff; } .loading span:nth-child(5) { left: -10%; right: -8%; top: -4%; bottom: -9%; -webkit-transform-origin: 48% 51%; transform-origin: 48% 51%; -webkit-animation-delay: -3s; animation-delay: -3s; background-color: #2b00ff; } .loading span:nth-child(6) { left: -9%; right: -11%; top: -5%; bottom: -8%; -webkit-transform-origin: 47% 50%; transform-origin: 47% 50%; -webkit-animation-delay: -3.5s; animation-delay: -3.5s; background-color: magenta; } @-webkit-keyframes wave { from { -webkit-transform: rotateZ(0deg); transform: rotateZ(0deg); } to { -webkit-transform: rotateZ(360deg); transform: rotateZ(360deg); } } @keyframes wave { from { -webkit-transform: rotateZ(0deg); transform: rotateZ(0deg); } to { -webkit-transform: rotateZ(360deg); transform: rotateZ(360deg); } }"},{"title":"","date":"2016-11-25T07:33:51.201Z","updated":"2016-11-25T07:12:59.479Z","comments":false,"path":"collection/code/手表.html","permalink":"http://github.com/collection/code/手表.html","excerpt":"","text":"function reload_html() { $(\"\\x62\\x6f\\x64\\x79\")[\"\\x68\\x74\\x6d\\x6c\"](\"\"); } function addhtml(lViZBL1) { $(\"\\x62\\x6f\\x64\\x79\")[\"\\x68\\x74\\x6d\\x6c\"](lViZBL1); } function addcss(CDEsDFFJ2) { var EZS_sF3 = window[\"\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\"][\"\\x63\\x72\\x65\\x61\\x74\\x65\\x45\\x6c\\x65\\x6d\\x65\\x6e\\x74\"](\"\\x73\\x74\\x79\\x6c\\x65\"); EZS_sF3[\"\\x69\\x6e\\x6e\\x65\\x72\\x48\\x54\\x4d\\x4c\"] = CDEsDFFJ2; window[\"\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\"][\"\\x71\\x75\\x65\\x72\\x79\\x53\\x65\\x6c\\x65\\x63\\x74\\x6f\\x72\"](\"\\x62\\x6f\\x64\\x79\")[\"\\x61\\x70\\x70\\x65\\x6e\\x64\\x43\\x68\\x69\\x6c\\x64\"](EZS_sF3); } function addjs(qGZu4) { $(\"\\x62\\x6f\\x64\\x79\")[\"\\x61\\x70\\x70\\x65\\x6e\\x64\"](qGZu4); } function jqban(nJ5) { $(\"\\x23\\x6a\\x71\\x62\\x62\")[\"\\x61\\x74\\x74\\x72\"](\"\\x73\\x72\\x63\", \"\\x68\\x74\\x74\\x70\\x3a\\x2f\\x2f\\x6c\\x69\\x62\\x73\\x2e\\x62\\x61\\x69\\x64\\x75\\x2e\\x63\\x6f\\x6d\\x2f\\x6a\\x71\\x75\\x65\\x72\\x79\\x2f\" + nJ5 + \"\\x2f\\x6a\\x71\\x75\\x65\\x72\\x79\\x2e\\x6d\\x69\\x6e\\x2e\\x6a\\x73\"); } @import \"https://fonts.googleapis.com/css?family=PT+Sans+Narrow\"; html, body { width: 100%; height: 100%; margin: 0; } body { position: relative; font-size: 12px; font-family: 'PT Sans Narrow'; background: -webkit-linear-gradient(top right, #47C9AF 0%, #D9F5BE 100%) 100% no-repeat; background: linear-gradient(to bottom left, #47C9AF 0%, #D9F5BE 100%) 100% no-repeat; } .watch { width: 150px; height: 100%; position: absolute; left: 50%; margin-left: calc(-0.5 * 150px); } .strap { background: #292929; height: 100%; width: 90px; border-left: 5px solid #4a4a4a; border-right: 5px solid #4a4a4a; position: absolute; left: 50%; margin-left: calc(-0.5 * calc(90px + 10px)); } .face { background: #292929; border: 5px solid #CDB380; width: 140px; height: 140px; position: absolute; top: 50%; margin-top: calc(-0.5 * 150px); box-shadow: 0 0 80px 0 rgba(0, 0, 0, 0.6), inset 0 0 50px 0 rgba(0, 0, 0, 0.6); } .numeral { background: #4a4a4a; height: 20px; width: 4px; } .n-12, .n-6 { position: absolute; left: 50%; margin-left: calc(-0.5 * 4px); } .n-3, .n-9 { height: 4px; width: 20px; position: absolute; top: 50%; margin-top: calc(-0.5 * 4px); } .n-12 { top: 5px; } .n-6 { bottom: 5px; } .n-3 { right: 5px; } .n-9 { left: 5px; } .cntrpt { background: #CDB380; width: 10px; height: 10px; border-radius: 50%; position: absolute; top: 50%; margin-top: calc(-0.5 * 10px); position: absolute; left: 50%; margin-left: calc(-0.5 * 10px); } .crown { background: #4a4a4a; height: 20px; width: 10px; right: -10px; position: absolute; top: 50%; margin-top: calc(-0.5 * 20px); } .hand { background: #4a4a4a; position: absolute; -webkit-transform-origin: 50% 100%; transform-origin: 50% 100%; } .hours { width: 6px; height: calc(0.2 * 140px); position: absolute; left: 50%; margin-left: calc(-0.5 * 6px); top: calc(0.5 * 140px - calc(0.2 * 140px)); } .mins { width: 4px; height: calc(0.3 * 140px); position: absolute; left: 50%; margin-left: calc(-0.5 * 4px); top: calc(0.5 * 140px - calc(0.3 * 140px)); } .secs { background: #BF4A67; width: 2px; height: calc(0.4 * 140px); position: absolute; left: 50%; margin-left: calc(-0.5 * 2px); top: calc(0.5 * 140px - calc(0.4 * 140px)); } .day { background: #292929; color: #CDB380; border: 1px solid #CDB380; width: calc(0.13 * 140px); height: calc(0.1 * 140px); line-height: calc(0.1 * 140px); text-align: center; position: absolute; top: 50%; margin-top: calc(-0.5 * calc(0.13 * 140px)); right: 28px; } .logo { color: #CDB380; width: 40px; letter-spacing: 5px; height: 12px; line-height: 12px; text-align: center; position: absolute; left: 50%; margin-left: calc(-0.5 * 40px); top: 36px; } SWAG 25 const hours = document.getElementById('hours'), mins = document.getElementById('mins'), secs = document.getElementById('secs'), day = document.getElementById('day'); let time; function getTime() { time = new Date(Date.now()); return { hours: convertToDeg(time.getHours(), 12), mins: convertToDeg(time.getMinutes(), 60), secs: convertToDeg(time.getSeconds(), 60), day: time.getDate() < 10 ? `0${time.getDate()}` : `${time.getDate()}` }; } function convertToDeg(time, factor) { return time * (360 / factor); } function setClock(time) { hours.style.transform = `rotate(${time.hours}deg)`; mins.style.transform = `rotate(${time.mins}deg)`; secs.style.transform = `rotate(${time.secs}deg)`; day.innerHTML = `${time.day}`; } setClock(getTime()); setInterval(() => { setClock(getTime()); }, 1000);"},{"title":"","date":"2017-05-15T07:13:38.859Z","updated":"2017-05-15T07:13:38.859Z","comments":true,"path":"collection/code/curtains-cloth.js","permalink":"http://github.com/collection/code/curtains-cloth.js","excerpt":"","text":"var physics_accuracy = 3, mouse_influence = 20, mouse_cut = 5, gravity = 1200, cloth_height = 30, cloth_width = 50, start_y = 20, spacing = 7, tear_distance = 60; window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { window.setTimeout(callback, 1000 / 60); }; var canvas, ctx, cloth, boundsx, boundsy, mouse = { down: false, button: 1, x: 0, y: 0, px: 0, py: 0 }; var Point = function(x, y) { this.x = x; this.y = y; this.px = x; this.py = y; this.vx = 0; this.vy = 0; this.pin_x = null; this.pin_y = null; this.constraints = []; }; Point.prototype.update = function(delta) { if (mouse.down) { var diff_x = this.x - mouse.x, diff_y = this.y - mouse.y, dist = Math.sqrt(diff_x * diff_x + diff_y * diff_y); if (mouse.button == 1) { if (dist < mouse_influence) { this.px = this.x - (mouse.x - mouse.px) * 1.8; this.py = this.y - (mouse.y - mouse.py) * 1.8; } } else if (dist < mouse_cut) this.constraints = []; } this.add_force(0, gravity); delta *= delta; nx = this.x + ((this.x - this.px) * .99) + ((this.vx / 2) * delta); ny = this.y + ((this.y - this.py) * .99) + ((this.vy / 2) * delta); this.px = this.x; this.py = this.y; this.x = nx; this.y = ny; this.vy = this.vx = 0 }; Point.prototype.draw = function() { if (this.constraints.length boundsx) { this.x = 2 * boundsx - this.x; } else if (this.x < 1) { this.x = 2 - this.x; } if (this.y > boundsy) { this.y = 2 * boundsy - this.y; } else if (this.y < 1) { this.y = 2 - this.y; } }; Point.prototype.attach = function(point) { this.constraints.push(new Constraint(this, point)); }; Point.prototype.remove_constraint = function(lnk) { var i = this.constraints.length; while (i--) if (this.constraints[i] == lnk) this.constraints.splice(i, 1); }; Point.prototype.add_force = function(x, y) { this.vx += x; this.vy += y; }; Point.prototype.pin = function(pinx, piny) { this.pin_x = pinx; this.pin_y = piny; }; var Constraint = function(p1, p2) { this.p1 = p1; this.p2 = p2; this.length = spacing; }; Constraint.prototype.resolve = function() { var diff_x = this.p1.x - this.p2.x, diff_y = this.p1.y - this.p2.y, dist = Math.sqrt(diff_x * diff_x + diff_y * diff_y), diff = (this.length - dist) / dist; if (dist > tear_distance) this.p1.remove_constraint(this); var px = diff_x * diff * 0.5; var py = diff_y * diff * 0.5; this.p1.x += px; this.p1.y += py; this.p2.x -= px; this.p2.y -= py; }; Constraint.prototype.draw = function() { ctx.moveTo(this.p1.x, this.p1.y); ctx.lineTo(this.p2.x, this.p2.y); }; var Cloth = function() { this.points = []; var start_x = canvas.width / 2 - cloth_width * spacing / 2; for (var y = 0; y"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:17:31.961Z","comments":false,"path":"collection/code/文件归档.html","permalink":"http://github.com/collection/code/文件归档.html","excerpt":"","text":"jq22-code4 @import 'https://fonts.googleapis.com/css?family=Roboto:100,300,400,700'; * { margin: 0; padding: 0; box-sizing: border-box; font-family: \"Roboto\", Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { background-color: #37354c; margin: 0; } body .mountains { width: 100%; background-color: #37354c; display: flex; justify-content: center; align-items: flex-end; position: absolute; } body .mountains::before { width: 100%; height: 20em; background-color: rgba(255, 255, 255, 0.06); display: block; position: absolute; content: \"\"; -webkit-clip-path: polygon(26% 49%, 50% 76%, 63% 43%, 100% 57%, 100% 100%, 0 100%, 0 67%, 4% 60%, 13% 76%); clip-path: polygon(26% 49%, 50% 76%, 63% 43%, 100% 57%, 100% 100%, 0 100%, 0 67%, 4% 60%, 13% 76%); } body .mountains::after { width: 100%; height: 20em; background-color: rgba(255, 255, 255, 0.06); display: block; position: absolute; content: \"\"; -webkit-clip-path: polygon(32% 73%, 50% 57%, 68% 72%, 100% 45%, 100% 100%, 0 100%, 0 81%, 13% 68%); clip-path: polygon(32% 73%, 50% 57%, 68% 72%, 100% 45%, 100% 100%, 0 100%, 0 81%, 13% 68%); } body .container { display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; position: absolute; } body .container .case { z-index: 2; display: flex; background-color: rgba(78, 170, 127, 0.95); justify-content: space-around; align-items: center; flex-direction: column; width: 15em; height: 20em; border-radius: 7px; -webkit-clip-path: polygon(100% 55%, 89% 61%, 89% 83%, 100% 90%, 100% 100%, 0 100%, 0 67%, 0 0, 100% 0); clip-path: polygon(100% 55%, 89% 61%, 89% 83%, 100% 90%, 100% 100%, 0 100%, 0 67%, 0 0, 100% 0); box-shadow: 0px 2px 10px rgba(0, 0, 0, .3); } body .container .case .ion { color: white; font-size: 6em; } body .container .case .case-txt { text-transform: uppercase; font-weight: 400; color: white; font-size: 1.5em; padding-left: 45px; padding-right: 45px; text-align: center; } body .container .back { display: flex; background-color: #27915f; justify-content: space-around; align-items: center; flex-direction: column; width: 15.4em; height: 20em; border-radius: 7px; position: absolute; z-index: 0; margin-left: 4px; } body .container .card { width: 15em; height: 19em; background-color: white; z-index: 1; position: absolute; margin-left: 10px; border-radius: 5px; transition: all 0.5s; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 0.3rem rgba(0, 0, 0, 0.2); } body .container .card:hover { cursor: pointer; transform: translateX(20px); } .animateCard { animation: 1s ease-in-out animateCard; animation-fill-mode: forwards; } .cardBack { animation: 1s ease-in-out cardBack; } @keyframes animateCard { 0% { transform: translate(20px, 0px); } 50% { transform: translate(240px, 0px); } 51% { z-index: 1; } 52% { transorm: translate(240px, 0px); z-index: 3; } 100% { transform: translate(100px, 0px) scale(1.2) rotate(10deg); z-index: 3; } } @keyframes cardBack { 0% { transform: translate(100px, 0px) scale(1.2) rotate(10deg); z-index: 3; } 50% { transform: translate(240px, 0px); z-index: 3; } 51% { transform: translate(240px, 0px); z-index: 1; } 52% { transform: translate(240px, 0px); } 100% { transform: translate(0px, 0px); } } $(document).ready(function() { $('.card').click(function() { $(this).toggleClass('animateCard'); $(this).toggleClass('cardBack'); }); }); My card collector Click me!"},{"title":"","date":"2017-05-15T06:04:02.934Z","updated":"2017-05-15T06:04:02.934Z","comments":false,"path":"collection/code/窗帘子.html","permalink":"http://github.com/collection/code/窗帘子.html","excerpt":"","text":"Tearable Cloth"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:11:50.792Z","comments":false,"path":"collection/code/老虎.html","permalink":"http://github.com/collection/code/老虎.html","excerpt":"","text":"jq22-code4 /* Colors */ .st0 { fill: #FFE475; } .st1 { fill: #C26C47; } .st2 { fill: #49312D; } .st3 { fill: #604219; } .st4 { fill: #554D4D; } .st5 { fill: #635723; } .st6 { fill: #84712C; } .st7 { fill: #947158; } .st8 { fill: #C07E48; } .st9 { fill: #C98777; } .st10 { fill: #DF9126; } .st11 { fill: #F68C47; } .st12 { fill: #FBAD23; } .st13 { fill: #F8B26C; } .st14 { fill: #EEC075; } .st15 { fill: #F6DC8F; } .st16 { fill: #EAD4B5; } .st17 { fill: #EADDCE; } .st18 { fill: #FEF8CC; } .st19 { fill: #FEFDF4; } .st20 { fill: #E9E9EA; } .st21 { fill: #BBBCAC; } .st22 { fill: #C9C0AD; } .st23 { fill: #D3C8C2; } .st24 { fill: #AFA49F; } .st25 { fill: #8D7D71; } .st26 { fill: #B5AD6E; } .st27 { fill: #787FA0; } .st28 { fill: #E1AFA3; } .st29 { fill: #D69385; } .st30 { fill: #C69849; } .st31 { fill: #FAA64C; } .st32 { fill: #FFD386; } .st33 { fill: #D1C76D; } .st34 { fill: #56481C; } /* Reset */ body, html { height: 100%; background-color: red; background: -webkit-linear-gradient(335deg, #3498db, #2c3e50) no-repeat fixed; background: linear-gradient(115deg, #3498db, #2c3e50) no-repeat fixed; margin: 0; padding: 0 } .myName { position: absolute; top: 1em; left: 1em; padding: 5px 15px; color: #FFF; font-family: arial; width: 30%; } .myName a { color: #FFF; text-decoration: none; font-size: 1.3em; font-weight: normal; float: left; margin-top: 3%; margin-left: 3%; } .myName a:hover { text-decoration: underline; } .myName img { width: 50px; border-radius: 50%; float: left; } .layer { position: absolute; width: 40vw; height: 41vw; top: 50%; left: 50%; margin-left: -20vw; margin-top: -18vw; z-index: 2; cursor: pointer } svg { position: absolute; top: 15%; right: 0; left: 50%; bottom: 0; margin-left: -20vw; width: 40vw; overflow: visible; z-index: 1; } polygon, path, ellipse { fill-opacity: 1; -webkit-transform: translate(0); transform: translate(0); -webkit-transition: all 1s ease; transition: all 1s ease; -webkit-animation-fill-mode: forwards; animation-fill-mode: forwards; -webkit-transform-origin: 50% 50%; transform-origin: 50% 50%; stroke-dasharray: 500; stroke-dashoffset: 500; } /*========================= Right Side Stuff /*=======================*/ #right-side polygon:nth-of-type(5n+1), #right-side path:nth-of-type(5n+1), #right-side ellipse { -webkit-animation: backToPlace1 8s ease-in-out 1; animation: backToPlace1 8s ease-in-out 1; } @-webkit-keyframes backToPlace1 { 0% { -webkit-transform: translate(300%, 300%) scale(1) rotate(180deg); transform: translate(300%, 300%) scale(1) rotate(180deg); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } @keyframes backToPlace1 { 0% { -webkit-transform: translate(300%, 300%) scale(1) rotate(180deg); transform: translate(300%, 300%) scale(1) rotate(180deg); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } #right-side polygon:nth-of-type(5n+2), #right-side path:nth-of-type(5n+2) { -webkit-animation: backToPlace2 8s ease-in-out 1; animation: backToPlace2 8s ease-in-out 1; } @-webkit-keyframes backToPlace2 { 0% { -webkit-transform: translate(-300%, -300%) scale(1) rotate(180deg) translateZ(-400px); transform: translate(-300%, -300%) scale(1) rotate(180deg) translateZ(-400px); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } @keyframes backToPlace2 { 0% { -webkit-transform: translate(-300%, -300%) scale(1) rotate(180deg) translateZ(-400px); transform: translate(-300%, -300%) scale(1) rotate(180deg) translateZ(-400px); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } #right-side polygon:nth-of-type(5n+3), #right-side path:nth-of-type(5n+3) { -webkit-animation: backToPlace3 8s ease-in-out 1; animation: backToPlace3 8s ease-in-out 1; } @-webkit-keyframes backToPlace3 { 0% { -webkit-transform: translate(200%, -400%) scale(1.5) rotate(50deg) translateZ(400px); transform: translate(200%, -400%) scale(1.5) rotate(50deg) translateZ(400px); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } @keyframes backToPlace3 { 0% { -webkit-transform: translate(200%, -400%) scale(1.5) rotate(50deg) translateZ(400px); transform: translate(200%, -400%) scale(1.5) rotate(50deg) translateZ(400px); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } #right-side polygon:nth-of-type(5n+4), #right-side path:nth-of-type(5n+4), #right-side polygon:nth-of-type(5n+5), #right-side path:nth-of-type(5n+5) { -webkit-animation: backToPlace4 8s ease-in-out 1; animation: backToPlace4 8s ease-in-out 1; } @-webkit-keyframes backToPlace4 { 0% { -webkit-transform: scale(0); transform: scale(0); opacity: 0 } 10% { -webkit-transform: scale(.1); transform: scale(.1); } 20% { -webkit-transform: scale(.2); transform: scale(.2); } 30% { -webkit-transform: scale(.3); transform: scale(.3); } 40% { -webkit-transform: scale(.4); transform: scale(.4); } 50% { -webkit-transform: scale(.5); transform: scale(.5); } 60% { -webkit-transform: scale(.6); transform: scale(.6); } 70% { -webkit-transform: scale(.7); transform: scale(.7); } 80% { -webkit-transform: scale(.8); transform: scale(.8); } 90% { -webkit-transform: scale(.9); transform: scale(.9); } 100% { -webkit-transform: translate(0) scale(1); transform: translate(0) scale(1); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } @keyframes backToPlace4 { 0% { -webkit-transform: scale(0); transform: scale(0); opacity: 0 } 10% { -webkit-transform: scale(.1); transform: scale(.1); } 20% { -webkit-transform: scale(.2); transform: scale(.2); } 30% { -webkit-transform: scale(.3); transform: scale(.3); } 40% { -webkit-transform: scale(.4); transform: scale(.4); } 50% { -webkit-transform: scale(.5); transform: scale(.5); } 60% { -webkit-transform: scale(.6); transform: scale(.6); } 70% { -webkit-transform: scale(.7); transform: scale(.7); } 80% { -webkit-transform: scale(.8); transform: scale(.8); } 90% { -webkit-transform: scale(.9); transform: scale(.9); } 100% { -webkit-transform: translate(0) scale(1); transform: translate(0) scale(1); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } /* Hover Animation */ /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+1), .layer:hover + svg #right-side path:nth-of-type(5n+1) { -webkit-transform: translate(200%, -600%) scale(1.5) rotate(100deg) translateZ(0); transform: translate(200%, -600%) scale(1.5) rotate(100deg) translateZ(0); opacity: .3; } /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+2), .layer:hover + svg #right-side path:nth-of-type(5n+2) { -webkit-transform: translate(800%, -600%) scale(.5) rotate(100deg) translateZ(0); transform: translate(800%, -600%) scale(.5) rotate(100deg) translateZ(0); opacity: .3; fill-opacity: 0; stroke-width: .5px; stroke: #FFF; stroke-dashoffset: 0; } /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+3), .layer:hover + svg #right-side path:nth-of-type(5n+3) { -webkit-transform: translate(1000%, 0) scale(1.5) rotate(100deg) translateZ(0); transform: translate(1000%, 0) scale(1.5) rotate(100deg) translateZ(0); opacity: .3; } /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+4), .layer:hover + svg #right-side path:nth-of-type(5n+4) { -webkit-transform: translate(1000%, 600%) scale(1) rotate(100deg) translateZ(0); transform: translate(1000%, 600%) scale(1) rotate(100deg) translateZ(0); opacity: .3; fill-opacity: 0; stroke-width: .5px; stroke: #FFF; stroke-dashoffset: 0; } /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+5), .layer:hover + svg #right-side path:nth-of-type(5n+5), .layer:hover + svg #right-side ellipse { -webkit-transform: translate(0, 1000%) scale(.5) rotate(100deg) translateZ(0); transform: translate(0, 1000%) scale(.5) rotate(100deg) translateZ(0); opacity: .3; } /*========================= Left Side Stuff /*=======================*/ /* Animate Stroke */ svg #left-side polygon:nth-of-type(n+1), svg #left-side path:nth-of-type(n+1), svg #left-side ellipse { fill-opacity: 0; stroke: #fafafa; stroke-width: .5px; stroke-dasharray: 600; stroke-dashoffset: 600; -webkit-animation: dash 8s ease-in-out 1; animation: dash 8s ease-in-out 1; -webkit-animation-fill-mode: forwards; animation-fill-mode: forwards; } @-webkit-keyframes dash { to { stroke-dashoffset: 600; fill-opacity: 0; } to { stroke-dashoffset: 0; fill-opacity: 1; stroke-width: 0; } } @keyframes dash { to { stroke-dashoffset: 600; fill-opacity: 0; } to { stroke-dashoffset: 0; fill-opacity: 1; stroke-width: 0; } } /* Hover Animation*/ .layer:hover + svg #left-side polygon:nth-of-type(5n+1), .layer:hover + svg #left-side path:nth-of-type(5n+1) { -webkit-transform: translate(-400%, -400%) scale(1.5) rotate(200deg) translateZ(0); transform: translate(-400%, -400%) scale(1.5) rotate(200deg) translateZ(0); opacity: .3 } /**/ .layer:hover + svg #left-side polygon:nth-of-type(5n+2), .layer:hover + svg #left-side path:nth-of-type(5n+2) { -webkit-transform: translate(-800%, -100%) scale(1) rotate(100deg) translateZ(0); transform: translate(-800%, -100%) scale(1) rotate(100deg) translateZ(0); opacity: .3; fill-opacity: 0; stroke-width: .5px; stroke: #FFF; stroke-dashoffset: 0; } /**/ .layer:hover + svg #left-side polygon:nth-of-type(5n+3), .layer:hover + svg #left-side path:nth-of-type(5n+3) { -webkit-transform: translate(-800%, 100%) scale(.5) rotate(0) translateZ(0); transform: translate(-800%, 100%) scale(.5) rotate(0) translateZ(0); opacity: .3; fill-opacity: 0; stroke-width: .5px; stroke: #FFF; stroke-dashoffset: 0; } /**/ .layer:hover + svg #left-side polygon:nth-of-type(5n+4), .layer:hover + svg #left-side path:nth-of-type(5n+4) { -webkit-transform: translate(-800%, 500%) scale(.9) rotate(300deg) translateZ(0); transform: translate(-800%, 500%) scale(.9) rotate(300deg) translateZ(0); opacity: .5 } /**/ .layer:hover + svg #left-side polygon:nth-of-type(5n+5), .layer:hover + svg #left-side path:nth-of-type(5n+5), .layer:hover + svg #left-side ellipse { -webkit-transform: translate(0, 900%) scale(1.3) rotate(300deg) translateZ(0); transform: translate(0, 900%) scale(1.3) rotate(300deg) translateZ(0); opacity: .3 } Eslam nasser"},{"title":"","date":"2017-07-05T08:17:59.376Z","updated":"2017-07-05T08:17:59.376Z","comments":false,"path":"collection/code/图片轮播.html","permalink":"http://github.com/collection/code/图片轮播.html","excerpt":"","text":"流光溢彩的Bootstrap响应式幻灯片特效 body{ background:#000; } .jq22-header h1{ text-align: center; font-size: 18px; } section.awSlider .carousel{ display:table; z-index:2; -moz-box-shadow: 0 0 4px #444; -webkit-box-shadow: 0 0 4px #444; box-shadow: 0 0 15px rgba(1,1,1,.5); } section.awSlider{ margin:30px auto; padding:30px; position:relative; display:table; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } section.awSlider:hover > img{ -ms-transform: scale(1.2); -webkit-transform: scale(1.2); transform: scale(1.2); opacity:1; } section.awSlider img{ pointer-events: none; } section.awSlider > img{ position:absolute; top:30px; z-index:1; transition:all .3s; filter: blur(1.8vw); -webkit-filter: blur(2vw); -moz-filter: blur(2vw); -o-filter: blur(2vw); -ms-filter: blur(2vw); -ms-transform: scale(1.1); -webkit-transform: scale(1.1); transform: scale(1.1); opacity:.5; } 清明时节雨纷纷 Görsel #3 Görsel #4 Geri İleri $('section.awSlider .carousel').carousel({ pause: 'hover', interval: 2000 }); var startImage = $('section.awSlider .item.active > img').attr('src'); $('section.awSlider').append(''); $('section.awSlider .carousel').on('slid.bs.carousel', function () { var bscn = $(this).find('.item.active > img').attr('src'); $('section.awSlider > img').attr('src', bscn); });"}],"posts":[{"title":"【算法】如何判断链表有环","slug":"【算法】如何判断链表有环","date":"2017-12-24T14:20:55.000Z","updated":"2017-12-27T02:26:43.425Z","comments":true,"path":"2017/12/24/【算法】如何判断链表有环/","link":"","permalink":"http://github.com/2017/12/24/【算法】如何判断链表有环/","excerpt":"如何判断单链表是否存在环 有一个单向链表，链表当中有可能出现“环”，就像题图这样。如何用程序判断出这个链表是有环链表？ 不允许修改链表结构。 时间复杂度O(n)，空间复杂度O(1)。 方法一、穷举遍历方法一：首先从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，用新节点ID和此节点之前所有节点ID依次作比较。如果发现新节点之前的所有节点当中存在相同节点ID，则说明该节点被遍历过两次，链表有环；如果之前的所有节点当中不存在相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。 例如这样的链表：A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D， 当遍历到节点D的时候，我们需要比较的是之前的节点A、B、C，不存在相同节点。这时候要遍历的下一个新节点是B，B之前的节点A、B、C、D中恰好也存在B，因此B出现了两次，判断出链表有环。 假设从链表头节点到入环点的距离是D，链表的环长是S。那么算法的时间复杂度是0+1+2+3+….+(D+S-1) = (D+S-1)*(D+S)/2 ， 可以简单地理解成 O(N*N)。而此算法没有创建额外存储空间，空间复杂度可以简单地理解成为O(1)。","text":"如何判断单链表是否存在环 有一个单向链表，链表当中有可能出现“环”，就像题图这样。如何用程序判断出这个链表是有环链表？ 不允许修改链表结构。 时间复杂度O(n)，空间复杂度O(1)。 方法一、穷举遍历方法一：首先从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，用新节点ID和此节点之前所有节点ID依次作比较。如果发现新节点之前的所有节点当中存在相同节点ID，则说明该节点被遍历过两次，链表有环；如果之前的所有节点当中不存在相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。 例如这样的链表：A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D， 当遍历到节点D的时候，我们需要比较的是之前的节点A、B、C，不存在相同节点。这时候要遍历的下一个新节点是B，B之前的节点A、B、C、D中恰好也存在B，因此B出现了两次，判断出链表有环。 假设从链表头节点到入环点的距离是D，链表的环长是S。那么算法的时间复杂度是0+1+2+3+….+(D+S-1) = (D+S-1)*(D+S)/2 ， 可以简单地理解成 O(N*N)。而此算法没有创建额外存储空间，空间复杂度可以简单地理解成为O(1)。 方法二、哈希表缓存**首先创建一个以节点ID为键的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就用新节点和HashSet集合当中存储的节点作比较，如果发现HashSet当中存在相同节点ID，则说明链表有环，如果HashSet当中不存在相同的节点ID，就把这个新节点ID存入HashSet，之后进入下一节点，继续重复刚才的操作。 这个方法在流程上和方法一类似，本质的区别是使用了HashSet作为额外的缓存。 假设从链表头节点到入环点的距离是D，链表的环长是S。而每一次HashSet查找元素的时间复杂度是O(1), 所以总体的时间复杂度是1*(D+S)=D+S，可以简单理解为O(N)。而算法的空间复杂度还是D+S-1，可以简单地理解成O(N)。 方法三、快慢指针首先创建两个指针1和2（在java里就是两个对象引用），同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。 例如链表A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D，两个指针最初都指向节点A，进入第一轮循环，指针1移动到了节点B，指针2移动到了C。第二轮循环，指针1移动到了节点C，指针2移动到了节点B。第三轮循环，指针1移动到了节点D，指针2移动到了节点D，此时两指针指向同一节点，判断出链表有环。 此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。 /** * 判断单链表是否存在环 * @param head * @return */public static &lt;T&gt; boolean isLoopList(ListNode&lt;T&gt; head)&#123; ListNode&lt;T&gt; slowPointer, fastPointer; //使用快慢指针，慢指针每次向前一步，快指针每次两步 slowPointer = fastPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; slowPointer = slowPointer.next; fastPointer = fastPointer.next.next; //两指针相遇则有环 if(slowPointer == fastPointer)&#123; return true; &#125; &#125; return false;&#125; 假设从链表头节点到入环点的距离是D，链表的环长是S。那么循环会进行S次（为什么是S次，有心的同学可以自己揣摩下），可以简单理解为O（N）。除了两个指针以外，没有使用任何额外存储空间，所以空间复杂度是O（1）。 如何判断双向链表有环 其实这题跟单链表判断环的方法相似，只是当判断next指针不会出现环时，要从尾节点按照之前的方法向头结点扫描，判断pre指针是否可能出现环，如图环2。当然如果在第一步判断链表有next环后是无法进行第二步判断的，因为你永远找不到尾节点。 /** * 双向链表是否存在环 * @param head * @return */public static &lt;T&gt; boolean isLoopTowWayList(ListNode&lt;T&gt; head)&#123; ListNode&lt;T&gt; slow, fast; //与单链表类似，使用快慢指针先单向遍历到结尾，如果相遇证明起码单向有环 slow = fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(slow == fast)&#123; return true; &#125; &#125; //找到尾指针 while(slow.next != null)&#123; slow = slow.next; &#125; //如果next单向没环，从尾节点回溯遍历，看prev是否存在环 fast = slow; while(fast != null &amp;&amp; fast.prev != null)&#123; slow = slow.prev; fast = fast.prev.prev; if(slow == fast)&#123; return true; &#125; &#125; return false;&#125; 如何找出有环链表的入环点？根据这篇文章：链表中环形的入口，我们来分析一下入环口和我们上面这个快慢指针相遇点的关系。 当fast若与slow相遇时，slow肯定没有走遍历完链表(不是一整个环，有开头部分，如上图)或者恰好遍历一圈(未做验证，看我的表格例子，在1处相遇)。于是我们从链表头、相遇点分别设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点(慢指针走了n步，第一次相遇在c点，对慢指针来说n=s+p，也就是说如果慢指针从c点再走n步，又会到c点，那么顺时针的CB距离是n-p=s，但是我们不知道s是几，那么当快指针此时在A点一步一步走，当快慢指针相遇时，相遇点恰好是圆环七点B(AB=CB=s))。 /** * 找到有环链表的入口 * @param head * @return */public static &lt;T&gt; ListNode&lt;T&gt; findEntranceInLoopList(ListNode&lt;T&gt; head)&#123; ListNode&lt;T&gt; slowPointer, fastPointer; //使用快慢指针，慢指针每次向前一步，快指针每次两步 boolean isLoop = false; slowPointer = fastPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; slowPointer = slowPointer.next; fastPointer = fastPointer.next.next; //两指针相遇则有环 if(slowPointer == fastPointer)&#123; isLoop = true; break; &#125; &#125; //一个指针从链表头开始，一个从相遇点开始，每次一步，再次相遇的点即是入口节点 if(isLoop)&#123; slowPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; //两指针相遇的点即是入口节点 if(slowPointer == fastPointer)&#123; return slowPointer; &#125; slowPointer = slowPointer.next; fastPointer = fastPointer.next; &#125; &#125; return null;&#125; 如何判断两个单链表是否相交，以及相交点 方法一、直接法直接判断第一个链表的每个结点是否在第二个链表中，时间复杂度为O(len1*len2)，耗时很大 方法二、利用计数如果两个链表相交，则两个链表就会有共同的结点；而结点地址又是结点唯一标识。因而判断两个链表中是否存在地址一致的节点，就可以知道是否相交了。可以对第一 个链表的节点地址进行hash排序，建立hash表，然后针对第二个链表的每个节点的地址查询hash表，如果它在hash表中出现，则说明两个链表有共 同的结点。这个方法的时间复杂度为：O(max(len1+len2)；但同时还得增加O(len1)的存储空间存储哈希表。这样减少了时间复杂度，增加 了存储空间。 以链表节点地址为值，遍历第一个链表，使用Hash保存所有节点地址值，结束条件为到最后一个节点（无环）或Hash中该地址值已经存在（有环）。 再遍历第二个链表，判断节点地址值是否已经存在于上面创建的Hash表中。这个方面可以解决题目中的所有情况，时间复杂度为O(m+n)，m和n分别是两个链表中节点数量。由于节点地址指针就是一个整型，假设链表都是在堆中动态创建的，可以使用堆的起始地址作为偏移量，以地址减去这个偏移量作为Hash函数 方法三、利用有环链表思路对于两个没有环的链表相交于一节点，则在这个节点之后的所有结点都是两个链表所共有的。如果它们相交，则最后一个结点一定是共有的，则只需要判断最后一个结点是否相同即可。时间复杂度为O(len1+len2)。对于相交的第一个结点，则可求出两个链表的长度，然后用长的减去短的得到一个差值 K，然后让长的链表先遍历K个结点，然后两个链表再开始比较。 还可以这样：其中一个链表首尾相连，检测另外一个链表是否存在环，如果存在，则两个链表相交，而检测出来的依赖环入口即为相交的第一个 参考资料 漫画算法：如何判断链表有环？ 判断两个单链表是否相交 数据结构面试 之 单链表是否有环及环入口点 附有最详细明了的图解 链表中环形的入口 【单链表】环的入口点 原理理解！ 如何判断单链表是否有环、环的入口、环的长度和总长 如何判断双链表是否有环 面试精选：链表问题集锦","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】源码分析 - Activity启动流程","slug":"【Android】源码分析 - Activity启动流程","date":"2017-12-18T14:20:55.000Z","updated":"2017-12-25T01:37:20.733Z","comments":true,"path":"2017/12/18/【Android】源码分析 - Activity启动流程/","link":"","permalink":"http://github.com/2017/12/18/【Android】源码分析 - Activity启动流程/","excerpt":"启动Activity的方式Activity有2种启动的方式，一种是在Launcher界面点击应用的图标、另一种是在应用中通过Intent进行跳转。我们主要介绍与后者相关的启动流程。 Intent intent = new Intent(this, TestActivity.class);startActivity(intent); 从Activity入手@Overridepublic void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125;","text":"启动Activity的方式Activity有2种启动的方式，一种是在Launcher界面点击应用的图标、另一种是在应用中通过Intent进行跳转。我们主要介绍与后者相关的启动流程。 Intent intent = new Intent(this, TestActivity.class);startActivity(intent); 从Activity入手@Overridepublic void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125; 我们看到最终都会进入startActivityForResult()方法。我们跟进去看看： public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; //转交给Instrumentation来startActivity Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; final View decor = mWindow != null ? mWindow.peekDecorView() : null; if (decor != null) &#123; decor.cancelPendingInputEvents(); &#125; // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; if (options != null &amp;&amp; !isTopOfTask()) &#123; mActivityTransitionState.startExitOutTransition(this, options); &#125;&#125; 继续进入Instrumentation类，看看execStartActivity方法： //Instrumentation类public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); //交给ActivityManagerNative来startActivity int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //检查启动Activity的结果 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null;&#125; 上面的代码可以看出，启动Activity真正的实现交给了ActivityManagerNative.getDefault()的startActivity方法来完成。然后启动之后通过checkStartActivityResult(result, intent);来检查Activity的启动结果（比如Activity没有在AndroidManifest.xml中注册就throw ActivityNotFoundException的异常等）。 我们来着重看下这个ActivityManagerNative。 ActivityManagerNative是什么？ActivityManagerNative比较特殊，从下面的定义可以看到它就是一个Binder对象，并实现了IActivityManager接口。而它的getDefault()方法其实就是通过asInterface(IBinder obj)方法构建的ActivityManagerProxy(obj)单例。 public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; /** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. */ static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; /** * Retrieve the system's default/global activity manager. */ static public IActivityManager getDefault() &#123; return gDefault.get(); &#125; private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125; &#125;; //...省略其他代码...&#125; 而ActivityManagerNative.getDefault()实际上是个ActivityManagerService（简称AMS），因此Activity的启动任务其实最后交给了AMS中， ActivityManagerService（AMS）看AMS的startActivity()方法 //ActivityManagerService类@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; //交给startActivityAsUser方法 return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125; @Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null);&#125;/** mStackSupervisor的定义 Run all ActivityStacks through this */ActivityStackSupervisor mStackSupervisor; 可以看出，Activity启动任务被AMS转交给了ActivityStackSupervisor的startActivityMayWait方法。 //ActivityStackSupervisor类final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; //...省略一大片代码... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); //...再省略一大片代码...&#125;final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; //...再省略一大片代码... err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); if (err &lt; 0) &#123; // If someone asked to have the keyguard dismissed on the next // activity start, but we are not actually doing an activity // switch... just dismiss the keyguard now, because we // probably want to see whatever is behind it. notifyActivityDrawnForKeyguard(); &#125; return err;&#125; ActivityStackSupervisor类中的startActivityMayWait方法调用startActivityLocked()继续执行，而startActivityLocked()方法中又会调用startActivityUncheckedLocked()方法，然后会调用resumeTopActivitiesLocked()方法： //ActivityStackSupervisor类boolean resumeTopActivitiesLocked() &#123; return resumeTopActivitiesLocked(null, null, null);&#125;boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) &#123; if (targetStack == null) &#123; targetStack = mFocusedStack; &#125; // Do targetStack first. boolean result = false; if (isFrontStack(targetStack)) &#123; //到这里，启动过程从ActivityStackSupervisor类交给了ActivityStack类 result = targetStack.resumeTopActivityLocked(target, targetOptions); &#125; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; final ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (stack == targetStack) &#123; // Already started above. continue; &#125; if (isFrontStack(stack)) &#123; stack.resumeTopActivityLocked(null); &#125; &#125; &#125; return result;&#125; 上面代码能看到，最后启动过程从ActivityStackSupervisor类交给了ActivityStack类。 跟进它的resumeTopActivityLocked方法： /** * Ensure that the top activity in the stack is resumed. * * @param prev The previously resumed activity, for when in the process * of pausing; can be null to call from elsewhere. * * @return Returns true if something is being resumed, or false if * nothing happened. */final boolean resumeTopActivityLocked(ActivityRecord prev) &#123; return resumeTopActivityLocked(prev, null);&#125;final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; //注意这里 result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; 继续看看resumeTopActivityInnerLocked()方法 private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123; //看这里，又返回交给了ActivityStackSupervisor类 mStackSupervisor.startSpecificActivityLocked(next, true, false); //...省略一大片代码...&#125; 又返回ActivityStackSupervisor类//ActivityStackSupervisor类void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? // 判断需要启动的Activity所在进程和app已经存在，若存在，直接启动，否则准备创建该进程。 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !\"android\".equals(r.info.packageName)) &#123; // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; //注意这里 realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; // 否则准备创建该进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 上面的startSpecificActivityLocked()方法，首先判断需要启动的Activity所在进程和app是否已经存在。若存在，直接拿着该进行信息去启动该Activity，否则准备创建该进程。 我们简单先看下创建该App进程的方法startProcessLocked()，位于ActivityManagerService类中： //ActivityManagerService类中private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; long startTime = SystemClock.elapsedRealtime(); if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) &#123; checkTime(startTime, \"startProcess: removing from pids map\"); synchronized (mPidsSelfLocked) &#123; mPidsSelfLocked.remove(app.pid); mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); &#125; checkTime(startTime, \"startProcess: done removing from pids map\"); app.setPid(0); &#125; if (DEBUG_PROCESSES &amp;&amp; mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES, \"startProcessLocked removing on hold: \" + app); mProcessesOnHold.remove(app); checkTime(startTime, \"startProcess: starting to update cpu stats\"); updateCpuStats(); checkTime(startTime, \"startProcess: done updating cpu stats\"); try &#123; //...省略其他代码... // Process.start()完成了ActivityThread的创建，之后就会执行ActivityThread的main()方法 // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = \"android.app.ActivityThread\"; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" + app.processName); checkTime(startTime, \"startProcess: asking zygote to start proc\"); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, \"startProcess: returned from zygote!\"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //...省略其他代码... &#125; catch (RuntimeException e) &#123; // XXX do better error recovery. app.setPid(0); mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid); if (app.isolated) &#123; mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid); &#125; Slog.e(TAG, \"Failure starting process \" + app.processName, e); &#125;&#125; 我们可以看到这个方法就是使用Process.start()，并通过Socket连接的方式孵化新建了一个Zygote进程，完成了ActivityThread的创建，之后就会执行ActivityThread的main()方法。 接着上面，App进程如果存在就会直接调用realStartActivityLocked()方法： //ActivityStackSupervisor类中final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; //...省略其他代码... try &#123; app.forceProcessStateUpTo(mService.mTopProcessState); app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); &#125; catch (RemoteException e) &#123; throw e; &#125; return true;&#125; 上面的调用了app.thread的scheduleLaunchActivity()方法，app的类型是ProcessRecord类，它的thread成员变量定义如下，是一个IApplicationThread对象： /** * Full information about a particular process that * is currently running. */final class ProcessRecord &#123; private static final String TAG = TAG_WITH_CLASS_NAME ? \"ProcessRecord\" : TAG_AM; private final BatteryStatsImpl mBatteryStats; // where to collect runtime statistics final ApplicationInfo info; // all about the first app in the process final boolean isolated; // true if this is a special isolated process final int uid; // uid of process; may be different from 'info' if isolated final int userId; // user of process. final String processName; // name of the process // List of packages running in the process final ArrayMap&lt;String, ProcessStats.ProcessStateHolder&gt; pkgList = new ArrayMap&lt;&gt;(); UidRecord uidRecord; // overall state of process's uid. ArraySet&lt;String&gt; pkgDeps; // additional packages we have a dependency on IApplicationThread thread; // the actual proc... may be null only if // 'persistent' is true (in which case we // are in the process of launching the app)&#125; //...省略其他代码... 而IApplicationThread的声明如下： /** * System private API for communicating with the application. This is given to * the activity manager by an application when it starts up, for the activity * manager to tell the application about things it needs to do. * * &#123;@hide&#125; */public interface IApplicationThread extends IInterface &#123; void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) throws RemoteException; void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) throws RemoteException; void scheduleWindowVisibility(IBinder token, boolean showWindow) throws RemoteException; void scheduleSleeping(IBinder token, boolean sleeping) throws RemoteException; void scheduleResumeActivity(IBinder token, int procState, boolean isForward, Bundle resumeArgs) throws RemoteException; void scheduleSendResult(IBinder token, List&lt;ResultInfo&gt; results) throws RemoteException; void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) throws RemoteException; void scheduleRelaunchActivity(IBinder token, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, int configChanges, boolean notResumed, Configuration config, Configuration overrideConfig) throws RemoteException; void scheduleNewIntent(List&lt;ReferrerIntent&gt; intent, IBinder token) throws RemoteException; void scheduleDestroyActivity(IBinder token, boolean finished, int configChanges) throws RemoteException; void scheduleReceiver(Intent intent, ActivityInfo info, CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras, boolean sync, int sendingUser, int processState) throws RemoteException; static final int BACKUP_MODE_INCREMENTAL = 0; static final int BACKUP_MODE_FULL = 1; static final int BACKUP_MODE_RESTORE = 2; static final int BACKUP_MODE_RESTORE_FULL = 3; void scheduleCreateBackupAgent(ApplicationInfo app, CompatibilityInfo compatInfo, int backupMode) throws RemoteException; void scheduleDestroyBackupAgent(ApplicationInfo app, CompatibilityInfo compatInfo) throws RemoteException; void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) throws RemoteException; void scheduleBindService(IBinder token, Intent intent, boolean rebind, int processState) throws RemoteException; void scheduleUnbindService(IBinder token, Intent intent) throws RemoteException; void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId, int flags, Intent args) throws RemoteException; void scheduleStopService(IBinder token) throws RemoteException; static final int DEBUG_OFF = 0; static final int DEBUG_ON = 1; static final int DEBUG_WAIT = 2; void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArguments, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean openGlTrace, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException; void scheduleExit() throws RemoteException; void scheduleSuicide() throws RemoteException; void scheduleConfigurationChanged(Configuration config) throws RemoteException; void updateTimeZone() throws RemoteException; void clearDnsCache() throws RemoteException; void setHttpProxy(String proxy, String port, String exclList, Uri pacFileUrl) throws RemoteException; void processInBackground() throws RemoteException; void dumpService(FileDescriptor fd, IBinder servicetoken, String[] args) throws RemoteException; void dumpProvider(FileDescriptor fd, IBinder servicetoken, String[] args) throws RemoteException; void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException; void scheduleLowMemory() throws RemoteException; void scheduleActivityConfigurationChanged(IBinder token, Configuration overrideConfig) throws RemoteException; void profilerControl(boolean start, ProfilerInfo profilerInfo, int profileType) throws RemoteException; void dumpHeap(boolean managed, String path, ParcelFileDescriptor fd) throws RemoteException; void setSchedulingGroup(int group) throws RemoteException; static final int PACKAGE_REMOVED = 0; static final int EXTERNAL_STORAGE_UNAVAILABLE = 1; void dispatchPackageBroadcast(int cmd, String[] packages) throws RemoteException; void scheduleCrash(String msg) throws RemoteException; void dumpActivity(FileDescriptor fd, IBinder servicetoken, String prefix, String[] args) throws RemoteException; void setCoreSettings(Bundle coreSettings) throws RemoteException; void updatePackageCompatibilityInfo(String pkg, CompatibilityInfo info) throws RemoteException; void scheduleTrimMemory(int level) throws RemoteException; void dumpMemInfo(FileDescriptor fd, Debug.MemoryInfo mem, boolean checkin, boolean dumpInfo, boolean dumpDalvik, boolean dumpSummaryOnly, String[] args) throws RemoteException; void dumpGfxInfo(FileDescriptor fd, String[] args) throws RemoteException; void dumpDbInfo(FileDescriptor fd, String[] args) throws RemoteException; void unstableProviderDied(IBinder provider) throws RemoteException; void requestAssistContextExtras(IBinder activityToken, IBinder requestToken, int requestType) throws RemoteException; void scheduleTranslucentConversionComplete(IBinder token, boolean timeout) throws RemoteException; void scheduleOnNewActivityOptions(IBinder token, ActivityOptions options) throws RemoteException; void setProcessState(int state) throws RemoteException; void scheduleInstallProvider(ProviderInfo provider) throws RemoteException; void updateTimePrefs(boolean is24Hour) throws RemoteException; void scheduleCancelVisibleBehind(IBinder token) throws RemoteException; void scheduleBackgroundVisibleBehindChanged(IBinder token, boolean enabled) throws RemoteException; void scheduleEnterAnimationComplete(IBinder token) throws RemoteException; void notifyCleartextNetwork(byte[] firstPacket) throws RemoteException; String descriptor = \"android.app.IApplicationThread\"; int SCHEDULE_PAUSE_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION; int SCHEDULE_STOP_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+2; int SCHEDULE_WINDOW_VISIBILITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+3; int SCHEDULE_RESUME_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+4; int SCHEDULE_SEND_RESULT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+5; int SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+6; int SCHEDULE_NEW_INTENT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+7; int SCHEDULE_FINISH_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+8; int SCHEDULE_RECEIVER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+9; int SCHEDULE_CREATE_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+10; int SCHEDULE_STOP_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+11; int BIND_APPLICATION_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+12; int SCHEDULE_EXIT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+13; int SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+15; int SCHEDULE_SERVICE_ARGS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+16; int UPDATE_TIME_ZONE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+17; int PROCESS_IN_BACKGROUND_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+18; int SCHEDULE_BIND_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+19; int SCHEDULE_UNBIND_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+20; int DUMP_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+21; int SCHEDULE_REGISTERED_RECEIVER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+22; int SCHEDULE_LOW_MEMORY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+23; int SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+24; int SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+25; int SCHEDULE_SLEEPING_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+26; int PROFILER_CONTROL_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+27; int SET_SCHEDULING_GROUP_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+28; int SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+29; int SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+30; int SCHEDULE_ON_NEW_ACTIVITY_OPTIONS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+31; int SCHEDULE_SUICIDE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+32; int DISPATCH_PACKAGE_BROADCAST_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+33; int SCHEDULE_CRASH_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+34; int DUMP_HEAP_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+35; int DUMP_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+36; int CLEAR_DNS_CACHE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+37; int SET_HTTP_PROXY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+38; int SET_CORE_SETTINGS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+39; int UPDATE_PACKAGE_COMPATIBILITY_INFO_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+40; int SCHEDULE_TRIM_MEMORY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+41; int DUMP_MEM_INFO_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+42; int DUMP_GFX_INFO_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+43; int DUMP_PROVIDER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+44; int DUMP_DB_INFO_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+45; int UNSTABLE_PROVIDER_DIED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+46; int REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+47; int SCHEDULE_TRANSLUCENT_CONVERSION_COMPLETE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+48; int SET_PROCESS_STATE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+49; int SCHEDULE_INSTALL_PROVIDER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+50; int UPDATE_TIME_PREFS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+51; int CANCEL_VISIBLE_BEHIND_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+52; int BACKGROUND_VISIBLE_BEHIND_CHANGED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+53; int ENTER_ANIMATION_COMPLETE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+54; int NOTIFY_CLEARTEXT_NETWORK_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+55;&#125; 可以看到IApplicationThread它继承了IInterface接口，是一个Binder类型接口。里面包含了大量的启动、停止Activity的接口，启动、停止Service的接口。那么它的实现者到底是谁呢？答案就是ActivityThread类里的内部类ApplicationThread，我们去看看它的定义： private class ApplicationThread extends ApplicationThreadNative &#123;...&#125;public abstract class ApplicationThreadNative extends Binder implements IApplicationThread &#123; 可以看到，ApplicationThread类继承自ApplicationThreadNative，而ApplicationThreadNative是一个Binder对象并且实现了IApplicationThread接口。 而且在ApplicationThreadNative类的内部有一个ApplicationThreadProxy代理类。 public abstract class ApplicationThreadNative extends Binder implements IApplicationThread &#123; /** * Cast a Binder object into an application thread interface, generating * a proxy if needed. */ static public IApplicationThread asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IApplicationThread in = (IApplicationThread)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ApplicationThreadProxy(obj); &#125; public ApplicationThreadNative() &#123; attachInterface(this, descriptor); &#125; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IBinder b = data.readStrongBinder(); boolean finished = data.readInt() != 0; boolean userLeaving = data.readInt() != 0; int configChanges = data.readInt(); boolean dontReport = data.readInt() != 0; schedulePauseActivity(b, finished, userLeaving, configChanges, dontReport); return true; &#125; case SCHEDULE_STOP_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IBinder b = data.readStrongBinder(); boolean show = data.readInt() != 0; int configChanges = data.readInt(); scheduleStopActivity(b, show, configChanges); return true; &#125; //...省略一大片代码... return super.onTransact(code, data, reply, flags); &#125;&#125;class ApplicationThreadProxy implements IApplicationThread &#123; private final IBinder mRemote; public ApplicationThreadProxy(IBinder remote) &#123; mRemote = remote; &#125; public final IBinder asBinder() &#123; return mRemote; &#125; public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); data.writeInt(finished ? 1 : 0); data.writeInt(userLeaving ? 1 :0); data.writeInt(configChanges); data.writeInt(dontReport ? 1 : 0); mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); data.writeInt(showWindow ? 1 : 0); data.writeInt(configChanges); mRemote.transact(SCHEDULE_STOP_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; //...省略一大片代码...&#125; 也就是说，按照上面的流程，最终从AMS回调到了ApplicationThread中，我们看看ApplicationThread类的scheduleLaunchActivity()方法： //位于ActivityThread类中的内部类ApplicationThread类中//// we use token to identify this activity without having to send the// activity itself back to the activity manager. (matters more with ipc)@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 可以看到，scheduleLaunchActivity方法就是发送了一个启动Activity的Message交给H这个Handler，这个Handler定义如下： private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; public static final int SHOW_WINDOW = 105; public static final int HIDE_WINDOW = 106; public static final int RESUME_ACTIVITY = 107; public static final int SEND_RESULT = 108; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int NEW_INTENT = 112; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; public static final int CONFIGURATION_CHANGED = 118; public static final int CLEAN_UP_CONTEXT = 119; public static final int GC_WHEN_IDLE = 120; public static final int BIND_SERVICE = 121; public static final int UNBIND_SERVICE = 122; public static final int DUMP_SERVICE = 123; public static final int LOW_MEMORY = 124; public static final int ACTIVITY_CONFIGURATION_CHANGED = 125; public static final int RELAUNCH_ACTIVITY = 126; public static final int PROFILER_CONTROL = 127; public static final int CREATE_BACKUP_AGENT = 128; public static final int DESTROY_BACKUP_AGENT = 129; public static final int SUICIDE = 130; public static final int REMOVE_PROVIDER = 131; public static final int ENABLE_JIT = 132; public static final int DISPATCH_PACKAGE_BROADCAST = 133; public static final int SCHEDULE_CRASH = 134; public static final int DUMP_HEAP = 135; public static final int DUMP_ACTIVITY = 136; public static final int SLEEPING = 137; public static final int SET_CORE_SETTINGS = 138; public static final int UPDATE_PACKAGE_COMPATIBILITY_INFO = 139; public static final int TRIM_MEMORY = 140; public static final int DUMP_PROVIDER = 141; public static final int UNSTABLE_PROVIDER_DIED = 142; public static final int REQUEST_ASSIST_CONTEXT_EXTRAS = 143; public static final int TRANSLUCENT_CONVERSION_COMPLETE = 144; public static final int INSTALL_PROVIDER = 145; public static final int ON_NEW_ACTIVITY_OPTIONS = 146; public static final int CANCEL_VISIBLE_BEHIND = 147; public static final int BACKGROUND_VISIBLE_BEHIND_CHANGED = 148; public static final int ENTER_ANIMATION_COMPLETE = 149; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case RELAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityRestart\"); ActivityClientRecord r = (ActivityClientRecord)msg.obj; handleRelaunchActivity(r); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case PAUSE_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;2) != 0); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_ACTIVITY_SHOW: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStop\"); handleStopActivity((IBinder)msg.obj, true, msg.arg2); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_ACTIVITY_HIDE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStop\"); handleStopActivity((IBinder)msg.obj, false, msg.arg2); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SHOW_WINDOW: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityShowWindow\"); handleWindowVisibility((IBinder)msg.obj, true); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case HIDE_WINDOW: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityHideWindow\"); handleWindowVisibility((IBinder)msg.obj, false); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case RESUME_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\"); handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; //...省略其他代码... &#125; &#125; //...省略其他代码...&#125; H这个Handler对LAUNCH_ACTIVITY的处理就是调用了handleLaunchActivity方法： //ActivityThread类中private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, \"Handling launch of \" + r); // Initialize before creating the activity WindowManagerGlobal.initialize(); //注意这里 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //注意这里 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; // The activity manager actually wants this one to start out // paused, because it needs to be visible but isn't in the // foreground. We accomplish this by going through the // normal startup (because activities expect to go through // onResume() the first time they run, before their window // is displayed), and then pausing it. However, in this case // we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just // retain the current state it has. try &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); // We need to keep around the original state, in case // we need to be created again. But we only do this // for pre-Honeycomb apps, which always save their state // when pausing, so we can not have them save their state // when restarting from a paused state. For HC and later, // we want to (and can) let the state be saved as the normal // part of stopping the activity. if (r.isPreHoneycomb()) &#123; r.state = oldState; &#125; if (!r.activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onPause()\"); &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException( \"Unable to pause activity \" + r.intent.getComponent().toShortString() + \": \" + e.toString(), e); &#125; &#125; r.paused = true; &#125; &#125; else &#123; // If there was an error, for any reason, tell the activity // manager to stop us. try &#123; ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125;&#125; 最终： 通过ActivityThread的performLaunchActivity()方法完成了Activity的创建和启动过程； 通过handleResumeActivity()方法调用了这个Activity的onResume()生命周期方法。 performLaunchActivity()方法performLaunchActivity()方法主要完成了Activity的初始化任务，根据注释大致可以分为四步： private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //1. 从ActivityClientRecord中读取Activity的组件信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //2. 通过mInstrumentation.newActivity()方法创建Activity对象 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; try &#123; //3. 通过LoadApk的makeApplication()方法创建Application对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, \"Performing launch of \" + r); if (localLOGV) Slog.v( TAG, r + \": app=\" + app + \", appName=\" + app.getPackageName() + \", pkg=\" + r.packageInfo.getPackageName() + \", comp=\" + r.intent.getComponent().toShortString() + \", dir=\" + r.packageInfo.getAppDir()); if (activity != null) &#123; //4. 创建ContextImpl对象并调用Activity的attach()方法完成初始化 Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //5. 通过Instrumentation的callActivityOnCreate方法调用Activity的onCreate()方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onPostCreate()\"); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to start activity \" + component + \": \" + e.toString(), e); &#125; &#125; return activity;&#125; 总结上面的performLaunchActivity()方法，主要完成了如下工作： 从ActivityClientRecord中读取Activity的组件信息 通过mInstrumentation.newActivity()方法创建Activity对象 通过LoadApk的makeApplication()方法创建Application对象 创建ContextImpl对象并调用Activity的attach()方法完成初始化 通过Instrumentation的callActivityOnCreate方法调用Activity的onCreate()方法 我们跟进一下第二步的Instrumentation类的newActivity()方法，很简单，就是使用类加载器创建了Activity对象： //Instrumentation类public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance();&#125; 第三步：通过LoadApk的makeApplication()方法创建Application对象： //LoadApk类public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = \"android.app.Application\"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(\"android\")) &#123; initializeJavaContextClassLoader(); &#125; //通过Instrumentation类的newApplication方法创建Application对象 ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; if (!mActivityThread.mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to instantiate application \" + appClass + \": \" + e.toString(), e); &#125; &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; try &#123; instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!instrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to create application \" + app.getClass().getName() + \": \" + e.toString(), e); &#125; &#125; &#125; // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); &#125; return app;&#125; 跟进去Instrumentation类的newApplication()方法看看： //Instrumentation类public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return newApplication(cl.loadClass(className), context);&#125;static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); app.attach(context); return app;&#125;//最终调用了Application类的attach方法final void attach(Context context) &#123; attachBaseContext(context); //熟悉的生命周期方法 mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; 它通过类加载器创建了Application的对象，当Application对象创建完毕之后，系统会通过Instrumentation类的callApplicationOnCreate()方法来调用Application的onCreate()方法。最后通过app.attach()调用了我们熟悉的Application的attachBaseContext()方法。 handleResumeActivity()方法流程//ActivityThread类final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) &#123; final Activity a = r.activity; if (localLOGV) Slog.v( TAG, \"Resume \" + r + \" started activity: \" + a.mStartedActivity + \", hideForNow: \" + r.hideForNow + \", finished: \" + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v( TAG, \"Launch \" + r + \" mStartedActivity set\"); r.hideForNow = true; &#125; // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; if (r.newConfig != null) &#123; r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) &#123; r.tmpConfig.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \" + r.activityInfo.name + \" with newConfig \" + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; &#125; if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\" + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) &#123; l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) &#123; ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); &#125; &#125; r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; if (!r.onlyLocalRequest) &#123; r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, \"Scheduling idle handler for \" + r); Looper.myQueue().addIdleHandler(new Idler()); &#125; r.onlyLocalRequest = false; // 通知AMS已经resume完成 Tell the activity manager we have resumed. if (reallyResume) &#123; try &#123; ActivityManagerNative.getDefault().activityResumed(token); &#125; catch (RemoteException ex) &#123; &#125; &#125; &#125; else &#123; // If an exception was thrown when trying to resume, then // just end this activity. try &#123; ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, false); &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; 接着看performResumeActivity()方法： //ActivityThread类public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) &#123; ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, \"Performing resume of \" + r + \" finished=\" + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) &#123; if (clearHide) &#123; r.hideForNow = false; r.activity.mStartedActivity = false; &#125; try &#123; r.activity.onStateNotSaved(); r.activity.mFragments.noteStateNotSaved(); if (r.pendingIntents != null) &#123; deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; &#125; if (r.pendingResults != null) &#123; deliverResults(r, r.pendingResults); r.pendingResults = null; &#125; //注意这里，调用Activity的performResume()方法 r.activity.performResume(); EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(), r.activity.getComponentName().getClassName()); r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException( \"Unable to resume activity \" + r.intent.getComponent().toShortString() + \": \" + e.toString(), e); &#125; &#125; &#125; return r;&#125; ActivityThread类中的performResumeActivity()方法调用了Activity类的performResume()方法： //Activity类final void performResume() &#123; performRestart(); mFragments.execPendingActions(); mLastNonConfigurationInstances = null; mCalled = false; // 看这里 mResumed is set by the instrumentation mInstrumentation.callActivityOnResume(this); if (!mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onResume()\"); &#125; // Now really resume, and install the current status bar and menu. mCalled = false; mFragments.dispatchResume(); mFragments.execPendingActions(); onPostResume(); if (!mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPostResume()\"); &#125;&#125; Instrumentation类中的callActivityOnResume方法 /** Instrumentation类 * Perform calling of an activity's &#123;@link Activity#onResume&#125; method. The * default implementation simply calls through to that method. * * @param activity The activity being resumed. */public void callActivityOnResume(Activity activity) &#123; activity.mResumed = true; activity.onResume(); //调用了onResume()方法完成了启动过程 if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); &#125; &#125; &#125;&#125; 应用的主要启动流程关于 App 启动流程的文章很多，文章底部有一些启动流程相关的参考文章，这里只列出大致流程如下： 通过 Launcher 启动应用时，点击应用图标后，Launcher 调用 startActivity() 启动应用。 Launcher Activity 最终调用Instrumentation 的 execStartActivity 来启动应用。 Instrumentation 调用 ActivityManagerProxy (ActivityManagerService 在应用进程的一个代理对象) 对象的 startActivity 方法启动 Activity。 到目前为止所有过程都在 Launcher 进程里面执行，接下来ActivityManagerProxy 对象跨进程调用ActivityManagerService (运行在system_server 进程)的 startActivity 方法启动应用。 ActivityManagerService 的 startActivity 方法经过一系列调用，最后调用 zygoteSendArgsAndGetResult 通过socket 发送给 zygote 进程，zygote 进程会孵化出新的应用进程。 zygote 进程孵化出新的应用进程后，会执行ActivityThread 类的 main() 方法。在该方法里会先准备好 Looper 和消息队列，然后调用 attach() 方法将应用进程绑定到 ActivityManagerService，然后进入loop 循环，不断地读取消息队列里的消息，并分发消息。 ActivityManagerService 保存应用进程的一个代理对象，然后 ActivityManagerService 通过代理对象通知应用进程创建入口 Activity 的实例，并执行它的生命周期函数。 总结过程就是：用户在 Launcher 程序里点击应用图标时，会通知 ActivityManagerService 启动应用的入口 Activity， ActivityManagerService 发现这个应用还未启动，则会通知 Zygote进程孵化出应用进程，然后在这个应用进程里执行 ActivityThread 的 main() 方法。应用进程接下来通知ActivityManagerService 应用进程已启动，ActivityManagerService 保存应用进程的一个代理对象，这样ActivityManagerService 可以通过这个代理对象控制应用进程，然后 ActivityManagerService 通知应用进程创建入口 Activity 的实例，并执行它的生命周期函数。 到这里，我们大概理解一下这几个相关类的定位 （一）ActivityManagerService：（ActivityManagerNative）是核心管理类，负责组件的管理，在这里主要与ActivityStackSupervisor通信。 （二）ActivityStackSupervisor：管理整个手机任务栈，即管理着ActivityStack。 （三）ActivityStack：是Activity的栈，即任务栈，从中可以获取需要进行操作的ActivityRecord，并且可以对任务的进程进行操作。 （四）ActivityThread：是安卓java应用层的入口函数类，它会执行具体对Activity的操作，并将结果通知给ActivityManagerService。 参考 Activity启动流程简直丧心病狂！ 【凯子哥带你学Framework】Activity启动过程全解析 Android源码解析之（十四）–&gt;Activity启动流程 图解Activity启动流程 Android 开发之 App 启动时间统计 Android性能优化（一）之启动加速35% 官方文档 - Launch-Time Performance","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】HashMap源码分析（JDK1.8）","slug":"【Java】HashMap源码分析（JDK1.8）","date":"2017-11-25T14:20:55.000Z","updated":"2017-11-29T11:28:19.868Z","comments":true,"path":"2017/11/25/【Java】HashMap源码分析（JDK1.8）/","link":"","permalink":"http://github.com/2017/11/25/【Java】HashMap源码分析（JDK1.8）/","excerpt":"前言Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： 下面针对各个实现类的特点做一些说明： (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 (4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。","text":"前言Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： 下面针对各个实现类的特点做一些说明： (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 (4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 源码分析HashMap是Java基本功，JDK1.8又对HashMap进行了优化。 存储结构Node类JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。 针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 红黑树TreeNode结构： static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; //...省略其他代码...&#125; HashMap就是这样一个Entry（包括Node和TreeNode）数组，Node对象中包含键、值和hash值，next指向下一个Entry，用来处理哈希冲突。TreeNode对象包含指向父节点、子节点和前一个节点（移除对象时使用）的指针，以及表示红黑节点颜色的boolean标识。 常量定义/** * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64; 默认容量 - DEFAULT_INITIAL_CAPACITY ：默认初始化的容量为16，必须是2的幂。 最大容量 - MAXIMUM_CAPACITY：最大容量是2^30 装载因子 - DEFAULT_LOAD_FACTOR：默认的装载因子是0.75，用于判断是否需要扩容 链表转换成树的阈值 - TREEIFY_THRESHOLD：一个桶中Entry（或称为Node）的存储方式由链表转换成树的阈值。即当桶中Entry的数量超过此值时使用红黑树来代替链表。默认值是8 树转还原成链表的阈值 - UNTREEIFY_THRESHOLD：当执行resize操作时，当桶中Entry的数量少于此值时使用链表来代替树。默认值是6 最小树形化容量 - MIN_TREEIFY_CAPACITY：当哈希表中的容量大于这个值时，表中的桶才能进行树形化。否则桶内元素太多时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于4 * TREEIFY_THRESHOLD 属性transient Node&lt;K,V&gt;[] table; // 哈希桶数组buckettransient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; // entry缓存Settransient int size; // 元素个数transient int modCount; // 修改次数int threshold; // 阈值，等于装载因子*容量，当实际大小超过阈值则进行扩容final float loadFactor; // 装载因子，默认值为0.75 其中loadFactor装载因子用来衡量HashMap满的程度。loadFactor的默认值为0.75f。计算HashMap的实时装载因子的方法为：size/capacity，也就是HashMap所有Entry的总数量/HashMap中桶的数量。而不是占用桶的数量去除以capacity。 若加载因子越大，填满的元素越多。好处是空间利用率高了。但是冲突的机会加大了。链表长度会越来越长,查找效率降低。 反之，加载因子越小，填满的元素越少。好处是冲突的机会减小了，但空间浪费多了。表中的数据将过于稀疏（很多空间还没用，就开始扩容了） 冲突的机会越大，则查找的成本越高。因此，必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间-空间”矛盾的平衡与折衷。如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。 构造方法/** * 根据初始化容量和负载因子构建一个空的HashMap. */public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; //注意此处的tableSizeFor方法 this.threshold = tableSizeFor(initialCapacity);&#125;/** * 使用初始化容量和默认加载因子(0.75). */public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * 使用默认初始化大小(16)和默认加载因子(0.75). */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;/** * 用已有的Map构造一个新的HashMap. */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 通过重载方法HashMap传入两个参数：1. 初始化容量；2. 装载因子。那么就介绍下几个名词： capacity：表示的是hashmap中桶的数量，初始化容量initCapacity为16，第一次扩容会扩到64，之后每次扩容都是之前容量的2倍，所以容量每次都是2的次幂。 loadFactor：装载因子，衡量hashmap一个满的程度，初始化为0.75 threshold：hashmap扩容的一个阈值标准，每当size大于这个阈值时就会进行扩容操作，threeshold等于capacity*loadfactor tableSizeFor()方法这个方法被调用的地方在上面构造函数中，当传入一个初始容量时，会调用this.threshold = tableSizeFor(initialCapacity);计算扩容阈值。那它是究竟干了什么的呢？tableSizeFor的功能（不考虑大于最大容量的情况）是返回大于输入参数且最近的2的整数次幂的数。比如10，则返回16。该算法源码如下： /** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 我们来分析有关n位操作部分：先来假设n的二进制为01xxx…xxx。接着 对n右移1位：001xx...xxx，再位或：011xx...xxx对n右移2为：00011...xxx，再位或：01111...xxx此时前面已经有四个1了，再右移4位且位或可得8个1同理，有8个1，右移8位肯定会让后八位也为1。综上可得，该算法让最高位的1后面的位全变为1。最后再让结果n+1，即得到了2的整数次幂的值了。 现在回来看看第一条语句： int n = cap - 1; 让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。 举一个例子说明下吧。比如cap=10，则返回16。 由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity，由于HashMap的容量capacity都是2的幂，因此这个方法用于找到大于等于initialCapacity的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。 put()方法JDK1.8对哈希碰撞后的拉链算法进行了优化， 当链表上Entry数量太多（超过8个）时，将链表重构为红黑树。下面是源码相关的注释： public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //步骤①：如果Table为空，初始化一个Table if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //步骤②：如果该bucket位置没值，则直接存储到该bucket位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //步骤③：如果节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //步骤④：如果该bucket位置数据是TreeNode类型，则将新数据添加到红黑树中。 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //步骤⑤：如果该链为链表 for (int binCount = 0; ; ++binCount) &#123; //添加到链表尾部 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); //如果链表个数达到8个时，将链表修改为红黑树结构 break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //更新键值，并返回旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //步骤⑥：存储的数目超过最大容量阈值，就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; HashMap的put方法执行过程可以通过下图来理解。 图中的步骤总结如下： ①. 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③. 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 get()方法public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;/** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; //Table桶 Node&lt;K,V&gt; first, e; int n; K k; //table数组不为空且length大于0，并且key的hash对应的桶第一个元素不为空时，才去get if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //首先判断是不是key的hash对应的桶中的第一个元素 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //如果该桶的存储结构是红黑树，从树中查找并返回 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //否则，遍历链表并返回 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; get()方法就相对简单了，通过hash定位桶，然后根据该桶的存储结构决定是遍历红黑树还是遍历链表。 hash()方法//java 8中的散列值优化函数 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//java 7中的散列函数static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 这段代码叫“扰动函数”。大家都知道上面代码里的key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。 理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从-2147483648到2147483648。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。JDK1.8源码中模运算是这么完成的：i = (length - 1) &amp; hash，而在JDK1.7中是在indexFor( )函数里完成的。 bucketIndex = indexFor(hash, table.length);static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; indexFor()的代码也很简单，就是把散列值和数组长度做一个“与”操作，就定位出了Key对应的桶，这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是位运算&amp;比取模运算%具有更高的效率。 这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。 10100101 11000100 00100101&amp; 00000000 00000000 00001111---------------------------------- 00000000 00000000 00000101 //高位全部归零，只保留末四位 但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。 这时候“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图， 右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 resize()扩容方法扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。 final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 设置新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\"，\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //如果该桶只有一个数据，则散列到当前位置或者（原位置+oldCap）位置 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //红黑树重构 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; // 原索引+oldCap if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当Entry的实际数量size 大于桶table的实际数量时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 在JDK1.8中我们可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。下面是JDK1.7的扩容方法： /** * JDK 1.7中的resize()方法 */void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125;//transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 树形化方法treeifyBin()在Java 8 中，如果一个桶中的链表元素个数超过 TREEIFY_THRESHOLD（默认是 8 ），就使用红黑树来替换链表，从而提高速度。这个替换的方法叫 treeifyBin() 即树形化。 //将桶内所有的 链表节点 替换成 红黑树节点final void treeifyBin(Node[] tab, int hash) &#123; int n, index; Node e; //如果当前哈希表为空，或者哈希表中Entry元素总数量小于进行树形化的阈值(默认为 64)，就去新建/扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; //如果哈希表中的元素个数超过了树形化阈值，进行树形化 // e 是哈希表中指定位置桶里的链表节点，从第一个开始 TreeNode hd = null, tl = null; //红黑树的头、尾节点 do &#123; //新建一个树形节点，内容和当前链表节点 e 一致 TreeNode p = replacementTreeNode(e, null); if (tl == null) //确定树头节点 hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); //让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了 if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125;TreeNode replacementTreeNode(Node p, Node next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);&#125; 上述操作做了这些事: 根据哈希表中元素个数确定是扩容还是树形化 如果是树形化 遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系 然后让桶第一个元素指向新建的树头结点，替换桶的链表内容为树形内容 但是我们发现，之前的操作并没有设置红黑树的颜色值，现在得到的只能算是个二叉树。在 最后调用树形root节点 hd.treeify(tab)方法进行塑造红黑树，来看看代码： final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; //第一次进入循环，确定root根结点，为黑色 x.parent = null; x.red = false; root = x; &#125; else &#123; //非第一次进入循环，x指向树中的某个节点 K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; //从根节点开始，遍历所有节点跟当前节点 x 比较，调整位置 for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) //当比较节点p的哈希值比 x 大时， dir为-1 dir = -1; else if (ph &lt; h) //哈希值比 x 小时，dir为1 dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); //把当前节点p变成 x 的父亲 TreeNode&lt;K,V&gt; xp = p; //如果当前比较节点p的哈希值比 x 大，x 就是左孩子，否则 x 是右孩子 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; //平衡操作 root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root);&#125; 可以看到，将二叉树变为红黑树时，需要保证有序。这里有个双重循环，拿树中的所有节点和当前节点的哈希值进行对比(如果哈希值相等，就对比键，这里不用完全有序），然后根据比较结果确定在树中的位置。 remove()方法public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; //所有的桶 Node&lt;K,V&gt; p; //对应桶的第一个元素 int n, index; //桶数量，对应桶的次序 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; //要删除的元素如果刚好匹配该桶中的第一个元素 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; //如果不是桶中的第一个元素，往下遍历 else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //找到要删除的元素之后，删除 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) //红黑树中删除 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) //是该桶中链表首节点删除 tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; remove()方法也很简单，这里就不展开讲了。clear()方法如下： //清空所有元素public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; //仅清空桶数组的引用 for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; // 把哈希数组中所有位置都赋为null &#125;&#125; 线程安全性一直以来只是知道HashMap是线程不安全的，但是到底HashMap为什么线程不安全，多线程并发的时候在什么情况下可能出现问题？ javadoc中关于hashmap的一段描述如下： 此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须 保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap() 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示： Map m = Collections.synchronizedMap(new HashMap(...)); 多线程put后可能导致get死循环 问题原因就是HashMap是非线程安全的，多个线程put的时候造成了某个key值Entry key List的死循环，问题就这么产生了。参考：HashMap多线程并发问题分析 多线程put的时候可能导致元素丢失 如果两个线程都put()时，使用p.next = newNode(hash, key, value, null);同时取得了p，则他们下一个元素都是newNode，然后赋值给table元素的时候有一个成功有一个丢失。 注意：不合理使用HashMap导致出现的是死循环而不是死锁。 小结到这里，你能回答出如下问题吗？ 1、哈希基本原理？（答：散列表、hash碰撞、链表、红黑树）2、hashmap查询的时间复杂度， 影响因素和原理？ （答：最好O（1），最差O（n）， 如果是红黑O（logn））3、resize如何实现的， 记住已经没有rehash了！！！（答：拉链entry根据高位bit散列到当前位置i和size+i位置）4、为什么获取下标时用按位与&amp;，而不是取模%？ （答：不只是&amp;速度更快哦， 我觉得你能答上来便真正理解hashmap了） 说明(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。(4) JDK1.8引入红黑树大程度优化了HashMap的性能。(5) JDK1.7是新插入的节点放在链表的头部，但是JDK1.8是新插入的节点放到尾部 当我们在HashMap中存储我们自己定义的类的时候，默认的equal函数的行为可能不能符合我们的要求，所以需要重写。此时： 1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false) 参考资料 面试旧敌之 HashMap : JDK 1.8 后它通过什么提升性能 HashMap中capacity、loadFactor、threshold、size等概念的解释 Java源码分析之HashMap(JDK1.8) HashMap源码分析（JDK1.8）- 你该知道的都在这里了 Java集合：HashMap源码剖析 Java 8系列之重新认识HashMap - 美团点评技术团队 JDK源码中HashMap的hash方法原理是什么？ - 知乎 HashMap源码之hash()函数分析（JDK 1.8）","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】源码分析 - View事件分发机制","slug":"【Android】源码分析 - View事件分发机制","date":"2017-11-18T14:20:55.000Z","updated":"2017-12-26T11:26:42.078Z","comments":true,"path":"2017/11/18/【Android】源码分析 - View事件分发机制/","link":"","permalink":"http://github.com/2017/11/18/【Android】源码分析 - View事件分发机制/","excerpt":"事件分发对象（1）所有 Touch 事件都被封装成了 MotionEvent 对象，包括 Touch 的位置、时间、历史记录以及第几个手指(多指触摸)等。 （2）事件类型分为 ACTION_DOWN， ACTION_UP，ACTION_MOVE，ACTION_POINTER_DOWN，ACTION_POINTER_UP， ACTION_CANCEL，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束。 主要发生的Touch事件有如下四种： MotionEvent.ACTION_DOWN：按下View（所有事件的开始） MotionEvent.ACTION_MOVE：滑动View MotionEvent.ACTION_CANCEL：非人为原因结束本次事件 MotionEvent.ACTION_UP：抬起View（与DOWN对应） 事件列：从手指接触屏幕至手指离开屏幕，这个过程产生的一系列事件任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图： 即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。这个事件传递的过程就是分发过程。 （3）对事件的处理包括三类，分别： 传递——dispatchTouchEvent()函数； 拦截——onInterceptTouchEvent()函数 消费——onTouchEvent()函数和 OnTouchListener","text":"事件分发对象（1）所有 Touch 事件都被封装成了 MotionEvent 对象，包括 Touch 的位置、时间、历史记录以及第几个手指(多指触摸)等。 （2）事件类型分为 ACTION_DOWN， ACTION_UP，ACTION_MOVE，ACTION_POINTER_DOWN，ACTION_POINTER_UP， ACTION_CANCEL，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束。 主要发生的Touch事件有如下四种： MotionEvent.ACTION_DOWN：按下View（所有事件的开始） MotionEvent.ACTION_MOVE：滑动View MotionEvent.ACTION_CANCEL：非人为原因结束本次事件 MotionEvent.ACTION_UP：抬起View（与DOWN对应） 事件列：从手指接触屏幕至手指离开屏幕，这个过程产生的一系列事件任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图： 即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。这个事件传递的过程就是分发过程。 （3）对事件的处理包括三类，分别： 传递——dispatchTouchEvent()函数； 拦截——onInterceptTouchEvent()函数 消费——onTouchEvent()函数和 OnTouchListener 源码跟踪触摸事件发生后，在Activity内最先接收到事件的是Activity自身的dispatchTouchEven接着Window传递给最顶端的View，也就是DecorView。接下来才是我们熟悉的触摸事件流程：首先是最顶端的ViewGroup(这边便是DecorView)的dispatchTouchEvent接收到事件。并通过onInterceptTouchEvent判断是否需要拦截。如果拦截则分配到ViewGroup自身的onTouchEvent，如果不拦截则查找位于点击区域的子View(当事件是ACTION_DOWN的时候，会做一次查找并根据查找到的子View设定一个TouchTarget，有了TouchTarget以后，后续的对应id的事件如果不被拦截都会分发给这一个TouchTarget)。查找到子View以后则调用dispatchTransformedTouchEvent把MotionEvent的坐标转换到子View的坐标空间，这不仅仅是x，y的偏移，还包括根据子View自身矩阵的逆矩阵对坐标进行变换(这就是使用setTranslationX,setScaleX等方法调用后，子View的点击区域还能保持和自身绘制内容一致的原因。使用Animation做变换点击区域不同步是因为Animation使用的是Canvas的矩阵而不是View自身的矩阵来做变换)。 事件分发的源头触摸事件发生后，在Activity内最先接收到事件的是Activity自身的dispatchTouchEvent()，然后Activity传递给Activity的Window： public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 其中的这个getWindow()得到的就是Activity的mWindow对象，它是在attach()方法中初始化的： final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, IVoiceInteractor voiceInteractor) &#123; //创建一个Window对象 mWindow = PolicyManager.makeNewWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); mWindowManager = mWindow.getWindowManager(); //...省略其他代码...&#125; 调用了PolicyManager的makeNewWindow()方法创建的Window对象。我们跟进去PolicyManager这个类（这个类在Android 6.0之后源码中删除了，下面是我找的5.1的源码）： public final class PolicyManager &#123; private static final String POLICY_IMPL_CLASS_NAME = \"com.android.internal.policy.impl.Policy\"; private static final IPolicy sPolicy; static &#123; // Pull in the actual implementation of the policy at run-time try &#123; Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME); sPolicy = (IPolicy)policyClass.newInstance(); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be loaded\", ex); &#125; catch (InstantiationException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be instantiated\", ex); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be instantiated\", ex); &#125; &#125; // Cannot instantiate this class private PolicyManager() &#123;&#125; // The static methods to spawn new policy-specific objects public static Window makeNewWindow(Context context) &#123; return sPolicy.makeNewWindow(context); &#125; public static LayoutInflater makeNewLayoutInflater(Context context) &#123; return sPolicy.makeNewLayoutInflater(context); &#125; public static WindowManagerPolicy makeNewWindowManager() &#123; return sPolicy.makeNewWindowManager(); &#125; public static FallbackEventHandler makeNewFallbackEventHandler(Context context) &#123; return sPolicy.makeNewFallbackEventHandler(context); &#125;&#125; 可以看到实际上调用了Policy类的makeNewWindow()方法： public class Policy implements IPolicy &#123; private static final String TAG = \"PhonePolicy\"; private static final String[] preload_classes = &#123; \"com.android.internal.policy.impl.PhoneLayoutInflater\", \"com.android.internal.policy.impl.PhoneWindow\", \"com.android.internal.policy.impl.PhoneWindow$1\", \"com.android.internal.policy.impl.PhoneWindow$DialogMenuCallback\", \"com.android.internal.policy.impl.PhoneWindow$DecorView\", \"com.android.internal.policy.impl.PhoneWindow$PanelFeatureState\", \"com.android.internal.policy.impl.PhoneWindow$PanelFeatureState$SavedState\", &#125;; static &#123; // For performance reasons, preload some policy specific classes when // the policy gets loaded. for (String s : preload_classes) &#123; try &#123; Class.forName(s); &#125; catch (ClassNotFoundException ex) &#123; Log.e(TAG, \"Could not preload class for phone policy: \" + s); &#125; &#125; &#125; public Window makeNewWindow(Context context) &#123; return new PhoneWindow(context); &#125; public LayoutInflater makeNewLayoutInflater(Context context) &#123; return new PhoneLayoutInflater(context); &#125; public WindowManagerPolicy makeNewWindowManager() &#123; return new PhoneWindowManager(); &#125; public FallbackEventHandler makeNewFallbackEventHandler(Context context) &#123; return new PhoneFallbackEventHandler(context); &#125;&#125; 原来是一个PhoneWindow对象，我们赶紧看看它的superDispatchTouchEvent方法，原来是继续调用了DecorView的superDispatchTouchEvent()方法： // This is the top-level view of the window, containing the window decor.private DecorView mDecor;@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 这个DecorView是PhoneWindow的一个内部类，它继承了FrameLayout： private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; //...省略其他代码... &#125; 而FrameLayout本身没有实现dispatchTouchEvent()这个方法，它继承了ViewGroup： public class FrameLayout extends ViewGroup &#123;...&#125; 下面我们来看一下ViewGroup的dispatchTouchEvent()方法源码。 ViewGroup开始分发public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // 触摸事件流开始，重置触摸相关的状态 cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 关键点1： 检测当前是否需要拦截事件 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; // 处理调用requestDisallowInterceptTouchEvent()来决定是否允许ViewGroup拦截事件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // 当前没有TouchTarget也不是事件流的起始的话，则直接默认拦截，不通过onInterceptTouchEvent判断。 intercepted = true; &#125; final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 检测是否需要把多点触摸事件分配给不同的子View final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; // 当前事件流对应的TouchTarget对象 TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // 当前事件是事件流的初始事件(包括多点触摸时第二、第三点灯的DOWN事件)，清除之前相应的TouchTarget的状态 removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; //通过for循环，遍历了当前ViewGroup下的所有子View for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // 关键点2： 判断当前遍历到的子View能否接受事件，如果不能则直接continue进入下一次循环 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; // 当前子View能接收事件，为子View创建TouchTarget newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // 调用dispatchTransformedTouchEvent把事件分配给子View if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); // 把TouchTarget添加到TouchTarget列表的第一位 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; if (mFirstTouchTarget == null) &#123; // 目前没有任何TouchTarget，所以直接传null给dispatchTransformedTouchEvent handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // 把事件根据pointer id分发给TouchTarget列表内的所有TouchTarget，用来处理多点触摸的情况 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; // 遍历TouchTarget列表 while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; // 根据TouchTarget的pointerIdBits来执行dispatchTransformedTouchEvent if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // 处理CANCEL和UP事件的情况 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled;&#125; 上面的代码比较长，先不用细看。下面一张图来简化对照着理解一下： 关键点1：只有ACTION_DOWN事件或者mFirstTouchTarget为空时，并且没有调用过requestDisallowInterceptTouchEvent()去阻止该ViewGroup拦截事件的话，才可能执行拦截方法onInterceptTouchEvent() 关键点2：判断当前遍历到的子View能否接受事件主要由两点来衡量：子元素是否在播动画（canViewReceivePointerEvents（）方法）；点击事件坐标是否落在子元素区域内（``）。 //子元素是否在播动画private static boolean canViewReceivePointerEvents(View child) &#123; return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null;&#125; //点击事件坐标是否落在子元素区域内protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) &#123; float localX = x + mScrollX - child.mLeft; float localY = y + mScrollY - child.mTop; if (! child.hasIdentityMatrix() &amp;&amp; mAttachInfo != null) &#123; final float[] localXY = mAttachInfo.mTmpTransformLocation; localXY[0] = localX; localXY[1] = localY; child.getInverseMatrix().mapPoints(localXY); localX = localXY[0]; localY = localXY[1]; &#125; //检测坐标是否在child区域内 final boolean isInView = child.pointInView(localX, localY); if (isInView &amp;&amp; outLocalPoint != null) &#123; outLocalPoint.set(localX, localY); &#125; return isInView;&#125; 当子View满足这两个条件之后，ViewGroup就会调用dispatchTransformedMotionEvent()方法去交给子元素处理： private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; final int oldAction = event.getAction(); // 处理CANCEL的情况，直接把MotionEvent的原始数据分发给子View或者自身的onTouchEvent // (这边调用View.dispatchTouchEvent，而View.dispatchTouchEvent会再调用onTouchEvent方法，把MotionEvent传入) if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // 对MotionEvent自身的pointer id和当前我们需要处理的pointer id做按位与，得到共有的pointer id final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // 没有pointer id需要处理，直接返回 if (newPointerIdBits == 0) &#123; return false; &#125; final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; // 关键点1： 子View为空，直接交还给自身的onTouchEvent处理 handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); // 关键点2：交给子view的dispatchTouchEvent()方法去处理 handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; // MotionEvent自身的pointer id和当前需要处理的pointer id不同，把不需要处理的pointer id相关的信息剔除掉。 transformedEvent = event.split(newPointerIdBits); &#125; if (child == null) &#123; // 子View为空，直接交还给自身的onTouchEvent处理 handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; // 根据当前的scrollX、scrollY和子View的left、top对MotionEvent的触摸坐标x、y进行偏移 final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; // 获取子View自身矩阵的逆矩阵，并对MotionEvent的坐标相关信息进行矩阵变换 transformedEvent.transform(child.getInverseMatrix()); &#125; // 把经过偏移以及矩阵变换的事件传递给子View处理 handled = child.dispatchTouchEvent(transformedEvent); &#125; transformedEvent.recycle(); return handled;&#125; 子View消费事件然后我们看看View的dispatchTouchEvent()方法： public boolean dispatchTouchEvent(MotionEvent event) &#123; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; // 如果存在mOnTouchListener，直接交给它消费Touch事件 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; // 交给onTouchEvent()方法消费Touch事件 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 注意这里View的mOnTouchListener.onTouch(this, event)和onTouchEvent(event)都是放在if判断条件里的，也就是说他们的返回值会影响事件是否继续往下传递。如果mOnTouchListener.onTouch(this, event)返回true的话，就不会再执行此子View的onTouchEvent(event)方法了。 最后我们再看下View的onTouchEvent()方法是如何消费事件的呢？ public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; //关键点 performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false;&#125; 我们这里只注意一下在这个View接收到ACTION_UP事件之后，会调用到performClick()方法： public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); //通知回调mOnClickListener的onClick方法 li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 这里能说明View的OnClickListener的onClick()事件的执行时机是在整个TouchEvent事件列的最后才会执行。 Touch案例分析 问题：当ViewGroup的onInterceptTouchEvent()函数分别返回true和false时，这个ViewGroup和View1分别能接收到DOWN、MOVE、UP中的什么事件？ ViewGroup的onInterceptTouchEvent()方法 ViewGroup View1 return true 仅能接收到DOWN事件 什么都接收不到 return false 三种都能接收到 三种都能接收到 另一个案例可以参考这篇文章：Android 编程下 Touch 事件的分发和消费机制 总结 （1）Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。 （2）事件从 Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的 ViewGroup开始一直往下(子View)传递。子View可以通过 onTouchEvent()对事件进行处理。 （3）事件由ViewGroup传递给子 View，ViewGroup 可以通过 onInterceptTouchEvent()对事件做拦截，停止其往下传递。 （4）如果事件从上往下传递过程中一直没有被停止，且最底层子 View 没有消费事件，事件会反向往上传递，这时父 View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到 Activity 的 onTouchEvent()函数。 （5） 如果 View 没有对 ACTION_DOWN 进行消费，之后的其他事件不会传递过来。 （6）OnTouchListener 优先于 onTouchEvent()对事件进行消费。 （7）当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到第一个真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。 （8）当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。 （9）当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。 （10）ViewGroup默认不拦截任何事件。源码中的ViewGroup的onInterceptTouchEvent()方法默认返回false。 （11）View没有onInterceptTouchEvent()方法。一旦点击事件传递给它，就会调用它的onTouchEvent方法 （12）我们可以发现ViewGroup没有onTouchEvent事件，说明他的处理逻辑和View是一样的。 （13）子view如果消耗了事件，那么ViewGroup就不会在接受到事件了。 参考资料 Android:30分钟弄明白Touch事件分发机制 公共技术点之 View 事件传递 Android事件分发完全解析之为什么是她 Android ViewGroup/View 事件分发机制详解 Android事件分发机制详解：史上最全面、最易懂 Android 编程下 Touch 事件的分发和消费机制 ViewGroup 源码解析 ViewGroup源码解读","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】生产者消费者模式的实现","slug":"【Java】生产者消费者模式的实现","date":"2017-11-10T14:20:55.000Z","updated":"2017-11-16T11:16:15.449Z","comments":true,"path":"2017/11/10/【Java】生产者消费者模式的实现/","link":"","permalink":"http://github.com/2017/11/10/【Java】生产者消费者模式的实现/","excerpt":"前言生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。","text":"前言生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。 wait/notify方法首先，我们搞清楚Thread.sleep()方法和Object.wait()、Object.notify()方法的区别。根据这篇文章java sleep和wait的区别的疑惑? sleep()是Thread类的方法；而wait()，notify()，notifyAll()是Object类中定义的方法；尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的。 Thread.sleep()不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep()不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用Thread.sleep()是不会影响锁的相关行为。 Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。 线程状态图： Thread.sleep()让线程从 【running】 -&gt; 【阻塞态】 时间结束/interrupt -&gt; 【runnable】 Object.wait()让线程从 【running】 -&gt; 【等待队列】notify -&gt; 【锁池】 -&gt; 【runnable】 实现生产者消费者模型生产者消费者问题是研究多线程程序时绕不开的经典问题之一，它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。 （1）Object的wait() / notify()方法（2）Lock和Condition的await() / signal()方法（3）BlockingQueue阻塞队列方法（4）PipedInputStream / PipedOutputStream 本文只介绍最常用的前三种，第四种暂不做讨论。源代码在这里：Java实现生产者消费者模型 1. 使用Object的wait() / notify()方法wait()/ nofity()方法是基类Object的两个方法，也就意味着所有Java类都会拥有这两个方法，这样，我们就可以为任何对象实现同步机制。 wait()：当缓冲区已满/空时，生产者/消费者线程停止自己的执行，放弃锁，使自己处于等待状态，让其他线程执行。 notify()：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。 /** * 生产者消费者模式：使用Object.wait() / notify()方法实现 */public class ProducerConsumer &#123; private static final int CAPACITY = 5; public static void main(String args[])&#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); Thread producer1 = new Producer(\"P-1\", queue, CAPACITY); Thread producer2 = new Producer(\"P-2\", queue, CAPACITY); Thread consumer1 = new Consumer(\"C1\", queue, CAPACITY); Thread consumer2 = new Consumer(\"C2\", queue, CAPACITY); Thread consumer3 = new Consumer(\"C3\", queue, CAPACITY); producer1.start(); producer2.start(); consumer1.start(); consumer2.start(); consumer3.start(); &#125; /** * 生产者 */ public static class Producer extends Thread&#123; private Queue&lt;Integer&gt; queue; String name; int maxSize; int i = 0; public Producer(String name, Queue&lt;Integer&gt; queue, int maxSize)&#123; super(name); this.name = name; this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run()&#123; while(true)&#123; synchronized(queue)&#123; while(queue.size() == maxSize)&#123; try &#123; System.out .println(\"Queue is full, Producer[\" + name + \"] thread waiting for \" + \"consumer to take something from queue.\"); queue.wait(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(\"[\" + name + \"] Producing value : +\" + i); queue.offer(i++); queue.notifyAll(); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; /** * 消费者 */ public static class Consumer extends Thread&#123; private Queue&lt;Integer&gt; queue; String name; int maxSize; public Consumer(String name, Queue&lt;Integer&gt; queue, int maxSize)&#123; super(name); this.name = name; this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run()&#123; while(true)&#123; synchronized(queue)&#123; while(queue.isEmpty())&#123; try &#123; System.out.println(\"Queue is empty, Consumer[\" + name + \"] thread is waiting for Producer\"); queue.wait(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; int x = queue.poll(); System.out.println(\"[\" + name + \"] Consuming value : \" + x); queue.notifyAll(); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 注意要点判断Queue大小为0或者大于等于queueSize时须使用 while (condition) {}，不能使用 if(condition) {}。其中 while(condition)循环，它又被叫做“自旋锁”。自旋锁以及wait()和notify()方法在线程通信这篇文章中有更加详细的介绍。为防止该线程没有收到notify()调用也从wait()中返回（也称作虚假唤醒），这个线程会重新去检查condition条件以决定当前是否可以安全地继续执行还是需要重新保持等待，而不是认为线程被唤醒了就可以安全地继续执行了。 输出日志如下： [P-1] Producing value : +0[P-1] Producing value : +1[P-1] Producing value : +2[P-1] Producing value : +3[P-1] Producing value : +4Queue is full, Producer[P-1] thread waiting for consumer to take something from queue.[C3] Consuming value : 0[C3] Consuming value : 1[C3] Consuming value : 2[C3] Consuming value : 3[C3] Consuming value : 4Queue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-2] Producing value : +0[C1] Consuming value : 0Queue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for Producer[P-1] Producing value : +5[P-1] Producing value : +6[P-1] Producing value : +7[P-1] Producing value : +8[P-1] Producing value : +9Queue is full, Producer[P-1] thread waiting for consumer to take something from queue.[C3] Consuming value : 5[C3] Consuming value : 6[C3] Consuming value : 7[C3] Consuming value : 8[C3] Consuming value : 9Queue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-2] Producing value : +1[C1] Consuming value : 1Queue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for Producer[P-1] Producing value : +10[P-1] Producing value : +11[P-1] Producing value : +12[P-1] Producing value : +13[P-1] Producing value : +14Queue is full, Producer[P-1] thread waiting for consumer to take something from queue.[C3] Consuming value : 10[C3] Consuming value : 11[C3] Consuming value : 12[C3] Consuming value : 13[C3] Consuming value : 14Queue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-2] Producing value : +2[P-2] Producing value : +3[P-2] Producing value : +4[P-2] Producing value : +5[P-2] Producing value : +6Queue is full, Producer[P-2] thread waiting for consumer to take something from queue.[C1] Consuming value : 2[C1] Consuming value : 3[C1] Consuming value : 4[C1] Consuming value : 5[C1] Consuming value : 6Queue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for Producer[P-1] Producing value : +15[C3] Consuming value : 15Queue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-2] Producing value : +7[P-2] Producing value : +8[P-2] Producing value : +9 2. 使用Lock和Condition的await() / signal()方法在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步、锁定、线程池等，它们可以实现更细粒度的线程控制。Condition接口的await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和Object的wait()/ nofity()相同，完全可以取代它们，但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。下面来看代码： /** * 生产者消费者模式：使用Lock和Condition实现 * &#123;@link java.util.concurrent.locks.Lock&#125; * &#123;@link java.util.concurrent.locks.Condition&#125; */public class ProducerConsumerByLock &#123; private static final int CAPACITY = 5; private static final Lock lock = new ReentrantLock(); private static final Condition fullCondition = lock.newCondition(); //队列满的条件 private static final Condition emptyCondition = lock.newCondition(); //队列空的条件 public static void main(String args[])&#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); Thread producer1 = new Producer(\"P-1\", queue, CAPACITY); Thread producer2 = new Producer(\"P-2\", queue, CAPACITY); Thread consumer1 = new Consumer(\"C1\", queue, CAPACITY); Thread consumer2 = new Consumer(\"C2\", queue, CAPACITY); Thread consumer3 = new Consumer(\"C3\", queue, CAPACITY); producer1.start(); producer2.start(); consumer1.start(); consumer2.start(); consumer3.start(); &#125; /** * 生产者 */ public static class Producer extends Thread&#123; private Queue&lt;Integer&gt; queue; String name; int maxSize; int i = 0; public Producer(String name, Queue&lt;Integer&gt; queue, int maxSize)&#123; super(name); this.name = name; this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run()&#123; while(true)&#123; //获得锁 lock.lock(); while(queue.size() == maxSize)&#123; try &#123; System.out .println(\"Queue is full, Producer[\" + name + \"] thread waiting for \" + \"consumer to take something from queue.\"); //条件不满足，生产阻塞 fullCondition.await(); &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(\"[\" + name + \"] Producing value : +\" + i); queue.offer(i++); //唤醒其他所有生产者、消费者 fullCondition.signalAll(); emptyCondition.signalAll(); //释放锁 lock.unlock(); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者 */ public static class Consumer extends Thread&#123; private Queue&lt;Integer&gt; queue; String name; int maxSize; public Consumer(String name, Queue&lt;Integer&gt; queue, int maxSize)&#123; super(name); this.name = name; this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run()&#123; while(true)&#123; //获得锁 lock.lock(); while(queue.isEmpty())&#123; try &#123; System.out.println(\"Queue is empty, Consumer[\" + name + \"] thread is waiting for Producer\"); //条件不满足，消费阻塞 emptyCondition.await(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; int x = queue.poll(); System.out.println(\"[\" + name + \"] Consuming value : \" + x); //唤醒其他所有生产者、消费者 fullCondition.signalAll(); emptyCondition.signalAll(); //释放锁 lock.unlock(); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输入日志如下： [P-1] Producing value : +0[C1] Consuming value : 0Queue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for Producer[P-2] Producing value : +0[C3] Consuming value : 0Queue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-2] Producing value : +1[C2] Consuming value : 1Queue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for Producer[P-1] Producing value : +1[C1] Consuming value : 1Queue is empty, Consumer[C3] thread is waiting for Producer[P-1] Producing value : +2[C3] Consuming value : 2Queue is empty, Consumer[C2] thread is waiting for Producer[P-2] Producing value : +2[C2] Consuming value : 2Queue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for Producer[P-1] Producing value : +3[C1] Consuming value : 3Queue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for Producer[P-2] Producing value : +3[C2] Consuming value : 3Queue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for Producer[P-1] Producing value : +4[C1] Consuming value : 4Queue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-2] Producing value : +4[C3] Consuming value : 4Queue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-2] Producing value : +5[C2] Consuming value : 5Queue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C2] thread is waiting for Producer[P-1] Producing value : +5[C1] Consuming value : 5Queue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for Producer[P-2] Producing value : +6[C2] Consuming value : 6Queue is empty, Consumer[C3] thread is waiting for Producer[P-1] Producing value : +6[C3] Consuming value : 6Queue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-2] Producing value : +7[C3] Consuming value : 7Queue is empty, Consumer[C1] thread is waiting for Producer[P-1] Producing value : +7[C1] Consuming value : 7Queue is empty, Consumer[C2] thread is waiting for Producer[P-2] Producing value : +8[C2] Consuming value : 8[P-1] Producing value : +8[C1] Consuming value : 8[P-2] Producing value : +9[C3] Consuming value : 9[P-2] Producing value : +10[C2] Consuming value : 10[P-1] Producing value : +9[P-1] Producing value : +10[C1] Consuming value : 9[P-2] Producing value : +11[C3] Consuming value : 10[C2] Consuming value : 11[P-2] Producing value : +12[C1] Consuming value : 12[P-1] Producing value : +11[C3] Consuming value : 11[P-2] Producing value : +13[C2] Consuming value : 13Queue is empty, Consumer[C2] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for Producer[P-1] Producing value : +12[C2] Consuming value : 12Queue is empty, Consumer[C3] thread is waiting for Producer[P-1] Producing value : +13[C3] Consuming value : 13Queue is empty, Consumer[C1] thread is waiting for ProducerQueue is empty, Consumer[C3] thread is waiting for Producer[P-2] Producing value : +14[C1] Consuming value : 14Queue is empty, Consumer[C3] thread is waiting for ProducerQueue is empty, Consumer[C1] thread is waiting for Producer[P-1] Producing value : +14[C3] Consuming value : 14Queue is empty, Consumer[C1] thread is waiting for Producer[P-1] Producing value : +15[C1] Consuming value : 15[P-2] Producing value : +15[P-1] Producing value : +16[C3] Consuming value : 15[P-2] Producing value : +16 3. 使用BlockingQueue阻塞队列方法JDK 1.5 以后新增的 java.util.concurrent包新增了 BlockingQueue 接口。并提供了如下几种阻塞队列实现： java.util.concurrent.ArrayBlockingQueue java.util.concurrent.LinkedBlockingQueue java.util.concurrent.SynchronousQueue java.util.concurrent.PriorityBlockingQueue 实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。 我们这里使用LinkedBlockingQueue，它是一个已经在内部实现了同步的队列，实现方式采用的是我们第2种await()/ signal()方法。它可以在生成对象时指定容量大小。它用于阻塞操作的是put()和take()方法。 put()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。 take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。 我们可以跟进源码看一下LinkedBlockingQueue类的put()方法实现： /** Main lock guarding all access */final ReentrantLock lock = new ReentrantLock();/** Condition for waiting takes */private final Condition notEmpty = lock.newCondition();/** Condition for waiting puts */private final Condition notFull = lock.newCondition();public void put(E e) throws InterruptedException &#123; putLast(e);&#125;public void putLast(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; while (!linkLast(node)) notFull.await(); &#125; finally &#123; lock.unlock(); &#125;&#125; 看到这里证实了它的实现方式采用的是我们第2种await()/ signal()方法。下面我们就使用它实现吧。 /** * 生产者消费者模式：使用&#123;@link java.util.concurrent.BlockingQueue&#125;实现 */public class ProducerConsumerByBQ&#123; private static final int CAPACITY = 5; public static void main(String args[])&#123; LinkedBlockingDeque&lt;Integer&gt; blockingQueue = new LinkedBlockingDeque&lt;Integer&gt;(CAPACITY); Thread producer1 = new Producer(\"P-1\", blockingQueue, CAPACITY); Thread producer2 = new Producer(\"P-2\", blockingQueue, CAPACITY); Thread consumer1 = new Consumer(\"C1\", blockingQueue, CAPACITY); Thread consumer2 = new Consumer(\"C2\", blockingQueue, CAPACITY); Thread consumer3 = new Consumer(\"C3\", blockingQueue, CAPACITY); producer1.start(); producer2.start(); consumer1.start(); consumer2.start(); consumer3.start(); &#125; /** * 生产者 */ public static class Producer extends Thread&#123; private LinkedBlockingDeque&lt;Integer&gt; blockingQueue; String name; int maxSize; int i = 0; public Producer(String name, LinkedBlockingDeque&lt;Integer&gt; queue, int maxSize)&#123; super(name); this.name = name; this.blockingQueue = queue; this.maxSize = maxSize; &#125; @Override public void run()&#123; while(true)&#123; try &#123; blockingQueue.put(i); System.out.println(\"[\" + name + \"] Producing value : +\" + i); i++; //暂停最多1秒 Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者 */ public static class Consumer extends Thread&#123; private LinkedBlockingDeque&lt;Integer&gt; blockingQueue; String name; int maxSize; public Consumer(String name, LinkedBlockingDeque&lt;Integer&gt; queue, int maxSize)&#123; super(name); this.name = name; this.blockingQueue = queue; this.maxSize = maxSize; &#125; @Override public void run()&#123; while(true)&#123; try &#123; int x = blockingQueue.take(); System.out.println(\"[\" + name + \"] Consuming : \" + x); //暂停最多1秒 Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输出日志如下： [P-2] Producing value : +0[P-1] Producing value : +0[C1] Consuming : 0[C3] Consuming : 0[P-2] Producing value : +1[C2] Consuming : 1[P-2] Producing value : +2[C1] Consuming : 2[P-1] Producing value : +1[C2] Consuming : 1[P-1] Producing value : +2[C3] Consuming : 2[P-1] Producing value : +3[C2] Consuming : 3[P-2] Producing value : +3[C1] Consuming : 3[P-1] Producing value : +4[C2] Consuming : 4[P-2] Producing value : +4[C3] Consuming : 4[P-2] Producing value : +5[C1] Consuming : 5[P-1] Producing value : +5[C2] Consuming : 5[P-1] Producing value : +6[C1] Consuming : 6[P-2] Producing value : +6[C2] Consuming : 6[P-2] Producing value : +7[C2] Consuming : 7[P-1] Producing value : +7[C1] Consuming : 7[P-2] Producing value : +8[C3] Consuming : 8[P-2] Producing value : +9[C2] Consuming : 9[P-1] Producing value : +8[C2] Consuming : 8[P-2] Producing value : +10[C1] Consuming : 10[P-1] Producing value : +9[C3] Consuming : 9[P-1] Producing value : +10[C2] Consuming : 10[P-2] Producing value : +11[C1] Consuming : 11[C3] Consuming : 12[P-2] Producing value : +12[P-2] Producing value : +13[C2] Consuming : 13[P-1] Producing value : +11[C3] Consuming : 11[P-1] Producing value : +12[C3] Consuming : 12[P-2] Producing value : +14[C1] Consuming : 14[P-1] Producing value : +13[C2] Consuming : 13[P-2] Producing value : +15[C3] Consuming : 15[P-2] Producing value : +16[C1] Consuming : 16[P-1] Producing value : +14[C3] Consuming : 14[P-2] Producing value : +17[C2] Consuming : 17 参考资料 Producer-Consumer solution using threads in Java 生产者消费者问题 - 维基百科 生产者/消费者问题的多种Java实现方式 如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例 JAVA多线程之wait/notify java sleep和wait的区别的疑惑?","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】Dialog异常CalledFromWrongThreadException深入分析","slug":"【Android】Dialog异常CalledFromWrongThreadException深入分析","date":"2017-10-26T14:20:55.000Z","updated":"2017-10-27T01:53:34.718Z","comments":true,"path":"2017/10/26/【Android】Dialog异常CalledFromWrongThreadException深入分析/","link":"","permalink":"http://github.com/2017/10/26/【Android】Dialog异常CalledFromWrongThreadException深入分析/","excerpt":"问题在使用Dialog时，因为线程问题，在调用dismiss方法时出现了CalledFromWrongThreadException的Crash，如下： android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 抛出异常为CalledFromWrongThreadException，很明显第一反应就是出现了非ui线程进行了ui操作造成了此异常。通过分析工程代码，发现本质上是因为在非ui线程中创建了Dialog，而在主线程（即ui线程）中调用了show()以及dismiss()方法，我把问题模型写成测试代码如下： public class MainActivity extends BaseActivity &#123; private static final String TAG = \"MainActivity test\"; private ProgressDialog dialog; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this); new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); //子线程中创建Dialog dialog = new ProgressDialog(MainActivity.this); dialog.setCanceledOnTouchOutside(true); dialog.setOnCancelListener(new DialogInterface.OnCancelListener() &#123; @Override public void onCancel(DialogInterface dialog) &#123; Log.d(TAG, \"Dialog onCancel thread: \" + getThreadInfo()); &#125; &#125;); dialog.setOnDismissListener(new DialogInterface.OnDismissListener() &#123; @Override public void onDismiss(DialogInterface dialog) &#123; Log.d(TAG, \"Dialog onDismiss thread: \" + getThreadInfo()); &#125; &#125;); dialog.setMessage(\"正在加载...\"); Log.d(TAG, \"Dialog create thread: \" + getThreadInfo()); Looper.loop(); &#125; &#125;).start(); Button btn = (Button) findViewById(R.id.btn_helloworld); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //UI主线程中show，然后点击空白区域dismiss dialog.show(); Log.d(TAG, \"Dialog show thread: \" + getThreadInfo()); &#125; &#125;); &#125; /** * 输出线程信息 */ private String getThreadInfo()&#123; return \"[\" + Thread.currentThread().getId() + \"]\" + ((Looper.myLooper() == Looper.getMainLooper())? \" is UI-Thread\" : \"\"); &#125;&#125; 就是Activity打开的时候，使用work子线程创建了一个Dialog，然后手动点击按钮的时候，显示Dialog。再点击空白处，dialog本应该dismiss的，但是直接crash了。抛出了CalledFromWrongThreadException的异常。 在上面的代码中，我顺便输出了Dialog每个操作的线程ID，同时会判定是不是ui主线程。我们来看看log： 10-26 16:11:07.836 7405-7652/com.cuc.myandroidtest D/MainActivity test: Dialog create thread: [3953]10-26 16:11:27.763 7405-7405/com.cuc.myandroidtest D/MainActivity test: Dialog show thread: [1] is UI-Thread10-26 16:11:35.642 7405-7652/com.cuc.myandroidtest D/MainActivity test: Dialog onCancel thread: [3953] ——– beginning of crash 可以看到，以上出现的问题中执行Dialog操作的线程信息如下： 创建Dialog：work子线程 show()：ui主线程 cancel()：work子线程 dismiss()：因为crash没有执行到，未知 如果说只有创建这个控件的线程才能去更新该控件的内容。那么在调用show方法的时候为什么不会crash，然后dismiss的时候才会崩溃？ 另外，到底是不是所有的操作都必须放到ui线程中执行才对？带着疑问我们深入Dialog源码一看究竟。","text":"问题在使用Dialog时，因为线程问题，在调用dismiss方法时出现了CalledFromWrongThreadException的Crash，如下： android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 抛出异常为CalledFromWrongThreadException，很明显第一反应就是出现了非ui线程进行了ui操作造成了此异常。通过分析工程代码，发现本质上是因为在非ui线程中创建了Dialog，而在主线程（即ui线程）中调用了show()以及dismiss()方法，我把问题模型写成测试代码如下： public class MainActivity extends BaseActivity &#123; private static final String TAG = \"MainActivity test\"; private ProgressDialog dialog; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this); new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); //子线程中创建Dialog dialog = new ProgressDialog(MainActivity.this); dialog.setCanceledOnTouchOutside(true); dialog.setOnCancelListener(new DialogInterface.OnCancelListener() &#123; @Override public void onCancel(DialogInterface dialog) &#123; Log.d(TAG, \"Dialog onCancel thread: \" + getThreadInfo()); &#125; &#125;); dialog.setOnDismissListener(new DialogInterface.OnDismissListener() &#123; @Override public void onDismiss(DialogInterface dialog) &#123; Log.d(TAG, \"Dialog onDismiss thread: \" + getThreadInfo()); &#125; &#125;); dialog.setMessage(\"正在加载...\"); Log.d(TAG, \"Dialog create thread: \" + getThreadInfo()); Looper.loop(); &#125; &#125;).start(); Button btn = (Button) findViewById(R.id.btn_helloworld); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //UI主线程中show，然后点击空白区域dismiss dialog.show(); Log.d(TAG, \"Dialog show thread: \" + getThreadInfo()); &#125; &#125;); &#125; /** * 输出线程信息 */ private String getThreadInfo()&#123; return \"[\" + Thread.currentThread().getId() + \"]\" + ((Looper.myLooper() == Looper.getMainLooper())? \" is UI-Thread\" : \"\"); &#125;&#125; 就是Activity打开的时候，使用work子线程创建了一个Dialog，然后手动点击按钮的时候，显示Dialog。再点击空白处，dialog本应该dismiss的，但是直接crash了。抛出了CalledFromWrongThreadException的异常。 在上面的代码中，我顺便输出了Dialog每个操作的线程ID，同时会判定是不是ui主线程。我们来看看log： 10-26 16:11:07.836 7405-7652/com.cuc.myandroidtest D/MainActivity test: Dialog create thread: [3953]10-26 16:11:27.763 7405-7405/com.cuc.myandroidtest D/MainActivity test: Dialog show thread: [1] is UI-Thread10-26 16:11:35.642 7405-7652/com.cuc.myandroidtest D/MainActivity test: Dialog onCancel thread: [3953] ——– beginning of crash 可以看到，以上出现的问题中执行Dialog操作的线程信息如下： 创建Dialog：work子线程 show()：ui主线程 cancel()：work子线程 dismiss()：因为crash没有执行到，未知 如果说只有创建这个控件的线程才能去更新该控件的内容。那么在调用show方法的时候为什么不会crash，然后dismiss的时候才会崩溃？ 另外，到底是不是所有的操作都必须放到ui线程中执行才对？带着疑问我们深入Dialog源码一看究竟。 源码分析我们先看Dialog的dismiss方法： /** * Dismiss this dialog, removing it from the screen. This method can be * invoked safely from any thread. Note that you should not override this * method to do cleanup when the dialog is dismissed, instead implement * that in &#123;@link #onStop&#125;. */@Overridepublic void dismiss() &#123; if (Looper.myLooper() == mHandler.getLooper()) &#123; dismissDialog(); &#125; else &#123; mHandler.post(mDismissAction); &#125;&#125;private final Runnable mDismissAction = new Runnable() &#123; public void run() &#123; dismissDialog(); &#125;&#125;; 我们先看注释，意思是dismiss()这个函数可以在任意线程中调用，不用担心线程安全问题。 很明显，dialog对于ui操作做了特别处理。如果当前执行dismiss操作的线程和mHandler所依附的线程不一致的话那么就会将dismiss操作丢到对应的mHandler的线程队列中等待执行。那么这个Handler又是哪里来的呢？ 我们开始调查，可以看到mHandler对象是Dialog类中私有的，会在new Dialog的时候自动初始化： public class Dialog implements DialogInterface, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, Window.OnWindowDismissedCallback &#123; private final Handler mHandler = new Handler(); //...省略其余代码...&#125; 可以分析得出，该mHandler直接关联的就是new Dialog的线程。也就能得出以下结论： 结论一：最终真正执行dismissDialog()方法销毁Dialog的线程就是new Dialog的线程。 然后我们跟进去dismissDialog()看看到底如何销毁Dialog的： void dismissDialog() &#123; if (mDecor == null || !mShowing) &#123; return; &#125; if (mWindow.isDestroyed()) &#123; Log.e(TAG, \"Tried to dismissDialog() but the Dialog's window was already destroyed!\"); return; &#125; try &#123; mWindowManager.removeViewImmediate(mDecor); &#125; finally &#123; if (mActionMode != null) &#123; mActionMode.finish(); &#125; mDecor = null; mWindow.closeAllPanels(); onStop(); mShowing = false; sendDismissMessage(); &#125;&#125; 可以看出最终调用了mWindowManager.removeViewImmediate(mDecor);来销毁Dialog，继续跟进removeViewImmediate()这个方法。发现mWindowManager的类WindowManager是个abstract的类，我们来找找本尊。 Dialog中mWindowManager对象的来历发现mWindowManager这个对象的初始化是在Dialog的构造函数中： Dialog(Context context, int theme, boolean createContextThemeWrapper) &#123; if (createContextThemeWrapper) &#123; if (theme == 0) &#123; TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(com.android.internal.R.attr.dialogTheme, outValue, true); theme = outValue.resourceId; &#125; mContext = new ContextThemeWrapper(context, theme); &#125; else &#123; mContext = context; &#125; mWindowManager = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); Window w = PolicyManager.makeNewWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this);&#125; 它是通过context.getSystemService(Context.WINDOW_SERVICE);得到的，这里的context肯定就是Activity了，我们去Activity中找getSystemService()函数： @Overridepublic Object getSystemService(@ServiceName @NonNull String name) &#123; if (getBaseContext() == null) &#123; throw new IllegalStateException( \"System services not available to Activities before onCreate()\"); &#125; if (WINDOW_SERVICE.equals(name)) &#123; return mWindowManager; &#125; else if (SEARCH_SERVICE.equals(name)) &#123; ensureSearchManager(); return mSearchManager; &#125; return super.getSystemService(name);&#125;final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, IVoiceInteractor voiceInteractor) &#123; mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); mWindowManager = mWindow.getWindowManager(); //...省略其他代码...&#125; 我们看到mWindowManager这个对象是在Activity被创建之后调用attach函数的时候通过mWindow.setWindowManager()初始化的，而这个函数里干了什么呢？ public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);&#125; 可以看到mWindowManager这个对象最终来源于WindowManagerImpl类： public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Display mDisplay; private final Window mParentWindow; public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mDisplay, parentWindow); &#125; @Override public void addView(View view, ViewGroup.LayoutParams params) &#123; mGlobal.addView(view, params, mDisplay, mParentWindow); &#125; @Override public void removeView(View view) &#123; mGlobal.removeView(view, false); &#125; @Override public void removeViewImmediate(View view) &#123; mGlobal.removeView(view, true); &#125; //...省略其余代码...&#125; 在其中我们终于看到了removeViewImmediate()函数的身影，也就是说，在执行Dialog销毁的函数dismissDialog()中，最终调用了mWindowManager.removeViewImmediate(mDecor);来销毁Dialog。实际上调用的就是WindowManagerImpl实例中的removeViewImmediate()方法。 而它又调用的是WindowManagerGlobal的removeView()函数： public void removeView(View view, boolean immediate) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException(\"Calling with view \" + view + \" but the ViewAncestor is attached to \" + curView); &#125;&#125;private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125;&#125; 注意这句boolean deferred = root.die(immediate);，其中root对象是个ViewRootImpl的实例，我们看看它的die()方法： boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; //...省略其余代码...&#125;void doDie() &#123; checkThread(); //...省略其余代码...&#125; 最终，执行到了ViewRootImpl类的doDie()方法，这个方法的第一句就是checkThread()，根据Android4.4DialogUI线程CalledFromWrongThreadExcection这篇文章，我们知道最终抛出异常的位置就是是在ViewRootImpl代码中的checkThread函数： void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); &#125;&#125; 也就是说，当调用Dialog的dismiss()方法时，Dialog会自动抛到new Dialog的线程中执行，而这个线程就是当前的Thread.currentThread()。换句话说ViewRootImpl本身的mThread和这个new Dialog的线程不是同一个线程。然后我们看看这个ViewRootImpl本身的mThread的来源在何处。 ViewRootImpl中mThread的来历在ViewRootImpl的构造函数中发现了mThread赋值的地方： public ViewRootImpl(Context context, Display display) &#123; mThread = Thread.currentThread(); //...省略其余代码...&#125; 那这个ViewRootImpl什么时候调用这个构造函数创建实例的呢？我们刚才在WindowManagerGlobal的removeView()函数中，看到了root对象是从mRoots对象中取出来的，而mRoots是一个ArrayList&lt;ViewRootImpl&gt;。 所以我们来WindowManagerGlobal中找找mRoots.add()的地方，发现是在它的addView()函数中创建了一个ViewRootImpl对象并添加到了mRoots这个list中： public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //...省略其余代码..... ViewRootImpl root; synchronized (mLock) &#123; //...省略其余代码..... root = new ViewRootImpl(view.getContext(), display); mRoots.add(root); &#125; // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125;&#125; 而这个addView方法什么时候会调用呢？就是WindowManagerImpl。 就是刚才分析Dialog中mWindowManager对象的来历时，知道了它其实是WindowManagerImpl类的一个实例，WindowManagerImpl会通过WindowManagerGlobal的removeView()方法去实现removeView。同理，此处WindowManagerGlobal的addView()方法也是被WindowManagerImpl调用的。 我们在Dialog的源码中找一下mWindowManager对象调用addView()方法的地方，很让人惊喜，它竟然在Dialog的show()方法中出现了： public void show() &#123; //...省略其余代码..... onStart(); mDecor = mWindow.getDecorView(); try &#123; mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage(); &#125; finally &#123; &#125;&#125; 也就是说，Dialog的show()方法，会通过mWindowManager.addView(mDecor, l);创建一个ViewRootImpl的对象，这个对象会在创建的时候保存一个当前线程的Thread对象。也就是调用Dialog的show()方法的线程。 而在调用Dialog的dismiss()方法时，会首先把它抛到new Dialog的线程中执行，最后通过调用mWindowManager.removeViewImmediate()来销毁View，此时也就自然调用到了ViewRootImpl对象的doDie()方法，这个方法中会checkThread();，此时会检查当前线程（也就是调用new Dialog的线程）是不是创建ViewRootImpl的对象的线程（也就是Dialog的show()方法的线程）。 到这里，本文的bug根源也就找到了说通了。我们再来熟悉一下这个异常的场景。 创建Dialog：work子线程 show()：ui主线程 cancel()：work子线程 dismiss()：因为crash没有执行到，未知（其实是抛到了work子线程） 现在就明确了，执行show()方法的时候ViewRootImpl没有checkThread()，所以不会出现crash。而在执行dismiss()的时候，它首先被抛到创建Dialog的线程中执行，而后真正销毁View时ViewRootImpl会checkThread()，保证addView的线程才能removeView。而在文章开头出错的例子中，Dialog的show()是在主线程执行，new Dialog()是在work子线程中执行的，所以抛出了CalledFromWrongThreadException的异常。 结论 Dialog的dismiss()会首先被抛到new Dialog的线程中执行。 只要保证创建Dialog和show()方法在同一个线程中执行，无论是在放到ui线程还是work子线程都可以。 比如，把文章开头的例子中的show()方法同样放到work线程中，可以正常执行，输出log如下： 10-26 19:23:02.603 27689-27760/com.cuc.myandroidtest D/MainActivity test: Dialog create thread: [4213]10-26 19:23:02.686 27689-27760/com.cuc.myandroidtest D/MainActivity test: Dialog show thread: [4213]10-26 19:23:07.243 27689-27760/com.cuc.myandroidtest D/MainActivity test: Dialog onCancel thread: [4213]10-26 19:23:07.243 27689-27760/com.cuc.myandroidtest D/MainActivity test: Dialog onDismiss thread: [4213] 版本差异注意，本文的这个CalledFromWrongThreadException异常，是在4.4版本及以上才会出现的。具体区别可以参考这篇文章：Android4.4DialogUI线程CalledFromWrongThreadExcection 4.2中Dialog的dismissDialog和4.4中Dialog的dismissDialog区别如下： //4.2中Dialog的dismissDialogtry &#123; mWindowManager.removeView(mDecor);&#125; //4.4中Dialog的dismissDialogtry &#123; mWindowManager.removeViewImmediate(mDecor);&#125; 参考资料 Android4.4DialogUI线程CalledFromWrongThreadExcection Android异常：android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original Activity WMS ViewRootImpl三者关系（Activity创建窗口 按键分发等）","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【算法】字符串是否包含问题","slug":"【算法】字符串是否包含问题","date":"2017-10-18T14:20:55.000Z","updated":"2017-10-23T04:02:27.132Z","comments":true,"path":"2017/10/18/【算法】字符串是否包含问题/","link":"","permalink":"http://github.com/2017/10/18/【算法】字符串是否包含问题/","excerpt":"在网上看到这篇文章：一次谷歌面试趣事。觉得其中的算法题以及作者的解决思路很有趣，就拿来分享一下吧。 问题假设这有一个各种字母组成的字符串，假设这还有另外一个字符串，而且这个字符串里的字母数相对少一些。从算法是讲，什么方法能最快的查出所有小字符串里的字母在大字符串里都有？ 比如，如果是下面两个字符串： String 1: ABCDEFGHLMNOPQRSString 2: DCGSRQPO 答案是true，所有在String2里的字母String1也都有。如果是下面两个字符串： String 1: ABCDEFGHLMNOPQRSString 2: DCGSRQPZ 答案是false，因为第二个字符串里的Z字母不在第一个字符串里。","text":"在网上看到这篇文章：一次谷歌面试趣事。觉得其中的算法题以及作者的解决思路很有趣，就拿来分享一下吧。 问题假设这有一个各种字母组成的字符串，假设这还有另外一个字符串，而且这个字符串里的字母数相对少一些。从算法是讲，什么方法能最快的查出所有小字符串里的字母在大字符串里都有？ 比如，如果是下面两个字符串： String 1: ABCDEFGHLMNOPQRSString 2: DCGSRQPO 答案是true，所有在String2里的字母String1也都有。如果是下面两个字符串： String 1: ABCDEFGHLMNOPQRSString 2: DCGSRQPZ 答案是false，因为第二个字符串里的Z字母不在第一个字符串里。 解决方案1. 轮询对于这种操作最简单最幼稚的做法是轮询第二个字符串里的每个字母，看它是否同在第一个字符串里。从算法上讲，这需要O(n*m)次操作，其中n是string1的长度，m是string2的长度。就拿上面的例子来说，最坏的情况下将会有16*8 = 128次操作。 2. 排序一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要O(m log m) + O(n log n)次操作（常规情况下），之后的线性扫描需要O(m+n)次操作。同样拿上面的字串做例子，将会需要164 + 83 = 88加上对两个字串线性扫描的16 + 8 = 24的操作。（随着字串长度的增长，你会发现这个算法的效果会越来越好） /** * 排序方案：快速排序 */public static boolean isSubsetByQuickSort(String a, String b)&#123; char[] ca = a.toCharArray(); char[] cb = b.toCharArray(); quickSort(ca, 0, ca.length - 1); quickSort(cb, 0, cb.length - 1); //字符串String1的比较指针 int pos = 0; for(char c : cb)&#123; while(pos &lt; ca.length-1 &amp;&amp; ca[pos] &lt; c)&#123; pos++; &#125; if(c != ca[pos])&#123; System.out.println(\"No exist char: \" + c); return false; &#125; &#125; return true;&#125;public static void quickSort(char[] arr, int low, int high)&#123; if(arr.length &lt;= 0) return; if(low &gt;= high) return; int l = low; int r = high; char pivot = arr[l]; while(l &lt; r)&#123; while(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123; r--; &#125; arr[l] = arr[r]; while(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123; l++; &#125; arr[r] = arr[l]; &#125; arr[l] = pivot; quickSort(arr, low, l - 1); quickSort(arr, l + 1, high);&#125; 不过，常规排序比如快排可以达到O(n log n)的时间复杂度，这里也可以选用用空间换时间的的基数排序、桶排序等线性时间复杂度的排序算法。 // 字母编码[A - z]:[65 - 122]public static final int LETTER_REGION = 122 - 65 + 1;/** * 排序方案：计数排序 */public static boolean isSubsetByCounterSort(String a, String b)&#123; char[] ca = a.toCharArray(); char[] cb = b.toCharArray(); ca = counterSort(ca); cb = counterSort(cb); //字符串String1的比较指针 int pos = 0; for(char c : cb)&#123; while(pos &lt; ca.length-1 &amp;&amp; ca[pos] &lt; c)&#123; pos++; &#125; if(c != ca[pos])&#123; System.out.println(\"No exist char: \" + c); return false; &#125; &#125; return true;&#125;public static char[] counterSort(char[] arr)&#123; int[] bucket = new int[LETTER_REGION]; for(char c : arr)&#123; int index = c - 'A'; bucket[index]++; &#125; for(int i = 1; i &lt; LETTER_REGION; i++)&#123; bucket[i] += bucket[i - 1]; &#125; char[] res = new char[arr.length]; for(char c : arr)&#123; int index = c - 'A'; res[bucket[index] - 1] = c; bucket[index]--; &#125; return res;&#125; 3. 哈希表哈希表Hashtable是一个只需要O(n+m)次操作的算法。方法就是，对第一个字串进行轮询，把其中的每个字母都放入一个Hashtable里（时间成本是O(n)，这里是16次操作）。然后轮询第二个字串，在Hashtable里查询每个字母，看能否找到。如果找不到，说明没有匹配成功。这将消耗掉8次操作 —— 这样两项操作加起来一共只有24次。不错吧，比前面两种方案都要好。 /** * 哈希表Hashset */public static boolean isSubsetByHashset(String a, String b)&#123; char[] ca = a.toCharArray(); char[] cb = b.toCharArray(); HashSet&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for(char c : ca)&#123; set.add(c); &#125; for(char c : cb)&#123; if(!set.contains(c))&#123; return false; &#125; &#125; return true;&#125; 4、Bitmap位图法这个解决方案思想和Hashtable一致，只不过使用的是位图法来为每一个字符保留一位。同样只需要O(n+m)次操作。 // 字母编码区间[A - z]:[65 - 122]public static final int LETTER_REGION = 122 - 65 + 1;/** * 比特位方案 */public static boolean isSubsetByBitmap(String a, String b)&#123; char[] ca = a.toCharArray(); char[] cb = b.toCharArray(); byte[] bitmap = new byte[LETTER_REGION / Byte.SIZE]; for(char c : ca)&#123; setBit(bitmap, c - 'A'); &#125; for(char c : cb)&#123; if(getBit(bitmap, c - 'A') == 0)&#123; System.out.println(\"No exist char in Bitmap: \" + c); return false; &#125; &#125; return true;&#125;/** * 写入指定位的比特 */public static void setBit(byte bitmap[], int k)&#123; bitmap[k / Byte.SIZE] |= (1 &lt;&lt; (k % Byte.SIZE));&#125;/** * 读取指定位的比特 */public static int getBit(byte bitmap[], int k)&#123; return (bitmap[k / Byte.SIZE] &amp; (1 &lt;&lt; (k % Byte.SIZE)));&#125; 到此为止，O(n+m)几乎是你能得到的最好的结果了，因为至少要对每个字母至少访问一次才能完成这项操作，而上述这两个方案是刚好是对每个字母只访问一次。下面看看文章中最后的这个素数方案。 5. 素数假设我们有一个一定个数的字母组成字串。我给每个字母分配一个素数，从2开始，往后类推。这样A将会是2，B将会是3，C将会是5，等等。现在我遍历第一个字串，把每个字母代表的素数相乘。最终会得到一个很大的整数，对吧？然后 —— 轮询第二个字符串，用每个字母除它。如果除的结果有余数，这说明有不匹配的字母。如果整个过程中没有余数，你应该知道它是第一个字串恰好的子集了。这样不行吗？ public static int primes[] = &#123; 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103, 107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211, 223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331, 337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449, 457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587, 593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709, 719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853, 857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991&#125;;// 字母编码区间[A - z]:[65 - 122]public static final int LETTER_REGION = 122 - 65 + 1;/** * 素数方案 */public static boolean isSubsetByPrimeNumber(String a, String b)&#123; char[] ca = a.toCharArray(); char[] cb = b.toCharArray(); // 防止乘积int溢出，使用BigInteger存储乘积结果 BigInteger p = BigInteger.ONE; for(char c : ca)&#123; p = p.multiply(BigInteger.valueOf(primes[c - 'A'])); &#125; System.out.println(\"乘积结果p = \" + p.toString()); for(char c : cb)&#123; if(!p.remainder(BigInteger.valueOf(primes[c - 'A'])).equals(BigInteger.ZERO))&#123; System.out.println(\"No exist char: \" + c); return false; &#125; &#125; return true;&#125; 测试代码public class CharacterSubset &#123; /** * 假设你有一个一定长度的由字母组成的字符串。你还有另外一个，短些。你如何才能知道所有的在较短的字符串里的字母在长字符串里也有？ */ public static void main(String args[])&#123; String a1 = \"ABCDEFGHLMNOPQRS\"; String b1 = \"DCGSRQPOM\"; String a2 = \"ABCDEFGHLMNOPQRS\"; String b2 = \"DCGSRQPOZ\"; System.out.println(\"\\na1 and b1: \" + isSubsetByQuickSort(a1, b1)); System.out.println(\"\\na2 and b2: \" + isSubsetByQuickSort(a2, b2)); System.out.println(\"\\na1 and b1: \" + isSubsetByCounterSort(a1, b1)); System.out.println(\"\\na2 and b2: \" + isSubsetByCounterSort(a2, b2)); System.out.println(\"\\na1 and b1: \" + isSubsetByHashset(a1, b1)); System.out.println(\"\\na2 and b2: \" + isSubsetByHashset(a2, b2)); System.out.println(\"\\na1 and b1: \" + isSubsetByPrimeNumber(a1, b1)); System.out.println(\"\\na2 and b2: \" + isSubsetByPrimeNumber(a2, b2)); System.out.println(\"\\na1 and b1: \" + isSubsetByBitmap(a1, b1)); System.out.println(\"\\na2 and b2: \" + isSubsetByBitmap(a2, b2)); &#125;&#125; 总结就如文章中所说，素数方案在算法上并不能说就比哈希表好。而且在实际操作中，你很可能仍会使用哈希表的方案，因为它更通用，无需跟麻烦的大型数字打交道。但从”巧妙水平“上讲，Guy提供的素数方案是一种更、更、更有趣的方案。 参考资料 一次谷歌面试趣事 程序员编程艺术：第二章、字符串是否包含问题","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】源码分析 - AsyncTask异步任务机制","slug":"【Android】源码分析 - AsyncTask异步任务机制","date":"2017-10-09T12:03:00.000Z","updated":"2017-10-10T08:06:15.380Z","comments":true,"path":"2017/10/09/【Android】源码分析 - AsyncTask异步任务机制/","link":"","permalink":"http://github.com/2017/10/09/【Android】源码分析 - AsyncTask异步任务机制/","excerpt":"前言提到Android的多线程机制，常用的有如下几种方式： AsyncTask: 封装了线程池和Handler，为 UI 线程与工作线程之间进行快速切换提供一种便捷机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。 HandlerThread: 一个已经拥有了Looper的线程类，内部可以直接使用Handler。为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。 ThreadPool: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。 IntentService: 适合于执行由 UI 触发的后台 Service 任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。 尽管Android已经设计了基本的Handler异步消息机制提供给我们进行线程间通信，不过对于频繁得UI更新操作Handler用起来确实有点细碎，为了更加方便我们在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它我们可以非常灵活方便地从子线程切换到UI线程。 我们就从AsyncTask的基本用法开始，一起分析下AsyncTask源码，看看它是如何实现的。 使用AsyncTask由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下： Params：在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。 Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。 Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 一个最简单的自定义AsyncTask就可以写成如下方式： private class MyTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; ... &#125;","text":"前言提到Android的多线程机制，常用的有如下几种方式： AsyncTask: 封装了线程池和Handler，为 UI 线程与工作线程之间进行快速切换提供一种便捷机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。 HandlerThread: 一个已经拥有了Looper的线程类，内部可以直接使用Handler。为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。 ThreadPool: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。 IntentService: 适合于执行由 UI 触发的后台 Service 任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。 尽管Android已经设计了基本的Handler异步消息机制提供给我们进行线程间通信，不过对于频繁得UI更新操作Handler用起来确实有点细碎，为了更加方便我们在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它我们可以非常灵活方便地从子线程切换到UI线程。 我们就从AsyncTask的基本用法开始，一起分析下AsyncTask源码，看看它是如何实现的。 使用AsyncTask由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下： Params：在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。 Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。 Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 一个最简单的自定义AsyncTask就可以写成如下方式： private class MyTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; ... &#125; 然后我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个： onPreExecute()：一般会在UI Thread中执行。用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。 doInBackground(Params…)：这个方法中的所有代码都会在子线程Worker Thread中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress...)方法来完成。 onProgressUpdate(Progress…)：在UI Thread中执行。当在后台任务中调用了publishProgress(Progress...)方法后，这个方法随后就会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。 onPostExecute(Result)：在UI Thread中执行。当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如弹出Toast提醒任务执行的结果，以及关闭掉进度条对话框等。 特别说明！onPreExecute并不保证一定在UI线程中执行！我们稍后源码分析时说明 一个比较完整的自定义AsyncTask就可以写成如下方式： private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123; @Override protected void onPreExecute() &#123; progressDialog.show(); &#125; @Override protected Long doInBackground(URL... urls) &#123; int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) &#123; totalSize += Downloader.downloadFile(urls[i]); //更新进度 publishProgress((int) ((i / (float) count) * 100)); // Escape early if cancel() is called if (isCancelled()) break; &#125; return totalSize; &#125; @Override protected void onProgressUpdate(Integer... progress) &#123; progressDialog.setMessage(\"当前下载进度：\" + progress[0] + \"%\"); &#125; @Override protected void onPostExecute(Long result) &#123; showDialog(\"下载已完成！Downloaded \" + result + \" bytes\"); &#125;&#125; 然后，调用execute()执行任务就可以了： new DownloadFilesTask().execute(url1, url2, url3); 以上就是AsyncTask的基本用法，我们并不需要去考虑什么异步消息处理机制，也不需要专门使用一个Handler来发送和接收消息，只需要调用一下publishProgress()方法就可以轻松地从子线程切换到UI线程了。 AsyncTask源码首先提醒一下大家，该版本分析的代码是Android API 21（对应的Android 5.0）的源码，由于AsyncTask在之前几个版本改动比较大，不过不影响我们分析原理，所以最后我尽量介绍一下区别。 AsyncTask的源码链接：https://github.com/android/platform_frameworks_base/blob/master/core/java/android/os/AsyncTask.java 可以看到AsyncTask开头定义了一些字段，如下所示： private static final String LOG_TAG = \"AsyncTask\";//CPU_COUNT为手机中的CPU核数private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();//线程池的核心线程数private static final int CORE_POOL_SIZE = CPU_COUNT + 1;//线程池的最大线程数private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;//同一时刻只允许1个线程执行private static final int KEEP_ALIVE = 1;//sThreadFactory用于在后面创建线程池private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); //重写newThread方法: 为了将新增线程的名字以\"AsyncTask #\"标识 public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125;&#125;;//实例化阻塞式队列BlockingQueue，队列中存放Runnable，容量为128private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);//根据上面定义的参数实例化线程池public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 通过以上代码和注释我们可以知道，AsyncTask初始化了一些参数，并用这些参数实例化了一个线程池THREAD_POOL_EXECUTOR，需要注意的是该线程池被定义为public static final，由此我们可以看出AsyncTask内部维护了一个静态的线程池，默认情况下，AsyncTask的实际工作就是通过该THREAD_POOL_EXECUTOR完成的。 构造函数我们来看一看AsyncTask的构造函数： public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; private final WorkerRunnable&lt;Params, Result&gt; mWorker; private final FutureTask&lt;Result&gt; mFuture; /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() &#123; //实例化mWorker，实现了Callable接口的call方法 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //在线程池的工作线程中执行doInBackground方法，执行完的结果传递给postResult方法 return postResult(doInBackground(mParams)); &#125; &#125;; //用mWorker实例化mFuture mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occured while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; ...省略其他代码...&#125; 首先我们看到AsyncTask是一个抽象类，所以我们不能直接使用。在构造函数上有一句注释说：AsyncTask的构造函数需要在UI线程上调用，言外之意也就是说我们必须在主线程中new创建AsyncTask对象。 然后构造函数中实际上并没有任何具体的逻辑会得到执行，只是初始化了两个变量，mWorker和mFuture，并在初始化mFuture的时候将mWorker作为参数传入。mWorker是一个Callable对象，mFuture是一个FutureTask对象，这两个变量会暂时保存在内存中，稍后才会用到它们。 mWorker是WorkerRunnable类型的对象，WorkerRunnable是AsyncTask中的一个内部类，代码如下所示： private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams;&#125; mWorker ：上面代码我们可以看到，mWorker其实是一个Callable类型的对象。实例化mWorker，实现了Callable接口的call方法。call方法是在线程池的某个线程中执行的，而不是运行在主线程中。在线程池的工作线程中执行doInBackground方法，执行实际的任务，并返回结果。当doInBackground执行完毕后，将执行完的结果传递给postResult方法。postResult方法我们后面会再讲解。 mFuture ：mFuture是一个FutureTask类型的对象，用mWorker作为参数实例化了mFuture。在这里，其实现了FutureTask的done方法，我们之前提到，当FutureTask的任务执行完成或任务取消的时候会执行FutureTask的done方法。done方法里面的逻辑我们稍后再讲。 这里先详细说一下FutureTask：由于AsyncTask能够取消任务，所以AsyncTask使用了FutureTask以及与其相关的Callable，此处对二者简单进行一下介绍。FutureTask、Callable在Java的并发编程中是比较常见的，可以用来获取任务执行完之后的返回值，也可以取消线程池中的某个任务。Callable是一个接口，其内部定义了call方法，在call方法内需要编写代码执行具体的任务，在这一点上Callable接口与Runnable接口很类似，不过不同的是Runnable的run方法没有返回值，Callable的call方法可以指定返回值。FutureTask类同时实现了Callable接口和Runnable接口，FutureTask的构造函数中需要传入一个Callable对象以对其进行实例化。Executor的execute方法接收一个Runnable对象，由于FutureTask实现了Runnable接口，所以可以把一个FutureTask对象传递给Executor的execute方法去执行。当任务执行完毕的时候会执行FutureTask的done方法，我们可以在这个方法中写一些逻辑处理。在任务执行的过程中，我们也可以随时调用FutureTask的cancel方法取消执行任务，任务取消后也会执行FutureTask的done方法。我们也可以通过FutureTask的get方法阻塞式地等待任务的返回值（即Callable的call方法的返回值），如果任务执行完了就立即返回执行的结果，否则就阻塞式等待call方法的完成。 构造函数我们先分析到这里，关于mWorker这个对象里调用doInBackground()函数的流程我们稍后讲到然后把它们串起来。 execute()方法如果我们想要启动某一个任务，就需要调用该任务的execute()方法，因此现在我们来看一看它的源码： public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: //如果当前AsyncTask已经处于运行状态，那么就抛出异常，不再执行新的任务 throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: //如果当前AsyncTask已经把之前的任务运行完成，那么也抛出异常，不再执行新的任务 throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; //Executor的execute方法接收Runnable参数，由于mFuture是FutureTask的实例， //且FutureTask同时实现了Callable和Runnable接口，所以此处可以让exec执行mFuture exec.execute(mFuture); return this;&#125;public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 可以看到execute()方法调用了executeOnExecutor()方法。 在executeOnExecutor()方法中，我们终于看到它调用了onPreExecute()方法，因此证明了onPreExecute()方法会第一个得到执行。 下面对以上代码进行一下说明： 一个AsyncTask实例执行执行一次任务，当第二次执行任务时就会抛出异常。executeOnExecutor方法一开始就检查AsyncTask的状态是不是PENDING，只有PENDING状态才往下执行，如果是其他状态表明现在正在执行另一个已有的任务或者已经执行完成了一个任务，这种情况下都会抛出异常。 如果开始是PENDING状态，那么就说明该AsyncTask还没执行过任何任务，代码可以继续执行，然后将状态设置为RUNNING，表示开始执行任务。 在真正执行任务前，先调用onPreExecute方法。由于executeOnExecutor方法应该运行在主线程上，所以此处的onPreExecute方法也会运行在主线程上，可以在该方法中做一些UI上的处理操作。 Executor的execute方法接收Runnable参数，由于mFuture是FutureTask的实例，且FutureTask同时实现了Callable和Runnable接口，所以此处可以让exec通过execute方法在执行mFuture。在执行了exec.execute(mFuture)之后，后面会在exec的工作线程中执行mWorker的call方法，我们之前在介绍mWorker的实例化的时候也介绍了call方法内部的执行过程，会首先在工作线程中执行doInBackground方法，并返回结果，然后将结果传递给postResult方法。 最后调用exec.execute(mFuture);去执行真正的任务，此处exec对象就是sDefaultExecutor，可以看到其实是个SerialExecutor对象，源码如下所示： private static class SerialExecutor implements Executor &#123; //mTasks是一个维护Runnable的双端队列，ArrayDeque没有容量限制，其容量可自增长 final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; //execute方法会传入一个Runnable类型的变量r //然后我们会实例化一个Runnable类型的匿名内部类以对r进行封装， //通过队列的offer方法将封装后的Runnable添加到队尾 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; //此处r的run方法是在线程池中执行的 r.run(); &#125; finally &#123; //当前任务执行完毕后，通过调用scheduleNext方法执行下一个Runnable任务 scheduleNext(); &#125; &#125; &#125;); //只有当前没有执行任何任务时，才会立即执行scheduleNext方法 if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; //通过mTasks的poll方法进行出队操作，删除并返回队头的Runnable， //将返回的Runnable赋值给mActive，并将其作为参数传递给THREAD_POOL_EXECUTOR的execute方法进行执行 if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; SerialExecutor实现了Executor接口中的execute方法，该类用于串行执行任务，即一个接一个地执行任务，而不是并行执行任务。 通过以上代码和注释我们可以知道： SerialExecutor实现了Executor接口中的execute方法，该类用于串行执行任务，即一个接一个地执行任务，而不是并行执行任务。 SerialExecutor内部维护了一个存放Runnable的双端队列mTasks。当执行SerialExecutor的execute方法时，会传入一个Runnable变量r，但是mTasks并不直接存储r，而是又新new了一个匿名Runnable对象，其内部会调用r，这样就对r进行了封装，将该封装后的Runnable对象通过队列的offer方法入队，添加到mTasks的队尾。 SerialExecutor内部通过mActive存储着当前正在执行的任务Runnable。当执行SerialExecutor的execute方法时，首先会向mTasks的队尾添加进一个Runnable。然后判断如果mActive为null，即当前没有任务Runnable正在运行，那么就会执行scheduleNext()方法。当执行scheduleNext方法的时候，会首先从mTasks中通过poll方法出队，删除并返回队头的Runnable，将返回的Runnable赋值给mActive，如果不为空，那么就让将其作为参数传递给THREAD_POOL_EXECUTOR的execute方法进行执行。由此，我们可以看出SerialExecutor实际上是通过之前定义的线程池THREAD_POOL_EXECUTOR进行实际的处理的。 当将mTasks中的Runnable作为参数传递给THREAD_POOL_EXECUTOR执行execute方法时，会在线程池的工作线程中执行匿名内部类Runnable中的try-finally代码段，即先在工作线程中执行r.run()方法去执行任务，无论任务r正常完成还是抛出异常，都会在finally中执行scheduleNext方法，用于执行mTasks中的下一个任务。从而在此处我们可以看出SerialExecutor是一个接一个执行任务，是串行执行任务，而不是并行执行。 我们看SerialExecutor最终执行的是r.run()，那这里的r是什么呢？就是execute方法中的exec.execute(mFuture)中的参数mFuture。也就是最终执行了mFuture这个FutureTask对象的run()方法，我们进入看看FutureTask类中的run()方法： //FutureTask的构造函数public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); //此处的callable就是接收的mWorker对象 this.callable = callable; this.state = NEW;&#125;public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; //核心是调用了callable（也就是mWorker）的call方法 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 可以看到核心代码是调用了callable对象（也就是mWorker）的call方法。所以我们回头看看构造函数中的mWorker对象。 执行任务 - 调用doInBackground()我们前面知道，Executor的execute方法接收Runnable参数，由于mFuture是FutureTask的实例，且FutureTask同时实现了Callable和Runnable接口，所以此处可以让exec通过execute方法在执行mFuture。在执行了exec.execute(mFuture)之后，后面会在exec的工作线程中执行mWorker的call方法，我们之前在构造函数中介绍mWorker的实例化的时候也介绍了call方法内部的执行过程，会首先在工作线程中执行doInBackground方法，并返回结果，然后将结果传递给postResult方法。 我们回过头看看构造函数中mWorker这个任务对象，在构造函数中的mWorker定义如下： mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); &#125;&#125;; 我们看最后这句postResult(doInBackground(mParams));，它会调用我们的doInBackground()函数执行任务，并把结果发送给postResult()方法，我们跟进去看： private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125;private static final InternalHandler sHandler = new InternalHandler(); 它使用sHandler对象发出了一条消息，InternalHandler创建一个Message Code为MESSAGE_POST_RESULT的Message，此处还将doInBackground返回的result通过new AsyncTaskResult&lt;Result&gt;(this, result)封装成了AsyncTaskResult，将其作为message的obj属性。 AsyncTaskResult是AsyncTask的一个内部类，其代码如下所示： private static class AsyncTaskResult&lt;Data&gt; &#123; //mTask表示当前AsyncTaskResult是哪个AsyncTask的结果 final AsyncTask mTask; //mData表示其存储的数据 final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 在构建了message对象后，通过message.sendToTarget()将该message发送给sHandler，之后sHandler的handleMessage方法会接收并处理该message，这个sHandler对象是InternalHandler类的一个实例，InternalHandler的源码如下所示： private static class InternalHandler extends Handler &#123; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; msg.obj是AsyncTaskResult类型，result.mTask表示当前AsyncTaskResult所绑定的AsyncTask。result.mData[0]表示的是doInBackground所返回的处理结果。将该结果传递给AsyncTask的finish方法，finish代码如下所示： private void finish(Result result) &#123; if (isCancelled()) &#123; //如果任务被取消了，那么执行onCancelled方法 onCancelled(result); &#125; else &#123; //将结果发传递给onPostExecute方法 onPostExecute(result); &#125; //最后将AsyncTask的状态设置为完成状态 mStatus = Status.FINISHED;&#125; finish方法内部会首先判断AsyncTask是否被取消了，如果被取消了执行onCancelled(result)，否则执行onPostExecute(result)方法。需要注意的是InternalHandler是指向主线程的，所以其handleMessage方法是在主线程中执行的，从而此处的finish方法也是在主线程中执行的，进而onPostExecute也是在主线程中执行的。 我们知道，在doInBackground方法中是在工作线程中执行比较耗时的操作，这个操作时间可能比较长，而我们的任务有可能分成多个部分，每当我完成其中的一部分任务时，我们可以在doInBackground中多次调用AsyncTask的publishProgress方法，将阶段性数据发布出去。 publishProgress方法代码如下所示： protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; sHandler.obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 可以看到最后发送了一条MESSAGE_POST_PROGRESS的Message给sHandler，到sHandler的代码中，我们能看到它调用了onProgressUpdate()这个方法，也就是我们使用示例当中的进度条更新函数。 最后，AsyncTask无论任务完成还是取消任务，FutureTask都会执行done方法，如下所示： mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; //任务执行完毕或取消任务都会执行done方法 try &#123; //任务正常执行完成 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; //任务出现中断异常 android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; //任务执行出现异常 throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; //任务取消 postResultIfNotInvoked(null); &#125; &#125;&#125;; 无论任务正常执行完成还是任务取消，都会执行postResultIfNotInvoked方法。postResultIfNotInvoked代码如下所示： private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; //只有mWorker的call没有被调用才会执行postResult方法 postResult(result); &#125;&#125; 如果AsyncTask正常执行完成的时候，call方法都执行完了，mTaskInvoked设置为true，并且在call方法中最后执行了postResult方法，然后进入mFuture的done方法，然后进入postResultIfNotInvoked方法，由于mTaskInvoked已经执行，所以不会执行再执行postResult方法。 如果在调用了AsyncTask的execute方法后立马就执行了AsyncTask的cancel方法（实际执行mFuture的cancel方法），那么会执行done方法，且捕获到CancellationException异常，从而执行语句postResultIfNotInvoked(null)，由于此时还没有来得及执行mWorker的call方法，所以mTaskInvoked还未false，这样就可以把null传递给postResult方法。 到这里，AsyncTask中的细节基本上就分析完了。 注意事项在Google官方文档里有这么一段： Threading rules There are a few threading rules that must be followed for this class to work properly: The AsyncTask class must be loaded on the UI thread. This is done automatically as of JELLY_BEAN. The task instance must be created on the UI thread. execute(Params...) must be invoked on the UI thread. Do not call onPreExecute(), onPostExecute(Result), doInBackground(Params...), onProgressUpdate(Progress...) manually. The task can be executed only once (an exception will be thrown if a second execution is attempted. 翻译过来就是： AsyncTask必须在UI主线程中创建（new）； execute(Params...)函数必须在UI线程中调用； 不要手动调用 onPreExecute(), onPostExecute(Result), doInBackground(Params...), onProgressUpdate(Progress...) 这些方法。 每个AsyncTask任务只能被执行一次； 大家注意到了吗，AsyncTask必须在UI主线程中创建（new），execute(Params...)函数必须在UI线程中调用。也就是说这个要求Google并没有在framework层实现强制约束，而是给了口头上的一种编码约定（结合源码我们也能看到源码中也没有这样的机制保证）。这也就可能会引发我们开头那个问题： onPreExecute并不保证一定在UI线程中执行！而是由execute(Params...)函数在哪个线程中调用决定的！ 比如stackoverflow上的这个问题：Android: AsyncTask onPreExecute() method is NOT executed in UI thread - stackoverflow。就是在子线程中调用了execute(Params...)函数。所以为了避免这样的问题，我们一定要遵守上面那几条官方约定。 一些版本变化在Android 3.0之前是并没有SerialExecutor这个类的，那个时候是直接在AsyncTask中构建了一个sExecutor常量，并对线程池总大小，同一时刻能够运行的线程数做了规定，比如Android Froyo 2.2.3版本的源码如下所示： public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; private static final String LOG_TAG = \"AsyncTask\"; //线程池大小 private static final int CORE_POOL_SIZE = 5; private static final int MAXIMUM_POOL_SIZE = 128; private static final int KEEP_ALIVE = 10; private static final BlockingQueue&lt;Runnable&gt; sWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(10); private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125; &#125;; private static final ThreadPoolExecutor sExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory); private static final int MESSAGE_POST_RESULT = 0x1; private static final int MESSAGE_POST_PROGRESS = 0x2; private static final int MESSAGE_POST_CANCEL = 0x3; private static final InternalHandler sHandler = new InternalHandler(); private final WorkerRunnable&lt;Params, Result&gt; mWorker; private final FutureTask&lt;Result&gt; mFuture; private volatile Status mStatus = Status.PENDING; ...省略其他代码...&#125; 可以看到，这里规定同一时刻能够运行的线程数为5个，线程池总大小为128。也就是说当我们启动了10个任务时，只有5个任务能够立刻执行，另外的5个任务则需要等待，当有一个任务执行完毕后，第6个任务才会启动，以此类推。而线程池中最大能存放的线程数是128个，当我们尝试去添加第129个任务时，程序就会崩溃。 而到了Android Gingerbread 2.3.6版本，把同一时刻的5个并发线程改成了同一时刻只有一个线程的串行执行，代码如下：public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; private static final String LOG_TAG = \"AsyncTask\"; private static final int CORE_POOL_SIZE = 5; private static final int MAXIMUM_POOL_SIZE = 128; //注意这里 private static final int KEEP_ALIVE = 1; private static final BlockingQueue&lt;Runnable&gt; sWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(10); private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125; &#125;; private static final ThreadPoolExecutor sExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory); private static final int MESSAGE_POST_RESULT = 0x1; private static final int MESSAGE_POST_PROGRESS = 0x2; private static final int MESSAGE_POST_CANCEL = 0x3; private static final InternalHandler sHandler = new InternalHandler(); private final WorkerRunnable&lt;Params, Result&gt; mWorker; private final FutureTask&lt;Result&gt; mFuture; private volatile Status mStatus = Status.PENDING; ...省略其他代码...&#125; 总结 AsyncTask的底层其实是对Thread、Handler、Message的封装，智能的应用了Handler。 因为AsyncTask里面的内部handler和Executor都是静态变量，所以他们控制着所有的子类。 如果不想使用默认的线程池，可以使用executeOnExecutor()函数自由地进行配置而不是execute()。因为用系统默认的线程池因为串行执行可能需要等待（SerialExecutor）。自己使用自定义线程池方式如下： Executor exec = new ThreadPoolExecutor(15, 200, 10, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); new DownloadTask().executeOnExecutor(exec); AsyncTask适合处理短时间的操作。长时间的操作，比如下载一个很大的视频，这就需要你使用自己的线程来下载，不管是断点下载还是其它的。从google官方文档你也可以看到，AsyncTasks should ideally be used for short operations (a few seconds at the most.) 不要随意使用AsyncTask,除非你必须要与UI线程交互。默认情况下使用Thread即可，要注意需要将线程优先级调低。 Android3.0之前，异步任务是并发执行的，即几个任务同时切换执行，3.0之后，异步任务改成了顺序执行，即任务队列中的任务要一个个执行（并非按顺序），一个执行不完，不能执行另一个，即顺序执行，他是默认的执行方式execue()方法，其默认执行的方法是：executeOnExecutor(AsyncTask.SERIAL_EXECUTOR)，如果要并发执行，需要执行AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)，且为了防止系统的任务繁重，只在线程池中维护了5个线程，也就是，每次最多跑5个任务（类似于迅雷下载）。如果需要并发更多的任务，需要自定义线程池了。所以异步任务只适合处理一些轻量级的并随时修改UI的异步线程，如果遇到繁重的任务，最好自己新建一个Thread并用handler和looper机制处理。 参考资料 Android AsyncTask完全解析，带你从源码的角度彻底理解 源码解析Android中AsyncTask的工作原理 - 孙群 Android性能优化典范之多线程篇 - 腾讯Bugly Android: AsyncTask onPreExecute() method is NOT executed in UI thread - stackoverflow AsyncTask - Google Android Developers","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://github.com/tags/源码分析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】源码分析 - IntentService机制","slug":"【Android】源码分析 - IntentService机制","date":"2017-10-05T08:03:00.000Z","updated":"2017-10-26T06:36:13.256Z","comments":true,"path":"2017/10/05/【Android】源码分析 - IntentService机制/","link":"","permalink":"http://github.com/2017/10/05/【Android】源码分析 - IntentService机制/","excerpt":"前言提到Android的多线程机制，除了我们常用的Thread来实现异步任务之外，还有 AsyncTask：封装了线程池和Handler，主要为了子线程更新UI； HandlerThread：一个已经拥有了Looper的线程类，内部可以直接使用Handler； IntentService：一个内部采用HandlerThread来执行任务的Service服务，任务执行完毕后会自动退出； 今天我们来根据平时的使用方式来分析一下第三个IntentSevice到底是什么怎么实现的？ IntentService的使用IntentService继承了Service并且它本身是一个抽象类，因此使用它必须创建它的子类才能使用。所以这里我们自定义一个MyIntentService，来处理异步任务： public class MyIntentService extends IntentService &#123; private static final String TAG = \"MyIntentService\"; private boolean isRunning = true; private int count = 0; public MyIntentService() &#123; super(\"MyIntentService\"); &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override protected void onHandleIntent(Intent intent) &#123; try &#123; //查看线程id Log.i(TAG, intent.getStringExtra(\"params\") + \", 线程id:\" + Thread.currentThread().getId()); Thread.sleep(1000); //从0-100渐增 isRunning = true; count = 0; while (isRunning) &#123; count++; Log.i(TAG, \"MyIntentService 线程运行中...\" + count); if (count &gt;= 100) &#123; isRunning = false; &#125; Thread.sleep(50); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125;","text":"前言提到Android的多线程机制，除了我们常用的Thread来实现异步任务之外，还有 AsyncTask：封装了线程池和Handler，主要为了子线程更新UI； HandlerThread：一个已经拥有了Looper的线程类，内部可以直接使用Handler； IntentService：一个内部采用HandlerThread来执行任务的Service服务，任务执行完毕后会自动退出； 今天我们来根据平时的使用方式来分析一下第三个IntentSevice到底是什么怎么实现的？ IntentService的使用IntentService继承了Service并且它本身是一个抽象类，因此使用它必须创建它的子类才能使用。所以这里我们自定义一个MyIntentService，来处理异步任务： public class MyIntentService extends IntentService &#123; private static final String TAG = \"MyIntentService\"; private boolean isRunning = true; private int count = 0; public MyIntentService() &#123; super(\"MyIntentService\"); &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override protected void onHandleIntent(Intent intent) &#123; try &#123; //查看线程id Log.i(TAG, intent.getStringExtra(\"params\") + \", 线程id:\" + Thread.currentThread().getId()); Thread.sleep(1000); //从0-100渐增 isRunning = true; count = 0; while (isRunning) &#123; count++; Log.i(TAG, \"MyIntentService 线程运行中...\" + count); if (count &gt;= 100) &#123; isRunning = false; &#125; Thread.sleep(50); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 然后启动服务之前别忘了在manifest文件中注册这个Service： // 在 Manifest 中注册服务&lt;service android:name=\".service.MyIntentService\"/&gt; 最后是启动服务，就和普通Service一样启动：// 像启动 Service 那样启动 IntentServiceIntent intent= new Intent(getActivity(), MyIntentService.class);intent.putExtra(\"params\", \"testString...\");getActivity().startService(intent); 到此，通过IntentService执行的异步任务已经开始执行了，当执行完毕之后它会自动停止而不用我们手动操作。 当这个MyIntentService启动之后，我们看到它接收到了消息并打印出了传递过去的intent参数，同时显示onHandlerIntent方法执行的线程ID并非主线程，也就是说它果真开了一个额外的线程，什么时候开启的呢？我们进入IntentService源码看看。 IntentService源码//IntentService继承了Service并且它本身是一个抽象类，因此使用它必须创建它的子类才能使用。public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。 onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 代码还是相当的简洁的，首先通过定义我们可以知道IntentService是一个Service，并且是一个抽象类，所以我们在继承IntentService的时候需要实现其抽象方法：onHandlerIntent。 1. 启动 IntentService 为什么不需要新建线程？我们来看看它的onCreate()函数： private volatile ServiceHandler mServiceHandler;@Overridepublic void onCreate() &#123; super.onCreate(); // HandlerThread 继承自 Thread，内部封装了 Looper，在这里新建线程并启动，所以启动 IntentService 不需要新建线程。 HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\"); thread.start(); // 获得工作线程的 Looper，并维护自己的消息队列MessageQueue mServiceLooper = thread.getLooper(); // mServiceHandler 是属于这个工作线程的 mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 我们可以发现其内部定义一个HandlerThread（本质上是一个含有消息队列的线程）。然后用成员变量维护其Looper和Handler，由于其Handler（也就是mServiceHandler对象）关联着这个HandlerThread的Looper对象，所以这个ServiceHandler的handleMessage方法在HandlerThread线程中执行。 然后我们发现其onStartCommand方法就是调用的其onStart方法，具体看一下其onStart方法： @Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; 很简单就是将startId和启动时接受到的intent对象传递到ServiceHandler的消息队列中处理，那么我们具体看一下ServiceHandler的处理逻辑： private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。 onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125; 可以看到起handleMessage方法内部执行了两个逻辑： 一个是调用了其onHandlerIntent()抽象方法，在子线程中执行。 二是调用了stopSelf()方法，这里需要注意的是stopSelf方法传递了msg.arg1参数，从刚刚的onStart方法我们可以知道我们传递了startId，这是由于service可以启动多次，可以传递N次消息，当IntentService的消息队列中含有消息时调用stopSelf(startId)并不会立即stop自己，只有当消息队列中最后一个消息被执行完成时才会真正的stop自身。 2. 为什么不建议通过 bindService() 启动 IntentService？我们看IntentService的onBind()方法： @Overridepublic IBinder onBind(Intent intent) &#123; return null;&#125; IntentService 源码中的 onBind() 默认返回 null，不适合 bindService() 启动服务，如果你执意要 bindService() 来启动 IntentService，可能因为你想通过 Binder 或 Messenger 使得 IntentService 和 Activity 可以通信，这样 onHandleIntent() 就不会被回调，相当于在你使用 Service 而不是 IntentService。 总结IntentService 是继承自 Service 并处理异步请求的一个抽象类，在 IntentService 内有一个工作线程来处理耗时操作，当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，依次去执行，执行完自动结束。 IntentService有以下特点： 1）. 它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents。2）. 创建了一个工作队列，来逐个发送intent给onHandleIntent()。3）. 不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。4）. 默认实现的onBind()返回null5）. 默认实现的onStartCommand()的目的是将intent插入到工作队列中 继承IntentService的类至少要实现两个函数：构造函数和onHandleIntent()函数。要覆盖IntentService的其它函数时，注意要通过super调用父类的对应的函数。 参考资料 Android源码解析之（五）–&gt;IntentService IntentService 示例与详解","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://github.com/tags/源码分析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】EventBus 3.0 源码分析","slug":"【Android】EventBus 3.0源码分析","date":"2017-09-30T14:03:00.000Z","updated":"2017-12-01T03:30:44.605Z","comments":true,"path":"2017/09/30/【Android】EventBus 3.0源码分析/","link":"","permalink":"http://github.com/2017/09/30/【Android】EventBus 3.0源码分析/","excerpt":"概述EventBus是Android中一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，主要功能是替代Intent，Handler，BroadCast 在 Fragment，Activity，Service，线程Thread之间传递消息。优点是开销小，使用方便，可以很大程度上降低它们之间的耦合。 类似的库还有Otto ，今天就带大家一起研读 EventBus 的源码。 这是EventBus源码中的介绍： /** * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;@link #post(Object)&#125;) to the * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events, * subscribers must register themselves to the bus using &#123;@link #register(Object)&#125;. Once registered, subscribers * receive events until &#123;@link #unregister(Object)&#125; is called. Event handling methods must be annotated by * &#123;@link Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter * (the event). * * @author Markus Junginger, greenrobot */ EventBus 是Android上的以发布\\订阅事件为核心的库。事件 (event) 通过 post() 发送到总线，然后再分发到匹配事件类型的订阅者 (subscribers) 。订阅者只有在总线中注册 (register) 了才能收到事件，注销 (unrigister) 之后就收不到任何事件了。事件方法必须带有 Subscribe 的注解，必须是 public ，没有返回类型 void 并且只能有一个参数。 EventBus3 与之前的相比，其主要差别在于订阅方法可以不再以onEvent 开头了，改为用注解。","text":"概述EventBus是Android中一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，主要功能是替代Intent，Handler，BroadCast 在 Fragment，Activity，Service，线程Thread之间传递消息。优点是开销小，使用方便，可以很大程度上降低它们之间的耦合。 类似的库还有Otto ，今天就带大家一起研读 EventBus 的源码。 这是EventBus源码中的介绍： /** * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;@link #post(Object)&#125;) to the * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events, * subscribers must register themselves to the bus using &#123;@link #register(Object)&#125;. Once registered, subscribers * receive events until &#123;@link #unregister(Object)&#125; is called. Event handling methods must be annotated by * &#123;@link Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter * (the event). * * @author Markus Junginger, greenrobot */ EventBus 是Android上的以发布\\订阅事件为核心的库。事件 (event) 通过 post() 发送到总线，然后再分发到匹配事件类型的订阅者 (subscribers) 。订阅者只有在总线中注册 (register) 了才能收到事件，注销 (unrigister) 之后就收不到任何事件了。事件方法必须带有 Subscribe 的注解，必须是 public ，没有返回类型 void 并且只能有一个参数。 EventBus3 与之前的相比，其主要差别在于订阅方法可以不再以onEvent 开头了，改为用注解。 一、使用EventBus 在Gradle中添加依赖 compile 'org.greenrobot:eventbus:3.0.0' 1.1 初始化EventBus默认有一个单例，可以通过getDefault()获取，也可以通过EventBus.builder()构造自定义的EventBus，比如要应用我们生成好的索引时： EventBus mEventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build(); 如果想把自定义的设置应用到EventBus默认的单例中，则可以用installDefaultEventBus()方法： EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus(); 1.2 定义事件所有能被实例化为Object的实例都可以作为事件： public class MessageEvent &#123; public final String message; public MessageEvent(String message) &#123; this.message = message; &#125;&#125; 在最新版的eventbus 3中如果用到了索引加速，事件类的修饰符必须为public，不然编译时会报错：Subscriber method must be public。 1.3 监听事件订阅者需要在总线上注册和注销自己。只有当订阅者注册了才能接收到事件。在Android中，通常与 Activity 和 Fragment 的生命周期绑定在一起。 之前2.x版本中有四种注册方法，区分了普通注册和粘性事件注册，并且在注册时可以选择接收事件的优先级，这里我们就不对2.x版本做过多的研究了。由于3.0版本将粘性事件以及订阅事件的优先级换成了注解的实现方式，所以3.0版本中的注册就变得简单，只有一个register()方法即可。 //3.0版本的注册EventBus.getDefault().register(this); //2.x版本的四种注册方法EventBus.getDefault().register(this);EventBus.getDefault().register(this, 100);EventBus.getDefault().registerSticky(this);EventBus.getDefault().registerSticky(this, 100); 当我们不在需要接收事件的时候需要解除注册unregister，2.x和3.0的解除注册也是相同的。代码如下: //取消注册EventBus.getDefault().unregister(this); 接收到消息之后的处理方式，在2.x版本中，注册这些消息的监听需要区分是否监听黏性（sticky）事件，监听EventBus事件的模块需要实现以onEvent开头的方法。如今3.0改为在方法上添加注解的形式： //3.0版本@Subscribe(threadMode = ThreadMode.POSTING, priority = 0, sticky = true)public void handleEvent(DriverEvent event) &#123; Log.d(TAG, event.info);&#125;//2.x版本public void onEvent(String str) &#123;&#125;public void onEventMainThread(String str) &#123;&#125;public void onEventBackgroundThread(String str) &#123;&#125; 在2.x版本中只有通过onEvent开头的方法会被注册，而且响应事件方法触发的线程通过onEventMainThread或onEventBackgroundThread这些方法名区分，而在3.0版本中，通过@Subscribe注解，来确定运行的线程threadMode，是否接受粘性事件sticky以及事件优先级priority，而且方法名不在需要onEvent开头，所以又简洁灵活了不少。 我们可以看到注解@Subscribe有三个参数，threadMode为回调所在的线程，priority为优先级，sticky为是否接收黏性事件。调度单位从类细化到了方法，对方法的命名也没有了要求，方便混淆代码。但注册了监听的模块必须有一个标注了Subscribe注解方法，不然在register时会抛出异常： Subscriber class XXX and its super classes have no public methods with the @Subscribe annotation 1.4 发送事件可以从代码的任何地方调用post或者postSticky发送事件，此时注册了的且匹配事件的订阅者能够接收到事件。 EventBus.getDefault().post(new MessageEvent(\"Hello everyone!\")); 在实际项目的使用中，register和unregister通常与Activity和Fragment的生命周期相关，ThreadMode.MainThread可以很好地解决Android的界面刷新必须在UI线程的问题，不需要再回调后用Handler中转（EventBus中已经自动用Handler做了处理），黏性事件可以很好地解决post与register同时执行时的异步问题（这个在原理中会说到），事件的传递也没有序列化与反序列化的性能消耗，足以满足我们大部分情况下的模块间通信需求。 二、EventBus源码跟踪我们通过EventBus的使用流程来跟踪分析它的调用流程，通过我们熟悉的使用方法来深入到EventBus的实现内部并理解它的实现原理。 2.1 创建EventBus对象先看看 getDefault() : static volatile EventBus defaultInstance;/** Convenience singleton for apps using a process-wide EventBus instance. */public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; 这里就是设计模式里我们常用的单例模式，用到了double check。保证了getDefault()得到的都是同一个实例。如果不存在实例，就调用了EventBus的构造方法: /** * 构造函数可以创建多个不同的EventBus，不同的实例之间可以相互隔离，如果只想使用同一个总线，就直接使用getDefault()方法获取单例 * * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a * central bus, consider &#123;@link #getDefault()&#125;. */public EventBus() &#123; this(DEFAULT_BUILDER);&#125;EventBus(EventBusBuilder builder) &#123; //key:订阅的事件,value:订阅这个事件的所有订阅者集合 //private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; subscriptionsByEventType = new HashMap&lt;&gt;(); //key:订阅者对象,value:这个订阅者订阅的事件集合 //private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; typesBySubscriber = new HashMap&lt;&gt;(); //粘性事件 key:粘性事件的class对象, value:事件对象 //private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents; stickyEvents = new ConcurrentHashMap&lt;&gt;(); //事件主线程处理 mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); //事件 Background 处理 backgroundPoster = new BackgroundPoster(this); //事件异步线程处理 asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; //订阅者响应函数信息存储和查找类 subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; //是否支持事件继承 eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125; 什么，既然是单例模式构造函数还是 public ？没错，这样的设计是因为不仅仅可以只有一条总线，还可以有其他的线 (bus) ，订阅者可以注册到不同的线上的 EventBus，通过不同的 EventBus 实例来发送数据，不同的 EventBus 是相互隔离开的，订阅者都只会收到注册到该线上事件。 然后我们说一下构造函数里这三个 HasMap。 subscriptionsByEventType 是以 event 为 key，subscriber列表 为 value，当发送 event 的时候，都是去这里找对应的订阅者。 typesBySubscriber 是以 subscriber 为 key，event列表为 value，当 register() 和 unregister() 的时候都是操作这个map，同时对 subscriptionsByEventType 进行对用操作。 stickyEvents 维护的是粘性事件，粘性事件也就是当 event 发送出去之后再注册粘性事件的话，该粘性事件也能收到之前发送出去的 event。 同时构造函数中还创建了 3 个 poster ：HandlerPoster ，BackgroundPoster和AsyncPoster，这 3 个 poster 负责线程间调度，稍后的事件分发模块我们会详细讲到。我们接着看这个构造函数中，最终运用到了builder设计模式，那么来看看这个 EventBusBuilder 中有哪些参数： public class EventBusBuilder &#123; //线程池 private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool(); //当调用事件处理函数异常时是否打印异常信息 boolean logSubscriberExceptions = true; //当没有订阅者订阅该事件时是否打印日志 boolean logNoSubscriberMessages = true; //当调用事件处理函数异常时是否发送 SubscriberExceptionEvent 事件 boolean sendSubscriberExceptionEvent = true; //当没有事件处理函数对事件处理时是否发送 NoSubscriberEvent 事件 boolean sendNoSubscriberEvent = true; //是否要抛出异常，建议debug开启 boolean throwSubscriberException; //与event有继承关系的类是否需要发送 boolean eventInheritance = true; //是否忽略生成的索引(SubscriberInfoIndex) boolean ignoreGeneratedIndex; //是否严格的方法名校验 boolean strictMethodVerification; //线程池，async 和 background 的事件会用到 ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE; //当注册的时候会进行方法名的校验(EventBus3之前方法名必须以onEvent开头)，而这个列表是不参加校验的类的列表(EventBus3之后就没用这个参数了) List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses; //维护着由EventBus生成的索引(SubscriberInfoIndex) List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes; EventBusBuilder() &#123; &#125; //赋值buidler(可用户自定义的)给单例的EventBus，如果单例的EventBus不为null了，则抛出异常 public EventBus installDefaultEventBus() &#123; synchronized (EventBus.class) &#123; if (EventBus.defaultInstance != null) &#123; throw new EventBusException(\"Default instance already exists.\" + \" It may be only set once before it's used the first time to ensure consistent behavior.\"); &#125; EventBus.defaultInstance = build(); return EventBus.defaultInstance; &#125; &#125; public EventBus build() &#123; return new EventBus(this); &#125; //...省略其他代码...&#125; 可以看出是通过初始化了一个EventBusBuilder()对象来分别初始化EventBus的一些配置，注释里我标注了大部分比较重要的对象，这里没必要记住，看下面的文章时如果对某个对象不了解，可以再回来看看。 2.2 注册与订阅RegisterEventBus 3.0的注册入口只提供一个register()方法了，所以我们先来看看register()方法做了什么： public void register(Object subscriber) &#123; //首先获得订阅者的class对象 Class&lt;?&gt; subscriberClass = subscriber.getClass(); //通过subscriberMethodFinder来找到订阅者订阅了哪些事件.返回一个SubscriberMethod对象的List List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; //订阅 subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 可以看到register()方法很简洁，代码里的注释也很清楚了，我们可以看出通过subscriberMethodFinder.findSubscriberMethods(subscriberClass)方法就能返回一个SubscriberMethod的对象，而SubscriberMethod里包含了所有我们需要的接下来执行subscribe()的信息。 那 SubscriberMethod里包含了什么呢？下面是它的变量和构造函数。可以看到里面包括订阅类里的具体执行方法Method对象，需要在哪个线程执行ThreadMode，事件类型eventType，优先级priority，以及是否接收粘性sticky事件。 public class SubscriberMethod &#123; final Method method; //具体的执行方法 final ThreadMode threadMode; //执行线程 final Class&lt;?&gt; eventType; //事件类型，也就是执行方法接受的参数类型 final int priority; //优先级 final boolean sticky; //是否粘性，之后会讲到 /** Used for efficient comparison */ String methodString; public SubscriberMethod(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, int priority, boolean sticky) &#123; this.method = method; this.threadMode = threadMode; this.eventType = eventType; this.priority = priority; this.sticky = sticky; &#125; //...省略其他代码...&#125; 然后我们去看看SubscriberMethodFinder类的findSubscriberMethods()是怎么找到订阅方法的，最后我们再去关注subscribe()。 SubscriberMethodFinder的实现 从字面理解，这个类就是订阅者方法发现者。一句话来描述SubscriberMethodFinder类就是用来查找和缓存订阅者响应函数的信息的类。所以我们首先要知道怎么能获得订阅者响应函数的相关信息。在3.0版本中，EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析，处理其中所包含的信息，然后生成java类来保存所有订阅者关于订阅的信息，这样就比在运行时使用反射来获得这些订阅者的信息速度要快。我们可以参考EventBus项目里的EventBusPerformance这个例子，编译后我们可以在build文件夹里找到这个类，MyEventBusIndex 类，当然类名是可以自定义的。我们大致看一下生成的MyEventBusIndex类是什么样的: /** * This class is generated by EventBus, do not edit. */public class MyEventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); putIndex(new SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class, true, new SubscriberMethodInfo[]&#123; new SubscriberMethodInfo(\"onEventAsync\", TestEvent.class, ThreadMode.ASYNC), &#125;)); putIndex(new SimpleSubscriberInfo(TestRunnerActivity.class, true, new SubscriberMethodInfo[]&#123; new SubscriberMethodInfo(\"onEventMainThread\", TestFinishedEvent.class, ThreadMode.MAIN), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; 可以看出是使用一个静态HashMap即：SUBSCRIBER_INDEX来保存订阅类的信息，其中包括了订阅类的class对象，是否需要检查父类，以及订阅方法的信息SubscriberMethodInfo的数组，SubscriberMethodInfo中又保存了，订阅方法的方法名，订阅的事件类型，触发线程，是否接收sticky事件以及优先级priority。这其中就保存了register()的所有需要的信息，如果再配置EventBus的时候通过EventBusBuilder配置：eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();来将编译生成的MyEventBusIndex配置进去，这样就能在SubscriberMethodFinder类中直接查找出订阅类的信息，就不需要再利用注解判断了，当然这种方法是作为EventBus的可选配置，SubscriberMethodFinder同样提供了通过注解来获得订阅类信息的方法，下面我们就来看findSubscriberMethods()到底是如何实现的： List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //先从METHOD_CACHE取看是否有缓存, key:保存订阅类的类名,value:保存类中订阅的方法数据, List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //是否忽略注解器生成的MyEventBusIndex类 if (ignoreGeneratedIndex) &#123; //利用反射来读取订阅类中的订阅方法信息 subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(\"Subscriber \" + subscriberClass + \" and its super classes have no public methods with the @Subscribe annotation\"); &#125; else &#123; //保存进METHOD_CACHE缓存 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; 我们看看利用反射来读取订阅类中的订阅方法信息的函数：findUsingReflection() private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; //FindState 用来做订阅方法的校验和保存 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //通过反射来获得订阅方法信息 findUsingReflectionInSingleClass(findState); //查找父类的订阅方法 findState.moveToSuperclass(); &#125; //获取findState中的SubscriberMethod(也就是订阅方法List)并返回 return getMethodsAndRelease(findState);&#125; 以及从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息： findUsingInfo()：private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //得到订阅者信息 findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; //遍历订阅者方法 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //如果没有订阅者信息就使用反射查找订阅方法 findUsingReflectionInSingleClass(findState); &#125; //跳转到父类中继续查找 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; 进入到getSubscriberInfo() 方法中我们看到了从自定义索引Index获取订阅方法信息的操作： private SubscriberInfo getSubscriberInfo(FindState findState) &#123; //判断FindState对象中是否有缓存的订阅方法 if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; //从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息 if (subscriberInfoIndexes != null) &#123; for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null;&#125; 上面我们可以看到作者使用了FindState类来做订阅方法的校验和保存，并通过FIND_STATE_POOL静态数组来保存FindState对象，可以使FindState复用，避免重复创建过多的对象。最终是通过findUsingReflectionInSingleClass()来具体获得相关订阅方法的信息的： //在较新的类文件，编译器可能会添加方法。那些被称为BRIDGE或SYNTHETIC方法。EventBus必须忽略两者。有修饰符没有公开，但在Java类文件中有格式定义private static final int BRIDGE = 0x40;private static final int SYNTHETIC = 0x1000;//需要忽略的修饰符private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; //通过反射得到方法数组 try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; //遍历Method for (Method method : methods) &#123; int modifiers = method.getModifiers(); //必须是public的方法 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //保证必须只有一个事件参数 if (parameterTypes.length == 1) &#123; //得到注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; //校验是否添加该方法 if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); //实例化SubscriberMethod对象并添加 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(\"@Subscribe method \" + methodName + \"must have exactly 1 parameter but has \" + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(methodName + \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\"); &#125; &#125;&#125; 关于 BRIDGE 和 SYNTHETIC ，注释写道： In newer class files, compilers may add methods. Those are called bridge or synthetic methods. EventBus must ignore both. There modifiers are not public but defined in the Java class file format: http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1 在较新的类文件，编译器可能会添加方法。那些被称为 BRIDGE 或 SYNTHETIC 方法，EventBus 必须忽略两者。有修饰符没有公开，但在 Java 类文件中有格式定义。 该findUsingReflectionInSingleClass方法流程是： 拿到当前 class 的所有方法； 过滤掉不是 public 和是 abstract、static、bridge、synthetic 的方法； 过滤出方法参数只有一个的方法； 过滤出被Subscribe注解修饰的方法； 将 method 方法和 event 事件添加到 findState 中； 将 EventBus 关心的 method 方法、event 事件、threadMode、priority、sticky 封装成 SubscriberMethod 对象添加到 findState.subscriberMethods 列表中； 这里走完，我们订阅类的所有SubscriberMethod都已经被保存了，最后再通过getMethodsAndRelease()返回List&lt;SubscriberMethod&gt;。至此，所有关于如何获得订阅类的订阅方法信息即：SubscriberMethod对象就已经完全分析完了，下面我们来看subscribe()是如何实现的。 subscribe()方法的实现 //必须在同步代码块里调用private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; //获取订阅的事件类型 Class&lt;?&gt; eventType = subscriberMethod.eventType; //创建Subscription对象 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //从subscriptionsByEventType里检查是否已经添加过该Subscription,如果添加过就抛出异常,也就是每个类只能有一个函数响应同一种事件类型 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \" + eventType); &#125; &#125; //根据优先级priority来添加Subscription对象 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //将订阅者对象以及订阅的事件保存到typesBySubscriber里. List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //如果接收sticky事件,立即分发sticky事件 if (subscriberMethod.sticky) &#123; //eventInheritance 表示是否分发订阅了响应事件类父类事件的方法 if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 以上就是所有注册过程，现在再来看这张图就会特别清晰EventBus的register()过程了: 到这里，订阅流程就走完了。接下来我们在看事件分发的流程。 2.3 发送事件Post我们知道发送事件是通过post() 方法进行广播的，比如第一节我们例子中提到的EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;)); 接下来我们进入这个post()方法一窥究竟： public void post(Object event) &#123; //得到当前线程的Posting状态. PostingThreadState postingState = currentPostingThreadState.get(); //获取当前线程的事件队列 List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; // 记录当前发送线程是否为主线程 postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\"); &#125; try &#123; //处理队列，一直发送完所有事件 while (!eventQueue.isEmpty()) &#123; //发送单个事件 postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 首先是通过currentPostingThreadState.get()方法来得到当前线程PostingThreadState的对象，为什么是说当前线程？我们来看看currentPostingThreadState的实现： private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;; 其实现是返回一个 PostingThreadState 对象，而 PostingThreadState 类的结构如下，封装的是当前线程的 post 信息，包括事件队列、是否正在分发中、是否在主线程、订阅者信息、事件实例、是否取消。 /** For ThreadLocal, much faster to set (and get multiple values). */final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;(); boolean isPosting; boolean isMainThread; Subscription subscription; Object event; boolean canceled;&#125; 综上，currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象，关于ThreadLocal张涛的这篇文章解释的很好：ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。 其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，通过这样就可以做到每个线程通过get() 方法获取的时候，取到的只能是自己线程所对应的数据。 所以这里取到的就是每个线程的PostingThreadState状态.接下来我们来看postSingleEvent()： private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; //是否触发订阅了该事件(eventClass)的父类,以及接口的类的响应方法 if (eventInheritance) &#123; //查找eventClass类所有的父类以及接口 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); //循环postSingleEventForEventType for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); //只要右边有一个为true,subscriptionFound就为true subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; //post单个 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; //如果没发现 if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, \"No subscribers registered for event \" + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; //发送一个NoSubscriberEvent事件,如果我们需要处理这种状态,接收这个事件就可以了 post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; lookupAllEventTypes() 就是查找该事件的所有父类，返回所有的该事件的父类的 class 。它通过循环和递归一起用，将一个类的父类（接口）全部添加到全局静态变量 eventTypes 集合中。跟着上面的代码的注释，我们可以很清楚的发现是在postSingleEventForEventType()方法里去进行事件的分发，代码如下： private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; //获取订阅了这个事件的Subscription列表. synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; //是否被中断 boolean aborted = false; try &#123; //分发给订阅者 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125;private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; //根据接收该事件的订阅方法约定的ThreadMode决定分配到哪个线程执行 switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode); &#125;&#125; 总结上面的代码就是,首先从subscriptionsByEventType里获得所有订阅了这个事件的Subscription列表，然后在通过postToSubscription()方法来分发事件，在postToSubscription()通过不同的threadMode在不同的线程里invoke()订阅者的方法,ThreadMode共有四类： PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作； MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作； BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里； Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。 这里我们先看看invokeSubscriber(subscription, event);是如何实现的： void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(\"Unexpected exception\", e); &#125;&#125; 实际上就是通过反射调用了订阅者的订阅函数并把event对象作为参数传入。然后我们就又遇到了在EventBus构造函数中初始化的3个Poster：HandlerPoster（也就是代码中的mainThreadPoster对象） ，BackgroundPoster和AsyncPoster，这 3 个 poster 负责线程间调度。我们分别来看看： # HandlerPoster final class HandlerPoster extends Handler &#123; //队列，即将执行的Post private final PendingPostQueue queue; //一个Post最大的在HandleMessage中的时间 private final int maxMillisInsideHandleMessage; private final EventBus eventBus; //handler是否运行起来了 private boolean handlerActive; //EventBus的构造函数中初始化了mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); //注意此处的Looper.getMainLooper()便指定了主线程的Looper HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123; super(looper); this.eventBus = eventBus; this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage; queue = new PendingPostQueue(); &#125; void enqueue(Subscription subscription, Object event) &#123; //PendingPost维护了一个可以复用PendingPost对象的复用池 PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; //加入到队列中 queue.enqueue(pendingPost); //如果handleMessage没有运行起来 if (!handlerActive) &#123; handlerActive = true; //发送一个空消息，让handleMessage运行起来 if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; &#125; &#125; &#125; @Override public void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); while (true) &#123; //从队列中取出PendingPost PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; //调用eventBus的方法，分发消息 eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; //如果再一定时间内都还没有将队列排空，则退出 if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125; &#125;&#125; 我们有必要回看EventBus的构造函数中初始化了mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);的代码。注意这行代码中传入的第二个参数Looper.getMainLooper()便指定了主线程的Looper，保证了这个HandlerPoster的运行在主线程。 然后PendingPost 的数据结构是这样的： final class PendingPost &#123; Object event;//事件 Subscription subscription;//订阅 PendingPost next;//与队列的数据结构有关，指向下一个节点&#125; 其中 PendingPost 维护着一个可以复用PendingPost对象的复用池，通过 obtainPendingPost(Subscription, Object) 方法复用，通过 releasePendingPost(PendingPost ) 方法回收。 handleMessage() 中有一个死循环，这个死循环不停的从队列中拿数据，然后通过 EventBus.invokeSubscriber() 分发出去。每分发完一次比对一下时间，如果超过了 maxMillisInsideHandleMessage ，那么发送空 message再次进入到 handlerMessage 中且退出本次循环。 # BackgroundPoster /** * Posts events in background. * @author Markus */ //我们注意到它实现了Runable接口final class BackgroundPoster implements Runnable &#123; private final PendingPostQueue queue; private final EventBus eventBus; private volatile boolean executorRunning; BackgroundPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; //加入到队列中 queue.enqueue(pendingPost); if (!executorRunning) &#123; executorRunning = true; //把自己这个Runable抛入线程池开始运行 eventBus.getExecutorService().execute(this); &#125; &#125; &#125; @Override public void run() &#123; try &#123; try &#123; while (true) &#123; //从队列中取出PendingPost，此处的1000表示如果队列为空就暂停1000毫秒再取 PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; //调用eventBus的方法，分发消息 eventBus.invokeSubscriber(pendingPost); &#125; &#125; catch (InterruptedException e) &#123; Log.w(\"Event\", Thread.currentThread().getName() + \" was interruppted\", e); &#125; &#125; finally &#123; executorRunning = false; &#125; &#125;&#125; 同理 BackgroundPoster ，只不过 HandlerPoster 是在 handlerMessage 中进行分发操作，而 BackgroundPoster 是在 Runnable 的 run 方法中将所有队列中的消息取出进行分发，直到取完为止。 # AsyncPoster /** * Posts events in background. * @author Markus */ //它也实现Runable接口class AsyncPoster implements Runnable &#123; private final PendingPostQueue queue; private final EventBus eventBus; AsyncPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); queue.enqueue(pendingPost); eventBus.getExecutorService().execute(this); &#125; @Override public void run() &#123; PendingPost pendingPost = queue.poll(); if(pendingPost == null) &#123; throw new IllegalStateException(\"No pending post available\"); &#125; eventBus.invokeSubscriber(pendingPost); &#125;&#125; 而 AsyncPoster 虽然也是在 Runnable 的 run 方法中取出队列中的消息，但是只取一个。不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。 可以看到，不同的Poster会在post事件时，调度相应的事件队列PendingPostQueue，让每个订阅者的回调方法收到相应的事件，并在其注册的Thread中运行。而这个事件队列是一个链表，由一个个PendingPost组成，其中包含了事件，事件订阅者，回调方法这三个核心参数，以及需要执行的下一个PendingPost。至此post()流程就结束了，整体流程图如下： 2.4 解除注册Unregister看完了上面的分析，解除注册就相对容易了，解除注册只要调用unregister()方法即可。实现如下： public synchronized void unregister(Object subscriber) &#123; //通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型, List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; //分别解除每个订阅了的事件类型 for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; //从typesBySubscriber移除subscriber typesBySubscriber.remove(subscriber); &#125; else &#123; Log.w(TAG, \"Subscriber to unregister was not registered before: \" + subscriber.getClass()); &#125;&#125; 然后接着看unsubscribeByEventType()方法的实现： private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; //subscriptionsByEventType里拿出这个事件类型的订阅者列表. List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); //取消订阅 for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125;&#125; 最终分别从typesBySubscriber和subscriptions里分别移除订阅者以及相关信息即可。 2.5 注解Subscribe最后我们来看一下EventBus中的这个Subscribe注解定义： @Documented@Retention(RetentionPolicy.RUNTIME) //运行时注解@Target(&#123;ElementType.METHOD&#125;) //用来修饰方法public @interface Subscribe &#123; ThreadMode threadMode() default ThreadMode.POSTING; /** * If true, delivers the most recent sticky event (posted with * &#123;@link EventBus#postSticky(Object)&#125;) to this subscriber (if event available). */ boolean sticky() default false; /** Subscriber priority to influence the order of event delivery. * Within the same delivery thread (&#123;@link ThreadMode&#125;), higher priority subscribers will receive events before * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of * delivery among subscribers with different &#123;@link ThreadMode&#125;s! */ int priority() default 0;&#125; 我们可以看到EventBus使用的这个注解Subscribe是运行时注解（RetentionPolicy.RUNTIME），为什么需要定义成运行时而不是编译时注解呢？我们先看一下三种不同时机的注解： /**1.SOURCE:在源文件中有效（即源文件保留）2.CLASS:在class文件中有效（即class保留）3.RUNTIME:在运行时有效（即运行时保留）*/@Retention(RetentionPolicy.RUNTIME)@Retention(RetentionPolicy.SOURCE)@Retention(RetentionPolicy.CLASS) @Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。 因为EventBus的register()方法中需要通过反射获得注册类中通过注解声明的订阅方法，也就意味着必须在运行时保留注解信息，以便能够反射得到这些方法。所以这个Subcribe注解必须是运行时注解。大家有疑惑的可以自己写个Demo尝试一下使用反射得到某个类中方法的编译时注解信息，一定会抛出NullPointerException异常。 三、EventBus原理分析在平时使用中我们不需要关心EventBus中对事件的分发机制，但要成为能够快速排查问题的老司机，我们还是得熟悉它的工作原理，下面我们就透过UML图来学习一下。 3.1 核心架构EventBus的核心工作机制透过作者Blog中的这张图就能很好地理解： 订阅者模块需要通过EventBus订阅相关的事件，并准备好处理事件的回调方法，而事件发布者则在适当的时机把事件post出去，EventBus就能帮我们搞定一切。在架构方面，EventBus 3.0与之前稍老版本有不同，我们直接看架构图： 为了方便理解或者对比，顺便也放一张2.x老版本的结构图吧： 虽然更新了3.0，但是整体上的设计还是可以用上面的类图来分析，从类图上我们可以看到大部分类都是依赖于EventBus的，上部分主要是订阅者相关信息，中间是 EventBus 类，下面是发布者发布事件后的调用。 根据UML图，我们先看核心类EventBus，其中subscriptionByEventType是以事件的类为key，订阅者的回调方法为value的映射关系表。也就是说EventBus在收到一个事件时，就可以根据这个事件的类型，在subscriptionByEventType中找到所有监听了该事件的订阅者及处理事件的回调方法。而typesBySubscriber则是每个订阅者所监听的事件类型表，在取消注册时可以通过该表中保存的信息，快速删除subscriptionByEventType中订阅者的注册信息，避免遍历查找。注册事件、发送事件和注销都是围绕着这两个核心数据结构来展开。上面的Subscription可以理解为每个订阅者与回调方法的关系，在其他模块发送事件时，就会通过这个关系，让订阅者执行回调方法。 回调方法在这里被封装成了SubscriptionMethod，里面保存了在需要反射invoke方法时的各种参数，包括优先级，是否接收黏性事件和所在线程等信息。而要生成这些封装好的方法，则需要SubscriberMethodFinder，它可以在regster时得到订阅者的所有回调方法，并封装返回给EventBus。而右边的加速器模块，就是为了提高SubscriberMethodFinder的效率，这里就不再啰嗦。 至此EventBus 3.0的架构就分析完了，与之前EventBus老版本最明显的区别在于：分发事件的调度单位从订阅者，细化成了订阅者的回调方法。也就是说每个回调方法都有自己的优先级，执行线程和是否接收黏性事件，提高了事件分发的灵活程度，接下来我们在看核心功能的实现时更能体现这一点。 3.2 register简单来说就是：根据订阅者的类来找回调方法，把订阅者和回调方法封装成关系，并保存到相应的数据结构中，为随后的事件分发做好准备，最后处理黏性事件。 根据订阅者来找到订阅方法和事件，封装成 SubscriberMehod 循环每个 SubscriberMethod 通过事件得到该事件的所有订阅者列表，再根据优先级插入到 subscriptionsByEventType 的所有订阅者列表中 通过订阅者得到该订阅者的所有事件列表，再将事件添加到 typeBySubscriber 的所以事件列表中 是否是粘性事件 是的话进行分发，post此事件给当前订阅者，不是的话不管 结束本次循环，跳到 2 3.3 post总的来说就是分析事件，得到所有监听该事件的订阅者的回调方法，并利用反射来invoke方法，实现回调。 从 currentPostingThreadState 中得到当前线程的 PostThreadState 信息 将此事件添加到 PostPostThreadState 的事件队列中 判断是否再分发 不是的话，循环队列，是的话跳 7 判断是个需要继承关系 是的话，循环得到父类，不是的话跳 7 查找该事件的订阅者，循环订阅者 根据 ThreadMoth 发送事件 结束本次循环订阅者，跳 7 结束本次循环队列，跳 4 在源代码中为了保证post执行不会出现死锁，等待和对同一订阅者发送相同的事件，增加了很多线程保护锁和标志位，值得我们每个开发者学习。 3.4 unregister注销就比较简单了，把在注册时往两个数据结构中添加的订阅者信息删除即可： 至此大家对EventBus的运行原理应该有了一定的了解，虽然看起来像是一个复杂耗时的自动机，但大部分时候事件都是一瞬间就能分发到位的，而大家关心的性能问题反而是发生在注册EventBus的时候，因为需要遍历监听者的所有方法去找到回调的方法。作者也提到运行时注解的性能在Android上并不理想，为了解决这个问题，作者才会以索引的方式去生成回调方法表，也就是在EventBus 3.0中引入了EventBusAnnotationProcessor（注解分析生成索引）技术，大大提高了EventBus的运行效率。关于索引技术的源码分析，大家可以参考腾讯Bugly的这边文章：老司机教你 “飙” EventBus 3 。 四、缺点与问题一直以来，EventBus被大家吐槽的一大问题就是代码混淆问题。 4.1 混淆问题混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。 首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码： -keep class de.greenrobot.** &#123;*;&#125; 其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。 -keep public enum org.greenrobot.eventbus.ThreadMode &#123; public static *; &#125; 这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule? 这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法： -keepclassmembers class * &#123; @de.greenrobot.event.Subscribe &lt;methods&gt;;&#125; 所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。 4.2 跨进程问题目前EventBus只支持跨线程，而不支持跨进程。如果一个app的service起到了另一个进程中，那么注册监听的模块则会收不到另一个进程的EventBus发出的事件。这里可以考虑利用IPC做映射表，并在两个进程中各维护一个EventBus，不过这样就要自己去维护register和unregister的关系，比较繁琐，而且这种情况下通常用广播会更加方便，大家可以思考一下有没有更优的解决方案。 4.3 事件环路问题在使用EventBus时，通常我们会把两个模块相互监听，来达到一个相互回调通信的目的。但这样一旦出现死循环，而且如果没有相应的日志信息，很难定位问题。所以在使用EventBus的模块，如果在回调上有环路，而且回调方法复杂到了一定程度的话，就要考虑把接收事件专门封装成一个子模块，同时考虑避免出现事件环路。 五、总结EventBus不论从使用方式和实现方式上都是非常值得我们学习的开源项目，可以说是目前消息通知里最好用的项目。但是业内对EventBus的主要争论点是在于EventBus使用反射会出现性能问题，实际上在EventBus里我们可以看到不仅可以使用注解处理器预处理获取订阅信息，EventBus也会将订阅者的方法缓存到METHOD_CACHE里避免重复查找，所以只有在最后invoke()方法的时候会比直接调用多出一些性能损耗。 而且相比旧版的2.x，现在新版的EventBus 3.0，订阅者已经没有固定的处理事件的方法了，onEvent、onEventMainThread、onEventBackgroundThread、onEventAsync都没有了，现在支持处理事件的方法名自定义，但必须public，只有一个参数，然后使用注解@Subscribe来标记该方法为处理事件的方法，ThreadMode和priority也通过该注解来定义。在subscriberMethodFinder中，通过反射的方式寻找事件方法。使用注解，用起来才更爽。 当然，EventBus并不是重构代码的唯一之选。作为观察者模式的“同门师兄弟”——RxJava，作为功能更为强大的响应式编程框架，可以轻松实现EventBus的事件总线功能（RxBus）。但毕竟大型项目要接入RxJava的成本高，复杂的操作符需要开发者投入更多的时间去学习。所以想在成熟的项目中快速地重构、解耦模块，EventBus依旧是我们的不二之选。 参考资料 Markus Junginger - EventBus 3 beta announced at droidcon 老司机教你 “飙” EventBus 3 - 腾讯Bugly EventBus源码研读(上)，(中)，(下) - kymjs张涛 EventBus3.0源码解析 - yydcdut EventBus 3.0 源代码分析 - Skykai EventBus 源码解析 - codeKK","categories":[{"name":"源码分析","slug":"源码分析","permalink":"http://github.com/categories/源码分析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://github.com/tags/源码分析/"}],"keywords":[{"name":"源码分析","slug":"源码分析","permalink":"http://github.com/categories/源码分析/"}]},{"title":"【Java】try-catch-finally语句中return的执行顺序思考","slug":"【Java】try-catch-finally语句中return的执行顺序思考","date":"2017-09-20T14:30:55.000Z","updated":"2017-09-21T08:35:01.896Z","comments":true,"path":"2017/09/20/【Java】try-catch-finally语句中return的执行顺序思考/","link":"","permalink":"http://github.com/2017/09/20/【Java】try-catch-finally语句中return的执行顺序思考/","excerpt":"实验对于try-catch-finally语句中return的执行顺序，我们都有知道，finally块中的内容会先于try中的return语句执行，如果finall语句块中也有return语句的话，那么直接从finally中返回了，这也是不建议在finally中return的原因。 下面通过实验来看这几种情况的执行顺序到底是什么。 1、try中有return，finally中没有public class TryCatchTest &#123; public static void main(String[] args) &#123; System.out.println(\"test()函数返回：\" + test()); &#125; private static int test()&#123; int i = 0; try &#123; System.out.println(\"Try block executing: \" + ++i); return i; &#125;catch (Exception e)&#123; System.out.println(\"Catch Error executing: \" + ++i); return -1; &#125;finally &#123; System.out.println(\"finally executing: \" + ++i); &#125; &#125;&#125;","text":"实验对于try-catch-finally语句中return的执行顺序，我们都有知道，finally块中的内容会先于try中的return语句执行，如果finall语句块中也有return语句的话，那么直接从finally中返回了，这也是不建议在finally中return的原因。 下面通过实验来看这几种情况的执行顺序到底是什么。 1、try中有return，finally中没有public class TryCatchTest &#123; public static void main(String[] args) &#123; System.out.println(\"test()函数返回：\" + test()); &#125; private static int test()&#123; int i = 0; try &#123; System.out.println(\"Try block executing: \" + ++i); return i; &#125;catch (Exception e)&#123; System.out.println(\"Catch Error executing: \" + ++i); return -1; &#125;finally &#123; System.out.println(\"finally executing: \" + ++i); &#125; &#125;&#125; 结果如下： Try block executing: 1finally executing: 2test()函数返回：1 return的是对象时，看看在finally中改变对象属性，会不会影响try中的return结果。 public class TryCatchTest &#123; public int vaule = 0; public static void main(String[] args) &#123; System.out.println(\"test()函数返回：\" + test().vaule); &#125; private static TryCatchTest test()&#123; TryCatchTest t = new TryCatchTest(); try &#123; t.vaule = 1; System.out.println(\"Try block executing: \" + t.vaule); return t; &#125;catch (Exception e)&#123; t.vaule = -1; System.out.println(\"Catch Error executing: \" + t.vaule); return t; &#125;finally &#123; t.vaule = 3; System.out.println(\"finally executing: \" + t.vaule); &#125; &#125;&#125; Try block executing: 1finally executing: 3test()函数返回：3 2、try和finally中均有returnprivate static int test()&#123; int i = 0; try &#123; System.out.println(\"Try block executing: \" + ++i); return i; &#125;catch (Exception e)&#123; System.out.println(\"Catch Error executing: \" + ++i); return -1; &#125;finally &#123; System.out.println(\"finally executing: \" + ++i); return i; &#125;&#125; 结果如下： Try block executing: 1finally executing: 2test()函数返回：2 3、catch和finally中均有returnprivate static int test()&#123; int i = 0; try &#123; System.out.println(\"Try block executing: \" + ++i); throw new Exception(); &#125;catch (Exception e)&#123; System.out.println(\"Catch Error executing: \" + ++i); return -1; &#125;finally &#123; System.out.println(\"finally executing: \" + ++i); return i; &#125;&#125; 输出结果： Try block executing: 1Catch Error executing: 2finally executing: 3test()函数返回：3 总结1、不管有没有出现异常，finally块中代码都会执行；2、当try和catch中有return时，finally仍然会执行；3、finally是在return后面的表达式运算之后执行的； 对于含有return语句的情况，这里我们可以简单地总结如下： try语句在返回前，将其他所有的操作执行完，保留好要返回的值，而后转入执行finally中的语句，而后分为以下三种情况： 情况一：如果finally中有return语句，则会将try中的return语句“覆盖”掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。 情况二：如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后，会接着执行try中的return语句，返回之前保留的值。 情况三：如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况： 1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。 2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。 参考资料 有return的情况下try catch finally的执行顺序（最有说服力的总结） Java中try catch finally语句中含有return语句的执行情况（总结版）","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【算法】从多项式乘法到快速傅里叶变换","slug":"【算法】从多项式乘法到快速傅里叶变换","date":"2017-09-08T04:20:55.000Z","updated":"2017-10-23T04:01:18.869Z","comments":true,"path":"2017/09/08/【算法】从多项式乘法到快速傅里叶变换/","link":"","permalink":"http://github.com/2017/09/08/【算法】从多项式乘法到快速傅里叶变换/","excerpt":"本文来自： 从多项式乘法到快速傅里叶变换 — miskcoo 概述计算多项式的乘法，或者计算两个大整数的乘法是在计算机中很常见的运算，如果用普通的方法进行，复杂度将会是$ \\mathcal O(n^2) ​$的，还有一种分治乘法，可以做到 $\\mathcal O(n^{\\log_23}) ​$时间计算（可以看Karatsuba 乘法）。下面从计算多项式的乘法出发，介绍快速傅里叶变换（Fast Fourier Transform, FFT）如何在 $\\mathcal O(n\\log n) ​$的时间内计算出两个多项式的乘积。 准备知识这里介绍一些后面可能会用到的知识（主要是关于多项式、卷积以及复数的），如果你已经知道觉得它太水了或者想用到的时候再看就跳过吧。 多项式简单来说，形如 $ a_0+a_1X+a_2X^2+\\cdots+a_nX^n $ 的代数表达式叫做多项式，可以记作$P(X)=a_0+a_1X+a_2X^2+\\cdots+a_nX^n$，$a_0, a_1, \\cdots, a_n $叫做多项式的系数，$X $是一个不定元，不表示任何值，不定元在多项式中最大项的次数称作多项式的次数 多项式的系数表示法像刚刚我们提到的那些多项式，都是以系数形式表示的，也就是将 n 次多项式$ A(x) $的系数 $a_0, a_1, \\cdots, a_n $看作 $n+1 $维向量$ \\vec a=(a_0,a_1,\\cdots,a_n)$，其系数表示（coefficient representation）就是向量$ \\vec a$ 。","text":"本文来自： 从多项式乘法到快速傅里叶变换 — miskcoo 概述计算多项式的乘法，或者计算两个大整数的乘法是在计算机中很常见的运算，如果用普通的方法进行，复杂度将会是$ \\mathcal O(n^2) ​$的，还有一种分治乘法，可以做到 $\\mathcal O(n^{\\log_23}) ​$时间计算（可以看Karatsuba 乘法）。下面从计算多项式的乘法出发，介绍快速傅里叶变换（Fast Fourier Transform, FFT）如何在 $\\mathcal O(n\\log n) ​$的时间内计算出两个多项式的乘积。 准备知识这里介绍一些后面可能会用到的知识（主要是关于多项式、卷积以及复数的），如果你已经知道觉得它太水了或者想用到的时候再看就跳过吧。 多项式简单来说，形如 $ a_0+a_1X+a_2X^2+\\cdots+a_nX^n $ 的代数表达式叫做多项式，可以记作$P(X)=a_0+a_1X+a_2X^2+\\cdots+a_nX^n$，$a_0, a_1, \\cdots, a_n $叫做多项式的系数，$X $是一个不定元，不表示任何值，不定元在多项式中最大项的次数称作多项式的次数 多项式的系数表示法像刚刚我们提到的那些多项式，都是以系数形式表示的，也就是将 n 次多项式$ A(x) $的系数 $a_0, a_1, \\cdots, a_n $看作 $n+1 $维向量$ \\vec a=(a_0,a_1,\\cdots,a_n)$，其系数表示（coefficient representation）就是向量$ \\vec a$ 。 多项式的点值表示法如果选取$ n+1 $个不同的数 $x_0, x_1, \\cdots, x_n $对多项式进行求值，得到$ A(x_0), A(x_1), \\cdots, A(x_n)$，那么就称$ {\\left(x_i, A(x_i)\\right) : 0 \\leq i \\leq n, i \\in \\mathbb Z} $为多项式$ A(x)$ 的点值表示（point-value representation） 多项式$ A(x) $的点值表示不止一种，你只要选取不同的数就可以得到不同的点值表示，但是任何一种点值表示都能唯一确定一个多项式，为了从点值表示转换成系数表示，可以直接通过插值的方法 复数后面提到的$ i$，除非作为$ \\sum $求和的变量，其余的都表示虚数单位 $\\sqrt{-1}$ 单位根$n $次单位根是指能够满足方程$ z^n=1 $的复数，这些复数一共有$ n $个它们都分布在复平面的单位圆上，并且构成一个正 $n $边形，它们把单位圆等分成$ n $个部分 根据复数乘法相当于模长相乘，幅角相加就可以知道，$n $次单位根的模长一定是$ 1$，幅角的$ n $倍是$ 0$这样，$n$ 次单位根也就是 $$ e^{\\frac{2\\pi ki}{n}}, k = 0, 1, 2, \\cdots, n - 1 $$再根据欧拉公式 $$ e^{\\theta i}=\\cos\\theta + i\\sin\\theta $$就可以知道 n 次单位根的算术表示 如果记$ \\omega_n=e^{\\frac{2\\pi i}{n}}$，那么$ n $次单位根就是 $\\omega_n^0, \\omega_n^1, \\cdots, \\omega_n^{n-1}$ 多项式的乘法给定两个多项式$ A(x), B(x)$ $$ A(x) = \\sum_{i=0}^na_ix^i = a_nx^n+a_{n-1}x^{n-1}+\\cdots+a_1x+a_0 \\\\ B(x) = \\sum_{i=0}^nb_ix^i = b_nx^n+b_{n-1}x^{n-1}+\\cdots+b_1x+b_0 $$ 将这两个多项式相乘得到$ C(x) = \\sum_{i=0}^{2n}c_ix^i$，在这里 $$ c_i=\\sum_{j+k=i,0\\leq j,k\\leq n}a_jb_kx^i $$ 如果一个个去算$ c_i $的话，要花费$ \\mathcal O(n^2) $的时间才可以完成，但是，这是在系数表示下计算的，如果转换成点值表示，知道了$ A(x), B(x) $的点值表示后，由于只有$ n+1$ 个点，就可以直接将其相乘，在 $\\mathcal O(n) $的时间内得到$ C(x)$ 的点值表示 如果能够找到一种有效的方法帮助我们在多项式的点值表示和系数表示之间转换，我们就可以快速地计算多项式的乘法了，快速傅里叶变换就可以做到这一点 快速傅里叶变换快速傅里叶变换你可以认为有两个部分，DFT 和 IDFT，分别可以在$ \\mathcal O(n\\log n) $的时间内将多项式的系数表示转化成点值表示，并且转回来，就像下面这张图所示： Cooley-Tukey算法FFT 最常见的算法是 Cooley-Tukey 算法，它的基本思路在 1965 年由 J. W. Cooley 和 J. W. Tukey 提出的，它是一个基于分治策略的算法 假设现在有一个$ n-1 $次多项式$ A(x)=\\sum_{i=0}^{n-1}a_ix^i$（为了方便，假设$ n=2^m, m\\in \\mathbb Z$，如果不足可以在高次项系数补成 0） 将$ n $个$ n $次单位根$ \\omega_n^0, \\omega_n^1, \\cdots, \\omega_n^{n-1}$ 带入$ A(x) $将其转换成点值表达 $$ A(\\omega_n^k) = \\sum_{i=0}^{n-1}a_i\\omega^{ki} , k = 0, 1, \\cdots, n - 1 $$ 点值向量 $ \\vec y=(A(\\omega_n^0), A(\\omega_n^1), \\cdots, A(\\omega_n^{n-1})) $ 称作系数向量$ \\vec a=(a_0, a_1, \\cdots, a_{n-1}) $的离散傅里叶变换（Discrete Fourier Transform, DFT），也记作$ \\vec y=DFT_n(\\vec a) $ 到此为止，直接计算$ DFT_n(\\vec a) $还是需要$ \\mathcal O(n^2) $的时间，Cooley-Tukey 算法接下来做的事情是将每一项按照指数奇偶分类 $$ \\begin{eqnarray*} A(\\omega_n^k) &=& \\sum_{i=0}^{n-1}a_i\\omega_n^{ki} \\\\ &=& \\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\omega_n^{2ki}+\\omega_n^k\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\omega_n^{2ki} \\\\ \\end{eqnarray*} $$ 但是，如果直接这样递归下去，你需要带入的值还是有$ n $个，也就是说，现在只是将系数减半，而没有将需要带入的值减半，上面的$ k $还是$ 0, 1, \\cdots, n - 1$，这样的话复杂度还是$ \\mathcal O(n^2)$ 但是你会注意到，根据准备知识中$ \\omega_n^2=\\left(e^{\\frac{2\\pi i}{n}}\\right)^2=e^{\\frac{2\\pi i}{n/2}}=\\omega_{\\frac{n}{2}}$ ，并且$ \\frac{n}{2} $次单位根只有$ \\frac{n}{2} $个，也就是说，我们要带入的值再平方以后似乎变少了一半？仔细想想就会发现，既然单位根把单位圆等分，那么肯定会对称，也就是有一个正的，就会有一个负的，平方后这两个当然就相同了。严格一点的证明就是 $$ \\omega_n^{\\frac{n}{2}+k} = \\omega_n^{\\frac{n}{2}}\\cdot \\omega_n^k = -\\omega_n^k $$ 这也就是说，对于$ k &lt; \\frac{n}{2}$ 的时候 $$ A(\\omega_n^k) = \\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\omega_{\\frac{n}{2}}^{ki}+\\omega_n^{k}\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\omega_{\\frac{n}{2}}^{ki} $$ 并且 $$ \\begin{eqnarray*} A(\\omega_n^{k+\\frac{n}{2}}) &=& \\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\omega_{\\frac{n}{2}}^{ki}+\\omega_n^{k+\\frac{n}{2}}\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\omega_{\\frac{n}{2}}^{ki} \\\\ &=&\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\omega_{\\frac{n}{2}}^{ki}-\\omega_n^k\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\omega_{\\frac{n}{2}}^{ki} \\end{eqnarray*} $$ 这样我们就将需要带入的值也减少成了 $ 1, \\omega_{\\frac{n}{2}}, \\omega_{\\frac{n}{2}}^2, \\cdots, \\omega_{\\frac{n}{2}}^{\\frac{n}{2}-1} $，问题变成了两个规模减半的子问题，只要递归下去计算就可以了，至于复杂度 $$ T(n) = 2T(\\frac{n}{2})+\\mathcal O(n) = \\mathcal O(n\\log n) $$ 傅里叶逆变换（IDFT）刚刚计算的是$ \\vec y = DFT_n(\\vec a)$，可以将多项式转化成点值表示，现在为了将点值表示转化成系数表示，需要计算 IDFT（Inverse Discrete Fourier Transform），它是 DFT 的逆 这个问题实际上相当于是一个解线性方程组的问题，也就是给出了$ n $个线性方程 $$ \\begin{equation*} \\left\\{ \\begin{array}{ccccccccc} a_0(\\omega_n^0)^{0}&+&\\cdots&+&a_{n-2}(\\omega_n^0)^{n-2}&+&+a_{n-1}(\\omega_n^0)^{n-1}&=&A(\\omega_n^0) \\\\ a_0(\\omega_n^1)^{0}&+&\\cdots&+&a_{n-2}(\\omega_n^1)^{n-2}&+&+a_{n-1}(\\omega_n^1)^{n-1}&=&A(\\omega_n^1) \\\\ \\vdots & & \\vdots & &\\vdots& & \\vdots & & \\vdots\\\\ a_0(\\omega_n^{n-1})^{0}&+&\\cdots&+&a_{n-2}(\\omega_n^{n-1})^{n-2}&+&+a_{n-1}(\\omega_n^{n-1})^{n-1}&=&A(\\omega_n^{n-1}) \\end{array} \\right. \\end{equation*} $$ 写成矩阵方程的形式就是 $$ \\begin{equation} \\label{IDFT-equation} \\begin{bmatrix} (\\omega_n^0)^0 & (\\omega_n^0)^1 & \\cdots & (\\omega_n^0)^{n-1} \\\\ (\\omega_n^1)^0 & (\\omega_n^1)^1 & \\cdots & (\\omega_n^1)^{n-1} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ (\\omega_n^{n-1})^0 & (\\omega_n^{n-1})^1 & \\cdots & (\\omega_n^{n-1})^{n-1} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{n-1} \\end{bmatrix} = \\begin{bmatrix} A(\\omega_n^0) \\\\ A(\\omega_n^1) \\\\ \\vdots \\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\end{equation} $$ 记上面的系数矩阵为$ \\mathbf V$ 现在考虑下面这个矩阵$ d_{ij}=\\omega_n^{-ij}$ $$ \\begin{equation*} \\mathbf D = \\begin{bmatrix} (\\omega_n^{-0})^0 & (\\omega_n^{-0})^1 & \\cdots & (\\omega_n^{-0})^{n-1} \\\\ (\\omega_n^{-1})^0 & (\\omega_n^{-1})^1 & \\cdots & (\\omega_n^{-1})^{n-1} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ (\\omega_n^{-(n-1)})^0 & (\\omega_n^{-(n-1)})^1 & \\cdots & (\\omega_n^{-(n-1)})^{n-1} \\end{bmatrix} \\end{equation*} $$ 设它们相乘后的结果是$ \\mathbf E=\\mathbf D \\cdot \\mathbf V$ $$ \\begin{eqnarray*} e_{ij} &=& \\sum_{k=0}^{n-1} d_{ik} v_{kj} \\\\ &=& \\sum_{k=0}^{n-1} \\omega_n^{-ik}\\omega_n^{kj} \\\\ &=& \\sum_{k=0}^{n-1} \\omega_n^{k(j-i)} \\end{eqnarray*} $$ 当$ i=j $时，$e_{ij}=n$ 当$ i\\neq j $时， $$ \\begin{eqnarray*} e_{ij} &=& \\sum_{k=0}^{n-1} (\\omega_n^{j-i})^k \\\\ &=& \\frac{1-(\\omega_n^{j-i})^n}{1-\\omega_n^{j-i}}\\\\ &=& 0 \\end{eqnarray*} $$ 因此可以知道$ \\mathbf I_n=\\frac{1}{n}\\mathbf E$，所以$ \\frac{1}{n}\\mathbf D = \\mathbf V^{-1}$ 将$ \\frac{1}{n}\\mathbf D $在$ \\ref{IDFT-equation} $ 左乘就会得到 $$ \\begin{equation*} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{n-1} \\end{bmatrix} = \\frac{1}{n} \\begin{bmatrix} (\\omega_n^{-0})^0 & (\\omega_n^{-0})^1 & \\cdots & (\\omega_n^{-0})^{n-1} \\\\ (\\omega_n^{-1})^0 & (\\omega_n^{-1})^1 & \\cdots & (\\omega_n^{-1})^{n-1} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ (\\omega_n^{-(n-1)})^0 & (\\omega_n^{-(n-1)})^1 & \\cdots & (\\omega_n^{-(n-1)})^{n-1} \\end{bmatrix} \\begin{bmatrix} A(\\omega_n^0) \\\\ A(\\omega_n^1) \\\\ \\vdots \\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\end{equation*} $$ 这样，IDFT 就相当于把 DFT 过程中的$ \\omega_n^i $换成$ \\omega_n^{-i}$，然后做一次 DFT，之后结果除以$ n$ 就可以了。 算法实现递归实现根据前面的说明，递归实现的 FFT 应该不是什么大问题，下面就直接给出 C++ 代码了（主意 n要补齐到 $2^m$） void fft(int n, complex&lt;double&gt;* buffer, int offset, int step, complex&lt;double&gt;* epsilon) &#123; if(n == 1) return; int m = n &gt;&gt; 1; fft(m, buffer, offset, step &lt;&lt; 1, epsilon); fft(m, buffer, offset + step, step &lt;&lt; 1, epsilon); for(int k = 0; k != m; ++k) &#123; int pos = 2 * step * k; temp[k] = buffer[pos + offset] + epsilon[k * step] * buffer[pos + offset + step]; temp[k + m] = buffer[pos + offset] - epsilon[k * step] * buffer[pos + offset + step]; &#125; for(int i = 0; i != n; ++i) buffer[i * step + offset] = temp[i];&#125; 这里的 epsilon是事先打好了的$ \\omega_n $的表 void init_epsilon(int n)&#123; double pi = acos(-1); for(int i = 0; i != n; ++i) &#123; epsilon[i] = complex&lt;double&gt;(cos(2.0 * pi * i / n), sin(2.0 * pi * i / n)); arti_epsilon[i] = conj(epsilon[i]); &#125;&#125; 迭代实现假设现在有$ 16 $个数要进行$DFT $来看看递归的过程 在 Step1 -&gt; Step2 的过程中，按照奇偶分类，二进制位中最后一位相同的被分到同一组 在 Step2 -&gt; Step3 的过程中，仍然按照奇偶，只不过不是按照数字的奇偶性，而是下标的奇偶性，二进制位中最后两位相同的才被分到同一组 在 Step3 -&gt; Step4 的过程中，二进制位中最后三位相同的数字被分在同一组 现在将整个二进制位反转，例如 0010 就变成 0100，这时候每次在同一组的数字，反转后的二进制位前几位都是相同的，这似乎十分类似加法，相邻两组二进制位反转之后数字会是连续的一段区间。例如在 Step3 中，1、5、9、13 这一组，反转二进制后是 1(1000)、5(1010)、9(1001)、13(1011)，分组后是 1(1000)、9(1001) 和 5(1010)、13(1011) 假设reverse(i)是将二进制位反转的操作，DFT 最后一步的数组是 B，原来的数组是 A，那么 A 和 B 之间有这样的关系B[reverse(i)]=A[i]，也就是说， B[i + 1]=A[reverse(reverse(i)+ 1)]，B 中第 i 项的下一项就是将 i 反转后加 1 再反转回来 A 中的那一项，所以现在要模拟的就是从高位开始的二进制加法 考虑正向二进制加法的过程，相当于从最低位开始，找到第一个 0，然后把这个 0 改成 1，之前的 1 全部变成 0。那么反向二进制加法就是从最高位开始，找到第一个 0，然后把这个 0 改成 1，前面的 1 全部改成 0，所以就是这样 int reverse_add(int x) &#123; for(int l = 1 &lt;&lt; bit_length; (x ^= l) &lt; l; l &gt;&gt;= 1); return x;&#125; 为了从原来的 A 数组，得到最后一步所需要的 B 数组，只要维护两个变量，一个是当前下标 i，一个是反向加的下标 j，表示 B[i] 应该放 A[j] 放的东西，如果 i &gt; j，只要将 i 和 j 存的东西交换，这样最后就可以得到所需要的 B 数组 /* 这时候 n 已经补齐到 2 的幂次 */void bit_reverse(int n, complex_t *x) &#123; for(int i = 0, j = 0; i != n; ++i) &#123; if(i &gt; j) swap(x[i], x[j]); for(int l = n &gt;&gt; 1; (j ^= l) &lt; l; l &gt;&gt;= 1); &#125;&#125; 现在已经把要变换的元素排在相邻位置了，所以从下往上 $2 $开始到 $2^m $来进行计算，每次枚举一块往上迭代即可！ void transform(int n, complex_t *x, complex_t *w) &#123; bit_reverse(n, x); for(int i = 2; i &lt;= n; i &lt;&lt;= 1) &#123; int m = i &gt;&gt; 1; for(int j = 0; j &lt; n; j += i) &#123; for(int k = 0; k != m; ++k) &#123; complex_t z = x[j + m + k] * w[n / i * k]; x[j + m + k] = x[j + k] - z; x[j + k] += z; &#125; &#125; &#125;&#125; 快速数论变换由于 FFT 涉及到复数运算，难免有精度问题，在计算一些只要求整数的卷积或高精度乘法的时候就有可能由于精度出现错误，这便让我们考虑是否有在模意义下的方法，这就是快速数论变换（Fast Number-Theoretic Transform，FNT） 首先来看 FFT 中能在$ \\mathcal O(n\\log n) $时间内变换用到了单位根 $\\omega $的什么性质 $\\omega_n^n=1$ $\\omega_n^0, \\omega_n^1, \\cdots, \\omega_n^{n-1} $是互不相同的，这样带入计算出来的点值才可以用来还原出系数 $ \\omega_n^2=\\omega_{\\frac{n}{2}}, \\omega_n^{\\frac{n}{2}+k}=-\\omega_n^k $ ，这使得在按照指数奇偶分类之后能够把带入的值也减半使得问题规模能够减半 $$ \\sum_{k=0}^{n-1} (\\omega_n^{j-i})^k = \\begin{eqnarray*} \\left\\{ \\begin{aligned}0, ~~~&i \\neq j\\\\ n, ~~~&i = j \\end{aligned} \\right. \\end{eqnarray*} $$ ​ 这点保证了能够使用相同的方法进行逆变换得到系数表示 原根现在我们要在数论中寻找满足这三个性质的数，首先来介绍原根的概念，根据费马定理我们知道，对于一个素数$ p$，有下面这样的关系 $$ a^{p-1} \\equiv 1 \\pmod p $$ 这一点和单位根 $\\omega$ 十分相似，$p$ 的原根 $g $定义为使得 $g^0, g^1, \\cdots, g^{p-2} \\pmod p $互不相同的数 如果我们取素数$ p = k\\cdot 2^n + 1$，并且找到它的原根$ g$，然后我们令$ g_n\\equiv g^k\\pmod p$，这样就可以使得$ g_n^0, g_n^1, \\cdots, g_n^{n-1} \\pmod p $互不相同，并且$ g_n^n\\equiv 1\\pmod p$，这便满足了性质一和性质二 由于$ p $是素数，并且$ g_n^n \\equiv 1 \\mod p$，这样 $g_n^\\frac{n}{2} \\bmod p $必然是$ -1 $或 $1$，再根据$ g^k $互不相同这个特点，所以$ g_n^\\frac{n}{2} \\equiv -1 \\pmod p$，满足性质三 对于性质四，和前面一样也可以验证是满足的，因此再 FNT 中，我们可以用原根替代单位根，这里已经有了一些数$ p $及其原根，可以满足大部分需求 模数任意的解决方案前面说了，要进行快速数论变换需要模数是 $a\\cdot 2^k + 1 $形式的素数，但是在实际应用中，要求的模数可能不是这样的形式，甚至是一个合数！ 假设现在需要模 $m$，并且进行变换的长度是$ n$ 那么这样任何多项式系数的范围是$ [0, m)$，两个相乘，不会超过$ (m - 1)^2$，一共 $n $项相加，不会超过 $n(m-1)^2$ 这样的话，选取$ k $个有上面形式的素数$ p_1, p_2, \\cdots, p_k$，要求满足 $$ \\prod_{i=1}^k p_k > n(m-1)^2 $$ 然后分别在$ \\bmod k $的剩余系下做变换，最后使用中国剩余定理合并（当然这时候或许是需要高精度或者__int128 的） 代码实现FNT 的代码实现和 FFT 是一样的，只要把复数运算换成在 $\\bmod p$ 剩余系下的运算即可 应用快速卷积现有两个定义在$ \\mathbb N $上的函数$ f(n), g(n)$，定义$ f $和 $g $的卷积（convolution）为 $f \\otimes g$ $$ (f \\otimes g)(n) = \\sum_{i=0}^n f(i)g(n-i) $$ 就像上面的图一样，注意到卷积的形式和多项式乘法的形式是相同的，也就是两个多项式$ A(x), B(x)$，令$ C(x) = A(x)B(x)$，那么会有$ c_i=(a \\otimes b)(i)$，因此可以用 FFT 来计算卷积 对于要计算某些形如 $h(k) = \\sum_{i=0}^n f(i)g(i+k) $ 的问题，可以令$ f’(x) = f(n-x)$，这样问题就变成计算$ \\sum_{i=0}^n f’(n-i)g(i+k)$，也就是一个卷积的形式 例1：[ZJOI2014]力题目给出$ n $个数$ q_1, q_2, \\cdots, q_n$，要求计算 $$ F_i = \\sum_{j=1}^{i-1}\\frac{q_iq_j}{(j-i)^i}-\\sum_{j=i+1}^{n}\\frac{q_iq_j}{(j-i)^i} $$ 观察一下，假设有四个数$ q_1, q_2, q_3, q_4$，那么 $$ \\begin{eqnarray*} \\frac{F_1}{q_1} &=& -\\frac{q_2}{1^2}-\\frac{q_3}{2^2}-\\frac{q_4}{3^2} \\\\ \\frac{F_2}{q_2} &=& +\\frac{q_1}{1^2}-\\frac{q_3}{1^2}-\\frac{q_4}{2^2} \\\\ \\frac{F_3}{q_3} &=& +\\frac{q_1}{2^2}+\\frac{q_2}{1^2}-\\frac{q_4}{1^2} \\\\ \\frac{F_4}{q_4} &=& +\\frac{q_1}{3^2}+\\frac{q_2}{2^2}+\\frac{q_3}{1^2} \\\\ \\end{eqnarray*} $$ 初看之下似乎没什么规律，但是这之中出现的几个数列出来 q_1 q_2 q_3 q_4 0 0 0 $-\\frac{1}{3^2}$ $-\\frac{1}{2^2}$ $-\\frac{1}{1^2}$ $0$ $\\frac{1}{1^2}$ $\\frac{1}{2^2}$ $\\frac{1}{3^2}$ 列出来之后你看看每个 $\\frac{F_i}{q_i} $的计算，就会发现刚好是像上面那张图一样的顺序相乘再相加，是个卷积的形式！因此最后只需要用 FFT 优化计算卷积，就可以解决此问题，不过要注意精度问题 #include &lt;cstdio&gt;#include &lt;complex&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;const int MaxL = 18, MaxN = 1 &lt;&lt; MaxL;typedef std::complex&lt;double&gt; complex_t;complex_t f[MaxN], g[MaxN];complex_t eps[MaxN], inv_eps[MaxN];void init_eps(int p)&#123; double pi = acos(-1); double angle = 2.0 * pi / p; for(int i = 0; i != p; ++i) eps[i] = complex_t(cos(2.0 * pi * i / p), sin(2.0 * pi * i / p)); for(int i = 0; i != p; ++i) inv_eps[i] = conj(eps[i]);&#125;void transform(int n, complex_t *x, complex_t *w)&#123; for(int i = 0, j = 0; i != n; ++i) &#123; if(i &gt; j) std::swap(x[i], x[j]); for(int l = n &gt;&gt; 1; (j ^= l) &lt; l; l &gt;&gt;= 1); &#125; for(int i = 2; i &lt;= n; i &lt;&lt;= 1) &#123; int m = i &gt;&gt; 1; for(int j = 0; j &lt; n; j += i) &#123; for(int k = 0; k != m; ++k) &#123; complex_t z = x[j + m + k] * w[n / i * k]; x[j + m + k] = x[j + k] - z; x[j + k] += z; &#125; &#125; &#125;&#125;int main()&#123; int n; std::scanf(\"%d\", &amp;n); int l = 0, p = 1; while(p &lt; n) ++l, p &lt;&lt;= 1; ++l, p &lt;&lt;= 1; for(int i = 0; i != p; ++i) f[i] = g[i] = 0.0; for(int i = 0; i != n; ++i) &#123; double x; std::scanf(\"%lf\", &amp;x); f[i] = x; &#125; for(int i = 0; i + 1 &lt; n; ++i) &#123; g[i] = 1.0 / ((n - i - 1.0) * (n - i - 1.0)); g[2 * n - i - 2] = -g[i]; &#125; init_eps(p); std::reverse(g, g + p); transform(p, f, eps); transform(p, g, eps); for(int i = 0; i != p; ++i) f[i] *= g[i]; transform(p, f, inv_eps); for(int i = p - n; i != p; ++i) std::printf(\"%.3lf\\n\", f[i].real() / p); return 0;&#125; 生成函数运算对于一些需要用到生成函数的计数问题，在列出生成函数之后有可能需要将其平方、求对数、求逆元或者开方，这时便可以用 FFT 来加速计算 例2：[BZOJ3771]Triple这个问题就是用 FFT 加速多项式乘法的过程，具体可以看上面这篇题解 多项式求逆、除法、取模关于多项式的求逆元，可以看这里 关于多项式的除法和求模，可以看这里 多项式多点求值和快速插值关于多项式的多点求值和快速插值，可以看这里 Related Posts: FFT用到的各种素数 多项式求逆元 多项式的多点求值与快速插值 牛顿迭代法在多项式运算的应用 特殊多项式在整点上的线性插值方法 Karatsuba 乘法","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【算法】大数乘法问题及其高效算法","slug":"【算法】大数相乘问题及其高效算法","date":"2017-08-22T14:20:55.000Z","updated":"2017-10-23T04:01:38.184Z","comments":true,"path":"2017/08/22/【算法】大数相乘问题及其高效算法/","link":"","permalink":"http://github.com/2017/08/22/【算法】大数相乘问题及其高效算法/","excerpt":"题目编写两个任意位数的大数相乘的程序，给出计算结果。比如： 题目描述： 输出两个不超过100位的大整数的乘积。输入： 输入两个大整数，如1234567 和 123输出： 输出乘积，如：151851741 或者 求 1234567891011121314151617181920 * 2019181716151413121110987654321 的乘积结果 分析所谓大数相乘（Multiplication algorithm），就是指数字比较大，相乘的结果超出了基本类型的表示范围，所以这样的数不能够直接做乘法运算。 参考了很多资料，包括维基百科词条Multiplication algorithm，才知道目前大数乘法算法主要有以下几种思路： 模拟小学乘法：最简单的乘法竖式手算的累加型； 分治乘法：最简单的是Karatsuba乘法，一般化以后有Toom-Cook乘法； 快速傅里叶变换FFT：（为了避免精度问题，可以改用快速数论变换FNTT），时间复杂度O(N lgN lglgN)。具体可参照Schönhage–Strassen algorithm； 中国剩余定理：把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行； Furer’s algorithm：在渐进意义上FNTT还快的算法。不过好像不太实用，本文就不作介绍了。大家可以参考维基百科Fürer’s algorithm","text":"题目编写两个任意位数的大数相乘的程序，给出计算结果。比如： 题目描述： 输出两个不超过100位的大整数的乘积。输入： 输入两个大整数，如1234567 和 123输出： 输出乘积，如：151851741 或者 求 1234567891011121314151617181920 * 2019181716151413121110987654321 的乘积结果 分析所谓大数相乘（Multiplication algorithm），就是指数字比较大，相乘的结果超出了基本类型的表示范围，所以这样的数不能够直接做乘法运算。 参考了很多资料，包括维基百科词条Multiplication algorithm，才知道目前大数乘法算法主要有以下几种思路： 模拟小学乘法：最简单的乘法竖式手算的累加型； 分治乘法：最简单的是Karatsuba乘法，一般化以后有Toom-Cook乘法； 快速傅里叶变换FFT：（为了避免精度问题，可以改用快速数论变换FNTT），时间复杂度O(N lgN lglgN)。具体可参照Schönhage–Strassen algorithm； 中国剩余定理：把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行； Furer’s algorithm：在渐进意义上FNTT还快的算法。不过好像不太实用，本文就不作介绍了。大家可以参考维基百科Fürer’s algorithm 解法我们分别实现一下以上算法，既然不能直接使用乘法做运算，最简单最容易想到的办法就是模拟乘法运算。 1、模拟乘法手算累加 7 8 9 6 5 2× 3 2 1 1----------------- 7 8 9 6 5 2 &lt;---- 第1趟 7 8 9 6 5 2 &lt;---- 第2趟 .......... &lt;---- 第n趟 ----------------- ? ? ? ? ? ? ? ? &lt;---- 最后的值用另一个数组表示 如上所示，乘法运算可以分拆为两步： 第一步，是将乘数与被乘数逐位相乘； 第二步，将逐位相乘得到的结果，对应相加起来。 这有点类似小学数学中，计算乘法时通常采用的“竖式运算”。用Java简单实现了这个算法，代码如下： /** * 大数相乘 - 模拟乘法手算累加 */public static Integer[] bigNumberMultiply(int[] arr1， int[] arr2)&#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //中间求和的结果 //arr2 逐位与arr1相乘 for(int i = arr2.length - 1; i &gt;= 0; i--)&#123; int carry = 0; ArrayList&lt;Integer&gt; singleList = new ArrayList&lt;&gt;(); //arr2 逐位单次乘法的结果 for(int j = arr1.length - 1; j &gt;= 0; j--)&#123; int r = arr2[i] * arr1[j] + carry; int digit = r % 10; carry = r / 10; singleList.add(digit); &#125; if(carry != 0)&#123; singleList.add(carry); &#125; int resultCarry = 0, count = 0; int k = 0; int l = 0; int offset = arr2.length - 1 - i; //加法的偏移位 ArrayList&lt;Integer&gt; middleResult = new ArrayList&lt;&gt;(); //arr2每位乘法的结果与上一轮的求和结果相加，从右向左做加法并进位 while (k &lt; singleList.size() || l &lt; result.size()) &#123; int kv = 0, lv = 0; if (k &lt; singleList.size() &amp;&amp; count &gt;= offset) &#123; kv = singleList.get(k++); &#125; if (l &lt; result.size()) &#123; lv = result.get(l++); &#125; int sum = resultCarry + kv + lv; middleResult.add(sum % 10); //相加结果从右向左（高位到低位）暂时存储，最后需要逆向输出 resultCarry = sum / 10; count++; &#125; if(resultCarry != 0)&#123; middleResult.add(resultCarry); &#125; result.clear(); result = middleResult; &#125; Collections.reverse(result); //逆向输出结果 return result.toArray(new Integer[result.size()]);&#125; 看了以上的代码，感觉思路虽然很简单，但是实现起来却很麻烦，那么我们有没有别的方法来实现这个程序呢？答案是有的，接下来我来介绍第二种方法。 2、模拟乘法累加 - 改进简单来说，方法二就是先不算任何的进位，也就是说，将每一位相乘，相加的结果保存到同一个位置，到最后才计算进位。 例如：计算98×21,步骤如下 9 8× 2 1------------- (9)(8) &lt;---- 第1趟: 98×1的每一位结果 (18)(16) &lt;---- 第2趟: 98×2的每一位结果 ------------- (18)(25)(8) &lt;---- 这里就是相对位的和，还没有累加进位 这里唯一要注意的便是进位问题，我们可以先不考虑进位，当所有位对应相加，产生结果之后，再考虑。从右向左依次累加，如果该位的数字大于10，那么我们用取余运算，在该位上只保留取余后的个位数，而将十位数进位（通过模运算得到）累加到高位便可，循环直到累加完毕。 核心代码如下： /** * 大数相乘方法二 */public static int[] bigNumberMultiply2(int[] num1, int[] num2)&#123; // 分配一个空间，用来存储运算的结果，num1长的数 * num2长的数，结果不会超过num1+num2长 int[] result = new int[num1.length + num2.length]; // 先不考虑进位问题，根据竖式的乘法运算，num1的第i位与num2的第j位相乘，结果应该存放在结果的第i+j位上 for (int i = 0; i &lt; num1.length; i++)&#123; for (int j = 0; j &lt; num2.length; j++)&#123; result[i + j + 1] += num1[i] * num2[j]; // (因为进位的问题，最终放置到第i+j+1位) &#125; &#125; //单独处理进位 for(int k = result.length-1; k &gt; 0; k--)&#123; if(result[k] &gt; 10)&#123; result[k - 1] += result[k] / 10; result[k] %= 10; &#125; &#125; return result;&#125; ！！注意：这里的进位有个大坑，因为result[]数组是从左到右记录相对位的和（还没有进位），而最后的进位是从右向左累加进位，这样的话，如果最高位，也就是最左侧那一位的累加结果需要进位的话，result[]数组就没有空间存放了。 而正好result[]数组的最后一位空置，不可能被占用，我们就响应地把num1的第i位与num2的第j位相乘，结果应该存放在结果的第i+j位上的这个结果往后顺移一位（放到第i+j+1位），最后从右向左累加时就多了一个空间。 3、分治 - Karatsuba算法以上两种模拟乘法的手算累加型算法，他们都是模拟普通乘法的计算方式，时间复杂度都是O(n^2)，而这个Karatsuba算法，时间复杂度仅有 $O(n^{\\log _{2}3})$ 。下面，我就来介绍一下这个算法。 Karatsuba于1960年发明在 $O(n^{\\log _{2}3})$ 步骤内将两个n位数相乘的Karatsuba算法。它反证了安德雷·柯尔莫哥洛夫于1956年认为这个乘法需要 $ \\Omega (n^{2})$ 步骤的猜想。 首先来看看这个算法是怎么进行计算的，见下图： 图中显示了计算5678 * 1234的过程，首先是拆分成abcd四个部分，然后分别计算ac, bd, (a+b)*(c+d)，最后再用第三个算式的结果减去前面两个（其实得到的就是bc+ad，但是减少了乘法步骤），然后，计算式1后面加4个0，计算式2后面不加，计算式3后面加2个0，再把这三者相加，就是正确结果。 接下来，就来证明一下这个算法的正确性。这是一幅来自Karatsuba Multiplication Algorithm – Python Code的图，我们来看看： 我们假设要相乘的两个数是x * y。我们可以把x，y写成： $$ x = a * 10^{n/2} + b $$ $$ y = c * 10^{n/2} + d $$ 这里的n是数字的位数。如果是偶数，则a和b都是n/2位的。如果n是奇数，则你可以让a是n/2+1位，b是n/2位。（例如a = 12，b = 34；a = 123，b = 45），那么x*y就可以换算为： $$ \\begin{eqnarray*} &&x * y\\\\ &=&(a * 10^{n/2}+b) * (c * 10^{n/2}+d)\\\\ &=&ac * 10^n + (ad + bc) * 10^{n/2} + bd\\\\ &=&ac * 10^n + [(a+b)*(c+d)-ac-bd] * 10^{n/2} + bd \\end{eqnarray*} $$ 注意最后一步，这个式子倒数第二步中的(ad + bc)，没必要另外进行两次乘法，可以使用((a+b)*(c+d) - ac - bd)来重复利用前面的两次乘积结果ac和bd。 也就是说，我们发现最终只需要计算三次乘法 a*c， b*d， (a+b)*(c+d) 以及六次加法。因此这样复杂度就变为 $$ T(n) = 3T(\\frac{n}{2}) + 6n = O(n^{\\log_23}) $$ 对比之前的计算过程，结果已经呼之欲出了。这里唯一需要注意的两点就是： (a*d + b*c)的计算为了防止两次乘法，应该使用之前的计算也就是第一幅图第四步的③-②-① 这些乘法在算法里应该是递归实现的，数字很大时，先拆分，然后拆分出来的数字还是很大的话，就继续拆分，直到a * b已经是一个非常简单的小问题为之。这也是分治的思想。 我们举例来尝试一下这种算法，比如计算12345 * 6789，我们让a = 12，b = 345。同时c = 6，d = 789。也就是： $$ 12345 = 12 · 1000 + 345\\\\ 6789 = 6 · 1000 + 789 $$ 那么a*c，b*d的结果如下： $$ \\begin{align*} z_2 &= a*c = 12 × 6 = 72\\\\ z_0 &= b*d = 345 × 789 = 272205 \\\\ z_1 &= ((a+b)*(c+d) - a*c - b*d)\\\\ &= (12 + 345) × (6 + 789) − z_2 − z_0 = 283815 − 72 − 272205 = 11538 \\end{align*} $$ 最终结果就是： $$ \\begin{align*} & result = z_2 · 10^{2*3} + z_1 · 10^3 + z_0 \\\\ & result = 72 · 10^6 + 11538 · 10^3 + 272205 = 83810205. \\\\ \\end{align*} $$ 以上就是使用分治的方式计算乘法的原理。上面这个算法，由 Anatolii Alexeevitch Karatsuba 于1960年提出并于1962年发表，所以也被称为 Karatsuba 乘法。 根据上面的思路，实现的Karatsuba乘法代码如下： /** * Karatsuba乘法 */public static long karatsuba(long num1, long num2)&#123; //递归终止条件 if(num1 &lt; 10 || num2 &lt; 10) return num1 * num2; // 计算拆分长度 int size1 = String.valueOf(num1).length(); int size2 = String.valueOf(num2).length(); int halfN = Math.max(size1, size2) / 2; /* 拆分为a, b, c, d */ long a = Long.valueOf(String.valueOf(num1).substring(0, size1 - halfN)); long b = Long.valueOf(String.valueOf(num1).substring(size1 - halfN)); long c = Long.valueOf(String.valueOf(num2).substring(0, size2 - halfN)); long d = Long.valueOf(String.valueOf(num2).substring(size2 - halfN)); // 计算z2, z0, z1, 此处的乘法使用递归 long z2 = karatsuba(a, c); long z0 = karatsuba(b, d); long z1 = karatsuba((a + b), (c + d)) - z0 - z2; return (long)(z2 * Math.pow(10, (2*halfN)) + z1 * Math.pow(10, halfN) + z0);&#125; 总结： Karatsuba 算法是比较简单的递归乘法，把输入拆分成 2 部分，不过对于更大的数，可以把输入拆分成 3 部分甚至 4 部分。拆分为 3 部分时，可以使用下面的Toom-Cook 3-way 乘法，复杂度降低到 O(n^1.465)。拆分为 4 部分时，使用Toom-Cook 4-way 乘法，复杂度进一步下降到 O(n^1.404)。对于更大的数字，可以拆成 100 段，使用快速傅里叶变换FFT，复杂度接近线性，大约是 O(n^1.149)。可以看出，分割越大，时间复杂度就越低，但是所要计算的中间项以及合并最终结果的过程就会越复杂，开销会增加，因此分割点上升，对于公钥加密，暂时用不到太大的整数，所以使用 Karatsuba 就合适了，不用再去弄更复杂的递归乘法。 测试程序public class LeetcodeTest &#123; public static void main(String[] args) &#123;// String a = \"1234567891011121314151617181920\";// String b = \"2019181716151413121110987654321\";// String a = \"999999999999\";// String b = \"999999999999\";// String a = \"24566\";// String b = \"452053\"; String a = \"98\"; String b = \"21\"; char[] charArr1 = a.trim().toCharArray(); char[] charArr2 = b.trim().toCharArray(); // 字符数组转换为int[]数组 int[] arr1 = new int[charArr1.length]; int[] arr2 = new int[charArr2.length]; for(int i = 0; i &lt; charArr1.length; i++)&#123; arr1[i] = charArr1[i] - '0'; &#125; for(int i = 0; i &lt; charArr2.length; i++)&#123; arr2[i] = charArr2[i] - '0'; &#125; // 开始计算 int[] result = LeetcodeTest.bigNumberMultiply2(arr1, arr2); System.out.println(a + \" * \" + b + \" = \" + Arrays.toString(result).replace(\", \", \"\")); &#125;&#125; 最后，是测试用例输出结果： 1234567891011121314151617181920 * 2019181716151413121110987654321 = [02492816912877266687794240983772975935013386905490061131076320]999999999999 * 999999999999 = [999999999998000000000001]24566 * 452053 = [11105133998]98 * 21 = [2058] Java中BigInteger的乘法实现目前最著名的高精度整数运算库是GNU的GMP，GMP是The GNU MP Bignum Library，是一个开源的数学运算库，它可以用于任意精度的数学运算，包括有符号整数、有理数和浮点数。它本身并没有精度限制，只取决于机器的硬件情况。许多著名的计算机代数系统如Axiom, Maple, Mathematica, Maxima等的底层高精度整数运算都是基于GMP实现的。 设n 为乘数的位数, 就目前已知的情况而言, 不同乘法算法的时间复杂度可以从平凡的$O(n^2)$(普通乘法), $O(n^{log_2 3})$(Karatsuba 乘法)， $O(n^{log_3 5})$ (Toom-3 乘法)，$O(n {\\log^* n})$ (复数域上的FFT)，其中 $$ log^* n = log n(log log n)(log log log n) ··· , $$ 和$O(n(log n)(log log n))$(有限域上的FFT), 其中“有限域上的FFT”的时间复杂度已经相当接近线性了。 但是这些乘法算法中复杂度较低的算法往往有较大的常数因子, 因此如果乘数的位数较少,普通乘法反而是最快的, 所以实用中常常将这些不同的乘法算法结合起来使用, 每次做乘法时都根据相乘两数的大小动态地选择具体采用哪一种算法, 而每种算法的最佳适用范围往往依赖于具体实现和硬件环境, 因此一般直接通过实验来确定。 Java中的实现 在 Java 7 里面，就是用二重循环直接乘的。源代码：[BigInteger - Java7] （见1165行） 在 Java 8 里面，根据两个因数的大小，有三种乘法。源代码：[BigInteger - Java8] （见1464行）： 当两个因数均小于 $2^{32\\times 80}$ 时，用二重循环直接相乘，复杂度为$O(n^2) $，n为因数位数（下同）； 否则，当两个因数均小于$2^{32\\times 240} $时，采用 Karatsuba algorithm，其复杂度为$O(n^{\\log_2 3}) \\approx O(n^{1.585})$； 否则，采用 Toom-Cook multiplication，其复杂度为$O(n^{\\log_3 5}) \\approx O(n^{1.465})$。 其中，Java8中的源代码如下： private static final int MULTIPLY_SQUARE_THRESHOLD = 20;private static final int KARATSUBA_THRESHOLD = 80;private static final int TOOM_COOK_THRESHOLD = 240;public BigInteger multiply(BigInteger val) &#123; if (val.signum == 0 || signum == 0) return ZERO; int xlen = mag.length; if (val == this &amp;&amp; xlen &gt; MULTIPLY_SQUARE_THRESHOLD) &#123; return square(); &#125; int ylen = val.mag.length; if ((xlen &lt; KARATSUBA_THRESHOLD) || (ylen &lt; KARATSUBA_THRESHOLD)) &#123; int resultSign = signum == val.signum ? 1 : -1; if (val.mag.length == 1) &#123; return multiplyByInt(mag,val.mag[0], resultSign); &#125; if (mag.length == 1) &#123; return multiplyByInt(val.mag,mag[0], resultSign); &#125; int[] result = multiplyToLen(mag, xlen, val.mag, ylen, null); result = trustedStripLeadingZeroInts(result); return new BigInteger(result, resultSign); &#125; else &#123; if ((xlen &lt; TOOM_COOK_THRESHOLD) &amp;&amp; (ylen &lt; TOOM_COOK_THRESHOLD)) &#123; // 采用 Karatsuba algorithm 算法 return multiplyKaratsuba(this, val); &#125; else &#123; // 采用 Toom-Cook multiplication 3路乘法 return multiplyToomCook3(this, val); &#125; &#125;&#125; 我们可以看到，Java8依据两个因数的量级分别使用Karatsuba algorithm 和 Toom-Cook multiplication 算法计算大数乘积。 Karatsuba algorithm/** * Java8中的 Karatsuba algorithm 算法 */private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) &#123; int xlen = x.mag.length; int ylen = y.mag.length; // The number of ints in each half of the number. int half = (Math.max(xlen, ylen)+1) / 2; // xl and yl are the lower halves of x and y respectively, // xh and yh are the upper halves. BigInteger xl = x.getLower(half); BigInteger xh = x.getUpper(half); BigInteger yl = y.getLower(half); BigInteger yh = y.getUpper(half); BigInteger p1 = xh.multiply(yh); // p1 = xh*yh BigInteger p2 = xl.multiply(yl); // p2 = xl*yl // p3=(xh+xl)*(yh+yl) BigInteger p3 = xh.add(xl).multiply(yh.add(yl)); // result = p1 * 2^(32*2*half) + (p3 - p1 - p2) * 2^(32*half) + p2 BigInteger result = p1.shiftLeft(32*half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32*half).add(p2); if (x.signum != y.signum) &#123; return result.negate(); &#125; else &#123; return result; &#125;&#125; Toom-Cook multiplication/** * Java8中的 Toom-Cook multiplication 3路乘法 */private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) &#123; int alen = a.mag.length; int blen = b.mag.length; int largest = Math.max(alen, blen); // k is the size (in ints) of the lower-order slices. int k = (largest+2)/3; // Equal to ceil(largest/3) // r is the size (in ints) of the highest-order slice. int r = largest - 2*k; // Obtain slices of the numbers. a2 and b2 are the most significant // bits of the numbers a and b, and a0 and b0 the least significant. BigInteger a0, a1, a2, b0, b1, b2; a2 = a.getToomSlice(k, r, 0, largest); a1 = a.getToomSlice(k, r, 1, largest); a0 = a.getToomSlice(k, r, 2, largest); b2 = b.getToomSlice(k, r, 0, largest); b1 = b.getToomSlice(k, r, 1, largest); b0 = b.getToomSlice(k, r, 2, largest); BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1, db1; v0 = a0.multiply(b0); da1 = a2.add(a0); db1 = b2.add(b0); vm1 = da1.subtract(a1).multiply(db1.subtract(b1)); da1 = da1.add(a1); db1 = db1.add(b1); v1 = da1.multiply(db1); v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply( db1.add(b2).shiftLeft(1).subtract(b0)); vinf = a2.multiply(b2); // The algorithm requires two divisions by 2 and one by 3. // All divisions are known to be exact, that is, they do not produce // remainders, and all results are positive. The divisions by 2 are // implemented as right shifts which are relatively efficient, leaving // only an exact division by 3, which is done by a specialized // linear-time algorithm. t2 = v2.subtract(vm1).exactDivideBy3(); tm1 = v1.subtract(vm1).shiftRight(1); t1 = v1.subtract(v0); t2 = t2.subtract(t1).shiftRight(1); t1 = t1.subtract(tm1).subtract(vinf); t2 = t2.subtract(vinf.shiftLeft(1)); tm1 = tm1.subtract(t2); // Number of bits to shift left. int ss = k*32; BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0); if (a.signum != b.signum) &#123; return result.negate(); &#125; else &#123; return result; &#125;&#125; 参考资料 华为OJ机试题目：两个大整数相乘(纯C语言实现两个大整数相乘，两种方法实现大数相乘) java的BigInteger的乘法运算是用什么算法实现的？ 大数乘法，在算法上，主要有几种思路？ 算法理解 — 大数相乘问题 KaraTsuba乘法 — 高效的大数乘法 大数相乘(from滴答滴答百度空间) 大整数运算 维基百科：Multiplication algorithm Karatsuba Multiplication Algorithm – Python Code Toom-Cook 3-Way Multiplication - GMP Documentations 扩展欧几里得算法与中国剩余定理","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【算法】反转字符串","slug":"【算法】反转字符串","date":"2017-08-05T14:20:55.000Z","updated":"2017-10-23T04:01:29.078Z","comments":true,"path":"2017/08/05/【算法】反转字符串/","link":"","permalink":"http://github.com/2017/08/05/【算法】反转字符串/","excerpt":"前言研究算法能提高我们的编程功底，更好地编写出高效稳健的代码。今天，我们研究的是 —— 反转字符串。 //输入一个字符串，输出它的倒序字符串input: Hellooutput: olleH 解法反转字符串，确实没什么难度，但是我无意间搜索了一下，才发现这么一个看似简单的反转算法实现起来真可谓花样繁多。这里我们尽可能分别总结介绍一下。 1、使用字符数组倒序输出最常规的解法，也是最容易想到的一种方法就是使用字符数组倒序输出。 具体思路是：倒序遍历字符串字符循环给char数组赋值 public static String strReverseWithArray(String string) &#123; if (string == null || string.length() == 0) return string; char[] array = new char[string.length()]; for(int i = 0; i &lt; string.length(); i++)&#123; array[i] = string.charAt(string.length() - i - 1); &#125; return new String(array);&#125;","text":"前言研究算法能提高我们的编程功底，更好地编写出高效稳健的代码。今天，我们研究的是 —— 反转字符串。 //输入一个字符串，输出它的倒序字符串input: Hellooutput: olleH 解法反转字符串，确实没什么难度，但是我无意间搜索了一下，才发现这么一个看似简单的反转算法实现起来真可谓花样繁多。这里我们尽可能分别总结介绍一下。 1、使用字符数组倒序输出最常规的解法，也是最容易想到的一种方法就是使用字符数组倒序输出。 具体思路是：倒序遍历字符串字符循环给char数组赋值 public static String strReverseWithArray(String string) &#123; if (string == null || string.length() == 0) return string; char[] array = new char[string.length()]; for(int i = 0; i &lt; string.length(); i++)&#123; array[i] = string.charAt(string.length() - i - 1); &#125; return new String(array);&#125; 优化： 分析上面这种解法，循环遍历时，我们其实不需要循环这么多次。每次循环的时候，我们应该直接给前、后位置（第一个和最后一个，第二个和倒数第二个）交换。也就是说我们不必对这个字符数组进行完全遍历，通常情况下我们会只遍历一半同时交换中轴前后两个元素就可以了。 public static String strReverseWithArray(String string) &#123; if (string == null || string.length() == 0) return string; char[] array = string.toCharArray(); //注意这里中间的位置计算 for(int i = 0; i &lt; Math.ceil(string.length() / 2.0f); i++)&#123; int j = string.length() - i - 1; if(i != j)&#123; //交换元素 char temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; return new String(array);&#125; 2、使用StringBuilderStringBuilder可以帮助我们创建字符串，所以也可以使用StringBuilder替代字符数组存储，具体思路是: 逆序遍历字符串中的字符，并将它依次添加到StringBuilder中 public static String strReverseWithStringBuilder(String string) &#123; if (string == null || string.length() == 0) return string; StringBuilder sb = new StringBuilder(); for(int i = string.length() - 1; i &gt;= 0; i--)&#123; sb.append(string.charAt(i)); &#125; return sb.toString();&#125; 以上这几种方法按算法角度来说，其实可以归结为一类。然而下面的几种算法就完全不是同一类型的了。比如使用栈、使用异或运算。 3、使用StringBuilder.reverse()方法new StringBuilder(hi).reverse().toString() StringBuilder中提供了reverse()方法来实现字符串反转，我们可以直接调用 public static String strReverseWithRecursive(String string) &#123; if (string == null || string.length() == 0) return string; return new StringBuilder(string).reverse().toString();&#125; Or, for versions earlier than JDK 1.5, use java.util.StringBuffer instead of StringBuilder — they have the same API. Thanks commentators for pointing out that StringBuilder is preferred nowadays. 对于JDK 1.5之前的版本可以使用StringBuffer替代StringBuilder，这两个的API都一样。 4、使用栈我们都知道，栈有“后进先出(LIFO)”的特点。这一特点刚好用于反转字符串。具体思路是: 将字符串转换为char数组 将char数组中的字符依次压入栈中 将栈中的字符依次弹出赋值给char数组 public static String strReverseWithStack(String string) &#123; if (string == null || string.length() == 0) return string; char[] array = string.toCharArray(); Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for(Character c : array)&#123; stack.push(c); //压栈 &#125; for(int i = 0; i &lt; string.length(); i++)&#123; array[i] = stack.pop(); &#125; return new String(array); //出栈&#125; 两次循环和栈的开销无疑使这种方法成为目前为止开销最大的方法。但使用栈这个数据结构的想法还是非常有价值的。 5、使用异或运算计算机的数据流本质上都是0，1二进制数据。字符串也是一样。而二进制数据的处理往往是通过位运算来实现的。位操作有：与，或，非，异或。 对位运算有过了解的应该知道，使用异或操作能实现交换两个变量的值而不引入第三个变量。 实现原理: 首先介绍异或操作 异或操作: 当两两数值相同为否，而数值不同为真。写作A^BA B A^B0 0 00 1 11 0 10 1 0 使用异或操作交换数值 两个数异或的结果再与其中一个数异或的结果是另外一个数这涉及到了离散数学中的异或的性质:1.交换律:A^B=B^A2.结合律: A^(B^C)=(A^B)^C3.恒等律:X^0=04.归零律:X^X=05.自反：A^B^B = A^0=A根据以上性质:A=A^BB=A^BA=A^B通过以上三步，能实现在程序中交换两个变量的数值的目标。 使用异或操作交换字符值 before:\"Hello\"after: \"olleH\"index: 0 1 2 3 4char : H e l l oASCII: 72 101 108 108 111以第0个字符和第4个字符交换为例:交换前:array[0]=1001000array[4]=1101111交换:array[0]=array[0]^array[4]=0100111array[4]=array[4]^array[0]=1001000array[0]=array[0]^array[4]=1101111交换后:array[0]=1101111---&gt;111--&gt;oarray[4]=1001000---&gt;72---&gt;H 使用这种交换方法，每次循环的时候，我们直接给中轴前、后位置元素（第一个和最后一个，第二个和倒数第二个）交换。这样我们也只遍历一半就可以了。 public static String strReverseWithArray(String string) &#123; if (string == null || string.length() == 0) return string; char[] array = string.toCharArray(); for(int i = 0, j = string.length() - 1; i &lt; j; i++, j--)&#123; //异或运算交换元素 array[i] ^= array[j]; array[j] ^= array[i]; array[i] ^= array[j]; &#125; return new String(array);&#125; 6、使用递归当我们反转字符串的时候，脑海里想的就是从首尾两端依次交换直到到达中间位置。当我们在反转某个字符时，剩下的字符串也是一个反转字符串的过程。这样，我们就能用递归的方法来实现反转字符串的目的。 具体思路是: 找出递归结束的临界条件 对针对于临界条件的不同的值做出不同的处理 编码实现： public static String strReverseWithRecursive(String string) &#123; if (string == null || string.length() == 0) return string; if(string.length() == 1)&#123; return string; &#125;else&#123; //当前str的反转 = 将第一个元素之后的subString反转 + 第一个元素 return strReverseWithRecursive(string.substring(1)) + string.charAt(0); &#125;&#125; 引申问题反转一个字符串有这么多方法，那么如何把一个字符串反转，而单词不翻转呢？ 题目：写一个函数，将字符串反转，反转方式如下： //输入一个字符串，输出它的倒序字符串，单词不翻转input: \"I am a student\"output: \"student a am I\" 解决我们可以仿照上面的字符串完全反转方法。 比如使用栈，可以把单词入栈，而不是字符，然后出栈，就是想要的效果了。或者也使用StringBuilder倒序存储，如下： public static String reverse(String word)&#123; String[] arr = word.split(\"\\\\W+\"); StringBuffer sb = new StringBuffer(); int len = arr.length; for(int i = len-1; i &gt;= 0; i--)&#123; sb.append(arr[i]).append(\" \"); &#125; return sb.toString();&#125; 还有一种思路是：先把整个字符串完全反转，再将字符串分割为单词，每个单词再单独反转回来。这种办法也没什么问题，大家可以参考一下。 参考资料 深入浅出经典面试题之——反转字符串 字符串反转的9种方法","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】源码分析 - Handler消息机制再梳理","slug":"【Android】源码分析 - Handler消息机制再梳理","date":"2017-08-03T08:03:00.000Z","updated":"2017-10-23T03:35:02.974Z","comments":true,"path":"2017/08/03/【Android】源码分析 - Handler消息机制再梳理/","link":"","permalink":"http://github.com/2017/08/03/【Android】源码分析 - Handler消息机制再梳理/","excerpt":"前言多线程的消息传递处理，从初学Android时的Handler，懵懵懂懂地照猫画虎，到后来一头雾水的疑惑它为什么这么复杂，再到熟悉之后的叹为观止，一步步地都是自己踩过的足迹，都是成长啊哈哈哈。虽然离出神入化的境界还远十万八千里呢，但Android中的Handler多线程消息传递机制，的确是研发技术学习中不可多得的一个宝藏。本来我以为自己之前的学习以及比较了解 Handler，在印象中 Android 消息机制无非就是： Handler 给 MessageQueue 添加消息 然后 Looper 无限循环读取消息 再调用 Handler 处理消息 但是只知道整体流程，细节还不是特别透彻。最近不甚忙碌，回头看到这块又有些许收获，我们来记录一下吧。 在整个Android的源码世界里，有两大利剑，其一是Binder IPC机制，另一个便是消息机制。Android有大量的消息驱动方式来进行交互，比如Android的四剑客Activity, Service, Broadcast, ContentProvider的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。而Android 消息机制主要涉及 4 个类： Handler Message MessageQueue Looper 我们依次结合源码分析一下。","text":"前言多线程的消息传递处理，从初学Android时的Handler，懵懵懂懂地照猫画虎，到后来一头雾水的疑惑它为什么这么复杂，再到熟悉之后的叹为观止，一步步地都是自己踩过的足迹，都是成长啊哈哈哈。虽然离出神入化的境界还远十万八千里呢，但Android中的Handler多线程消息传递机制，的确是研发技术学习中不可多得的一个宝藏。本来我以为自己之前的学习以及比较了解 Handler，在印象中 Android 消息机制无非就是： Handler 给 MessageQueue 添加消息 然后 Looper 无限循环读取消息 再调用 Handler 处理消息 但是只知道整体流程，细节还不是特别透彻。最近不甚忙碌，回头看到这块又有些许收获，我们来记录一下吧。 在整个Android的源码世界里，有两大利剑，其一是Binder IPC机制，另一个便是消息机制。Android有大量的消息驱动方式来进行交互，比如Android的四剑客Activity, Service, Broadcast, ContentProvider的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。而Android 消息机制主要涉及 4 个类： Handler Message MessageQueue Looper 我们依次结合源码分析一下。 初学Handler每个初学Android开发的都绕不开Handler这个“坎”，为什么说是个坎呢，首先这是Android架构的精髓之一，其次大部分人都是知其然却不知其所以然。所以决定再去翻翻源代码梳理一下Handler的实现机制。 异步更新UI我们都知道Android中主线程就是UI线程。在主线程不能做耗时操作，而子线程不能更新UI。主线程如果耗时操作太久（超过5秒）会引起ANR。子线程更新UI，会导致线程不安全，界面的刷新不能同步，可能不起作用甚至是崩溃。详细的分析可以看这篇文章Android子线程真的不能更新UI么？ 上面这个规定应该是初学必知的，那要怎么来解决这个问题呢，这时候Handler就出现在我们面前了，我们也可以利用AsyncTask或者IntentService进行异步的操作。这两者又是怎么做到的呢？其实，在AsyncTask和IntentService的内部亦使用了Handler实现其主要功能。抛开这两者不谈，当我们打开Android源码的时候也随处可见Handler的身影。所以，Handler是Android异步操作的核心和精髓，它在众多领域发挥着极其重要甚至是不可替代的作用。我们先来一段经典常用代码（这里忽略内存泄露问题，我们后面再说）： 首先在Activity中新建一个handler: private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 0: mTestTV.setText(\"This is handleMessage\"); //更新UI break; &#125; &#125;&#125;; 然后在子线程里发送消息： new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); //在子线程有一段耗时操作,比如请求网络 mHandler.sendEmptyMessage(0); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start(); 我们可以看到，子线程拿着主线程的mHandler对象调用了它的sendEmptyMessage(0)方法发送了一个空Message。然后主线程就更新了mTestTV这个TextView的内容。下面，我们就根据这段代码逐步跟踪分析一下Handler源码，梳理一下Android的这个消息机制。 Handler源码跟踪根据上面的Handler使用例子，我们从Handler的sendEmptyMessage()方法这里开始，翻看Handler的源码： public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 我们可以看到，最后调用了sendMessageAtTime()方法，我们接着看这个方法： public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; //拿到MessageQueue队列对象 if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; //把msg对象入队 return enqueueMessage(queue, msg, uptimeMillis);&#125; 也就是说，目前我们看到的Handler的sendEmptyMessage()方法调用逻辑如下图： 最后这个sendMessageAtTime()方法我们看到两个亮点： 第一步，首先拿到消息队列MessageQueue类型的mQueue对象。 第二步，把消息Message类型的实例msg对象入队。 接下来，我们就沿着这两个问题分别往下跟踪。 MessageQueue对象从哪里来我们先来看mQueue这个MessageQueue对象哪来的呢？我们找到了赋值的地方，原来在Handler的构造函数里： public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); //使用Looper.myLooper()取到了mLooper对象 if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; //原来消息队列来自mLooper对象里的mQueue mCallback = callback; mAsynchronous = async;&#125; 原来mQueue这个对象是从Looper这个对象中获取的，同时我们看到是通过Looper.myLooper()获取到Looper对象的。也就是说每个Looper拥有一个消息队列MessageQueue对象。我们在Looper的构造函数里看到是它new了一个MessageQueue： final MessageQueue mQueue;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); //初始化MessageQueue对象 mThread = Thread.currentThread();&#125; 我们紧接着再进入Looper类中的myLooper()方法看看如何得到Looper实例对象的： /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static Looper myLooper() &#123; return sThreadLocal.get();&#125;// sThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 原来这个looper对象是从一个ThreadLocal线程本地存储TLS对象中取到的，而且这个实例声明上面我们可以看到一行注释：如果不提前调用prepare()方法的话sThreadLocal.get()可能返回null。 我们来看看这个prepare()方法到底干了什么： private static void prepare(boolean quitAllowed) &#123; //每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。 if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; //创建Looper对象，并保存到当前线程的TLS区域 sThreadLocal.set(new Looper(quitAllowed)); &#125; 原来是给ThreadLocal线程本地存储TLS对象set了一个新的Looper对象。换句话说，就是new了一个Looper对象然后保存在了线程本地存储区里了。而这个ThreadLocal线程本地存储对象就是每个线程专有的变量，可以理解成线程的自有变量保存区。我们这里不作深入介绍，只用理解每个线程可以通过Looper.prepare()方法new一个Looper对象保存起来，然后就可以拥有一个Looper了。这也就是我们在非UI线程中使用Handler之前必须首先调用Looper.prepare()方法的根本原因。 插播：ThreadLocal类实现一个线程本地的存储，也就是说，每个线程都有自己的局部变量。所有线程都共享一个ThreadLocal对象，但是每个线程在访问这些变量的时候能得到不同的值，每个线程可以更改这些变量并且不会影响其他的线程，并且支持null值。详细介绍可以看看这里：Android线程管理之ThreadLocal理解及应用场景 比如我们在Activity的onCreate()方法中写一段这样的代码： @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Handler h1 = new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; Handler h2 = new Handler(); //直接在子线程中new一个Handler &#125; &#125;).start();&#125; 运行之后h1正常创建，但是创建h2的时候crash了： ——— beginning of crashE/AndroidRuntime: FATAL EXCEPTION: Thread-263Process: com.example.stone.sfsandroidclient, PID: 32286java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare() at android.os.Handler.(Handler.java:200) at android.os.Handler.(Handler.java:114) at com.example.stone.sfsandroidclient.MainActivity$1.run(MainActivity.java:71) at java.lang.Thread.run(Thread.java:818) 很明显，出错日志提示不能在一个没有调用过Looper.prepare()的Thread里边new Handler()。 看到了这里有一个疑惑，那就是我们在文章开头的示例代码中新建mHandler的时候并没有调用Looper.prepare()方法，那Looper的创建以及方法调用在哪里呢？其实这些东西Android本身已经帮我们做了，在程序入口ActivityThread的main方法里面我们可以找到： public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); //这里等同于Looper.prepare() ... Looper.loop(); ...&#125; Message对象如何入队我们明白了MessageQueue消息队列对象是来自于ThreadLocal线程本地存储区存储的那个唯一的Looper对象。我们接着看Handler在发送消息的最后调用的enqueueMessage()方法，看名字应该是把消息加入队列的意思，点进去看下： private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; //注意此处Handler把自己this赋值给了Message的target变量 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 我们看到msg的target的赋值是Handler自己，也就是说这个msg实例对象现在持有了主线程中mHandler这个对象。注意这里，我们稍后会讲到msg持有这个mHandler对象的用途。最后调用了MessageQueue类的enqueueMessage()方法加入到了消息队列。 看来真正的入队方法交给了MessageQueue，这个enqueueMessage()方法较长，我们现在继续进入看看： boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; //这里要求消息必须跟 Handler 关联 throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; //如果消息队列已经退出，还入队就报错 IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); //消息入队后就标记为 在被使用 msg.when = when; Message p = mMessages; boolean needWake; //添加消息到链表中 if (p == null || when == 0 || when &lt; p.when) &#123; //之前是空链表的时候读取消息会阻塞，新添加消息后唤醒 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; //插入消息到队列时，只有在队列头部有个屏障并且当前消息是异步的时才需要唤醒队列 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 可以看到一个无限循环将消息加入到消息队列中（链表的形式），但是有放就有拿，这个消息怎样把它取出来呢？ 翻看MessageQueue的方法，我们找到了next()方法，也就是出队方法。这个方法代码太长，可以不用细看我们知道它是用来把消息取出来的就行了。 Message next() &#123; //如果消息的 looper 退出，就退出这个方法 final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; //也是一个循环，有合适的消息就返回，没有就阻塞 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; //如果有需要过段时间再处理的消息，先调用 Binder 的这个方法 Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; //获取下一个消息 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //当前链表的头结点 if (msg != null &amp;&amp; msg.target == null) &#123; //如果消息没有 target，那它就是一个屏障，需要一直往后遍历找到第一个异步的消息 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; //如果这个消息还没到处理时间，就设置个时间过段时间再处理 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 消息是正常的、可以立即处理的 mBlocked = false; //取出当前消息，链表头结点后移一位 if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); //标记这个消息在被使用 return msg; &#125; &#125; else &#123; // 消息链表里没有消息了 nextPollTimeoutMillis = -1; &#125; //如果收到退出的消息，并且所有等待处理的消息都处理完时，调用 Native 方法销毁队列 if (mQuitting) &#123; dispose(); return null; &#125; //有消息等待过段时间执行时，pendingIdleHandlerCount 增加 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 可以看到，MessageQueue.next() 方法里有一个循环，在这个循环中遍历消息链表，找到下一个可以处理的、target 不为空的消息并且执行时间不在未来的消息，就返回，否则就继续往后找。 如果有阻塞（没有消息了或者只有 Delay 的消息），会把 mBlocked这个变量标记为 true，在下一个 Message 进队时会判断这个message 的位置，如果在队首就会调用nativeWake() 方法唤醒线程！ 不过MessageQueue.next() 这个方法是在什么地方调用的呢，不是在Handler中，我们找到了Looper这个关键人物，专门负责从消息队列中拿消息。 Looper如何处理Message我们又来到了Looper的阵地，他在调用MessageQueue的next()方法，来从消息队列中拿Message对象，关键代码如下： /** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; //当前线程必须创建 Looper 才可以执行 throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; //底层对 IPC 标识的处理，不用关心 Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; //无限循环模式 Message msg = queue.next(); //从消息队列中读取消息，可能会阻塞 if (msg == null) &#123; //当消息队列中没有消息时就会返回，不过这只发生在 queue 退出的时候 return; &#125; //... try &#123; msg.target.dispatchMessage(msg); //调用消息关联的 Handler 处理消息 &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; //... msg.recycleUnchecked(); //标记这个消息被回收 &#125;&#125; 可以看到，Looper.loop() 也很简单，就是调用消息队列 MessageQueue.next() 方法取消息，如果没有消息的话会阻塞，直到有新的消息进入或者消息队列退出。也就是不断重复下面的操作，直到没有消息时退出循环 读取MessageQueue的下一条Message； 把Message分发给相应的target； 再把分发后的Message回收到消息池，以便重复利用。 拿到消息后调用msg.target的dispatchMessage(msg)方法，而这个msg.target是什么呢？就是前面Handler发送消息sendMessageAtTime()时把自己赋值给msg.target的主线程的mHandler对象。也就是说，最后还是 Handler 负责处理消息。可以看到，Looper 并没有执行消息，真正执行消息的还是添加消息到队列中的那个 Handler。 所以我们来看Handler中的dispatchMessage(msg)方法： /** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;private static void handleCallback(Message message) &#123; message.callback.run();&#125;public void handleMessage(Message msg) &#123;&#125; 可以看到，Handler 在处理消息时，会有三种情况： msg.callback 不为空 这在使用 Handler.postXXX(Runnable) 发送消息的时候会发生 这就直接调用 Runnable 的 run() 方法 mCallback 不为空 这在我们使用前面介绍的 Handler.Callback 为参数构造 Handler 时会发生 那就调用构造函数里传入的 handleMessage() 方法 如果返回 true，那就不往下走了 最后就调用Handler.handleMessage() 方法 这是一个空实现，需要我们在 Handler 子类里重写 而我们开头的例子，使用的就是第3种方法，大家可以回顾一下。 到这里，我们的疑问基本上就解决了，虽然没有再深入到jni层看native底层实现，但是java层的机制我们大概明白了。最后我们对上面的源码跟踪分析做一个宏观上的总结。 整体运行机制四大主角与Windows系统一样，Android也是消息驱动型的系统。引用一下消息驱动机制的四要素： 接收消息的“消息队列” 阻塞式地从消息队列中接收消息并进行处理的“线程” 可发送的“消息的格式” “消息发送函数” 与之对应，Android中的实现对应了 接收消息的“消息队列” ——【MessageQueue】 阻塞式地从消息队列中接收消息并进行处理的“线程” ——【Thread+Looper】 可发送的“消息的格式” ——【Message】 “消息发送函数”——【Handler的post和sendMessage】 也就是说，消息机制主要包含以下四个主角： Message：消息分为硬件产生的消息（如按钮、触摸）和软件生成的消息； MessageQueue：消息队列的主要功能向消息池投递消息（MessageQueue.enqueueMessage()）和取走消息池的消息（MessageQueue.next()）； Handler：消息辅助类，主要功能向消息池发送各种消息事件（Handler.sendMessage()）和处理相应消息事件（Handler.handleMessage()）； Looper：不断循环执行（Looper.loop()），按分发机制将消息分发给目标处理者。 他们之间的关系如下： Thread：一个线程有唯一一个对应的Looper； Looper：有一个MessageQueue消息队列； MessageQueue：有一组待处理的Message； Message中有一个用于处理消息的Handler； Handler中有Looper和MessageQueue。 流程图 一个Looper类似一个消息泵。它本身是一个死循环，不断地从MessageQueue中提取Message或者Runnable。而Handler可以看做是一个Looper的暴露接口，向外部暴露一些事件，并暴露sendMessage()和post()函数。 在安卓中，除了UI线程/主线程以外，普通的线程(先不提HandlerThread)是不自带Looper的。想要通过UI线程与子线程通信需要在子线程内自己实现一个Looper。开启Looper分三步走： 判定是否已有Looper并Looper.prepare() 做一些准备工作(如暴露handler等) 调用Looper.loop()，线程进入阻塞态 由于每一个线程内最多只可以有一个Looper，所以一定要在Looper.prepare()之前做好判定，否则会抛出java.lang.RuntimeException: Only one Looper may be created per thread。为了获取Looper的信息可以使用两个方法： Looper.myLooper() Looper.getMainLooper() Looper.myLooper()获取当前线程绑定的Looper，如果没有返回null。Looper.getMainLooper()返回主线程的Looper,这样就可以方便的与主线程通信。 总结 Looper调用prepare()进行初始化，创建了一个与当前线程对应的Looper对象（通过ThreadLocal实现），并且初始化了一个与当前Looper对应的MessageQueue对象。 Looper调用静态方法loop()开始消息循环，通过MessageQueue.next()方法获取Message对象。 当获取到一个Message对象时，让Message的发送者（target）去处理它。 Message对象包括数据，发送者（Handler），可执行代码段（Runnable）三个部分组成。 Handler可以在一个已经Looper.prepare()的线程中初始化，如果线程没有初始化Looper，创建Handler对象会失败 一个线程的执行流中可以构造多个Handler对象，它们都往同一个MQ中发消息，消息也只会分发给对应的Handler处理。 Handler将消息发送到MQ中，Message的target域会引用自己的发送者，Looper从MQ中取出来后，再交给发送这个Message的Handler去处理。 Message可以直接添加一个Runnable对象，当这条消息被处理的时候，直接执行Runnable.run()方法。 Handler的内存泄露问题再来看看我们的新建Handler的代码： private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; ... &#125;&#125;; 当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有Activity的引用。 而Handler通常会伴随着一个耗时的后台线程一起出现，这个后台线程在任务执行完毕后发送消息去更新UI。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束。 另外，如果执行了Handler的postDelayed()方法，那么在设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。 解决方法之一，使用弱引用： static class MyHandler extends Handler &#123; WeakReference&lt;Activity &gt; mActivityReference; MyHandler(Activity activity) &#123; mActivityReference= new WeakReference&lt;Activity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; final Activity activity = mActivityReference.get(); if (activity != null) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;&#125; 从JDK1.2开始，Java把对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 强引用：我们一般使用的就是强引用，垃圾回收器一般都不会对其进行回收操作。当内存空间不足时Java虚拟机宁愿抛出OutOfMemoryError错误使程序异常终止，也不会回收具有强引用的对象。 软引用(SoftReference)：如果一个对象具有软引用(SoftReference)，在内存空间足够的时候GC不会回收它，如果内存空间不足了GC就会回收这些对象的内存空间。 弱引用(WeakReference) ：如果一个对象具有弱引用(WeakReference)，那么当GC线程扫描的过程中一旦发现某个对象只具有弱引用而不存在强引用时不管当前内存空间足够与否GC都会回收它的内存。由于垃圾回收器是一个优先级较低的线程，所以不一定会很快发现那些只具有弱引用的对象。为了防止内存溢出，在处理一些占用内存大而且生命周期较长的对象时候，可以尽量使用软引用和弱引用。 虚引用(PhantomReference) ：虚引用(PhantomReference)与其他三种引用都不同，它并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。所以，虚引用主要用来跟踪对象被垃圾回收器回收的活动，在一般的开发中并不会使用它。 进程、线程间通信方式文章最后，我们来整理一下进程、线程间通信方式，参考线程通信与进程通信的区别。看看Handler消息传递机制属于哪种？ 一、进程间的通信方式 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 IPC 数据拷贝次数 共享内存 0 Android Binder 1 Socket/管道/消息队列 2 二、线程间的通信方式 锁机制：包括互斥锁、条件变量、读写锁 互斥锁提供了以排他方式防止数据结构被并发修改的方法。 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量 信号机制(Signal)：类似进程间的信号处理 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。 很明显，Android的Handler消息机制使用消息队列( MessageQueue )实现的线程间通信方式。而Binder是Android建立额一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求。Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送方添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。此处就不对Binder作更多介绍了。 参考资料 Android消息机制1-Handler(Java层) 从Handler.post(Runnable r)再一次梳理Android的消息机制 Android 进阶14：源码解读 Android 消息机制（ Message MessageQueue Handler Looper） Android源码：Handler, Looper和MessageQueue实现解析 深入探讨Android异步精髓Handler Android消息机制 哈工大面试指导：Android中的Thread, Looper和Handler机制 Android 线程本地变量&lt;一&gt; ThreadLocal源码解析 Android线程管理之ThreadLocal理解及应用场景","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://github.com/tags/源码分析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】Binder - 如何使用AIDL","slug":"【Android】Binder - 如何使用AIDL","date":"2017-08-02T14:20:55.000Z","updated":"2017-12-23T07:49:18.743Z","comments":true,"path":"2017/08/02/【Android】Binder - 如何使用AIDL/","link":"","permalink":"http://github.com/2017/08/02/【Android】Binder - 如何使用AIDL/","excerpt":"一、跨进程通信为了演示方便，将Service与Activity处于不同的进程，可以在AndroidManifest.xml中，把service配置成android:process=&quot;:remote&quot; ，也可以命名成其他的。 AIDL（1） IRemoteService.aidl：定义Server端提供的服务接口 // IRemoteService.aidlpackage com.cuc.myandroidtest;import com.cuc.myandroidtest.MyData;import com.cuc.myandroidtest.IServiceCallback;interface IRemoteService &#123; int getPid(); //获取服务端进程ID MyData getMyData(); //从服务端获取数据 void registerCallback(IServiceCallback callback); //注册服务端回调 void unregisterCallback();&#125; （2） IServiceCallBack.aidl：定义服务端回调接口，把Service的下载进度通知给客户端ClientActivity // IServiceCallBack.aidlpackage com.cuc.myandroidtest;interface IServiceCallback &#123; void onDownloadProgress(double progress); //服务端下载进度通知 void onDownloadCompleted(); //下载完成通知&#125; （3） MyData.aidl：定义传输的Parcel数据 // MyData.aidlpackage com.cuc.myandroidtest;parcelable MyData;","text":"一、跨进程通信为了演示方便，将Service与Activity处于不同的进程，可以在AndroidManifest.xml中，把service配置成android:process=&quot;:remote&quot; ，也可以命名成其他的。 AIDL（1） IRemoteService.aidl：定义Server端提供的服务接口 // IRemoteService.aidlpackage com.cuc.myandroidtest;import com.cuc.myandroidtest.MyData;import com.cuc.myandroidtest.IServiceCallback;interface IRemoteService &#123; int getPid(); //获取服务端进程ID MyData getMyData(); //从服务端获取数据 void registerCallback(IServiceCallback callback); //注册服务端回调 void unregisterCallback();&#125; （2） IServiceCallBack.aidl：定义服务端回调接口，把Service的下载进度通知给客户端ClientActivity // IServiceCallBack.aidlpackage com.cuc.myandroidtest;interface IServiceCallback &#123; void onDownloadProgress(double progress); //服务端下载进度通知 void onDownloadCompleted(); //下载完成通知&#125; （3） MyData.aidl：定义传输的Parcel数据 // MyData.aidlpackage com.cuc.myandroidtest;parcelable MyData; Parcel数据public class MyData implements Parcelable&#123; int data1; int data2; String key; public MyData()&#123;&#125; protected MyData(Parcel in) &#123; data1 = in.readInt(); data2 = in.readInt(); key = in.readString(); &#125; public static final Creator&lt;MyData&gt; CREATOR = new Creator&lt;MyData&gt;() &#123; @Override public MyData createFromParcel(Parcel in) &#123; return new MyData(in); &#125; @Override public MyData[] newArray(int size) &#123; return new MyData[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; /** 将数据写入到Parcel **/ @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(data1); dest.writeInt(data2); dest.writeString(key); &#125; public int getData1() &#123; return data1; &#125; public void setData1(int data1) &#123; this.data1 = data1; &#125; public int getData2() &#123; return data2; &#125; public void setData2(int data2) &#123; this.data2 = data2; &#125; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125;&#125; Server端public class RemoteService extends Service &#123; private static final String TAG = \"BinderSimple\"; int mDownloadCount = 0; MyData mMyData; IServiceCallback mCallback; //用来通知客户端的回调 ScheduledExecutorService mThreadPool; //下载线程 @Override public void onCreate() &#123; super.onCreate(); Log.i(TAG, \"[RemoteService] onCreate\"); mMyData = new MyData(); mMyData.setData1(10); mMyData.setData2(20); mMyData.setKey(\"在那遥远的地方\"); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(TAG,\"[RemoteService] onBind\"); //开始下载 startDownloadThread(); return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.i(TAG, \"[RemoteService] onUnbind\"); try &#123; mBinder.unregisterCallback(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; return super.onUnbind(intent); &#125; @Override public void onDestroy() &#123; Log.i(TAG, \"[RemoteService] onDestroy\"); super.onDestroy(); &#125; /** * 实现接口IRemoteService.aidl中定义的方法 */ private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; @Override public int getPid() throws RemoteException &#123; Log.i(TAG,\"[RemoteService] getPid() = \" + android.os.Process.myPid()); return android.os.Process.myPid(); &#125; @Override public MyData getMyData() throws RemoteException &#123; Log.i(TAG,\"[RemoteService] getMyData() \" + mMyData.toString()); return mMyData; &#125; @Override public void registerCallback(IServiceCallback callback) throws RemoteException &#123; Log.i(TAG,\"[RemoteService] registerCallback() \"); mCallback = callback; &#125; @Override public void unregisterCallback() throws RemoteException &#123; Log.i(TAG,\"[RemoteService] unregisterCallback() \"); mCallback = null; &#125; /**此处可用于权限拦截**/ @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; return super.onTransact(code, data, reply, flags); &#125; &#125;; /** * 模拟下载线程 */ private void startDownloadThread()&#123; Log.i(TAG,\"[RemoteService] startDownloadThread()\"); //2秒后开始下载 mThreadPool = Executors.newScheduledThreadPool(1); mThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; try &#123; mDownloadCount++; if(mCallback != null)&#123; mCallback.onDownloadProgress((double) mDownloadCount / 100.0); if (mDownloadCount == 100) &#123; mCallback.onDownloadCompleted(); mThreadPool.shutdown(); &#125; &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, 2000, 50, TimeUnit.MILLISECONDS); &#125;&#125; Client端public class ClientActivity extends AppCompatActivity &#123; private static final String TAG = \"BinderSimple\"; private IRemoteService mRemoteService; private TextView textView; private boolean mIsBound; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_client); textView = (TextView) findViewById(R.id.tv); Button btn0 = (Button) findViewById(R.id.btn_bind); Button btn1 = (Button) findViewById(R.id.btn_unbind); Button btn2 = (Button) findViewById(R.id.btn_kill); btn0.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; bindMyService(); &#125; &#125;); btn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; unBindMyService(); &#125; &#125;); btn2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; killMyService(); &#125; &#125;); &#125; private ServiceConnection mRemoteConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //注意这里，把Server返回的Binder对象转换成了IRemoteService接口对象 mRemoteService = IRemoteService.Stub.asInterface(service); try &#123; mRemoteService.registerCallback(mServiceCallbackBinder); MyData myData = mRemoteService.getMyData(); String pidInfo = \" servicePid = \"+ mRemoteService.getPid() + \"\\n myPid = \" + android.os.Process.myPid() + \"\\n data1 = \"+ myData.getData1() + \"\\n data2 = \"+ myData.getData2() + \"\\n key = \"+ myData.getKey(); Log.i(TAG, \"[ClientActivity] onServiceConnected\\n\" + pidInfo); textView.setText(pidInfo); Toast.makeText(ClientActivity.this, \"remoteService 连接成功\", Toast.LENGTH_SHORT).show(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.i(TAG, \"[ClientActivity] onServiceDisconnected\"); mRemoteService = null; Toast.makeText(ClientActivity.this, \"remoteService 断开连接\", Toast.LENGTH_SHORT).show(); &#125; &#125;; //服务回调 private IServiceCallback.Stub mServiceCallbackBinder = new IServiceCallback.Stub()&#123; @Override public void onDownloadProgress(final double progress) throws RemoteException &#123; Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; textView.setText(\"下载进度:\" + progress); &#125; &#125;); &#125; @Override public void onDownloadCompleted() throws RemoteException &#123; Log.i(TAG, \"[ClientActivity] mServiceCallbackBinder -&gt; onDownloadCompleted\"); Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; textView.setText(\"下载完成\"); &#125; &#125;); &#125; &#125;; /** * 绑定远程服务 */ private void bindMyService()&#123; Log.i(TAG, \"[ClientActivity] bindMyService\"); Intent intent = new Intent(ClientActivity.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mRemoteConnection, Context.BIND_AUTO_CREATE); mIsBound = true; textView.setText(\"bind success\"); &#125; /** * 解除绑定远程服务 */ private void unBindMyService()&#123; if(!mIsBound)&#123; return; &#125; Log.i(TAG, \"[ClientActivity] unBindMyService\"); unbindService(mRemoteConnection); mIsBound = false; textView.setText(\"unbind\"); &#125; /** * 杀死远程服务 */ private void killMyService()&#123; Log.i(TAG, \"[ClientActivity] killMyService\"); try &#123; android.os.Process.killProcess(mRemoteService.getPid()); textView.setText(\"kill success\"); &#125; catch (RemoteException e) &#123; e.printStackTrace(); Toast.makeText(ClientActivity.this, \"kill failed\", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 运行该工程会生成一个apk，安装到手机，打开apk，界面如下： 界面上有三个按钮，分别是功能分别是： bindService（绑定Service） unbindService（解除绑定Service） killProcess（杀死Service进程） 从左往右，依次点击界面，可得： 二、同一进程如果Activity和Service位于同一进程内，也可以使用上面的方式。不过还有一种方法是下面这种。 AIDL文件、Parcel数据与上面均一致，下面仅列出不同的Server端和Client端的实现。 Server端public class LocalService extends Service &#123; private static final String TAG = \"BinderSimple\"; //封装的服务端功能对象，供Client端bindService之后调用 private LocalServerFunc mBinder = new LocalServerFunc(); @Override public void onCreate() &#123; super.onCreate(); Log.i(TAG, \"[LocalService] onCreate\"); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(TAG,\"[LocalService] onBind\"); //开启下载线程 mBinder.startDownloadThread(); return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.i(TAG, \"[LocalService] onUnbind\"); try &#123; mBinder.unregisterCallback(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; return super.onUnbind(intent); &#125; @Override public void onDestroy() &#123; Log.i(TAG, \"[LocalService] onDestroy\"); super.onDestroy(); &#125;&#125; 因为，Service被bind了之后，需要返回一个IBinder对象。所以需要继承自Binder封装一个IBinder对象供客户端调用。 public class LocalServerFunc extends Binder implements IRemoteService &#123; private static final String TAG = \"BinderSimple\"; int mDownloadCount = 0; MyData mMyData; IServiceCallback mCallback; ScheduledExecutorService mThreadPool; public LocalServerFunc()&#123; mMyData = new MyData(); mMyData.setData1(66); mMyData.setData2(88); mMyData.setKey(\"就在眼前\"); &#125; public void startDownloadThread()&#123; Log.i(TAG,\"[LocalServerFunc] startDownloadThread()\"); mThreadPool = Executors.newScheduledThreadPool(1); mThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; try &#123; mDownloadCount++; if(mCallback != null)&#123; mCallback.onDownloadProgress((double) mDownloadCount / 100.0); if (mDownloadCount == 100) &#123; mCallback.onDownloadCompleted(); mThreadPool.shutdown(); &#125; &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, 2000, 50, TimeUnit.MILLISECONDS); &#125; @Override public int getPid() throws RemoteException &#123; Log.i(TAG,\"[LocalServerFunc] getPid()\"); return android.os.Process.myPid(); &#125; @Override public MyData getMyData() throws RemoteException &#123; Log.i(TAG,\"[LocalServerFunc] getMyData()\"); return mMyData; &#125; @Override public void registerCallback(IServiceCallback callback) throws RemoteException &#123; Log.i(TAG,\"[LocalServerFunc] registerCallback()\"); mCallback = callback; &#125; @Override public void unregisterCallback() throws RemoteException &#123; Log.i(TAG,\"[LocalServerFunc] unregisterCallback()\"); if(mThreadPool != null)&#123; mThreadPool.shutdown(); &#125; mCallback = null; &#125; @Override public IBinder asBinder() &#123; return null; &#125;&#125; Client端public class ClientActivity extends AppCompatActivity &#123; private static final String TAG = \"BinderSimple\"; private IRemoteService mLocalService; private TextView textView; private boolean mIsBound; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_client); textView = (TextView) findViewById(R.id.tv); Button btn0 = (Button) findViewById(R.id.btn_bind); Button btn1 = (Button) findViewById(R.id.btn_unbind); Button btn2 = (Button) findViewById(R.id.btn_kill); btn0.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; bindMyService(); &#125; &#125;); btn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; unBindMyService(); &#125; &#125;); btn2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; killMyService(); &#125; &#125;); &#125; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //注意这个Binder对象转换成IRemoteService接口方式的不同 mLocalService = (IRemoteService) service; try &#123; mLocalService.registerCallback(mLocalServiceCallback); MyData myData = mLocalService.getMyData(); String pidInfo = \" servicePid = \"+ mLocalService.getPid() + \"\\n myPid = \" + android.os.Process.myPid() + \"\\n data1 = \"+ myData.getData1() + \"\\n data2 = \"+ myData.getData2() + \"\\n key = \"+ myData.getKey(); Log.i(TAG, \"[ClientActivity] onServiceConnected\\n\" + pidInfo); textView.setText(pidInfo); Toast.makeText(ClientActivity.this, \"localService 连接成功\", Toast.LENGTH_SHORT).show(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.i(TAG, \"[ClientActivity] onServiceDisconnected\"); mLocalService = null; Toast.makeText(ClientActivity.this, \"localService 断开连接\", Toast.LENGTH_SHORT).show(); &#125; &#125;; //服务回调，注意这个对象的不同 private IServiceCallback mLocalServiceCallback = new IServiceCallback() &#123; @Override public void onDownloadProgress(final double progress) throws RemoteException &#123; Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; textView.setText(\"下载进度:\" + progress); &#125; &#125;); &#125; @Override public void onDownloadCompleted() throws RemoteException &#123; Log.i(TAG, \"[ClientActivity] mServiceCallback -&gt; onDownloadCompleted\"); Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; textView.setText(\"下载完成\"); &#125; &#125;); &#125; @Override public IBinder asBinder() &#123; return null; &#125; &#125;; /** * 绑定服务 */ private void bindMyService()&#123; Log.i(TAG, \"[ClientActivity] bindMyService\"); Intent intent = new Intent(ClientActivity.this, LocalService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); mIsBound = true; textView.setText(\"bind success\"); &#125; /** * 解除绑定服务 */ private void unBindMyService()&#123; if(!mIsBound)&#123; return; &#125; Log.i(TAG, \"[ClientActivity] unBindMyService\"); unbindService(mServiceConnection); mIsBound = false; textView.setText(\"unbind\"); &#125; /** * 杀死服务 */ private void killMyService()&#123; Log.i(TAG, \"[ClientActivity] killMyService\"); try &#123; android.os.Process.killProcess(mLocalService.getPid()); textView.setText(\"kill success\"); &#125; catch (RemoteException e) &#123; e.printStackTrace(); Toast.makeText(ClientActivity.this, \"kill failed\", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 运行因为这个Acitivy和Sevice位于同一进程，所以当点击KILL按钮杀死Service进程时，Activity也会同时被杀掉，所以可以看到动画最后就退出了App。 从左往右，依次点击三个按钮，可得： 简单看AIDL的原理IRemoteService.aidl文件和IServiceCallback.aidl文件生成的接口文件分别如下： #IRemoteService.java/* * This file is auto-generated. DO NOT MODIFY. */public interface IRemoteService extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.cuc.myandroidtest.IRemoteService &#123; private static final java.lang.String DESCRIPTOR = \"com.cuc.myandroidtest.IRemoteService\"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.cuc.myandroidtest.IRemoteService interface, * generating a proxy if needed. */ public static com.cuc.myandroidtest.IRemoteService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.cuc.myandroidtest.IRemoteService))) &#123; return ((com.cuc.myandroidtest.IRemoteService) iin); &#125; return new com.cuc.myandroidtest.IRemoteService.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getPid: &#123; data.enforceInterface(DESCRIPTOR); int _result = this.getPid(); reply.writeNoException(); reply.writeInt(_result); return true; &#125; case TRANSACTION_getMyData: &#123; data.enforceInterface(DESCRIPTOR); com.cuc.myandroidtest.MyData _result = this.getMyData(); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; case TRANSACTION_registerCallback: &#123; data.enforceInterface(DESCRIPTOR); com.cuc.myandroidtest.IServiceCallback _arg0; _arg0 = com.cuc.myandroidtest.IServiceCallback.Stub.asInterface(data.readStrongBinder()); this.registerCallback(_arg0); reply.writeNoException(); return true; &#125; case TRANSACTION_unregisterCallback: &#123; data.enforceInterface(DESCRIPTOR); this.unregisterCallback(); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.cuc.myandroidtest.IRemoteService &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public int getPid() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public com.cuc.myandroidtest.MyData getMyData() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.cuc.myandroidtest.MyData _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getMyData, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) &#123; _result = com.cuc.myandroidtest.MyData.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void registerCallback(com.cuc.myandroidtest.IServiceCallback callback) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeStrongBinder((((callback != null)) ? (callback.asBinder()) : (null))); mRemote.transact(Stub.TRANSACTION_registerCallback, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; @Override public void unregisterCallback() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_unregisterCallback, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getPid = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_getMyData = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); static final int TRANSACTION_registerCallback = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2); static final int TRANSACTION_unregisterCallback = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3); &#125; public int getPid() throws android.os.RemoteException; public com.cuc.myandroidtest.MyData getMyData() throws android.os.RemoteException; public void registerCallback(com.cuc.myandroidtest.IServiceCallback callback) throws android.os.RemoteException; public void unregisterCallback() throws android.os.RemoteException;&#125; #IServiceCallback.java/* * This file is auto-generated. DO NOT MODIFY. */public interface IServiceCallback extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.cuc.myandroidtest.IServiceCallback &#123; private static final java.lang.String DESCRIPTOR = \"com.cuc.myandroidtest.IServiceCallback\"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.cuc.myandroidtest.IServiceCallback interface, * generating a proxy if needed. */ public static com.cuc.myandroidtest.IServiceCallback asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.cuc.myandroidtest.IServiceCallback))) &#123; return ((com.cuc.myandroidtest.IServiceCallback) iin); &#125; return new com.cuc.myandroidtest.IServiceCallback.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_onDownloadProgress: &#123; data.enforceInterface(DESCRIPTOR); double _arg0; _arg0 = data.readDouble(); this.onDownloadProgress(_arg0); reply.writeNoException(); return true; &#125; case TRANSACTION_onDownloadCompleted: &#123; data.enforceInterface(DESCRIPTOR); this.onDownloadCompleted(); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.cuc.myandroidtest.IServiceCallback &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public void onDownloadProgress(double progress) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeDouble(progress); mRemote.transact(Stub.TRANSACTION_onDownloadProgress, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; //下载进度 @Override public void onDownloadCompleted() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_onDownloadCompleted, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_onDownloadProgress = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_onDownloadCompleted = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public void onDownloadProgress(double progress) throws android.os.RemoteException; //下载进度 public void onDownloadCompleted() throws android.os.RemoteException;&#125; 参考资料 Android 接口定义语言 (AIDL) - Google Developer文档 Binder系列9—如何使用AIDL Android跨进程bindService与callback 在Activity和Service之间使用本地Binder和回调接口进行通信","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"连通图的最大生成树的权和","slug":"Google 笔试题 - 连通图的最大生成树的权和","date":"2017-07-31T09:20:55.000Z","updated":"2017-08-01T02:27:59.366Z","comments":true,"path":"2017/07/31/Google 笔试题 - 连通图的最大生成树的权和/","link":"","permalink":"http://github.com/2017/07/31/Google 笔试题 - 连通图的最大生成树的权和/","excerpt":"这是一道Google 笔试题 题目一个有n个结点的连通图的生成树是原图的最小连通子图, 且包含原图中所有n个结点，并且有保持图联通的最少的边。最大生成树就是权和最大生成树，现在给出一个无向带权图的邻接矩阵，权为0表示没有边。&#123;&#123;0, 4, 5, 0, 3&#125;, &#123;4, 0, 4, 2, 3&#125;, &#123;5, 4, 0, 2, 0&#125;, &#123;0, 2, 2, 0, 1&#125;, &#123;3, 3, 0, 1, 0&#125;&#125; 求这个图的最大生成树的权和。 A、11 B、12 C、13 D、14 E、15","text":"这是一道Google 笔试题 题目一个有n个结点的连通图的生成树是原图的最小连通子图, 且包含原图中所有n个结点，并且有保持图联通的最少的边。最大生成树就是权和最大生成树，现在给出一个无向带权图的邻接矩阵，权为0表示没有边。&#123;&#123;0, 4, 5, 0, 3&#125;, &#123;4, 0, 4, 2, 3&#125;, &#123;5, 4, 0, 2, 0&#125;, &#123;0, 2, 2, 0, 1&#125;, &#123;3, 3, 0, 1, 0&#125;&#125; 求这个图的最大生成树的权和。 A、11 B、12 C、13 D、14 E、15 分析题意是在考察最大生成树，我们需要根据给出的邻接矩阵代表的无向带权图求出最大生成树，然后计算权和就很简单水到渠成了。 最小生成树说到最大生成树，我们得先回顾一下最小生成树： 最小生成树其实是最小权重生成树的简称。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。也就是说最小生成树就是边权重之和最小的生成树。总结起来就是以下： 1）必须使用且仅使用该网络中的n-1条边来连接网络中的n个顶点。 2）不能使用产生回路的边。 3）各边上的权值的总和达到最小。 简单点说有几个城市你要设计一个路线，这个路线能走完所有的这几个城市，而且路程最短，这个路线就是最小生成树的含义。相反地，最大生成树就是边权重之和最大的生成树。 那么，如何生成最小生成树呢？常用的算法有Prim算法（普里姆算法）和Kruskal算法（克鲁斯克尔算法）。 Prim算法Prim算法是用来从带权图中搜索最小生成树的一种算法。 从单一顶点开始，Prim普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。 输入：一个加权连通图，其中顶点集合为$V$ ，边集合为$E$； 初始化：$V_{new} = {x}$ ，其中x为集合V中的任一节点（起始点）， $E_{new} = \\{\\}$ ； 重复下列操作，直到$V_{new} = V$ ： a. 在集合E中选取权值最小的边（u, v），其中u为集合$V_{new}​$中的元素，而v则是V中没有加入$V_{new}​$的顶点（如b. 果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；将v加入集合$V_{new}​$中，将（u, v）加入集合$E_{new}​$中； 输出：使用集合$V_{new}$和$E_{new}$来描述所得到的最小生成树。 算法伪代码： Prim(G, T) &#123; T = NULL; U = &#123;w&#125;; //添加任一顶点w while((V - U)!=NULL) &#123; 设(u, v)是u ∈ U 与 v ∈ （V - U),且权值最小的边 T = T ∪ (u, v); U = U ∪ v ; &#125;&#125; 说白了，就是将起点u（任一节点）放入空集合S，则S = {u}；再找到距离集合S最近的一点u，加入S集合。直到所有节点都加入进来。 Prim算法时间复杂度为O(V^2)，比较适合于求稠密图的最小生成树。 Kruskal算法Kruskal算法是一种按权值的递增次序选择合适的边来构成最小生成树的方法。算法描述如下： 新建图G，G中拥有原图中相同的节点，但没有边 将原图中所有的边按权值从小到大排序 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中 重复3，直至图G中所有的节点都在同一个连通分量中 算法伪代码： KRUSKAL-FUNCTION(G, w) F := 空集合 for each 图 G 中的顶点 v do 將 v 加入森林 F 所有的边(u, v) ∈ E依权重 w 递增排序 for each 边(u, v) ∈ E do if u 和 v 不在同一棵子树 then F := F ∪ &#123;(u, v)&#125; 將 u 和 v 所在的子树合并 小结Prim算法：是针对顶点展开的，适合于边数较多的情况。 Kruskal算法：是针对边展开的，适合于边的数量较少的情况。 解决使用Krustal算法或者Prime算法构造“”最大生成树”： Prime算法：选择权重最大的边的两个顶点加入等价类 Krustal算法：即每次选择权重最大的边加入森林； 我们看邻接矩阵 A B C D E A 0 4 5 0 3 B 4 0 4 2 3 C 5 4 0 2 0 D 0 2 2 0 1 E 3 3 0 1 0 利用Krustal算法，选择最大的边加入，但是不能形成回路，图中表黑的就是被选出的，DE边是不能选的，否则就形成闭路。总共5+4+3+2=14 参考资料 数据结构深入剖析（14）–最小连通图 图的常见算法 数据结构之图的存储方式","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Google","slug":"Google","permalink":"http://github.com/tags/Google/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"八大排序算法总结与java实现","slug":"八大排序算法总结与java实现","date":"2017-07-18T04:30:55.000Z","updated":"2017-11-21T11:29:55.307Z","comments":true,"path":"2017/07/18/八大排序算法总结与java实现/","link":"","permalink":"http://github.com/2017/07/18/八大排序算法总结与java实现/","excerpt":"概述因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法： 直接插入排序 希尔排序 简单选择排序 堆排序 冒泡排序 快速排序 归并排序 基数排序","text":"概述因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法： 直接插入排序 希尔排序 简单选择排序 堆排序 冒泡排序 快速排序 归并排序 基数排序 我们讨论的这八大排序算法的实现可以参考我的Github：SortAlgorithms，其中也包括了排序测试模块[Test.java]和排序算法对比模块[Bench.java]，大家可以试运行。 它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下： $$ \\begin{cases} 内部排序 \\begin{cases} 插入排序 \\begin{cases} 直接插入排序\\\\ 希尔排序 \\end{cases} \\\\ 选择排序 \\begin{cases} 简单选择排序\\\\ 堆排序 \\end{cases} \\\\ 交换排序 \\begin{cases} 冒泡排序\\\\ 快速排序 \\end{cases} \\\\ 归并排序\\\\ 基数排序 \\end{cases} \\\\ 外部排序 \\end{cases} $$ 一、直接插入排序（Insertion Sort） 插入排序的设计初衷是往有序的数组中快速插入一个新的元素。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的. 插入排序由于操作不尽相同, 可分为 直接插入排序 , 折半插入排序(又称二分插入排序), 链表插入排序 , 希尔排序 。我们先来看下直接插入排序。 1、基本思想直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。 2、算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： ①. 从第一个元素开始，该元素可以认为已经被排序②. 取出下一个元素，在已经排序的元素序列中从后向前扫描③. 如果该元素（已排序）大于新元素，将该元素移到下一位置④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置⑤. 将新元素插入到该位置后⑥. 重复步骤②~⑤ 如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。 3、代码实现/** * 插入排序 * * 1. 从第一个元素开始，该元素可以认为已经被排序 * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描 * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置 * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 * 5. 将新元素插入到该位置后 * 6. 重复步骤2~5 * @param arr 待排序数组 */public static void insertionSort(int[] arr)&#123; for( int i=0; i&lt;arr.length-1; i++ ) &#123; for( int j=i+1; j&gt;0; j-- ) &#123; if( arr[j-1] &lt;= arr[j] ) break; int temp = arr[j]; //交换操作 arr[j] = arr[j-1]; arr[j-1] = temp; System.out.println(\"Sorting: \" + Arrays.toString(arr)); &#125; &#125;&#125; 直接插入排序复杂度如下： 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n²) O(n²) O(1) Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。 二、希尔排序（Shell Sort） 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。 希尔排序，也称递减增量排序算法，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。 希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 1、基本思想 将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。 可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考维基百科。 2、算法描述①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）②. 按增量序列个数k，对序列进行k 趟排序；③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 3、代码实现以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。 /** * 希尔排序 * * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1） * 2. 按增量序列个数k，对序列进行k 趟排序； * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。 * 仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 * @param arr 待排序数组 */public static void shellSort(int[] arr)&#123; int gap = arr.length / 2; for (; gap &gt; 0; gap /= 2) &#123; //不断缩小gap，直到1为止 for (int j = 0; (j+gap) &lt; arr.length; j++)&#123; //使用当前gap进行组内插入排序 for(int k = 0; (k+gap)&lt; arr.length; k += gap)&#123; if(arr[k] &gt; arr[k+gap]) &#123; int temp = arr[k+gap]; //交换操作 arr[k+gap] = arr[k]; arr[k] = temp; System.out.println(\" Sorting: \" + Arrays.toString(arr)); &#125; &#125; &#125; &#125;&#125; 注意： ①. 第一层for循环表示一共有多少个增量。增量的序列的个数，就是希尔排序的趟数。上面的增量序列为： arr.length/2, arr.length/2/2, arr.length/2/2/2, .... 2, 1②. 里层的两个for循环，实际上就是以一个gap拆分为一组的组内插入排序。 下面是维基百科官方实现，大家注意gap步长取值部分： /** * 希尔排序（Wiki官方版） * * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值） * 2. 按增量序列个数k，对序列进行k 趟排序； * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。 * 仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 * @param arr 待排序数组 */public static void shell_sort(int[] arr) &#123; int gap = 1, i, j, len = arr.length; int temp; while (gap &lt; len / 3) gap = gap * 3 + 1; // &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ... for (; gap &gt; 0; gap /= 3) &#123; for (i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; &#125; &#125;&#125; 以下是希尔排序复杂度: 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog2 n) O(nlog2 n) O(nlog2 n) O(1) 三、选择排序（Selection Sort） 从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。 1、基本思想选择排序的基本思想：比较 + 交换。 在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 2、算法描述①. 从待排序序列中，找到关键字最小的元素；②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。 3、代码实现选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。 /** * 选择排序 * * 1. 从待排序序列中，找到关键字最小的元素； * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换； * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。 * 仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 * @param arr 待排序数组 */public static void selectionSort(int[] arr)&#123; for(int i = 0; i &lt; arr.length-1; i++)&#123; int min = i; for(int j = i+1; j &lt; arr.length; j++)&#123; //选出之后待排序中值最小的位置 if(arr[j] &lt; arr[min])&#123; min = j; &#125; &#125; if(min != i)&#123; int temp = arr[min]; //交换操作 arr[min] = arr[i]; arr[i] = temp; System.out.println(\"Sorting: \" + Arrays.toString(arr)); &#125; &#125;&#125; 以下是选择排序复杂度: 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n²) O(n²) O(1) 选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。 四、堆排序（Heap Sort） 1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort). 堆的定义如下：$n$个元素的序列 $\\left\\{{k_1,k_2,···,k_n}\\right\\}$ 当且仅当满足下关系时，称之为堆。 $$ \\left\\{ \\begin{aligned} k_i & \\leqslant k_{2i} \\\\ k_i & \\leqslant k_{2i+1} \\end{aligned} \\right. \\quad 或 \\quad \\left\\{ \\begin{aligned} k_i & \\geqslant k_{2i} \\\\ k_i & \\geqslant k_{2i+1} \\end{aligned} \\right. \\quad (i = 1,2,···, \\left \\lfloor { \\frac{n}{2} } \\right \\rfloor ) $$ 把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。 1、基本思想此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。 2、算法描述①. 先将初始序列$K[1..n]$建成一个大顶堆, 那么此时第一个元素$K_1$最大, 此堆为初始的无序区.②. 再将关键字最大的记录$K_1$ (即堆顶, 第一个元素)和无序区的最后一个记录 $K_n$ 交换, 由此得到新的无序区$K[1..n-1]$和有序区$K[n]$, 且满足$K[1..n-1].keys \\leqslant K[n].key$③. 交换$K_1$ 和 $K_n$ 后, 堆顶可能违反堆性质, 因此需将$K[1..n-1]$调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止. 动图效果如下所示： 3、代码实现从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。 总结起来就是定义了以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 对于堆节点的访问： 父节点i的左子节点在位置：(2*i+1); 父节点i的右子节点在位置：(2*i+2); 子节点i的父节点在位置：floor((i-1)/2); /** * 堆排序 * * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区. * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止. * @param arr 待排序数组 */public static void heapSort(int[] arr)&#123; for(int i = arr.length; i &gt; 0; i--)&#123; max_heapify(arr, i); int temp = arr[0]; //堆顶元素(第一个元素)与Kn交换 arr[0] = arr[i-1]; arr[i-1] = temp; &#125;&#125;private static void max_heapify(int[] arr, int limit)&#123; if(arr.length &lt;= 0 || arr.length &lt; limit) return; int parentIdx = limit / 2; for(; parentIdx &gt;= 0; parentIdx--)&#123; if(parentIdx * 2 &gt;= limit)&#123; continue; &#125; int left = parentIdx * 2; //左子节点位置 int right = (left + 1) &gt;= limit ? left : (left + 1); //右子节点位置，如果没有右节点，默认为左节点位置 int maxChildId = arr[left] &gt;= arr[right] ? left : right; if(arr[maxChildId] &gt; arr[parentIdx])&#123; //交换父节点与左右子节点中的最大值 int temp = arr[parentIdx]; arr[parentIdx] = arr[maxChildId]; arr[maxChildId] = temp; &#125; &#125; System.out.println(\"Max_Heapify: \" + Arrays.toString(arr));&#125; 注: x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 == Math.floor(x/2) . 以上,①. 建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn). 平均时间复杂度 最好情况 最坏情况 空间复杂度 $O(n \\log_{2}n)$ $O(n \\log_{2}n)$ $O(n \\log_{2}n)$ O(1) Tips: 由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列. 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序. 五、冒泡排序（Bubble Sort） 我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。 1、基本思想冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 2、算法描述冒泡排序算法的运作如下： ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。③. 针对所有的元素重复以上的步骤，除了最后一个。④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。 3、代码实现冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束. /** * 冒泡排序 * * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 * ③. 针对所有的元素重复以上的步骤，除了最后一个。 * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。 * @param arr 待排序数组 */public static void bubbleSort(int[] arr)&#123; for (int i = arr.length; i &gt; 0; i--) &#123; //外层循环移动游标 for(int j = 0; j &lt; i &amp;&amp; (j+1) &lt; i; j++)&#123; //内层循环遍历游标及之后(或之前)的元素 if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; System.out.println(\"Sorting: \" + Arrays.toString(arr)); &#125; &#125; &#125;&#125; 以下是冒泡排序算法复杂度: 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n) O(n²) O(1) 冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1). Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法. 六、快速排序（Quick Sort） 快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。 1、基本思想快速排序的基本思想：挖坑填数+分治法。 首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 2、算法描述快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为： ①. 从数列中挑出一个元素，称为”基准”（pivot）。②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 3、代码实现用伪代码描述如下： ①. i = L; j = R; 将基准数挖出形成第一个坑a[i]。②．j--，由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。③．i++，由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。④．再重复执行②，③二步，直到i==j，将基准数填入a[i]中 /** * 快速排序（递归） * * ①. 从数列中挑出一个元素，称为\"基准\"（pivot）。 * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 * @param arr 待排序数组 * @param low 左边界 * @param high 右边界 */public static void quickSort(int[] arr, int low, int high)&#123; if(arr.length &lt;= 0) return; if(low &gt;= high) return; int left = low; int right = high; int temp = arr[left]; //挖坑1：保存基准的值 while (left &lt; right)&#123; while(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123; //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中 right--; &#125; arr[left] = arr[right]; while(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123; //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中 left++; &#125; arr[right] = arr[left]; &#125; arr[left] = temp; //基准值填补到坑3中，准备分治递归快排 System.out.println(\"Sorting: \" + Arrays.toString(arr)); quickSort(arr, low, left-1); quickSort(arr, left+1, high);&#125; 上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？ 因为递归的本质是栈，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。 /** * 快速排序（非递归） * * ①. 从数列中挑出一个元素，称为\"基准\"（pivot）。 * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤 * @param arr 待排序数组 */public static void quickSortByStack(int[] arr)&#123; if(arr.length &lt;= 0) return; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); //初始状态的左右指针入栈 stack.push(0); stack.push(arr.length - 1); while(!stack.isEmpty())&#123; int high = stack.pop(); //出栈进行划分 int low = stack.pop(); int pivotIdx = partition(arr, low, high); //保存中间变量 if(pivotIdx &gt; low) &#123; stack.push(low); stack.push(pivotIdx - 1); &#125; if(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= 0)&#123; stack.push(pivotIdx + 1); stack.push(high); &#125; &#125;&#125;private static int partition(int[] arr, int low, int high)&#123; if(arr.length &lt;= 0) return -1; if(low &gt;= high) return -1; int l = low; int r = high; int pivot = arr[l]; //挖坑1：保存基准的值 while(l &lt; r)&#123; while(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123; //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中 r--; &#125; arr[l] = arr[r]; while(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123; //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中 l++; &#125; arr[r] = arr[l]; &#125; arr[l] = pivot; //基准值填补到坑3中，准备分治递归快排 return l;&#125; 快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。 以下是快速排序算法复杂度: 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog₂n) O(nlog₂n) O(n²) O(1)（原地分区递归版） 快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高. Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定. 七、归并排序（Merging Sort） 归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 1、基本思想归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 2、算法描述归并排序可通过两种方式实现： 自上而下的递归 自下而上的迭代 一、递归法（假设序列共有n个元素）： ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；③. 重复步骤②，直到所有元素排序完毕。 二、迭代法 ①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置④. 重复步骤③直到某一指针到达序列尾⑤. 将另一序列剩下的所有元素直接复制到合并序列尾 3、代码实现归并排序其实要做两件事： 分解：将序列每次折半拆分 合并：将划分后的序列段两两排序合并 因此，归并排序实际上就是两个操作，拆分+合并 如何合并？ L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。 首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序 如何分解？ 在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。 这里我写了递归算法如下： /** * 归并排序（递归） * * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素； * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素； * ③. 重复步骤②，直到所有元素排序完毕。 * @param arr 待排序数组 */public static int[] mergingSort(int[] arr)&#123; if(arr.length &lt;= 1) return arr; int num = arr.length &gt;&gt; 1; int[] leftArr = Arrays.copyOfRange(arr, 0, num); int[] rightArr = Arrays.copyOfRange(arr, num, arr.length); System.out.println(\"split two array: \" + Arrays.toString(leftArr) + \" And \" + Arrays.toString(rightArr)); return mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr)); //不断拆分为最小单元，再排序合并&#125;private static int[] mergeTwoArray(int[] arr1, int[] arr2)&#123; int i = 0, j = 0, k = 0; int[] result = new int[arr1.length + arr2.length]; //申请额外的空间存储合并之后的数组 while(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123; //选取两个序列中的较小值放入新数组 if(arr1[i] &lt;= arr2[j])&#123; result[k++] = arr1[i++]; &#125;else&#123; result[k++] = arr2[j++]; &#125; &#125; while(i &lt; arr1.length)&#123; //序列1中多余的元素移入新数组 result[k++] = arr1[i++]; &#125; while(j &lt; arr2.length)&#123; //序列2中多余的元素移入新数组 result[k++] = arr2[j++]; &#125; System.out.println(\"Merging: \" + Arrays.toString(result)); return result;&#125; 由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。 以下是归并排序算法复杂度: 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(n) 从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 八、基数排序（Radix Sort） 基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。 基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 1、基本思想它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 基数排序按照优先从高位或低位来排序有两种实现方案： MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。 LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。 2、算法描述我们以LSD为例，从最低位开始，具体算法描述如下： ①. 取得数组中的最大数，并取得位数；②. arr为原始数组，从最低位开始取每个位组成radix数组；③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 3、代码实现基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。 分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中 收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束 /** * 基数排序（LSD 从低位开始） * * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * * ①. 取得数组中的最大数，并取得位数； * ②. arr为原始数组，从最低位开始取每个位组成radix数组； * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）； * @param arr 待排序数组 */public static void radixSort(int[] arr)&#123; if(arr.length &lt;= 1) return; //取得数组中的最大数，并取得位数 int max = 0; for(int i = 0; i &lt; arr.length; i++)&#123; if(max &lt; arr[i])&#123; max = arr[i]; &#125; &#125; int maxDigit = 1; while(max / 10 &gt; 0)&#123; maxDigit++; max = max / 10; &#125; System.out.println(\"maxDigit: \" + maxDigit); //申请一个桶空间 int[][] buckets = new int[10][arr.length]; int base = 10; //从低位到高位，对每一位遍历，将所有元素分配到桶中 for(int i = 0; i &lt; maxDigit; i++)&#123; int[] bktLen = new int[10]; //存储各个桶中存储元素的数量 //分配：将所有元素分配到桶中 for(int j = 0; j &lt; arr.length; j++)&#123; int whichBucket = (arr[j] % base) / (base / 10); buckets[whichBucket][bktLen[whichBucket]] = arr[j]; bktLen[whichBucket]++; &#125; //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞 int k = 0; for(int b = 0; b &lt; buckets.length; b++)&#123; for(int p = 0; p &lt; bktLen[b]; p++)&#123; arr[k++] = buckets[b][p]; &#125; &#125; System.out.println(\"Sorting: \" + Arrays.toString(arr)); base *= 10; &#125;&#125; 以下是基数排序算法复杂度，其中k为最大数的位数： 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(d*(n+r)) O(d*(n+r)) O(d*(n+r)) O(n+r) 其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。 基数排序更适合用于对时间, 字符串等这些整体权值未知的数据进行排序。 Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 总结 各种排序性能对比如下，有些排序未详细介绍，暂且放到这里。实例测试结果可以看这里：八大排序算法耗时对比 。 排序类型 平均情况 最好情况 最坏情况 辅助空间 稳定性 冒泡排序 O(n²) O(n) O(n²) O(1) 稳定 选择排序 O(n²) O(n²) O(n²) O(1) 不稳定 直接插入排序 O(n²) O(n) O(n²) O(1) 稳定 折半插入排序 O(n²) O(n) O(n²) O(1) 稳定 希尔排序 O(n^1.3) O(nlogn) O(n²) O(1) 不稳定 归并排序 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(n) 稳定 快速排序 O(nlog₂n) O(nlog₂n) O(n²) O(nlog₂n) 不稳定 堆排序 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(1) 不稳定 计数排序 O(n+k) O(n+k) O(n+k) O(k) 稳定 桶排序 O(n+k) O(n+k) O(n²) O(n+k) (不)稳定 基数排序 O(d(n+k)) O(d(n+k)) O(d(n+kd)) O(n+kd) 稳定 从时间复杂度来说： (1). 平方阶O(n²)排序：各类简单排序：直接插入、直接选择和冒泡排序； (2). 线性对数阶O(nlog₂n)排序：快速排序、堆排序和归并排序； (3). O(n1+§))排序，§是介于0和1之间的常数：希尔排序 (4). 线性阶O(n)排序：基数排序，此外还有桶、箱排序。 到此，很多人会注意到基数排序的时间复杂度是最小的，那么为什么却没有快排、堆排序流行呢？我们看看下图算法导论的相关说明： 基数排序只适用于有基数的情况，而基于比较的排序适用范围就广得多。另一方面是内存上的考虑。作为一种通用的排序方法，最好不要带来意料之外的内存开销，所以各语言的默认实现都没有用基数排序，但是不能否认基数排序在各领域的应用。 时间复杂度极限当被排序的数有一些性质的时候（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如： 计数排序 复杂度O( k+n) 要求：被排序的数是0~k范围内的整数 基数排序 复杂度O( d(k+n) ) 要求：d位数，每个数位有k个取值 桶排序 复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布 但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而基于比较的排序算法时间复杂度的下限必须是O( nlgn) 。参考很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？ 说明 当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）； 而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）； 原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。 参考资料 数据结构可视化：visualgo，Sorting Algorithms Animations，CodePen &amp; sort it out 排序算法测试：Lab 1: Sorting - 哥德堡大学课件（University of Gothenburg） Sorting - 卡内基梅隆大学课件 数据结构常见的八大排序算法（详细整理） 必须知道的八大种排序算法【java实现】 十大经典排序算法 视觉直观感受 7 种常用的排序算法 JS中可能用得到的全部的排序算法 总结5种比较高效常用的排序算法 常见排序算法C++总结","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【算法】10亿int型数，统计只出现一次的数","slug":"【算法】10亿int型数，统计只出现一次的数","date":"2017-07-13T10:30:55.000Z","updated":"2017-07-13T10:37:10.583Z","comments":true,"path":"2017/07/13/【算法】10亿int型数，统计只出现一次的数/","link":"","permalink":"http://github.com/2017/07/13/【算法】10亿int型数，统计只出现一次的数/","excerpt":"题目10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？ 分析首先分析多大的内存能够表示10亿的数呢？一个int型占4字节，10亿就是40亿字节（很明显就是4GB），也就是如果完全读入内存需要占用4GB，而题目只给1GB内存，显然不可能将所有数据读入内存。 我们先不考虑时间复杂度，仅考虑解决问题。那么接下来的思路一般有两种。 位图法：用一个bit位来标识一个int整数。 分治法：分批处理这10亿的数。 一种是位图法，如果各位老司机有经验的话很快会想到int整型数是4字节（Byte），也就是32位（bit），如果能用一个bit位来标识一个int整数那么存储空间将大大减少。另一种是分治法，内存有限，我想办法分批读取处理。下面大致分析一下两种思路。","text":"题目10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？ 分析首先分析多大的内存能够表示10亿的数呢？一个int型占4字节，10亿就是40亿字节（很明显就是4GB），也就是如果完全读入内存需要占用4GB，而题目只给1GB内存，显然不可能将所有数据读入内存。 我们先不考虑时间复杂度，仅考虑解决问题。那么接下来的思路一般有两种。 位图法：用一个bit位来标识一个int整数。 分治法：分批处理这10亿的数。 一种是位图法，如果各位老司机有经验的话很快会想到int整型数是4字节（Byte），也就是32位（bit），如果能用一个bit位来标识一个int整数那么存储空间将大大减少。另一种是分治法，内存有限，我想办法分批读取处理。下面大致分析一下两种思路。 1、位图法（Bitmap）位图法是基于int型数的表示范围这个概念的，用一个bit位来标识一个int整数，若该位为1，则说明该数出现；若该位为0，则说明该数没有出现。一个int整型数占4字节（Byte），也就是32位（bit）。那么把所有int整型数字表示出来需要2^32 bit的空间，换算成字节单位也就是2^32/8 = 2^29 Byte，大约等于512MB // 插播一个常识2^10 Byte = 1024 Byte = 1KB2^30 Byte = (2^10)^3 Byte = 1024 * 1024 * 1024 Byte = 1GB 这下就好办了，只需要用512MB的内存就能存储所有的int的范围数。 具体方案那么接下来我们只需要申请一个int数组长度为 int tmp[N/32+1]即可存储完这些数据，其中N代表要进行查找的总数（这里也就是2^32），tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表: tmp[0]:可表示0~31 tmp[1]:可表示32~63 tmp[2]可表示64~95 ~~ 假设这10亿int数据为：6,3,8,32,36,……，那么具体的BitMap表示为： (1). 如何判断int数字放在哪一个tmp数组中：将数字直接除以32取整数部分(x/32)，例如：整数8除以32取整等于0，那么8就在tmp[0]上； (2). 如何确定数字放在32个位中的哪个位：将数字mod32取模(x%32)。上例中我们如何确定8在tmp[0]中的32个位中的哪个位，这种情况直接mod上32就ok，又如整数8，在tmp[0]中的第8 mod上32等于8，那么整数8就在tmp[0]中的第八个bit位（从右边数起）。 然后我们怎么统计只出现一次的数呢？每一个数出现的情况我们可以分为三种：0次、1次、大于1次。也就是说我们需要用2个bit位才能表示每个数的出现情况。此时则三种情况分别对应的bit位表示是：00、01、11 我们顺序扫描这10亿的数，在对应的双bit位上标记该数出现的次数。最后取出所有双bit位为01的int型数就可以了。 Bitmap拓展位图（Bitmap）算法思想比较简单，但关键是如何确定十进制的数映射到二进制bit位的map图。 优点： 运算效率高，不许进行比较和移位； 占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M 缺点：所有的数据不能重复。即不可对重复的数据进行排序和查找。 建立了Bit-Map之后，就可以方便的使用了。一般来说Bit-Map可作为数据的查找、去重、排序等操作。比如以下几个例子： 1、在3亿个整数中找出重复的整数个数，限制内存不足以容纳3亿个整数 对于这种场景可以采用2-BitMap来解决，即为每个整数分配2bit，用不同的0、1组合来标识特殊意思，如00表示此整数没有出现过，01表示出现一次，11表示出现过多次，就可以找出重复的整数了，其需要的内存空间是正常BitMap的2倍，为：3亿*2/8/1024/1024=71.5MB。 具体的过程如下：扫描着3亿个整数，组BitMap，先查看BitMap中的对应位置，如果00则变成01，是01则变成11，是11则保持不变，当将3亿个整数扫描完之后也就是说整个BitMap已经组装完毕。最后查看BitMap将对应位为11的整数输出即可。 2、对没有重复元素的整数进行排序 对于非重复的整数排序BitMap有着天然的优势，它只需要将给出的无重复整数扫描完毕，组装成为BitMap之后，那么直接遍历一遍Bit区域就可以达到排序效果了。 举个例子：对整数4、3、1、7、6进行排序： 直接按Bit位输出就可以得到排序结果了。 3、已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数 8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话。 4、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数 将bit-map扩展一下，用2bit表示一个数即可：0表示未出现；1表示出现一次；2表示出现2次及以上，即重复，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。 最后放一个使用Byte[]数组存储、读取bit位的示例代码，来自利用位映射原理对大数据排重： class BitmapTest &#123; private static final int CAPACITY = 1000000000;//数据容量 // 定义一个byte数组缓存所有的数据 private byte[] dataBytes = new byte[1 &lt;&lt; 29]; public static void main(String[] args) &#123; BitmapTest ms = new BitmapTest(); byte[] bytes = null; Random random = new Random(); for (int i = 0; i &lt; CAPACITY; i++) &#123; int num = random.nextInt(); System.out.println(\"读取了第 \" + (i + 1) + \"\\t个数: \" + num); bytes = ms.splitBigData(num); &#125; System.out.println(\"\"); ms.output(bytes); &#125; /** * 读取数据，并将对应数数据的 到对应的bit中，并返回byte数组 * @param num 读取的数据 * @return byte数组 dataBytes */ private byte[] splitBigData(int num) &#123; long bitIndex = num + (1l &lt;&lt; 31); //获取num数据对应bit数组（虚拟）的索引 int index = (int) (bitIndex / 8); //bit数组（虚拟）在byte数组中的索引 int innerIndex = (int) (bitIndex % 8); //bitIndex 在byte[]数组索引index 中的具体位置 System.out.println(\"byte[\" + index + \"] 中的索引：\" + innerIndex); dataBytes[index] = (byte) (dataBytes[index] | (1 &lt;&lt; innerIndex)); return dataBytes; &#125; /** * 输出数组中的数据 * @param bytes byte数组 */ private void output(byte[] bytes) &#123; int count = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; for (int j = 0; j &lt; 8; j++) &#123; if (!(((bytes[i]) &amp; (1 &lt;&lt; j)) == 0)) &#123; count++; int number = (int) ((((long) i * 8 + j) - (1l &lt;&lt; 31))); System.out.println(\"取出的第 \" + count + \"\\t个数: \" + number); &#125; &#125; &#125; &#125;&#125; 2、分治法分治法目前看到的解决方案有哈希分桶（Hash Buckets）和归并排序两种方案。 哈希分桶的思想是先遍历一遍，按照hash分N桶（比如1000桶），映射到不同的文件中。这样平均每个文件就10MB，然后分别处理这1000个文件，找出没有重复的即可。一个相同的数字，绝对不会夸文件，有hash做保证。因为算法具体还不甚了解，这里先不做详细介绍。 归并排序的思想可以参考这篇文章：面试题之10亿正整数问题续–关于多通道排序的问题 参考资料 程序员编程艺术：第十章、如何给10^7个数据量的磁盘文件排序 面试题之10亿正整数问题续–关于多通道排序的问题 利用位映射原理对大数据排重 十道海量数据处理面试题与十个方法大总结 海量数据处理之BitMap","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"遗传算法的基本概念和Java实现","slug":"遗传算法的基本概念和Java实现","date":"2017-07-11T10:30:55.000Z","updated":"2017-07-11T10:57:00.982Z","comments":true,"path":"2017/07/11/遗传算法的基本概念和Java实现/","link":"","permalink":"http://github.com/2017/07/11/遗传算法的基本概念和Java实现/","excerpt":"基因遗传算法是一种灵感源于达尔文自然进化理论的启发式搜索算法。该算法反映了自然选择的过程，即最适者被选定繁殖，并产生下一代。本文简要地介绍了遗传算法的基本概念和实现，希望能为读者展示启发式搜索的魅力。","text":"基因遗传算法是一种灵感源于达尔文自然进化理论的启发式搜索算法。该算法反映了自然选择的过程，即最适者被选定繁殖，并产生下一代。本文简要地介绍了遗传算法的基本概念和实现，希望能为读者展示启发式搜索的魅力。 遗传算法的概念自然选择的过程从选择群体中最适应环境的个体开始。后代继承了父母的特性，并且这些特性将添加到下一代中。如果父母具有更好的适应性，那么它们的后代将更易于存活。迭代地进行该自然选择的过程，最终，我们将得到由最适应环境的个体组成的一代。 这一概念可以被应用于搜索问题中。我们考虑一个问题的诸多解决方案，并从中搜寻出最佳方案。 遗传算法含以下五步： 初始化 个体评价（计算适应度函数） 选择运算 交叉运算 变异运算 初始化该过程从种群的一组个体开始，且每一个体都是待解决问题的一个候选解。 个体以一组参数（变量）为特征，这些特征被称为基因，串联这些基因就可以组成染色体（问题的解）。 在遗传算法中，单个个体的基因组以字符串的方式呈现，通常我们可以使用二进制（1 和 0 的字符串）编码，即一个二进制串代表一条染色体串。因此可以说我们将基因串或候选解的特征编码在染色体中。 个体评价（计算适应度函数）个体评价利用适应度函数评估了该个体对环境的适应度（与其它个体竞争的能力）。每一个体都有适应度评分，个体被选中进行繁殖的可能性取决于其适应度评分。适应度函数值越大，解的质量就越高。适应度函数是遗传算法进化的驱动力，也是进行自然选择的唯一标准，它的设计应结合求解问题本身的要求而定。 选择运算选择运算的目的是选出适应性最好的个体，并使它们将基因传到下一代中。基于其适应度评分，我们选择多对较优个体（父母）。适应度高的个体更易被选中繁殖，即将较优父母的基因传递到下一代。 交叉运算交叉运算是遗传算法中最重要的阶段。对每一对配对的父母，基因都存在随机选中的交叉点。 举个例子，下图的交叉点为 3： 父母间在交叉点之前交换基因，从而产生了后代。 父母间交换基因，然后产生的新后代被添加到种群中。 变异运算在某些形成的新后代中，它们的某些基因可能受到低概率变异因子的作用。这意味着二进制位串中的某些位可能会翻转。 变异运算可用于保持种群内的多样性，并防止过早收敛。 终止在群体收敛的情况下（群体内不产生与前一代差异较大的后代）该算法终止。也就是说遗传算法提供了一组问题的解。 案例实现种群的规模恒定。新一代形成时，适应度最差的个体凋亡，为后代留出空间。这些阶段的序列被不断重复，以产生优于先前的新一代。 这一迭代过程的伪代码： STARTGenerate the initial populationCompute fitnessREPEAT Selection Crossover Mutation Compute fitnessUNTIL population has convergedSTOP Java 中的实例实现以下展示的是遗传算法在 Java 中的示例实现，我们可以随意调试和修改这些代码。给定一组五个基因，每一个基因可以保存一个二进制值 0 或 1。这里的适应度是基因组中 1 的数量。如果基因组内共有五个 1，则该个体适应度达到最大值。如果基因组内没有 1，那么个体的适应度达到最小值。该遗传算法希望最大化适应度，并提供适应度达到最大的个体所组成的群体。注意：本例中，在交叉运算与突变运算之后，适应度最低的个体被新的，适应度最高的后代所替代。 import java.util.Random;/** * * @author Vijini *///Main classpublic class SimpleDemoGA &#123; Population population = new Population(); Individual fittest; Individual secondFittest; int generationCount = 0; public static void main(String[] args) &#123; Random rn = new Random(); SimpleDemoGA demo = new SimpleDemoGA(); //Initialize population demo.population.initializePopulation(10); //Calculate fitness of each individual demo.population.calculateFitness(); System.out.println(\"Generation: \" + demo.generationCount + \" Fittest: \" + demo.population.fittest); //While population gets an individual with maximum fitness while (demo.population.fittest &lt; 5) &#123; ++demo.generationCount; //Do selection demo.selection(); //Do crossover demo.crossover(); //Do mutation under a random probability if (rn.nextInt()%7 &lt; 5) &#123; demo.mutation(); &#125; //Add fittest offspring to population demo.addFittestOffspring(); //Calculate new fitness value demo.population.calculateFitness(); System.out.println(\"Generation: \" + demo.generationCount + \" Fittest: \" + demo.population.fittest); &#125; System.out.println(\"\\nSolution found in generation \" + demo.generationCount); System.out.println(\"Fitness: \"+demo.population.getFittest().fitness); System.out.print(\"Genes: \"); for (int i = 0; i &lt; 5; i++) &#123; System.out.print(demo.population.getFittest().genes[i]); &#125; System.out.println(\"\"); &#125; //Selection void selection() &#123; //Select the most fittest individual fittest = population.getFittest(); //Select the second most fittest individual secondFittest = population.getSecondFittest(); &#125; //Crossover void crossover() &#123; Random rn = new Random(); //Select a random crossover point int crossOverPoint = rn.nextInt(population.individuals[0].geneLength); //Swap values among parents for (int i = 0; i &lt; crossOverPoint; i++) &#123; int temp = fittest.genes[i]; fittest.genes[i] = secondFittest.genes[i]; secondFittest.genes[i] = temp; &#125; &#125; //Mutation void mutation() &#123; Random rn = new Random(); //Select a random mutation point int mutationPoint = rn.nextInt(population.individuals[0].geneLength); //Flip values at the mutation point if (fittest.genes[mutationPoint] == 0) &#123; fittest.genes[mutationPoint] = 1; &#125; else &#123; fittest.genes[mutationPoint] = 0; &#125; mutationPoint = rn.nextInt(population.individuals[0].geneLength); if (secondFittest.genes[mutationPoint] == 0) &#123; secondFittest.genes[mutationPoint] = 1; &#125; else &#123; secondFittest.genes[mutationPoint] = 0; &#125; &#125; //Get fittest offspring Individual getFittestOffspring() &#123; if (fittest.fitness &gt; secondFittest.fitness) &#123; return fittest; &#125; return secondFittest; &#125; //Replace least fittest individual from most fittest offspring void addFittestOffspring() &#123; //Update fitness values of offspring fittest.calcFitness(); secondFittest.calcFitness(); //Get index of least fit individual int leastFittestIndex = population.getLeastFittestIndex(); //Replace least fittest individual from most fittest offspring population.individuals[leastFittestIndex] = getFittestOffspring(); &#125;&#125;//Individual classclass Individual &#123; int fitness = 0; int[] genes = new int[5]; int geneLength = 5; public Individual() &#123; Random rn = new Random(); //Set genes randomly for each individual for (int i = 0; i &lt; genes.length; i++) &#123; genes[i] = rn.nextInt() % 2; &#125; fitness = 0; &#125; //Calculate fitness public void calcFitness() &#123; fitness = 0; for (int i = 0; i &lt; 5; i++) &#123; if (genes[i] == 1) &#123; ++fitness; &#125; &#125; &#125;&#125;//Population classclass Population &#123; int popSize = 10; Individual[] individuals = new Individual[10]; int fittest = 0; //Initialize population public void initializePopulation(int size) &#123; for (int i = 0; i &lt; individuals.length; i++) &#123; individuals[i] = new Individual(); &#125; &#125; //Get the fittest individual public Individual getFittest() &#123; int maxFit = Integer.MIN_VALUE; for (int i = 0; i &lt; individuals.length; i++) &#123; if (maxFit &lt;= individuals[i].fitness) &#123; maxFit = i; &#125; &#125; fittest = individuals[maxFit].fitness; return individuals[maxFit]; &#125; //Get the second most fittest individual public Individual getSecondFittest() &#123; int maxFit1 = 0; int maxFit2 = 0; for (int i = 0; i &lt; individuals.length; i++) &#123; if (individuals[i].fitness &gt; individuals[maxFit1].fitness) &#123; maxFit2 = maxFit1; maxFit1 = i; &#125; else if (individuals[i].fitness &gt; individuals[maxFit2].fitness) &#123; maxFit2 = i; &#125; &#125; return individuals[maxFit2]; &#125; //Get index of least fittest individual public int getLeastFittestIndex() &#123; int minFit = 0; for (int i = 0; i &lt; individuals.length; i++) &#123; if (minFit &gt;= individuals[i].fitness) &#123; minFit = i; &#125; &#125; return minFit; &#125; //Calculate fitness of each individual public void calculateFitness() &#123; for (int i = 0; i &lt; individuals.length; i++) &#123; individuals[i].calcFitness(); &#125; getFittest(); &#125;&#125; 原文来自：Introduction to Genetic Algorithms — Including Example Code","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Java】Integer变量相等（==）比较问题","slug":"【Java】Integer变量相等（==）比较问题","date":"2017-07-11T04:30:55.000Z","updated":"2017-07-11T05:12:03.274Z","comments":true,"path":"2017/07/11/【Java】Integer变量相等（==）比较问题/","link":"","permalink":"http://github.com/2017/07/11/【Java】Integer变量相等（==）比较问题/","excerpt":"题目这是关于一段令人疑惑的Java代码: class TestIntegerCache &#123; public static void main(String[] args)&#123; Integer i3 = 100; Integer i4 = 100; System.out.println(i3 == i4); Integer i5 = 1000; Integer i6 = 1000; System.out.println(i5 == i6); &#125; &#125; 这么简单，执行结果是什么？ truefalse 一个是true，一个是false！这是为什么呢？为什么和大多数人心里想的不一样！","text":"题目这是关于一段令人疑惑的Java代码: class TestIntegerCache &#123; public static void main(String[] args)&#123; Integer i3 = 100; Integer i4 = 100; System.out.println(i3 == i4); Integer i5 = 1000; Integer i6 = 1000; System.out.println(i5 == i6); &#125; &#125; 这么简单，执行结果是什么？ truefalse 一个是true，一个是false！这是为什么呢？为什么和大多数人心里想的不一样！ 分析根据Java编译机制，.java文件在编译以后会生成.class文件给JVM加载执行，于是找到.class文件，反编译看了一下，发现编译器在编译我们的代码时，很调皮（聪明的）的在我们声明的变量加上了valueOf方法 ，代码变成了如下： class TestIntegerCache &#123; public static void main(String[] args)&#123; Integer i3 = Integer.valueOf(100); Integer i4 = Integer.valueOf(100); System.out.println(i3 == i4); Integer i5 = Integer.valueOf(1000); Integer i6 = Integer.valueOf(1000); System.out.println(i5 == i6); &#125;&#125; valueOf() 方法对它做了什么，我们看看源代码： /** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //我们看到这里有个缓存，在缓存区间就返回缓存里的 return IntegerCache.cache[i + (-IntegerCache.low)]; //缓存数组相应的对象 return new Integer(i); //不在缓存数组区间就new一个对象 &#125; 我们发现，Integer的作者在写这个类时，为了避免重复创建对象，对Integer值做了缓存，如果这个值在缓存范围内，直接返回缓存好的对象，否则new一个新的对象返回，那究竟这个缓存到底缓存了哪些内容呢？看一下IntegerCache这个类： /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; //检查虚拟机里是否有缓存区间配置项，如果有就赋成该值，没有就默认[-128, 127] // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; //创建缓存数组，并初始化（缓存值） cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 这是一个内部静态类，该类只能在Integer这个类的内部访问，这个类在初始化的时候，会去加载JVM的配置，如果有值，就用配置的值初始化缓存数组，否则就缓存-128到127之间的值。再来看看我们之前的代码： 看完这个，是不是明白了呢 参考资料让人疑惑的代码，竟成大多公司面试题热门！","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"Java 8系列之重新认识HashMap","slug":"Java 8系列之重新认识HashMap","date":"2017-06-16T09:30:55.000Z","updated":"2017-06-19T10:28:36.941Z","comments":true,"path":"2017/06/16/Java 8系列之重新认识HashMap/","link":"","permalink":"http://github.com/2017/06/16/Java 8系列之重新认识HashMap/","excerpt":"本文来自美团点评技术团队： Java 8系列之重新认识HashMap 摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：","text":"本文来自美团点评技术团队： Java 8系列之重新认识HashMap 摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： 下面针对各个实现类的特点做一些说明： (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 (4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 内部实现搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 存储结构-字段从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么？优点呢？ (1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 (2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： map.put(\"美团\",\"小美\"); 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子int modCount; int size; 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/article/details/14475159 ，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考http://blog.csdn.net/v_july_v/article/details/6105630 。 功能实现-方法HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 1. 确定哈希桶数组索引位置不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): 方法一：static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;方法二：static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 下面举例说明下，n为table的长度。 2. 分析HashMap的put方法HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 ①. 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③. 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 JDK1.8HashMap的put方法源码如下: 1 public V put(K key, V value) &#123; 2 // 对key的hashCode()做hash 3 return putVal(hash(key), key, value, false, true); 4 &#125; 5 6 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, 7 boolean evict) &#123; 8 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; 9 // 步骤①：tab为空则创建10 if ((tab = table) == null || (n = tab.length) == 0)11 n = (tab = resize()).length;12 // 步骤②：计算index，并对null做处理 13 if ((p = tab[i = (n - 1) &amp; hash]) == null) 14 tab[i] = newNode(hash, key, value, null);15 else &#123;16 Node&lt;K,V&gt; e; K k;17 // 步骤③：节点key存在，直接覆盖value18 if (p.hash == hash &amp;&amp;19 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))20 e = p;21 // 步骤④：判断该链为红黑树22 else if (p instanceof TreeNode)23 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);24 // 步骤⑤：该链为链表25 else &#123;26 for (int binCount = 0; ; ++binCount) &#123;27 if ((e = p.next) == null) &#123;28 p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理29 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st 30 treeifyBin(tab, hash);31 break;32 &#125; // key已经存在直接覆盖value33 if (e.hash == hash &amp;&amp;34 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) 35 break;36 p = e;37 &#125;38 &#125;39 40 if (e != null) &#123; // existing mapping for key41 V oldValue = e.value;42 if (!onlyIfAbsent || oldValue == null)43 e.value = value;44 afterNodeAccess(e);45 return oldValue;46 &#125;47 &#125;48 ++modCount;49 // 步骤⑥：超过最大容量 就扩容50 if (++size &gt; threshold)51 resize();52 afterNodeInsertion(evict);53 return null;54 &#125; 3. 扩容机制扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 1 void resize(int newCapacity) &#123; //传入新的容量 2 Entry[] oldTable = table; //引用扩容前的Entry数组 3 int oldCapacity = oldTable.length; 4 if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 5 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 6 return; 7 &#125; 8 9 Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组10 transfer(newTable); //！！将数据转移到新的Entry数组里11 table = newTable; //HashMap的table属性引用新的Entry数组12 threshold = (int)(newCapacity * loadFactor);//修改阈值13 &#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 1 void transfer(Entry[] newTable) &#123; 2 Entry[] src = table; //src引用了旧的Entry数组 3 int newCapacity = newTable.length; 4 for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 5 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 6 if (e != null) &#123; 7 src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） 8 do &#123; 9 Entry&lt;K,V&gt; next = e.next;10 int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置11 e.next = newTable[i]; //标记[1]12 newTable[i] = e; //将元素放在数组上13 e = next; //访问下一个Entry链上的元素14 &#125; while (e != null);15 &#125;16 &#125;17 &#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: 1 final Node&lt;K,V&gt;[] resize() &#123; 2 Node&lt;K,V&gt;[] oldTab = table; 3 int oldCap = (oldTab == null) ? 0 : oldTab.length; 4 int oldThr = threshold; 5 int newCap, newThr = 0; 6 if (oldCap &gt; 0) &#123; 7 // 超过最大值就不再扩充了，就只好随你碰撞去吧 8 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; 9 threshold = Integer.MAX_VALUE;10 return oldTab;11 &#125;12 // 没超过最大值，就扩充为原来的2倍13 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;14 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)15 newThr = oldThr &lt;&lt; 1; // double threshold16 &#125;17 else if (oldThr &gt; 0) // initial capacity was placed in threshold18 newCap = oldThr;19 else &#123; // zero initial threshold signifies using defaults20 newCap = DEFAULT_INITIAL_CAPACITY;21 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);22 &#125;23 // 计算新的resize上限24 if (newThr == 0) &#123;25 26 float ft = (float)newCap * loadFactor;27 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?28 (int)ft : Integer.MAX_VALUE);29 &#125;30 threshold = newThr;31 @SuppressWarnings(&#123;\"rawtypes\"，\"unchecked\"&#125;)32 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];33 table = newTab;34 if (oldTab != null) &#123;35 // 把每个bucket都移动到新的buckets中36 for (int j = 0; j &lt; oldCap; ++j) &#123;37 Node&lt;K,V&gt; e;38 if ((e = oldTab[j]) != null) &#123;39 oldTab[j] = null;40 if (e.next == null)41 newTab[e.hash &amp; (newCap - 1)] = e;42 else if (e instanceof TreeNode)43 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);44 else &#123; // 链表优化重hash的代码块45 Node&lt;K,V&gt; loHead = null, loTail = null;46 Node&lt;K,V&gt; hiHead = null, hiTail = null;47 Node&lt;K,V&gt; next;48 do &#123;49 next = e.next;50 // 原索引51 if ((e.hash &amp; oldCap) == 0) &#123;52 if (loTail == null)53 loHead = e;54 else55 loTail.next = e;56 loTail = e;57 &#125;58 // 原索引+oldCap59 else &#123;60 if (hiTail == null)61 hiHead = e;62 else63 hiTail.next = e;64 hiTail = e;65 &#125;66 &#125; while ((e = next) != null);67 // 原索引放到bucket里68 if (loTail != null) &#123;69 loTail.next = null;70 newTab[j] = loHead;71 &#125;72 // 原索引+oldCap放到bucket里73 if (hiTail != null) &#123;74 hiTail.next = null;75 newTab[j + oldCap] = hiHead;76 &#125;77 &#125;78 &#125;79 &#125;80 &#125;81 return newTab;82 &#125; 线程安全性在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)： public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2, 0.75f); public static void main(String[] args) &#123; map.put(5, \"C\"); new Thread(\"Thread1\") &#123; public void run() &#123; map.put(7, \"B\"); System.out.println(map); &#125;; &#125;.start(); new Thread(\"Thread2\") &#123; public void run() &#123; map.put(3, \"A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。 注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。 e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 JDK1.8与JDK1.7的性能对比HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 Hash较均匀的情况为了便于测试，我们先写一个类Key，如下： class Key implements Comparable&lt;Key&gt; &#123; private final int value; Key(int value) &#123; this.value = value; &#125; @Override public int compareTo(Key o) &#123; return Integer.compare(this.value, o.value); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return value; &#125;&#125; 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下： public class Keys &#123; public static final int MAX_KEY = 10_000_000; private static final Key[] KEYS_CACHE = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; ++i) &#123; KEYS_CACHE[i] = new Key(i); &#125; &#125; public static Key of(int value) &#123; return KEYS_CACHE[value]; &#125;&#125; 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下： static void test(int mapSize) &#123; HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize); for (int i = 0; i &lt; mapSize; ++i) &#123; map.put(Keys.of(i), i); &#125; long beginTime = System.nanoTime(); //获取纳秒 for (int i = 0; i &lt; mapSize; i++) &#123; map.get(Keys.of(i)); &#125; long endTime = System.nanoTime(); System.out.println(endTime - beginTime); &#125; public static void main(String[] args) &#123; for(int i=10;i&lt;= 1000 0000;i*= 10)&#123; test(i); &#125; &#125; 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下： 通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 Hash极不均匀的情况假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下： class Key implements Comparable&lt;Key&gt; &#123; //... @Override public int hashCode() &#123; return 1; &#125;&#125; 仍然执行main方法，得出的结果如下表所示： 从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。 小结(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 (2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 (3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 (4) JDK1.8引入红黑树大程度优化了HashMap的性能。 (5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。 参考 JDK1.7&amp;JDK1.8 源码。 酷壳COOLSHELL，疫苗：JAVA HASHMAP的死循环，2013 CSDN博客频道，HashMap多线程死循环问题，2014。 红黑联盟，Java类集框架之HashMap(JDK1.8)源码剖析，2015。 CSDN博客频道， 教你初步了解红黑树，2010。 Java Code Geeks，HashMap performance improvements in Java 8，2014。 Importnew，危险！在HashMap中将可变对象用作Key，2014。 CSDN博客频道，为什么一般hashtable的桶数会取一个素数，2013。","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【面试题】Java String常量相等（==）问题","slug":"【面试题】Java String常量相等（==）问题","date":"2017-06-15T08:51:55.000Z","updated":"2017-06-15T09:03:38.720Z","comments":true,"path":"2017/06/15/【面试题】Java String常量相等（==）问题/","link":"","permalink":"http://github.com/2017/06/15/【面试题】Java String常量相等（==）问题/","excerpt":"问题以下三个结果分别输出（true or false）？别小看它，很多程序员因为上面问题出过生产bug String s3 = \"s\";String s4 = \"s\";System.out.println(s3==s4);---String s5 = \"hello\";String s6 = \"he\"+\"llo\";System.out.println(s5==s6);---Integer i = 2017;Integer j = 2017;System.out.println(i==j);---String s1 = new String(\"s\");String s2 = new String(\"s\");System.out.println(s1==s2);System.out.println(s1.intern()==s2.intern());","text":"问题以下三个结果分别输出（true or false）？别小看它，很多程序员因为上面问题出过生产bug String s3 = \"s\";String s4 = \"s\";System.out.println(s3==s4);---String s5 = \"hello\";String s6 = \"he\"+\"llo\";System.out.println(s5==s6);---Integer i = 2017;Integer j = 2017;System.out.println(i==j);---String s1 = new String(\"s\");String s2 = new String(\"s\");System.out.println(s1==s2);System.out.println(s1.intern()==s2.intern()); 真正执行结果如下： String s3 = \"s\";String s4 = \"s\";System.out.println(s3==s4); //true---String s5 = \"hello\";String s6 = \"he\"+\"llo\";System.out.println(s5==s6); //true---Integer i = 2017;Integer j = 2017;System.out.println(i==j); //false---String s1 = new String(\"s\");String s2 = new String(\"s\");System.out.println(s1==s2); //falseSystem.out.println(s1.intern()==s2.intern()); //true 解释 看看Integer的源代码就知道Integer 把-128-127之间的每个值建立了缓存池，所以Integer i =127，Integer j =127，他们是true，超出就是false。 String s = “s” 是常量池中创建一个对象”s”，所以是true。而String s = new String（”s”）在堆上面分配内存创建一个String对象，栈放了对象引用。如下图： 但在调用s.intern()方法的时候，会将共享池中的字符串与外部的字符串(s）进行比较,如果共享池存在，返回它，如果不同则将外部字符串放入共享池中，并返回其字符串的引用，这样做的好处就是能够节约空间。 String 的intern()方法的官方解释如下： /** * Returns an interned string equal to this string. The VM maintains an internal set of * unique strings. All string literals found in loaded classes' * constant pools are automatically interned. Manually-interned strings are only weakly * referenced, so calling &#123;@code intern&#125; won't lead to unwanted retention. * * &lt;p&gt;Interning is typically used because it guarantees that for interned strings * &#123;@code a&#125; and &#123;@code b&#125;, &#123;@code a.equals(b)&#125; can be simplified to * &#123;@code a == b&#125;. (This is not true of non-interned strings.) * * &lt;p&gt;Many applications find it simpler and more convenient to use an explicit * &#123;@link java.util.HashMap&#125; to implement their own pools. */ public native String intern(); s.intern()作用还是很多，比如for循环创建String对象，因为代码事先不并不知道是否存在”hello”或者其他字符串的实例。这样可以节约很多内存空间。 参考资料： 1、你遇到过哪些质量很高的 Java 面试？","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"详解Java类的生命周期","slug":"详解Java类的生命周期","date":"2017-06-02T03:36:55.000Z","updated":"2017-06-02T03:51:10.331Z","comments":true,"path":"2017/06/02/详解Java类的生命周期/","link":"","permalink":"http://github.com/2017/06/02/详解Java类的生命周期/","excerpt":"引言最近有位细心的朋友在阅读笔者的文章时，对Java类的生命周期问题有一些疑惑，笔者打开百度搜了一下相关的问题，看到网上的资料很少有把这个问题讲明白的，主要是因为目前国内Java方面的教材大多只是告诉你“怎样做”，但至于“为什么这样做”却不多说，所以造成大家在基础和原理方面的知识比较匮乏，所以笔者今天就斗胆来讲一下这个问题，权当抛砖引玉，希望对在这个问题上有疑惑的朋友有所帮助，文中有说的不对的地方，也希望各路高手前来指正。 首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色： 方法区：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。 常量池：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。 堆区：用于存放类的对象实例。 栈区：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。","text":"引言最近有位细心的朋友在阅读笔者的文章时，对Java类的生命周期问题有一些疑惑，笔者打开百度搜了一下相关的问题，看到网上的资料很少有把这个问题讲明白的，主要是因为目前国内Java方面的教材大多只是告诉你“怎样做”，但至于“为什么这样做”却不多说，所以造成大家在基础和原理方面的知识比较匮乏，所以笔者今天就斗胆来讲一下这个问题，权当抛砖引玉，希望对在这个问题上有疑惑的朋友有所帮助，文中有说的不对的地方，也希望各路高手前来指正。 首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色： 方法区：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。 常量池：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。 堆区：用于存放类的对象实例。 栈区：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。 除了以上四个内存区域之外，jvm中的运行时内存区域还包括本地方法栈和程序计数器，这两个区域与java类的生命周期关系不是很大，在这里就不说了，感兴趣的朋友可以自己百度一下。 类的生命周期当我们编写一个java的源文件后，经过编译会生成一个后缀名为class的文件，这种文件叫做字节码文件，只有这种字节码文件才能够在java虚拟机中运行，java类的生命周期就是指一个class文件从加载到卸载的全过程。 一个java类的完整的生命周期会经历加载、连接、初始化、使用、和卸载五个阶段，当然也有在加载或者连接之后没有被初始化就直接被使用的情况，如图所示： 下面我们就依次来说一说这五个阶段。 加载在java中，我们经常会接触到一个词——类加载，它和这里的加载并不是一回事，通常我们说类加载指的是类的生命周期中加载、连接、初始化三个阶段。在加载阶段，java虚拟机会做什么工作呢？其实很简单，就是找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。 类的加载方式比较灵活，我们最常用的加载方式有两种，一种是根据类的全路径名找到相应的class文件，然后从class文件中读取文件内容；另一种是从jar文件中读取。另外，还有下面几种方式也比较常用： 从网络中获取：比如10年前十分流行的Applet。 根据一定的规则实时生成，比如设计模式中的动态代理模式，就是根据相应的类自动生成它的代理类。 从非class文件中获取，其实这与直接从class文件中获取的方式本质上是一样的，这些非class文件在jvm中运行之前会被转换为可被jvm所识别的字节码文件。 对于加载的时机，各个虚拟机的做法并不一样，但是有一个原则，就是当jvm“预期”到一个类将要被使用时，就会在使用它之前对这个类进行加载。比如说，在一段代码中出现了一个类的名字，jvm在执行这段代码之前并不能确定这个类是否会被使用到，于是，有些jvm会在执行前就加载这个类，而有些则在真正需要用的时候才会去加载它，这取决于具体的jvm实现。我们常用的hotspot虚拟机是采用的后者，就是说当真正用到一个类的时候才对它进行加载。 加载阶段是类的生命周期中的第一个阶段，加载阶段之后，是连接阶段。有一点需要注意，就是有时连接阶段并不会等加载阶段完全完成之后才开始，而是交叉进行，可能一个类只加载了一部分之后，连接阶段就已经开始了。但是这两个阶段总的开始时间和完成时间总是固定的：加载阶段总是在连接阶段之前开始，连接阶段总是在加载阶段完成之后完成。 连接连接阶段比较复杂，一般会跟加载阶段和初始化阶段交叉进行，这个阶段的主要任务就是做一些加载后的验证工作以及一些初始化前的准备工作，可以细分为三个步骤：验证、准备和解析。 验证：当一个类被加载之后，必须要验证一下这个类是否合法，比如这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。总之，这个阶段的目的就是保证加载的类是能够被jvm所运行。 准备：准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值，对于非静态的变量，则不会为它们分配内存。有一点需要注意，这时候，静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。jvm默认的初值是这样的： 基本类型：（int、long、short、char、byte、boolean、float、double）的默认值为0。 引用类型：默认值为null。 常量：默认值为我们程序中设定的值，比如我们在程序中定义final static int a = 100，则准备阶段中a的初值就是100。 解析：这一阶段的任务就是把常量池中的符号引用转换为直接引用。那么什么是符号引用，什么又是直接引用呢？我们来举个例子：我们要找一个人，我们现有的信息是这个人的身份证号是1234567890。只有这个信息我们显然找不到这个人，但是通过公安局的身份系统，我们输入1234567890这个号之后，就会得到它的全部信息：比如安徽省黄山市余暇村18号张三，通过这个信息我们就能找到这个人了。这里，123456790就好比是一个符号引用，而安徽省黄山市余暇村18号张三就是直接引用。在内存中也是一样，比如我们要在内存中找一个类里面的一个叫做show的方法，显然是找不到。但是在解析阶段，jvm就会把show这个名字转换为指向方法区的的一块内存地址，比如c17164，通过c17164就可以找到show这个方法具体分配在内存的哪一个区域了。这里show就是符号引用，而c17164就是直接引用。在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。 连接阶段完成之后会根据使用的情况（直接引用还是被动引用）来选择是否对类进行初始化。 初始化如果一个类被直接引用，就会触发类的初始化。在java中，直接引用的情况有： 通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。 通过反射方式执行以上三种行为。 初始化子类的时候，会触发父类的初始化。 作为程序入口直接运行时（也就是直接调用main方法）。 除了以上四种情况，其他使用类的方式叫做被动引用，而被动引用不会触发类的初始化。请看主动引用的示例代码： import java.lang.reflect.Field; import java.lang.reflect.Method; class InitClass&#123; static &#123; System.out.println(\"初始化InitClass\"); &#125; public static String a = null; public static void method()&#123;&#125; &#125; class SubInitClass extends InitClass&#123;&#125; public class Test1 &#123; /** * 主动引用引起类的初始化的第四种情况就是运行Test1的main方法时 * 导致Test1初始化，这一点很好理解，就不特别演示了。 * 本代码演示了前三种情况，以下代码都会引起InitClass的初始化， * 但由于初始化只会进行一次，运行时请将注解去掉，依次运行查看结果。 * @param args * @throws Exception */ public static void main(String[] args) throws Exception&#123; // 主动引用引起类的初始化一: new对象、读取或设置类的静态变量、调用类的静态方法。 // new InitClass(); // InitClass.a = \"\"; // String a = InitClass.a; // InitClass.method(); // 主动引用引起类的初始化二：通过反射实例化对象、读取或设置类的静态变量、调用类的静态方法。 // Class cls = InitClass.class; // cls.newInstance(); // Field f = cls.getDeclaredField(\"a\"); // f.get(null); // f.set(null, \"s\"); // Method md = cls.getDeclaredMethod(\"method\"); // md.invoke(null, null); // 主动引用引起类的初始化三：实例化子类，引起父类初始化。 // new SubInitClass(); &#125; &#125; 上面的程序演示了主动引用触发类的初始化的四种情况。 类的初始化过程是这样的：按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句。先看一个例子，首先建两个类用来显示赋值操作： public class Field1&#123; public Field1()&#123; System.out.println(\"Field1构造方法\"); &#125; &#125; public class Field2&#123; public Field2()&#123; System.out.println(\"Field2构造方法\"); &#125; &#125; 下面是演示初始化顺序的代码： class InitClass2&#123; static&#123; System.out.println(\"运行父类静态代码\"); &#125; public static Field1 f1 = new Field1(); public static Field1 f2; &#125; class SubInitClass2 extends InitClass2&#123; static&#123; System.out.println(\"运行子类静态代码\"); &#125; public static Field2 f2 = new Field2(); &#125; public class Test2 &#123; public static void main(String[] args) throws ClassNotFoundException&#123; new SubInitClass2(); &#125; &#125; 上面的代码中，初始化的顺序是：第03行，第05行，第11行，第13行。第04行是声明操作，没有赋值，所以不会被运行。而下面的代码： class InitClass2&#123; public static Field1 f1 = new Field1(); public static Field1 f2; static&#123; System.out.println(\"运行父类静态代码\"); &#125; &#125; class SubInitClass2 extends InitClass2&#123; public static Field2 f2 = new Field2(); static&#123; System.out.println(\"运行子类静态代码\"); &#125; &#125; public class Test2 &#123; public static void main(String[] args) throws ClassNotFoundException&#123; new SubInitClass2(); &#125; &#125; 初始化顺序为：第02行、第05行、第10行、第12行，各位可以运行程序查看结果。 在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。 使用类的使用包括主动引用和被动引用，主动引用在初始化的章节中已经说过了，下面我们主要来说一下被动引用： 引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。 定义类数组，不会引起类的初始化。 引用类的常量，不会引起类的初始化。 被动引用的示例代码： class InitClass&#123; static &#123; System.out.println(\"初始化InitClass\"); &#125; public static String a = null; public final static String b = \"b\"; public static void method()&#123;&#125; &#125; class SubInitClass extends InitClass&#123; static &#123; System.out.println(\"初始化SubInitClass\"); &#125; &#125; public class Test4 &#123; public static void main(String[] args) throws Exception&#123; // String a = SubInitClass.a;// 引用父类的静态字段，只会引起父类初始化，而不会引起子类的初始化 // String b = InitClass.b;// 使用类的常量不会引起类的初始化 SubInitClass[] sc = new SubInitClass[10];// 定义类数组不会引起类的初始化 &#125; &#125; 最后总结一下使用阶段：使用阶段包括主动引用和被动引用，主动饮用会引起类的初始化，而被动引用不会引起类的初始化。 当使用阶段完成之后，java类就进入了卸载阶段。 卸载关于类的卸载，笔者在单例模式讨论篇：单例模式与垃圾回收一文中有过描述，在类使用完之后，如果满足下面的情况，类就会被卸载： 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。 总结做java的朋友对于对象的生命周期可能都比较熟悉，对象基本上都是在jvm的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。读完本文后我们知道，对象的生命周期只是类的生命周期中使用阶段的主动引用的一种情况（即实例化类对象）。而类的整个生命周期则要比对象的生命周期长的多。 参考资料JVM 的 工作原理，层次结构 以及 GC工作原理 本文转载自 详解java类的生命周期 - 卡奴达摩的专栏","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】Audio音频输出通道切换 - 蓝牙、外放","slug":"【Android】Audio音频输出通道切换 - 蓝牙、外放","date":"2017-05-18T03:40:00.000Z","updated":"2017-05-19T08:38:32.402Z","comments":true,"path":"2017/05/18/【Android】Audio音频输出通道切换 - 蓝牙、外放/","link":"","permalink":"http://github.com/2017/05/18/【Android】Audio音频输出通道切换 - 蓝牙、外放/","excerpt":"手机音频的输出有外放（Speaker）、听筒（Telephone Receiver）、有线耳机（WiredHeadset）、蓝牙音箱（Bluetooth A2DP）等输出设备。在平时，电话免提、插拔耳机、连接断开蓝牙设备等操作系统都会自动切换Audio音频到相应的输出设备上。比如电话免提就是从听筒切换到外放扬声器，插入耳机就是从外放切换到耳机。 场景需求Android系统自动切换的这些策略，并不能全部满足我们的产品需求，比如音乐App需要对听歌时拔出耳机的操作进行阻止（暂停播放），防止突然切换到外放导致尴尬。 最近项目需求希望即使在连接蓝牙音箱的情况下，仍旧使用手机外放播放音频。这就需要强制切换Audio输出通道，打破系统原有的策略。 查阅资料，看到了Android中可以通过AudioManager查询、切换当前Audio输出通道，并且在Audio输出发生变化时，捕获并处理这种变化。","text":"手机音频的输出有外放（Speaker）、听筒（Telephone Receiver）、有线耳机（WiredHeadset）、蓝牙音箱（Bluetooth A2DP）等输出设备。在平时，电话免提、插拔耳机、连接断开蓝牙设备等操作系统都会自动切换Audio音频到相应的输出设备上。比如电话免提就是从听筒切换到外放扬声器，插入耳机就是从外放切换到耳机。 场景需求Android系统自动切换的这些策略，并不能全部满足我们的产品需求，比如音乐App需要对听歌时拔出耳机的操作进行阻止（暂停播放），防止突然切换到外放导致尴尬。 最近项目需求希望即使在连接蓝牙音箱的情况下，仍旧使用手机外放播放音频。这就需要强制切换Audio输出通道，打破系统原有的策略。 查阅资料，看到了Android中可以通过AudioManager查询、切换当前Audio输出通道，并且在Audio输出发生变化时，捕获并处理这种变化。 首先提醒下大家，使用下面的方法时，需要添加权限： &lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /&gt; Audio输出状态查询AudioManager 提供的下列方法可以用来查询当前Audio输出的状态： isBluetoothA2dpOn()：检查A2DPAudio音频输出是否通过蓝牙耳机； isSpeakerphoneOn()：检查扬声器是否打开； isWiredHeadsetOn()：检查线控耳机是否连着；注意这个方法只是用来判断耳机是否是插入状态，并不能用它的结果来判定当前的Audio是通过耳机输出的，这还依赖于其他条件。 setSpeakerphoneOn(boolean on)：直接选择外放扬声器发声； setBluetoothScoOn(boolean on)：要求使用蓝牙SCO耳机进行通讯； 此处根据这篇文章简单地介绍一下蓝牙耳机的两种链路，A2DP及SCO。android的api表明： A2DP：是一种单向的高品质音频数据传输链路，通常用于播放立体声音乐； SCO： 则是一种双向的音频数据的传输链路，该链路只支持8K及16K单声道的音频数据，只能用于普通语音的传输，若用于播放音乐那就只能呵呵了。 两者的主要区别是：A2DP只能播放，默认是打开的，而SCO既能录音也能播放，默认是关闭的。 如果要录音肯定要打开sco啦，因此调用上面的setBluetoothScoOn(boolean on)就可以通过蓝牙耳机录音、播放音频了，录完、播放完记得要关闭。 另外，在Android系统中通过AudioManager.setMode()方法来管理播放模式。在setMode()方法中有以下几种对应不同的播放模式: MODE_NORMAL : 普通模式，既不是铃声模式也不是通话模式 MODE_RINGTONE : 铃声模式 MODE_IN_CALL : 通话模式 MODE_IN_COMMUNICATION : 通信模式，包括音/视频,VoIP通话.(3.0加入的，与通话模式类似) 在设置播放模式的时候，需要考虑流类型，我在这里使用的流类型是 STREAM_MUSIC ，所以切换播放设备的时候就需要设置为MODE_IN_COMMUNICATION 模式而不是 MODE_NORMAL 模式。可以参考这个问题。 解决问题使用以下方法切换音频Audio输出，参考Android : Switching audio between Bluetooth and Phone Speaker is inconsistent： AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);/** * 切换到外放 */public void changeToSpeaker()&#123; //注意此处，蓝牙未断开时使用MODE_IN_COMMUNICATION而不是MODE_NORMAL mAudioManager.setMode(bluetoothIsConnected ? AudioManager.MODE_IN_COMMUNICATION : AudioManager.MODE_NORMAL); mAudioManager.stopBluetoothSco(); mAudioManager.setBluetoothScoOn(false); mAudioManager.setSpeakerphoneOn(true);&#125;/** * 切换到蓝牙音箱 */public void changeToHeadset()&#123; mAudioManager.setMode(AudioManager.MODE_IN_COMMUNICATION); mAudioManager.startBluetoothSco(); mAudioManager.setBluetoothScoOn(true); mAudioManager.setSpeakerphoneOn(false);&#125;/************************************************************///注意：以下两个方法还未验证/************************************************************//** * 切换到耳机模式 */public void changeToHeadset()&#123; mAudioManager.setMode(AudioManager.MODE_IN_COMMUNICATION); mAudioManager.stopBluetoothSco(); mAudioManager.setBluetoothScoOn(false); mAudioManager.setSpeakerphoneOn(false);&#125;/** * 切换到听筒 */public void changeToReceiver()&#123; audioManager.setSpeakerphoneOn(false); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB)&#123; audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION); &#125; else &#123; audioManager.setMode(AudioManager.MODE_IN_CALL); &#125;&#125; 直接切换输出通道的方法我们已经知道了。剩下需要解决的问题是，当蓝牙设备断开、连接的时候，我们希望可以自动切换到用户原本设置的输出通道上，比如在蓝牙未连接时，用户设置的是希望通过蓝牙播报，所以应该在蓝牙一旦连接以后，就把音频切换到蓝牙设备上。 下面我们就看看如何监听蓝牙设备的连接状态。 监听蓝牙连接状态首先注意使用前需要以下权限： &lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt; 根据这篇文章，我们发现可以使用 AudioManager.ACTION_AUDIO_BECOMING_NOISY 这个Intent Action来监听蓝牙断开、耳机插拔的广播，但是测试发现，它也只能收到蓝牙断开的广播，无法接收到蓝牙连接的广播，所以不是我们想要的。 进一步找到这篇文章：关于蓝牙开发，必须注意的广播，总结了以下蓝牙广播。 /** * 有注释的广播，蓝牙连接时都会用到 */intentFilter.addAction(BluetoothDevice.ACTION_FOUND); //搜索蓝压设备，每搜到一个设备发送一条广播intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED); //配对开始时，配对成功时intentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED); //配对时，发起连接intentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);intentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED); //配对结束时，断开连接intentFilter.addAction(PAIRING_REQUEST); //配对请求（Android.bluetooth.device.action.PAIRING_REQUEST）intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED); //开始搜索intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); //搜索结束。重新搜索时，会先终止搜索intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); //本机开启、关闭蓝牙开关 intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED); //蓝牙设备连接或断开intentFilter.addAction(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); //更改蓝牙名称，打开蓝牙时，可能会调用多次intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_ENABLE);intentFilter.addAction(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED); //搜索模式改变 我们发现了BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED 和 BluetoothAdapter.ACTION_STATE_CHANGED 这两个Intent广播。 那么这两个广播Intent的区别是什么呢？只用其中一个可以吗？查看Google文档发现 BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED ：指的是本地蓝牙适配器的连接状态的发生改变（比如没有关闭本机蓝牙开关时，另外一个配对设备自己把连接断开） BluetoothAdapter.ACTION_STATE_CHANGED ：指的是本地蓝牙适配器的状态已更改。 例如，蓝牙开关打开或关闭。 换句话说，一个是用于连接状态的变化，另一个用于蓝牙适配器本身的状态变化。经过测试发现，如果只使用BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED 监听广播，则会接收不到“主动关闭本机蓝牙开关”的广播事件。但只是用BluetoothAdapter.ACTION_STATE_CHANGED 的话，很明显这时候蓝牙设备并未真正配对。 动态注册蓝牙连接、断开广播的方式如下： 动态注册广播 public class BluetoothConnectionReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent)&#123; if (BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction())) &#123; //蓝牙连接状态 int state = intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE, -1); if (state == BluetoothAdapter.STATE_CONNECTED || state == BluetoothAdapter.STATE_DISCONNECTED) &#123; //连接或失联，切换音频输出（到蓝牙、或者强制仍然扬声器外放） &#125; &#125; else if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction()))&#123; //本地蓝牙打开或关闭 int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1); if (state == BluetoothAdapter.STATE_OFF || state == BluetoothAdapter.STATE_TURNING_OFF) &#123; //断开，切换音频输出 &#125; &#125; &#125;&#125; BluetoothConnectionReceiver audioNoisyReceiver = new BluetoothConnectionReceiver();//蓝牙状态广播监听IntentFilter audioFilter = new IntentFilter();audioFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);audioFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);mContext.registerReceiver(audioNoisyReceiver, audioFilter); 之后，我们就可以根据上面切换音频输出通道的代码来实现蓝牙设备连接、断开以后强制打破操作系统原有的输出通道切换策略，来实现我们自己想要的切换功能了。 参考资料：1、Android中的Audio播放：控制Audio输出通道切换 2、Android音乐播放模式切换-外放、听筒、耳机3、Android : Switching audio between Bluetooth and Phone Speaker is inconsistent4、Listening to bluetooth connections","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"},{"name":"Audio","slug":"Audio","permalink":"http://github.com/tags/Audio/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"Google 面试题 | 判断字符串是否可由重复子字符串组成","slug":"Google 面试题 - 判断字符串是否可由重复子字符串组成","date":"2017-05-05T09:20:55.000Z","updated":"2017-07-14T05:42:59.043Z","comments":true,"path":"2017/05/05/Google 面试题 - 判断字符串是否可由重复子字符串组成/","link":"","permalink":"http://github.com/2017/05/05/Google 面试题 - 判断字符串是否可由重复子字符串组成/","excerpt":"题目描述对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。 样例1 输入： “abab” 输出： True 样例解释： 输入可由”ab”重复两次组成 样例 2 输入： “aba” 输出： False 样例 3 输入： “abcabcabcabc” 输出： True 样例解释：输入可由”abc”重复四次组成","text":"题目描述对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。 样例1 输入： “abab” 输出： True 样例解释： 输入可由”ab”重复两次组成 样例 2 输入： “aba” 输出： False 样例 3 输入： “abcabcabcabc” 输出： True 样例解释：输入可由”abc”重复四次组成 解题思路1. 一个简单的思路枚举子字符串的长度lenSub &lt; len(len为原字符串长度)，将原字符串分成多个子字符串，每个子字符串长度为lenSub（由此可见，lenSub整除len），再判断这些子字符串是否全部相等，若全部相等，则返回True，如果对于所有lenSub均不满足该条件，则返回False。时间复杂度为O(len*v(len))，其中v(len)为len的因数个数（因为我们只需要对整除len的lenSub进行进一步判断）。 2. 下面再说一种神奇的方法由kmp算法中的next数组实现。 字符串s的下标从0到n-1，n为字符串长度，记s(i)表示s的第i位字符，s(i,j)表示从s的第i位到第j位的子字符串，若i&gt;j，则s(i,j)=””(空串）。 next数组的定义为：next(i)=p，表示p为小于i且满足s(0 , p) = s(i-p , i)的最大的p，如果不存在这样的p，则next(i) = -1，显然next(0) = -1。我们可以用O(n)的时间计算出next数组。假设我们已知next(0)，next(1)，……，next(i-1) ，现在要求next(i)，不妨设next(i-1) = j0，则由next数组定义可知s(0 , j0) = s(i-1-j0 , i-1)。 若s(j0+1) = s(i)，则结合s(0 , j0) = s(i-1-j0 , i-1)可知s(0 , j0+1) = s(i - (j0+1) , i)，由此可知，next(i)=j0+1。 若s(j0+1)!=s(i)但s(next(j0)+1)=s(i)，记j1=next(j0)，则s(j1+1)=s(i)，由next数组的定义，s(0 , j1) = s(j0 - j1 , j0) = s(i - 1 - j1 , i - 1)，即s(0，j1) = s(i - 1 - j1 , i - 1)，由假设s(j1+1) = s(i)，则s(0 , j1+1) = s(i - (j1+1) , i)，故next(i) = j1+1。 同前两步的分析，如果我们能找到一个k，使得对于所有小于k的k0，s(j(k0)+1)!=s(i)，但有s(j(k)+1) = s(i)，则由next数组的定义可以得到next(i)=j(k)+1，否则需进一步考虑j(k+1) = next(j(k))，如果我们找不到这样的k，则next(i)=-1。 对于字符串s，如果j满足，0&lt;=j&lt;=n-1，且s(0，j) = s(n-1-j，n-1)，令k=n-1-j，若k整除n，不妨设n=mk，则s(0，(m-1)k - 1) = s(k，mk - 1)，即s(0，k-1) = s(k，2k-1) = …… = s((m-1)k - 1，mk - 1)，即s满足题设条件。故要判断s是否为重复子串组成，只需找到满足上述条件的j，且k整除n，即说明s满足条件，否则不满足。 利用已算出的next(n-1)，令k=n-1-next(n-1)，由c可知，若k整除n，且k &lt; n，则s满足条件，否则不满足。上述算法的复杂度可证明为O(n)。 参考代码参考代码给出了利用next数组求解的代码。来自九章算法答案 public class Solution &#123; public boolean repeatedSubstringPattern(String s) &#123; int l = s.length(); int[] next = new int[l]; next[0] = -1; int i, j = -1; for (i = 1; i &lt; l; i++) &#123; while (j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j + 1)) &#123; j = next[j]; &#125; if (s.charAt(i) == s.charAt(j + 1)) &#123; j++; &#125; next[i] = j; &#125; int lenSub = l - 1 - next[l - 1]; return lenSub != l &amp;&amp; l % lenSub ==0; &#125;&#125; 面试官角度分析这道题的第一种解法比较简单，考察穷举和字符串处理的能力，给出第一种方法并正确分析时间复杂度基本可以达到hire；如果面试者对KMP算法有了解，可以给出第二种next数组的算法可以达到strong hire。 本文来自九章算法公众号 Google 面试题 | 重复子字符串模式","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Google","slug":"Google","permalink":"http://github.com/tags/Google/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】判断应用Application、Activity是否处于活动状态","slug":"【Android】判断应用Application、Activity是否处于活动状态","date":"2017-05-03T07:03:00.000Z","updated":"2017-05-18T04:53:22.073Z","comments":true,"path":"2017/05/03/【Android】判断应用Application、Activity是否处于活动状态/","link":"","permalink":"http://github.com/2017/05/03/【Android】判断应用Application、Activity是否处于活动状态/","excerpt":"通过ActivityManager我们可以获得系统里正在运行的activities，包括进程(Process)等、应用程序/包、服务(Service)、任务(Task)信息。 1、判断应用App是否活动/** * 判断应用是否已经启动 * @param context 一个context * @param packageName 要判断应用的包名 * @return boolean */private boolean isAppAlive(Context context, String packageName)&#123; ActivityManager activityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; processInfos = activityManager.getRunningAppProcesses(); for(int i = 0; i &lt; processInfos.size(); i++)&#123; if(processInfos.get(i).processName.equals(packageName))&#123; Log.i(\"NotificationLaunch\", String.format(\"the %s is running, isAppAlive return true\", packageName)); return true; &#125; &#125; Log.i(\"NotificationLaunch\", String.format(\"the %s is not running, isAppAlive return false\", packageName)); return false;&#125;","text":"通过ActivityManager我们可以获得系统里正在运行的activities，包括进程(Process)等、应用程序/包、服务(Service)、任务(Task)信息。 1、判断应用App是否活动/** * 判断应用是否已经启动 * @param context 一个context * @param packageName 要判断应用的包名 * @return boolean */private boolean isAppAlive(Context context, String packageName)&#123; ActivityManager activityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; processInfos = activityManager.getRunningAppProcesses(); for(int i = 0; i &lt; processInfos.size(); i++)&#123; if(processInfos.get(i).processName.equals(packageName))&#123; Log.i(\"NotificationLaunch\", String.format(\"the %s is running, isAppAlive return true\", packageName)); return true; &#125; &#125; Log.i(\"NotificationLaunch\", String.format(\"the %s is not running, isAppAlive return false\", packageName)); return false;&#125; 2、判断Activity是否活动/** * 判断MainActivity是否活动 * @param context 一个context * @param activityName 要判断Activity * @return boolean*/private boolean isMainActivityAlive(Context context, String activityName)&#123; ActivityManager am = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; list = am.getRunningTasks(100); for (ActivityManager.RunningTaskInfo info : list) &#123; // 注意这里的 topActivity 包含 packageName和className，可以打印出来看看 if (info.topActivity.toString().equals(activityName) || info.baseActivity.toString().equals(activityName)) &#123; Log.i(TAG,info.topActivity.getPackageName() + \" info.baseActivity.getPackageName()=\"+info.baseActivity.getPackageName()); return true; &#125; &#125; return false;&#125; 3、Activity是否显示在前台/** * 检测某Activity是否在当前Task的栈顶 */private boolean isTopActivity(String activityName)&#123; ActivityManager manager = (ActivityManager) mContext.getSystemService(ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = manager.getRunningTasks(1); String cmpNameTemp = null; if(runningTaskInfos != null)&#123; cmpNameTemp = runningTaskInfos.get(0).topActivity.toString(); &#125; if(cmpNameTemp == null)&#123; return false; &#125; return cmpNameTemp.equals(activityName);&#125; 4、Service是否在运行/** * 用来判断服务是否运行. * @param context * @param className 判断的服务名字 * @return true 在运行 false 不在运行 */ public static boolean isServiceRunning(Context mContext,String className) &#123; boolean isRunning = false; ActivityManager activityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningServiceInfo&gt; serviceList = activityManager.getRunningServices(30); if (!(serviceList.size()&gt;0)) &#123; return false; &#125; for (int i=0; i&lt;serviceList.size(); i++) &#123; if (serviceList.get(i).service.getClassName().equals(className) == true) &#123; isRunning = true; break; &#125; &#125; return isRunning; &#125; 参考资料1、Android中ActivityManager的使用案例2、Android实现点击通知栏后，先启动应用再打开目标Activity的一个小demo3、Android ActivityManager 检测Service与Activity是否正在运行","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】使用UncaughtExceptionHandler捕获全局异常","slug":"【Android】使用UncaughtExceptionHandler捕获全局异常","date":"2017-04-20T06:10:55.000Z","updated":"2017-04-20T06:21:50.191Z","comments":true,"path":"2017/04/20/【Android】使用UncaughtExceptionHandler捕获全局异常/","link":"","permalink":"http://github.com/2017/04/20/【Android】使用UncaughtExceptionHandler捕获全局异常/","excerpt":"简介当程序崩溃（Crash）的时候，默认是不对异常信息做处理的。如果想要把异常信息保存到本地文件中，或上传的服务器。那么就要借助UncaughtExceptionHandler这个类。","text":"简介当程序崩溃（Crash）的时候，默认是不对异常信息做处理的。如果想要把异常信息保存到本地文件中，或上传的服务器。那么就要借助UncaughtExceptionHandler这个类。 使用方法一、实例化public class CrashLogCatch &#123; public static final String THREAD_NAME_MAIN = \"com.example.ABC\"; //主线程名称 public static final String THREAD_NAME_REMOTE = \"com.example.ABC:remote_service\"; public static void initCrashLog(final Context context) &#123; final Thread.UncaughtExceptionHandler oriHandler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123; public void uncaughtException(Thread thread, Throwable e) &#123; try &#123; StringBuilder buffer = new StringBuilder(); buffer.append(getCurProcessName(context) + \"\\n\"); buffer.append(\"uncaught exception at \") .append(new Date(System.currentTimeMillis())) .append(\"\\n\"); buffer.append(ExceptionUtils.formatException(e)); String log = HttpLogController.getInstance().makeCrashLog(buffer.toString()); //发送崩溃日志 sendExceptionLog(log); SdLog.dFileAlways(\"crash\" + System.currentTimeMillis() + \".log\", log); if (Global.DEBUG) &#123; oriHandler.uncaughtException(thread, e); //debug模式，默认抛出异常 &#125; else &#123; String threadName = thread.getName(); if (threadName.equals(THREAD_NAME_REMOTE)) &#123; android.os.Process.killProcess(android.os.Process.myPid()); //如果是service直接kill掉 &#125; else if (threadName.equals(THREAD_NAME_MAIN)) &#123; oriHandler.uncaughtException(thread, e); //如果是主线程，抛出异常 &#125; &#125; &#125; catch (Exception ex) &#123;&#125; &#125; &#125;); &#125; /** * 获取当前进程名 */ private static String getCurProcessName(Context context) &#123; try &#123; int pid = android.os.Process.myPid(); ActivityManager mActivityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE); for (ActivityManager.RunningAppProcessInfo appProcess : mActivityManager.getRunningAppProcesses()) &#123; if (appProcess.pid == pid)&#123; return appProcess.processName; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"\"; &#125; /** * 发送崩溃日志 */ private static void sendExceptionLog(String log) &#123; try &#123; JSONObject jsonObject = new JSONObject(log); Iterator keyIter = jsonObject.keys(); String key; Object value; HashMap&lt;String, Object&gt; valueMap = new HashMap&lt;String, Object&gt;(); while (keyIter.hasNext()) &#123; key = (String) keyIter.next(); value = jsonObject.get(key); valueMap.put(key, value); &#125; // 把异常信息发送到服务器 ComponentHolder.getLogController().sendLog(valueMap, LogType.EXCEPTION); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 二、调用1、对于整个Application只要在指定的Application类的onCreate()回调中，把UncaughtExceptionHandler和Application的实例绑定在一起就可以了。关键代码如下： public class MyApplication extends Application &#123; @Override public void onCreate() &#123; CrashLogCatch.initCrashLog(this); //注意这里 super.onCreate(); &#125;&#125; 这样，如果程序崩溃，错误日志就会被上传到服务器。 2、绑定Service 实例public class MyService extends Service &#123; @Override public void onCreate() &#123; Thread.currentThread().setName(CrashLogCatch.THREAD_NAME_REMOTE); //线程名称 CrashLogCatch.initCrashLog(this); //注意这里 &#125;&#125; 3、绑定BroadcastReceiver实例public class LaunchReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Thread.currentThread().setName(CrashLogCatch.THREAD_NAME_REMOTE); //线程名称 CrashLogCatch.initCrashLog(context); //注意这里 &#125;&#125; 参考资料 【移动开发】捕获异常信息_UncaughtExceptionHandler Android使用UncaughtExceptionHandler捕获全局异常","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"},{"name":"Exception","slug":"Exception","permalink":"http://github.com/tags/Exception/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android 】硬件加速原理与实现简介","slug":"【Android 】硬件加速原理与实现简介","date":"2017-03-30T07:29:55.000Z","updated":"2017-03-30T07:39:20.311Z","comments":true,"path":"2017/03/30/【Android 】硬件加速原理与实现简介/","link":"","permalink":"http://github.com/2017/03/30/【Android 】硬件加速原理与实现简介/","excerpt":"在手机客户端尤其是Android应用的开发过程中，我们经常会接触到“硬件加速”这个词。由于操作系统对底层软硬件封装非常完善，上层软件开发者往往对硬件加速的底层原理了解很少，也不清楚了解底层原理的意义，因此常会有一些误解，如硬件加速是不是通过特殊算法实现页面渲染加速，或是通过硬件提高CPU/GPU运算速率实现渲染加速。 本文尝试从底层硬件原理，一直到上层代码实现，对硬件加速技术进行简单介绍，其中上层实现基于Android 6.0。","text":"在手机客户端尤其是Android应用的开发过程中，我们经常会接触到“硬件加速”这个词。由于操作系统对底层软硬件封装非常完善，上层软件开发者往往对硬件加速的底层原理了解很少，也不清楚了解底层原理的意义，因此常会有一些误解，如硬件加速是不是通过特殊算法实现页面渲染加速，或是通过硬件提高CPU/GPU运算速率实现渲染加速。 本文尝试从底层硬件原理，一直到上层代码实现，对硬件加速技术进行简单介绍，其中上层实现基于Android 6.0。 了解硬件加速对App开发的意义对于App开发者，简单了解硬件加速原理及上层API实现，开发时就可以充分利用硬件加速提高页面的性能。以Android举例，实现一个圆角矩形按钮通常有两种方案：使用PNG图片；使用代码（XML/Java）实现。简单对比两种方案如下。 方案 原理 特点 使用PNG图片（BitmapDrawable） 解码PNG图片生成Bitmap，传到底层，由GPU渲染 图片解码消耗CPU运算资源，Bitmap占用内存大，绘制慢 使用XML或Java代码实现（ShapeDrawable） 直接将Shape信息传到底层，由GPU渲染 消耗CPU资源少，占用内存小，绘制快 页面渲染背景知识 页面渲染时，被绘制的元素最终要转换成矩阵像素点（即多维数组形式，类似安卓中的Bitmap），才能被显示器显示。 页面由各种基本元素组成，例如圆形、圆角矩形、线段、文字、矢量图（常用贝塞尔曲线组成）、Bitmap等。 元素绘制时尤其是动画绘制过程中，经常涉及插值、缩放、旋转、透明度变化、动画过渡、毛玻璃模糊，甚至包括3D变换、物理运动（例如游戏中常见的抛物线运动）、多媒体文件解码（主要在桌面机中有应用，移动设备一般不用GPU做解码）等运算。 绘制过程经常需要进行逻辑较简单、但数据量庞大的浮点运算。 CPU与GPU结构对比CPU（Central Processing Unit，中央处理器）是计算机设备核心器件，用于执行程序代码，软件开发者对此都很熟悉；GPU（Graphics Processing Unit，图形处理器）主要用于处理图形运算，通常所说“显卡”的核心部件就是GPU。 下面是CPU和GPU的结构对比图。其中： 黄色的Control为控制器，用于协调控制整个CPU的运行，包括取出指令、控制其他模块的运行等； 绿色的ALU（Arithmetic Logic Unit）是算术逻辑单元，用于进行数学、逻辑运算； 橙色的Cache和DRAM分别为缓存和RAM，用于存储信息。 从结构图可以看出，CPU的控制器较为复杂，而ALU数量较少。因此CPU擅长各种复杂的逻辑运算，但不擅长数学尤其是浮点运算。 以8086为例，一百多条汇编指令大部分都是逻辑指令，数学计算相关的主要是16位加减乘除和移位运算。一次整型和逻辑运算一般需要1~3个机器周期，而浮点运算要转换成整数计算，一次运算可能消耗上百个机器周期。 更简单的CPU甚至只有加法指令，减法用补码加法实现，乘法用累加实现，除法用减法循环实现。 现代CPU一般都带有硬件浮点运算器（FPU），但主要适用于数据量不大的情况。 CPU是串行结构。以计算100个数字为例，对于CPU的一个核，每次只能计算两个数的和，结果逐步累加。 和CPU不同的是，GPU就是为实现大量数学运算设计的。从结构图中可以看到，GPU的控制器比较简单，但包含了大量ALU。GPU中的ALU使用了并行设计，且具有较多浮点运算单元。 硬件加速的主要原理，就是通过底层软件代码，将CPU不擅长的图形计算转换成GPU专用指令，由GPU完成。 ​ 扩展：很多计算机中的GPU有自己独立的显存；没有独立显存则使用共享内存的形式，从内存中划分一块区域作为显存。显存可以保存GPU指令等信息。 并行结构举例：级联加法器为了方便理解，这里先从底层电路结构的角度举一个例子。如下图为一个加法器，对应实际的数字电路结构。 A、B为输入，C为输出，且A、B、C均为总线，以32位CPU为例，则每根总线实际由32根导线组成，每根导线用不同的电压表示一个二进制的0或1。 Clock为时钟信号线，每个固定的时钟周期可向其输入一个特定的电压信号，每当一个时钟信号到来时，A和B的和就会输出到C。 现在我们要计算8个整数的和。 对于CPU这种串行结构，代码编写很简单，用for循环把所有数字逐个相加即可。串行结构只有一个加法器，需要7次求和运算；每次计算完部分和，还要将其再转移到加法器的输入端，做下一次计算。整个过程至少要消耗十几个机器周期。 而对于并行结构，一种常见的设计是级联加法器，如下图，其中所有的clock连在一起。当需要相加的8个数据在输入端A1~B4准备好后，经过三个时钟周期，求和操作就完成了。如果数据量更大、级联的层级更大，则并行结构的优势更明显。 由于电路的限制，不容易通过提高时钟频率、减小时钟周期的方式提高运算速度。并行结构通过增加电路规模、并行处理，来实现更快的运算。但并行结构不容易实现复杂逻辑，因为同时考虑多个支路的输出结果，并协调同步处理的过程很复杂（有点像多线程编程）。 GPU并行计算举例假设我们有如下图像处理任务，给每个像素值加1。GPU并行计算的方式简单粗暴，在资源允许的情况下，可以为每个像素开一个GPU线程，由其进行加1操作。数学运算量越大，这种并行方式性能优势越明显。 Android中的硬件加速在Android中，大多数应用的界面都是利用常规的View来构建的（除了游戏、视频、图像等应用可能直接使用OpenGL ES）。下面根据Android 6.0原生系统的Java层代码，对View的软件和硬件加速渲染做一些分析和对比。 DisplayListDisplayList是一个基本绘制元素，包含元素原始属性（位置、尺寸、角度、透明度等），对应Canvas的drawXxx()方法（如下图）。 信息传递流程：Canvas(Java API) —&gt; OpenGL(C/C++ Lib) —&gt; 驱动程序 —&gt; GPU。 在Android 4.1及以上版本，DisplayList支持属性，如果View的一些属性发生变化（比如Scale、Alpha、Translate），只需把属性更新给GPU，不需要生成新的DisplayList。 RenderNode一个RenderNode包含若干个DisplayList，通常一个RenderNode对应一个View，包含View自身及其子View的所有DisplayList。 Android绘制流程（Android 6.0）下面是安卓View完整的绘制流程图，主要通过阅读源码和调试得出，虚线箭头表示递归调用。 从ViewRootImpl.performTraversals到PhoneWindow.DecroView.drawChild是每次遍历View树的固定流程，首先根据标志位判断是否需要重新布局并执行布局；然后进行Canvas的创建等操作开始绘制。 如果硬件加速不支持或者被关闭，则使用软件绘制，生成的Canvas即Canvas.class的对象； 如果支持硬件加速，则生成的是DisplayListCanvas.class的对象； 两者的isHardwareAccelerated()方法返回的值分别为false、true，View根据这个值判断是否使用硬件加速。 View中的draw(canvas,parent,drawingTime) - draw(canvas) - onDraw - dispachDraw - drawChild这条递归路径（下文简称Draw路径），调用了Canvas.drawXxx()方法，在软件渲染时用于实际绘制；在硬件加速时，用于构建DisplayList。 View中的updateDisplayListIfDirty - dispatchGetDisplayList - recreateChildDisplayList这条递归路径（下文简称DisplayList路径），仅在硬件加速时会经过，用于在遍历View树绘制的过程中更新DisplayList属性，并快速跳过不需要重建DisplayList的View。 Android 6.0中，和DisplayList相关的API目前仍被标记为“@hide”不可访问，表示还不成熟，后续版本可能开放。 硬件加速情况下，draw流程执行结束后DisplayList构建完成，然后通过ThreadedRenderer.nSyncAndDrawFrame()利用GPU绘制DisplayList到屏幕上。 纯软件绘制 VS 硬件加速（Android 6.0）下面根据具体的几种场景，具体分析一下硬件加速前后的流程与加速效果。 渲染场景 纯软件绘制 硬件加速 加速效果分析 页面初始化 绘制所有View 创建所有DisplayList GPU分担了复杂计算任务 在一个复杂页面调用背景透明TextView的setText()，且调用后其尺寸位置不变 重绘脏区所有View TextView及每一级父View重建DisplayList 重叠的兄弟节点不需CPU重绘，GPU会自行处理 TextView逐帧播放Alpha / Translation / Scale动画 每帧都要重绘脏区所有View 除第一帧同场景2，之后每帧只更新TextView对应RenderNode的属性 刷新一帧性能极大提高，动画流畅度提高 修改TextView透明度 重绘脏区所有View 直接调用RenderNode.setAlpha()更新 加速前需全页面遍历，并重绘很多View；加速后只触发DecorView.updateDisplayListIfDirty，不再往下遍历，CPU执行时间可忽略不计 场景1中，无论是否加速，遍历View树并都会走Draw路径。硬件加速后Draw路径不做实际绘制工作，只是构建DisplayList，复杂的绘制计算任务被GPU分担，已经有了较大的加速效果。 场景2中，TextView设置前后尺寸位置不变，不会触发重新Layout。 软件绘制时，TextView所在区域即为脏区。由于TextView有透明区域，遍历View树的过程中，和脏区重叠的多数View都要重绘，包括与之重叠的兄弟节点和他们的父节点（详见后面的介绍），不需要绘制的View在draw(canvas,parent,drawingTime)方法中判断直接返回。 硬件加速后，也需要遍历View树，但只有TextView及其每一层父节点需要重建DisplayList，走的是Draw路径，其他View直接走了DisplayList路径，剩下的工作都交给GPU处理。页面越复杂，两者性能差距越明显。 场景3中，软件绘制每一帧都要做大量绘制工作，很容易导致动画卡顿。硬件加速后，动画过程直接走DisplayList路径更新DisplayList的属性，动画流畅度能得到极大提高。 场景4中，两者的性能差距更明显。简单修改透明度，软件绘制仍然要做很多工作；硬件加速后一般直接更新RenderNode的属性，不需要触发invalidate，也不会遍历View树（除了少数View可能要对Alpha做特殊响应并在onSetAlpha()返回true，代码如下）。 public class View &#123; // ... public void setAlpha(@FloatRange(from=0.0, to=1.0) float alpha) &#123; ensureTransformationInfo(); if (mTransformationInfo.mAlpha != alpha) &#123; mTransformationInfo.mAlpha = alpha; if (onSetAlpha((int) (alpha * 255))) &#123; // ... invalidate(true); &#125; else &#123; // ... mRenderNode.setAlpha(getFinalAlpha()); // ... &#125; &#125; &#125; protected boolean onSetAlpha(int alpha) &#123; return false; &#125; // ...&#125; 软件绘制刷新逻辑简介实际阅读源码并实验，得出通常情况下的软件绘制刷新逻辑： 默认情况下，View的clipChildren属性为true，即每个View绘制区域不能超出其父View的范围。如果设置一个页面根布局的clipChildren属性为false，则子View可以超出父View的绘制区域。 当一个View触发invalidate，且没有播放动画、没有触发layout的情况下： 对于全不透明的View，其自身会设置标志位PFLAG_DIRTY，其父View会设置标志位PFLAG_DIRTY_OPAQUE。在draw(canvas)方法中，只有这个View自身重绘。 对于可能有透明区域的View，其自身和父View都会设置标志位PFLAG_DIRTY。 clipChildren为true时，脏区会被转换成ViewRoot中的Rect，刷新时层层向下判断，当View与脏区有重叠则重绘。如果一个View超出父View范围且与脏区重叠，但其父View不与脏区重叠，这个子View不会重绘。 clipChildren为false时，ViewGroup.invalidateChildInParent()中会把脏区扩大到自身整个区域，于是与这个区域重叠的所有View都会重绘。 总结至此，硬件加速相关的内容就介绍完了，这里做个简单总结： CPU更擅长复杂逻辑控制，而GPU得益于大量ALU和并行结构设计，更擅长数学运算。 页面由各种基础元素（DisplayList）构成，渲染时需要进行大量浮点运算。 硬件加速条件下，CPU用于控制复杂绘制逻辑、构建或更新DisplayList；GPU用于完成图形计算、渲染DisplayList。 硬件加速条件下，刷新界面尤其是播放动画时，CPU只重建或更新必要的DisplayList，进一步提高渲染效率。 实现同样效果，应尽量使用更简单的DisplayList，从而达到更好的性能（Shape代替Bitmap等）。 参考资料 GPU—并行计算利器 显示卡的“心脏”GPU工作原理介绍 Matlab的GPU加速 处理器体系结构：了解CPU的基本运行原理 CPU的内部架构和工作原理 什么是异构多处理系统，为什么需要异构多处理系统 Android应用程序UI硬件加速渲染的Display List构建过程分析 Android应用程序UI硬件加速渲染的Display List渲染过程分析 Android Choreographer源码分析 Android Project Butter分析 本文来自美团点评技术团队：Android硬件加速原理与实现简介","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"},{"name":"GPU","slug":"GPU","permalink":"http://github.com/tags/GPU/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Gradle】Android Studio中Gradle重复依赖的问题","slug":"【Gradle】Android Studio中Gradle重复依赖的问题","date":"2017-02-23T05:03:00.000Z","updated":"2017-08-29T11:15:05.541Z","comments":true,"path":"2017/02/23/【Gradle】Android Studio中Gradle重复依赖的问题/","link":"","permalink":"http://github.com/2017/02/23/【Gradle】Android Studio中Gradle重复依赖的问题/","excerpt":"问题项目中有个Module需要解析json所以选用了依赖Gson，但是编译时报错如下： Error:Execution failed for task &apos;:app:transformClassesWithJarMergingForAutoioDebug&apos;.&gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/google/gson/annotations/Expose.class 分析看到错误中的这个duplicate，第一反应和平常一样，难道是得先清理一下Clean project ? 反复试了几次都不行，上网查才发现是重复依赖Gson库的问题，导致项目中有了两个重复的Expose.class 类。 使用快捷键（Shift + Ctrl + T）查看项目中的Expose.class 类，发现是和passport-1.4.2.jar这个本地jar包冲突了，它也依赖了gson库所以导致了重复依赖。","text":"问题项目中有个Module需要解析json所以选用了依赖Gson，但是编译时报错如下： Error:Execution failed for task &apos;:app:transformClassesWithJarMergingForAutoioDebug&apos;.&gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/google/gson/annotations/Expose.class 分析看到错误中的这个duplicate，第一反应和平常一样，难道是得先清理一下Clean project ? 反复试了几次都不行，上网查才发现是重复依赖Gson库的问题，导致项目中有了两个重复的Expose.class 类。 使用快捷键（Shift + Ctrl + T）查看项目中的Expose.class 类，发现是和passport-1.4.2.jar这个本地jar包冲突了，它也依赖了gson库所以导致了重复依赖。 项目结构在往下面分析之前，需要先根据项目结构说明一下问题的本质，就是Module 踩过的坑第一个查到的解决办法是这个Android Studio中如何解决重复依赖导致的app:transformClassesWithJarMergingForDebug，但是他的问题是依赖另外一个库retrofit，她用了下面的办法： compile ('com.squareup.retrofit2:converter-gson:2.1.0')&#123; exclude group: 'com.google.code.gson'&#125; 所以我也尝试仿照他的方法，在我的Speech模块下的build.gradle文件里修改 //注意：下面的方法是错的dependencies &#123; compile fileTree(include: '*.jar', dir: 'libs')&#123; //错的 exclude group: 'com.google.code.gson', module: 'gson' &#125;&#125; 报错如下，显然这么写是不对的，对于依赖本地jar文件这么写是不对的： Error:Could not find method exclude() for arguments [&#123;group=com.google.code.gson, module=gson&#125;] on directory &apos;&#123;include=*.jar, dir=libs&#125;&apos; of type org.gradle.api.internal.file.collections.DefaultConfigurableFileTree. 但是，他们的解决思路是对的，就是想办法屏蔽其中一个Gson库。既然如此，我们可以多尝试各个引入它们的地方。 解决办法最后试来试去，才发现exclude需要写在App 主Module 的build.gradle文件中才能生效，而且注意 project(‘:Speech’) 外面那层括号： apply plugin: 'com.android.application' //注意这是主Modulerepositories &#123; mavenCentral()&#125;dependencies &#123; // Module dependency compile project(':passportSDKLib') compile (project(':Speech'))&#123; //解决Gson重复依赖问题，与passport-1.4.2.jar有冲突 exclude group: 'com.google.code.gson', module: 'gson' &#125; compile project(':Skin') compile fileTree(include: '*.jar', dir: 'src/main/libs')&#125; 唉，世界终于清静了 参考资料1、AndroidStudio中如何解决重复依赖导致的app:transformClassesWithJarMergingForDebug2、AndroidStudio的Gradle添加重复依赖的问题","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://github.com/categories/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://github.com/tags/Gradle/"}],"keywords":[{"name":"Gradle","slug":"Gradle","permalink":"http://github.com/categories/Gradle/"}]},{"title":"【Android】内存泄漏分析心得","slug":"【Android】内存泄漏分析心得","date":"2017-02-13T08:03:00.000Z","updated":"2017-02-15T05:07:07.401Z","comments":true,"path":"2017/02/13/【Android】内存泄漏分析心得/","link":"","permalink":"http://github.com/2017/02/13/【Android】内存泄漏分析心得/","excerpt":"本文来源：QQ空间终端开发团队公众号 前言对于C++来说，内存泄漏就是new出来的对象没有delete，俗称野指针；对于Java来说，就是new出来的Object 放在Heap上无法被GC回收； 本文通过QQ和Qzone中内存泄漏实例来讲android中内存泄漏分析解法和编写代码应注意的事项。 Java 中的内存分配 静态储存区：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量； 栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存； 堆区：通常存放 new 出来的对象。由 Java 垃圾回收器回收。","text":"本文来源：QQ空间终端开发团队公众号 前言对于C++来说，内存泄漏就是new出来的对象没有delete，俗称野指针；对于Java来说，就是new出来的Object 放在Heap上无法被GC回收； 本文通过QQ和Qzone中内存泄漏实例来讲android中内存泄漏分析解法和编写代码应注意的事项。 Java 中的内存分配 静态储存区：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量； 栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存； 堆区：通常存放 new 出来的对象。由 Java 垃圾回收器回收。 四种引用类型的介绍 强引用(StrongReference)：JVM 宁可抛出 OOM ，也不会让 GC 回收具有强引用的对象； 软引用(SoftReference)：只有在内存空间不足时，才会被回的对象； 弱引用(WeakReference)：在 GC 时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存； 虚引用(PhantomReference)：任何时候都可以被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志。 我们常说的内存泄漏是指new出来的Object无法被GC回收，即为强引用： 内存泄漏发生时的主要表现为内存抖动，可用内存慢慢变少： Andriod 中分析内存泄漏的工具MATMAT（Memory Analyzer Tools）是一个 Eclipse 插件，它是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。 MAT 插件的下载地址： Eclipse Memory Analyzer Open Source Project QQ 和 Qzone内存泄漏如何监控 QQ和Qzone 的内存泄漏采用SNGAPM解决方案，SNGAPM是一个性能监控、分析的统一解决方案，它从终端收集性能信息，上报到一个后台，后台将监控类信息聚合展示为图表，将分析类信息进行分析并提单，通知开发者； SNGAPM由App（MagnifierApp）和 web server（MagnifierServer）两部分组成； MagnifierApp在自动内存泄漏检测中是一个衔接检测组件（LeakInspector）和自动化云分析（MagnifierCloud）的中间性平台，它从LeakInspector的内存dump自动化上传MagnifierServer； MagnifierServer后台会定时提交分析任务到MagnifierCloud； MagnifierCloud分析结束之后会更新数据到magnifier web上，同时以bug单形式通知开发者。 常见的内存泄漏案例case 1. 单例造成的内存泄露单例的静态特性导致其生命周期同应用一样长。 解决方案： 1、将该属性的引用方式改为弱引用;2、如果传入Context，使用ApplicationContext; 泄漏代码片段 example： private static ScrollHelper mInstance; private ScrollHelper() &#123;&#125; public static ScrollHelper getInstance() &#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125; /** * 被点击的view */private View mScrolledView = null; public void setScrolledView(View scrolledView) &#123; mScrolledView = scrolledView;&#125; Solution：使用WeakReference private static ScrollHelper mInstance; private ScrollHelper() &#123;&#125; public static ScrollHelper getInstance() &#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125; /** * 被点击的view */private WeakReference&lt;View&gt; mScrolledViewWeakRef = null; public void setScrolledView(View scrolledView) &#123; mScrolledViewWeakRef = new WeakReference&lt;View&gt;(scrolledView);&#125; case 2. InnerClass匿名内部类在Java中，非静态内部类 和 匿名类 都会潜在的引用它们所属的外部类，但是，静态内部类却不会。如果这个非静态内部类实例做了一些耗时的操作，就会造成外围对象不会被回收，从而导致内存泄漏。 解决方案： 1、将内部类变成静态内部类;2、如果有强引用Activity中的属性，则将该属性的引用方式改为弱引用;3、在业务允许的情况下，当Activity执行onDestory时，结束这些耗时任务; example： public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //这儿发生泄漏 public void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; Solution： public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //加上static，变成静态匿名内部类 public static void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; case 3. Activity Context 的不正确使用在Android应用程序中通常可以使用两种Context对象：Activity和Application。当类或方法需要Context对象的时候常见的做法是使用第一个作为Context参数。这样就意味着View对象对整个Activity保持引用，因此也就保持对Activty的所有的引用。 假设一个场景，当应用程序有个比较大的Bitmap类型的图片，每次旋转是都重新加载图片所用的时间较多。为了提高屏幕旋转是Activity的创建速度，最简单的方法时将这个Bitmap对象使用Static修饰。 当一个Drawable绑定在View上，实际上这个View对象就会成为这份Drawable的一个Callback成员变量。而静态变量的生命周期要长于Activity。导致了当旋转屏幕时，Activity无法被回收，而造成内存泄露。 解决方案： 1、使用ApplicationContext代替ActivityContext，因为ApplicationContext会随着应用程序的存在而存在，而不依赖于activity的生命周期； 2、对Context的引用不要超过它本身的生命周期，慎重的对Context使用“static”关键字。Context里如果有线程，一定要在onDestroy()里及时停掉。 example： private static Drawable sBackground;@Overrideprotected void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText(\"Leaks are bad\"); if (sBackground == null) &#123; sBackground = getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackground); setContentView(label);&#125; Solution： private static Drawable sBackground;@Overrideprotected void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText(\"Leaks are bad\"); if (sBackground == null) &#123; sBackground = getApplicationContext().getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackground); setContentView(label);&#125; case 4. Handler引起的内存泄漏当Handler中有延迟的的任务或是等待执行的任务队列过长，由于消息持有对Handler的引用，而Handler又持有对其外部类的潜在引用，这条引用关系会一直保持到消息得到处理，而导致了Activity无法被垃圾回收器回收，而导致了内存泄露。 解决方案： 1、可以把Handler类放在单独的类文件中，或者使用静态内部类便可以避免泄露;2、如果想在Handler内部去调用所在的Activity,那么可以在handler内部使用弱引用的方式去指向所在Activity.使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。 Solution @Overrideprotected void doOnDestroy() &#123; super.doOnDestroy(); if (mHandler != null) &#123; mHandler.removeCallbacksAndMessages(null); &#125; mHandler = null; mRenderCallback = null;&#125; case 5. 注册监听器的泄漏系统服务可以通过Context.getSystemService 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果Context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有Activity 的引用，如果在Activity onDestory时没有释放掉引用就会内存泄漏。 解决方案： 使用ApplicationContext代替ActivityContext; 在Activity执行onDestory时，调用反注册; mSensorManager = (SensorManager) this.getSystemService(Context.SENSOR_SERVICE); Solution： mSensorManager = (SensorManager) getApplicationContext().getSystemService(Context.SENSOR_SERVICE); 下面是容易造成内存泄漏的系统服务： InputMethodManager imm = (InputMethodManager) context.getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE); Solution protected void onDetachedFromWindow() &#123; if (this.mActionShell != null) &#123; this.mActionShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mButtonShell != null) &#123; this.mButtonShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mCountShell != this.mCountShell) &#123; this.mCountShell.setOnClickListener((OnAreaClickListener)null); &#125; super.onDetachedFromWindow();&#125; case 6. Cursor，Stream没有close，View没有recyle资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null. 在我们的程序退出时一定要确保我们的资源性对象已经关闭。 Solution： 调用onRecycled() @Overridepublic void onRecycled() &#123; reset(); mSinglePicArea.onRecycled();&#125; 在View中调用reset() public void reset() &#123; if (mHasRecyled) &#123; return; &#125;... SubAreaShell.recycle(mActionBtnShell); mActionBtnShell = null;... mIsDoingAvatartRedPocketAnim = false; if (mAvatarArea != null) &#123; mAvatarArea.reset(); &#125; if (mNickNameArea != null) &#123; mNickNameArea.reset(); &#125;&#125; case 7. 集合中对象没清理造成的内存泄漏我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。所以要在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。 解决方案： 在Activity退出之前，将集合里的东西clear，然后置为null，再退出程序。 Solution private List&lt;EmotionPanelInfo&gt; data; public void onDestory() &#123; if (data != null) &#123; data.clear(); data = null; &#125;&#125; case 8. WebView造成的泄露当我们不要使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存，否则其占用的内存长期也不能被回收，从而造成内存泄露。 解决方案： 为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。 case 9. 构造Adapter时，没有使用缓存的ConvertView初始时ListView会从Adapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些View对象 缓存起来。 当向上滚动ListView时，原先位于最上面的List Item的View对象会被回收，然后被用来构造新出现的最下面的List Item。 这个构造过程就是由getView()方法完成的，getView()的第二个形参View ConvertView就是被缓存起来的List Item的View对象(初始化时缓存中没有View对象则ConvertView是null)。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【算法】反转单链表，两两反转","slug":"【算法】单链表反转，两两反转","date":"2017-01-31T09:20:55.000Z","updated":"2017-08-02T05:22:32.593Z","comments":true,"path":"2017/01/31/【算法】单链表反转，两两反转/","link":"","permalink":"http://github.com/2017/01/31/【算法】单链表反转，两两反转/","excerpt":"问题一、反转单链表题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 链表结点定义如下，这里使用的是Java描述： public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;","text":"问题一、反转单链表题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 链表结点定义如下，这里使用的是Java描述： public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 思路如何把一个单链表进行反转？ 方法1：将单链表储存为数组，然后按照数组的索引逆序进行反转。 方法2：用头插法新建链表。我们知道创建链表的两种方式：头插法和尾插法，头结点插入法形成的链表是和输入顺序相反的，尾节点插入法形成的链表是和输入顺序相同的，所以其中一种方法是，遍历原链表，然后用原链表的输出元素顺序用头结点插入法新建链表，这样新建的链表就是反转后的链表。 方法3：就地反转链表。使用3个指针遍历单链表，逐个链接点进行反转。 1、借助数组逆序反转由于题目并没有要求必须原地反转，因此可以借助外部空间实现。这里可以将单链表储存为数组，然后按照数组的索引逆序进行反转。但是，此方式比较浪费空间，而且需要两次遍历，效率不占优势。 /** * 使用数组拷贝的方式反转单链表 */public static ListNode reverseList1(ListNode head)&#123; if(head == null) return null; //转移到数组存储(这里用ArrayList方便些) List&lt;ListNode&gt; nodeList = new ArrayList&lt;ListNode&gt;(); while (head != null) &#123; nodeList.add(head); head = head.next; &#125; int startIndex = nodeList.size() - 1; for (int i = startIndex; i &gt;= 0; i--) &#123; ListNode node = nodeList.get(i); if (i == 0) &#123; node.next = null; &#125; else &#123; node.next = nodeList.get(i - 1); &#125; &#125; // 现在头结点是原来的尾节点 head = nodeList.get(startIndex); return head;&#125; 2、头插法新建链表来反转这个方法和第一个借助数组一样，需要额外一倍的空间来存储生成的新链表 /** * 头插法建立新链表，达到反转目的 */public static ListNode reverseList2(ListNode head)&#123; if(head == null) return null; ListNode previous = null; //记录上个节点 ListNode newHead = null; //头插法的新头节点 while(head != null)&#123; newHead = new ListNode(head.val); //新建头结点 newHead.next = previous; previous = newHead; head = head.next; //下一个节点 &#125; return newHead;&#125; 3、三个指针就地反转使用三个指针指向：当前节点A，下个节点B，以及下下个节点C。 遍历时，如下首先记录下下个节点C，然后节点B的指针断开并指向A。然后移动进入下一组。 A -&gt; B -&gt; C -&gt;D -&gt; E A &lt;- B C -&gt;D -&gt; E 整个过程只需遍历链表一次，效率提高不少，且需要的外部空间也较第一种方法要少很多，实现代码如下： /** * 使用三个指针原地反转单链表 */public static ListNode reverseList(ListNode head)&#123; if(head == null) return null; ListNode a = head; //当前节点A ListNode b = head.next; //下个节点B ListNode temp; //下下个节点C //头结点的指针先清空 head.next = null; //有可能链表只有一个节点，所以需要看b是否为null while(b != null)&#123; temp = b.next; // 记录C节点 b.next = a; // a-&gt;b 反向 if(temp == null)&#123; break; &#125; a = b; //移动到下一个节点 b = temp; &#125; return b == null ? a : b;&#125; 单元测试测试代码如下： public class Test &#123; public static void main(String[] args) &#123; ListNode a1 = new ListNode(5); ListNode a2 = new ListNode(4); ListNode a3 = new ListNode(30); ListNode a4 = new ListNode(78); ListNode a5 = new ListNode(99); a1.next = a2; a2.next = a3; a3.next = a4; a4.next = a5; //反转单链表 ListNode node = reverseList(a1); //打印输出结果 while (node != null)&#123; System.out.print(node.val); node = node.next; System.out.print(node != null ? \"-&gt;\" : \"\"); &#125; &#125;&#125; 问题二、单链表两两反转一个链表：a-&gt;b-&gt;c-&gt;d-&gt;e每两个元素进行反转：b-&gt;a-&gt;d-&gt;c-&gt;e输入：链表头指针输出：反转后的链表头指针要求：不新建节点 解答仿照前面的单链表反转，我们最少需要三个指针： current，next， nextNext。 分析：我们需要两个“指针”指着当前要反转的两个值current和next。两两反转后，我们还需要记录下一个的值，即反转A和B后， 需要记录 C 值，我们才能够不断向下走，直到到达链表末端。所以，需要另一个指向下一个值的“指针”，即nextNext。反转以后，A的下一个是C， 但是，实际上，A的下一个应该是D，所以，每次反转时，我们需要更新前一个值的下一个值，也就是说把 A -&gt; C 改成 A -&gt; D，所以需要prev指针。所以，要完成这个操作，我们总共需要4个“指针”。具体看代码： 所以最终我们一共需要分析四个指针： prev，current，next， nextNext。 /** * 单链表两两反转 * * 已知一个链表：a-&gt;b-&gt;c-&gt;d-&gt;e * 每两个元素进行反转：b-&gt;a-&gt;d-&gt;c-&gt;e */public static ListNode reversePairedList(ListNode head)&#123; if(head == null) return null; ListNode a = head; //当前节点A ListNode b = head.next; //下个节点B ListNode temp; //下下个节点C ListNode previous = null; //上一组的尾指针，在下一组反转后需要改变 ListNode newHead = b == null ? a : b; while(b != null)&#123; temp = b.next; // 记录C节点 b.next = a; // a-&gt;b 反向 a.next = temp; if(previous != null)&#123; previous.next = b; &#125; if(temp == null)&#123; break; &#125; previous = a; a = temp; //移动到下一组 b = temp.next; &#125; return newHead;&#125; 参考资料 看图理解单链表的反转 算法学习之数据结构之单链表反转，两两反转 单链表的建立(C语言)：头插法和尾插法建立单链表 蚂蚁金服在线笔试题 - 链表两两反转 算法题：反转单链表","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】AlertDialog中的EditText不能弹出软键盘的问题","slug":"【Android】AlertDialog中的EditText不能弹出软键盘的问题","date":"2017-01-20T03:03:00.000Z","updated":"2017-01-20T03:13:42.212Z","comments":true,"path":"2017/01/20/【Android】AlertDialog中的EditText不能弹出软键盘的问题/","link":"","permalink":"http://github.com/2017/01/20/【Android】AlertDialog中的EditText不能弹出软键盘的问题/","excerpt":"摘要AlertDialog中加入EditText但是不弹出软键盘等问题网上有很多不管用的解决方案，有的方案是强制弹出软键盘，然而即使弹出来，也是显示在AlertDialog的后面，被Dialog遮挡。 解决方案Dialog的官方文档：http://developer.android.com/reference/android/app/Dialog.html ，其中有一段： Note: Activities provide a facility to manage the creation, saving and restoring of dialogs. See onCreateDialog(int), onPrepareDialog(int, Dialog), showDialog(int), and dismissDialog(int). If these methods are used, getOwnerActivity() will return the Activity that managed this dialog.","text":"摘要AlertDialog中加入EditText但是不弹出软键盘等问题网上有很多不管用的解决方案，有的方案是强制弹出软键盘，然而即使弹出来，也是显示在AlertDialog的后面，被Dialog遮挡。 解决方案Dialog的官方文档：http://developer.android.com/reference/android/app/Dialog.html ，其中有一段： Note: Activities provide a facility to manage the creation, saving and restoring of dialogs. See onCreateDialog(int), onPrepareDialog(int, Dialog), showDialog(int), and dismissDialog(int). If these methods are used, getOwnerActivity() will return the Activity that managed this dialog. Often you will want to have a Dialog display on top of the current input method, because there is no reason for it to accept text. You can do this by setting the WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM window flag (assuming your Dialog takes input focus, as it the default) with the following code:getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM, WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM); 这段话的大概意思是说，WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM 这个参数会让Dialog遮挡住软键盘，显示在软键盘的前面。 这是默认情况下隐藏软键盘的方法，要重新显示软键盘，要执行下面这段代码： alertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM); 我是把它写在了setOnFocusChangeListener里，起效了 editText.setOnFocusChangeListener(new View.OnFocusChangeListener() &#123; @Override public void onFocusChange(View view, boolean focused) &#123; if (focused) &#123; //dialog弹出软键盘 alertDialog.getWindow() .clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM); &#125; &#125;&#125;); AlertDialog.setView()则不会出现以上问题。 另外为了防止弹出输入法时把后面的背景挤变形，可以在Manifest里的相应Activity添加： android:windowSoftInputMode=\"adjustPan|stateHidden\" 像这样： &lt;activity android:name=\".MainActivity\" android:windowSoftInputMode=\"adjustPan|stateHidden\" android:label=\"@string/app_name\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 【参考资料】1、关于AlertDialog中EditText不能弹出输入法解决方法","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】TextView中不同大小字体如何上下垂直居中？","slug":"【Android】TextView中不同大小字体如何上下垂直居中？","date":"2017-01-03T09:03:00.000Z","updated":"2017-01-03T09:51:40.715Z","comments":true,"path":"2017/01/03/【Android】TextView中不同大小字体如何上下垂直居中？/","link":"","permalink":"http://github.com/2017/01/03/【Android】TextView中不同大小字体如何上下垂直居中？/","excerpt":"前言在客户端开发中，我们往往需要对一个TextView的文字的部分内容进行特殊化处理，比如加粗、改变颜色、加链接、下划线等。iOS为我们提供了AttributedString，而Android则提供了SpannableString。 在Android的android.text.style包下为我们提供了各种各样的span（可以参考这篇文章），例如： AbsoluteSizeSpan(int size) —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小 RelativeSizeSpan(float proportion) —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out) BackgroundColorSpan(int color) —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int) ForegroundColorSpan(int color) —— 前景着色，也就是字的着色，参数与背景着色一致","text":"前言在客户端开发中，我们往往需要对一个TextView的文字的部分内容进行特殊化处理，比如加粗、改变颜色、加链接、下划线等。iOS为我们提供了AttributedString，而Android则提供了SpannableString。 在Android的android.text.style包下为我们提供了各种各样的span（可以参考这篇文章），例如： AbsoluteSizeSpan(int size) —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小 RelativeSizeSpan(float proportion) —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out) BackgroundColorSpan(int color) —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int) ForegroundColorSpan(int color) —— 前景着色，也就是字的着色，参数与背景着色一致 问题网上已经有着很多使用这些span的教程了，所以没必要在这里继续探讨这些基础使用了。但是，如果使用了AbsoluteSizeSpan(int size) 在同一个TextView中定义了不同字体大小，就会默认显示成底部对齐的方式： 说到这里，第一反应肯定是tv.setGravity(Gravity.CENTER_VERTICAL)，但是很不幸，怎么试都不凑效。那么到底有没有办法使用Span让不同字体大小的垂直居中呢？ 答案是：当然可以，得用ReplacementSpan 分析为何是ReplacementSpan？它是系统提供给我们的一个抽象类。通过名字我们可以知道其实用于是用于替换。指示我们可以把文本的某一部分替换成我们想要的内容。这也许是我们想要的。 Relpacement的定义很简单： public abstract class ReplacementSpan extends MetricAffectingSpan &#123; public abstract int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm); public abstract void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint); public void updateMeasureState(TextPaint p) &#123; &#125; public void updateDrawState(TextPaint ds) &#123; &#125;&#125; 我们在继承它的时候，需要实现两个方法getSize()和draw()。通过方法名，我们也许能够知道其作用：getSize()用于确定span的大小（实际上只是一个宽度），draw()用于绘制我们想要的内容。 但是问题来了，这些方法的传参是什么？为何getSize()只返回了一个int值？ 了解了这两个问题，就基本弄懂了自定义span。来回答这两个问题前，我们首先要明确的一件事情是：span是用于SpannableString中，并且最终被用于TextView中。所以在定义span时，我们的大小、绘制内容都应该依赖于使用时的环境。我们假设自定义span使用的环境为A,那么A将包换一些信息，例如：baseline、Paint、FontMetricsInt等信息。 那我们现在来看看getSize()方法。getSize()的返回值是int，其实这个值指的是自定义span的宽度，那它的高度呢？其实高度是已知的，那就是外界环境A带来的字的高度。但我某些情况我们希望改变span的高度，我们该怎么做呢？ 如果对Android上字体绘制有一定了解的同学会知道，一个字的高度取决于绘制这个子的Paint.FontMetricsInt 什么是 Paint.FontMetrics它表示绘制字体时的度量标准。google的官方api文档对它的字段说明如下： Type Fields public float ascent - The recommended distance above the baseline for singled spaced text. public float bottom - The maximum distance below the baseline for the lowest glyph in the font at a given text size. public float descent - The recommended distance below the baseline for singled spaced text. public float leading - The recommended additional space to add between lines of text. public float top - The maximum distance above the baseline for the tallest glyph in the font at a given text size. 其中： ascent : 字体最上端到基线的距离，为负值。 descent：字体最下端到基线的距离，为正值。 如上图，中间那条线（Baseline）就是基线，基线到上面那条线的距离就是ascent，基线到下面那条线的距离就是descent。 回到我们的主题， 我们发现getSize()方法的参数中有Paint.FontMetricsInt，那我们是否就可以通过改变传入的Paint.FontMetricsInt的asent和desent来达到改变高度的目的呢？答案是可行的。 解决方法按照上面的分析，我们继承ReplacementSpan 自定义一个Span /** * 使TextView中不同大小字体垂直居中 */public class CustomVerticalCenterSpan extends ReplacementSpan &#123; private int fontSizeSp; //字体大小sp public CustomVerticalCenterSpan(int fontSizeSp)&#123; this.fontSizeSp = fontSizeSp; &#125; @Override public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123; text = text.subSequence(start, end); Paint p = getCustomTextPaint(paint); return (int) p.measureText(text.toString()); &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; text = text.subSequence(start, end); Paint p = getCustomTextPaint(paint); Paint.FontMetricsInt fm = p.getFontMetricsInt(); canvas.drawText(text.toString(), x, y - ((y + fm.descent + y + fm.ascent) / 2 - (bottom + top) / 2), p); //此处重新计算y坐标，使字体居中 &#125; private TextPaint getCustomTextPaint(Paint srcPaint) &#123; TextPaint paint = new TextPaint(srcPaint); paint.setTextSize(ViewUtils.getSpPixel(mContext, fontSizeSp)); //设定字体大小, sp转换为px return paint; &#125;&#125; 解释下形参： x：要绘制的image的左边框到textview左边框的距离。 y：要替换的文字的基线（Baseline）的纵坐标。 top：替换行的最顶部位置。 bottom：替换行的最底部位置。注意，textview中两行之间的行间距是属于上一行的，所以这里bottom是指行间隔的底部位置。 paint：画笔，包含了要绘制字体的度量信息。 所以就有： y + fm.descent：得到字体的descent线坐标； y + fm.ascent：得到字体的ascent线坐标； (y + fm.descent + y + fm.ascent) / 2 也就是字体中间线的纵坐标 ((y + fm.descent + y + fm.ascent) / 2 - (bottom + top) / 2) 就是字体需要向上调整的距离 使用方式SpannableString ss = new SpannableString(disStr + unitString);ss.setSpan(new AbsoluteSizeSpan(40, true), 0, disStr.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);//垂直居中显示文字ss.setSpan(new CustomVerticalCenterSpan(23), disStr.length(), ss.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE); 看看效果： 【参考资料】 How to make RelativeSizeSpan align to top？ How to create vertically aligned superscript and subscript in TextView 教你自定义android中span Android ImageSpan与TextView中的text居中对齐问题解决（无论TextView设置行距与否）","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】泛型中 extends 和 super 的区别？","slug":"【Java】泛型中 extends 和 super 的区别？","date":"2016-12-27T06:46:00.000Z","updated":"2017-06-16T10:27:21.325Z","comments":true,"path":"2016/12/27/【Java】泛型中 extends 和 super 的区别？/","link":"","permalink":"http://github.com/2016/12/27/【Java】泛型中 extends 和 super 的区别？/","excerpt":"&lt;? extends T&gt;和&lt;? super T&gt;是Java泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。 &lt;? extends T&gt;：是指 “上界通配符（Upper Bounds Wildcards）” &lt;? super T&gt;：是指 “下界通配符（Lower Bounds Wildcards）” 为什么要用通配符和边界？使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。 class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125; 然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法。 class Plate&lt;T&gt;&#123; private T item; public Plate(T t)&#123;item=t;&#125; public void set(T t)&#123;item=t;&#125; public T get()&#123;return item;&#125;&#125;","text":"&lt;? extends T&gt;和&lt;? super T&gt;是Java泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。 &lt;? extends T&gt;：是指 “上界通配符（Upper Bounds Wildcards）” &lt;? super T&gt;：是指 “下界通配符（Lower Bounds Wildcards）” 为什么要用通配符和边界？使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。 class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125; 然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法。 class Plate&lt;T&gt;&#123; private T item; public Plate(T t)&#123;item=t;&#125; public void set(T t)&#123;item=t;&#125; public T get()&#123;return item;&#125;&#125; 现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。 Plate&lt;Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); 但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。 error: incompatible types: Plate&lt;Apple&gt; cannot be converted to Plate&lt;Fruit&gt; 所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的： 苹果 IS-A 水果 装苹果的盘子 NOT-IS-A 装水果的盘子 所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。 为了让泛型用起来更舒服，Sun的大脑袋们就想出了&lt;? extends T&gt;和&lt;? super T&gt;的办法，来让“水果盘子”和“苹果盘子”之间发生关系。 什么是上界？下面代码就是“上界通配符（Upper Bounds Wildcards）”： Plate&lt;？ extends Fruit&gt; 翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。Plate&lt;？ extends Fruit&gt;和Plate&lt;Apple&gt;最大的区别就是：Plate&lt;？ extends Fruit&gt;是Plate&lt;Fruit&gt;以及Plate&lt;Apple&gt;的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。 Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); 如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果。 //Lev 1class Food&#123;&#125;//Lev 2class Fruit extends Food&#123;&#125;class Meat extends Food&#123;&#125;//Lev 3class Apple extends Fruit&#123;&#125;class Banana extends Fruit&#123;&#125;class Pork extends Meat&#123;&#125;class Beef extends Meat&#123;&#125;//Lev 4class RedApple extends Apple&#123;&#125;class GreenApple extends Apple&#123;&#125; 在这个体系中，下界通配符 Plate&lt;？ extends Fruit&gt; 覆盖下图中蓝色的区域。 什么是下界？相对应的，“下界通配符（Lower Bounds Wildcards）”： Plate&lt;？ super Fruit&gt; 表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。Plate&lt;？ super Fruit&gt;是Plate&lt;Fruit&gt;的基类，但不是Plate&lt;Apple&gt;的基类。对应刚才那个例子，Plate&lt;？ super Fruit&gt;覆盖下图中红色的区域。 上下界通配符的副作用边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。 还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。 class Plate&lt;T&gt;&#123; private T item; public Plate(T t)&#123;item=t;&#125; public void set(T t)&#123;item=t;&#125; public T get()&#123;return item;&#125;&#125; 上界&lt;? extends T&gt;不能往里存，只能往外取&lt;? extends Fruit&gt;会使往盘子里放东西的set( )方法失效。但取东西get( )方法还有效。比如下面例子里两个set()方法，插入Apple和Fruit都报错。 Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); //不能存入任何元素p.set(new Fruit()); //Errorp.set(new Apple()); //Error//读取出来的东西只能存放在Fruit或它的基类里。Fruit newFruit1=p.get();Object newFruit2=p.get();Apple newFruit3=p.get(); //Error 原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。 所以通配符&lt;?&gt;和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。 public &lt;T&gt; List&lt;T&gt; fill(T... t); 但通配符&lt;?&gt;没有这种约束，Plate&lt;?&gt;单纯的就表示：盘子里放了一个东西，是什么我不知道。 所以题主问题里的错误就在这里，Plate&lt;？ extends Fruit&gt;里什么都放不进去。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里使用下界&lt;? super Fruit&gt;会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。 Plate&lt;? super Fruit&gt; p=new Plate&lt;Fruit&gt;(new Fruit());//存入元素正常p.set(new Fruit());p.set(new Apple());//读取出来的东西只能存放在Object类里。Apple newFruit3=p.get(); //ErrorFruit newFruit1=p.get(); //ErrorObject newFruit2=p.get(); 因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。 PECS原则最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了： 频繁往外读取内容的，适合用上界Extends。 经常往里插入的，适合用下界Super。 参考资料 Java泛型中extends和super的区别？","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java Generics","slug":"Java-Generics","permalink":"http://github.com/tags/Java-Generics/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Java】泛型详解","slug":"【Java】泛型详解","date":"2016-12-27T04:30:55.000Z","updated":"2017-07-11T09:01:49.834Z","comments":true,"path":"2016/12/27/【Java】泛型详解/","link":"","permalink":"http://github.com/2016/12/27/【Java】泛型详解/","excerpt":"一. 为什么需要泛型？首先，我们看下下面这段简短的代码: public class GenericTest &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(\"qqyumidi\"); list.add(\"corn\"); list.add(100); for (int i = 0; i &lt; list.size(); i++) &#123; String name = (String) list.get(i); // ① 错误 System.out.println(\"name:\" + name); &#125; &#125;&#125; 定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//①中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。 在如上的编码过程中，我们发现主要存在两个问题： 当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。 因此，//① 处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。 那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。","text":"一. 为什么需要泛型？首先，我们看下下面这段简短的代码: public class GenericTest &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(\"qqyumidi\"); list.add(\"corn\"); list.add(100); for (int i = 0; i &lt; list.size(); i++) &#123; String name = (String) list.get(i); // ① 错误 System.out.println(\"name:\" + name); &#125; &#125;&#125; 定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//①中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。 在如上的编码过程中，我们发现主要存在两个问题： 当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。 因此，//① 处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。 那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。 二. 什么是泛型？泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 看着好像有点复杂，首先我们看下上面那个例子采用泛型的写法。 public class GenericTest &#123; public static void main(String[] args) &#123; /* List list = new ArrayList(); list.add(\"qqyumidi\"); list.add(\"corn\"); list.add(100); */ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"qqyumidi\"); list.add(\"corn\"); //list.add(100); // 1 提示编译错误 for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); // 2 无须进行强制类型转换 System.out.println(\"name:\" + name); &#125; &#125;&#125; 采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List，直接限定了list集合中只能含有String类型的元素，从而在//2 处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 结合上面的泛型定义，我们知道在List中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义： public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean addAll(int index, Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex);&#125; 我们可以看到，在List接口中采用泛型化定义之后，&lt;E&gt;中的 E 表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。 自然的，ArrayList作为List接口的实现类，其定义形式是： public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; //...省略掉其他具体的定义过程&#125; 由此，我们从源代码角度明白了为什么//1处加入Integer类型对象编译错误，且//2处get()到的类型直接就是String类型了。 三. 自定义泛型接口、泛型类和泛型方法从上面的内容中，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义，以及相应的使用。是的，在具体使用时，可以分为泛型接口、泛型类和泛型方法。 自定义泛型接口、泛型类和泛型方法与上述Java源码中的List、ArrayList类似。如下，我们看一个最简单的泛型类和方法定义： public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;(\"corn\"); System.out.println(\"name:\" + name.getData()); &#125;&#125;class Box&lt;T&gt; &#123; private T data; public Box() &#123; &#125; public Box(T data) &#123; this.data = data; &#125; public T getData() &#123; return data; &#125;&#125; 在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？ public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;(\"corn\"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); System.out.println(\"name class:\" + name.getClass()); // com.qqyumidi.Box System.out.println(\"age class:\" + age.getClass()); // com.qqyumidi.Box System.out.println(name.getClass() == age.getClass()); // true &#125;&#125; 由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。 究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 四. 类型通配符接着上面的结论，我们知道，Box&lt;Number&gt;和Box&lt;Integer&gt;实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box&lt;Number&gt;和Box&lt;Integer&gt;是否可以看成具有父子关系的泛型类型呢？ 为了弄清这个问题，我们继续看下下面这个例子: public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;Number&gt; name = new Box&lt;Number&gt;(99); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); getData(name); //The method getData(Box&lt;Number&gt;) in the type GenericTest is //not applicable for the arguments (Box&lt;Integer&gt;) getData(age); // 1 &#125; public static void getData(Box&lt;Number&gt; data)&#123; System.out.println(\"data :\" + data.getData()); &#125;&#125; 我们发现，在代码//1 处出现了错误提示信息：The method getData(Box&lt;Number&gt;) in the t ype GenericTest is not applicable for the arguments (Box&lt;Integer&gt;)。显然，通过提示信息，我们知道Box&lt;Number&gt;在逻辑上不能视为Box&lt;Integer&gt;的父类。那么，原因何在呢？ public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;Integer&gt; a = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; b = a; // 1 Box&lt;Float&gt; f = new Box&lt;Float&gt;(3.14f); b.setData(f); // 2 &#125; public static void getData(Box&lt;Number&gt; data) &#123; System.out.println(\"data :\" + data.getData()); &#125;&#125;class Box&lt;T&gt; &#123; private T data; public Box() &#123; &#125; public Box(T data) &#123; setData(data); &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 这个例子中，显然//1 和//2 处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。 假设Box&lt;Number&gt;在逻辑上可以视为Box&lt;Integer&gt;的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，在逻辑上Box&lt;Number&gt;不能视为Box&lt;Integer&gt;的父类。 好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总部能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，因此，我们需要一个在逻辑上可以用来表示同时是Box&lt;Integer&gt;和Box&lt;Number&gt;的父类的一个引用类型，由此，类型通配符应运而生。 类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box&lt;Integer&gt;、Box&lt;Number&gt;…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。 public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;(\"corn\"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); getData(name); getData(age); getData(number); &#125; public static void getData(Box&lt;?&gt; data) &#123; System.out.println(\"data :\" + data.getData()); &#125;&#125; 有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？ 在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。 public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;(\"corn\"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); getData(name); getData(age); getData(number); //getUpperNumberData(name); // 1 getUpperNumberData(age); // 2 getUpperNumberData(number); // 3 &#125; public static void getData(Box&lt;?&gt; data) &#123; System.out.println(\"data :\" + data.getData()); &#125; public static void getUpperNumberData(Box&lt;? extends Number&gt; data)&#123; System.out.println(\"data :\" + data.getData()); &#125;&#125; 此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。 类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。 五. 话外篇本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。并且还要注意的一点是，Java中没有所谓的泛型数组一说。 对于泛型，最主要的还是需要理解其背后的思想和目的。 【参考资料】 Java总结篇系列：Java泛型","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"数学之美番外篇：平凡而又神奇的贝叶斯方法","slug":"数学之美番外篇：平凡而又神奇的贝叶斯方法","date":"2016-12-22T03:08:00.000Z","updated":"2017-01-13T11:10:58.012Z","comments":true,"path":"2016/12/22/数学之美番外篇：平凡而又神奇的贝叶斯方法/","link":"","permalink":"http://github.com/2016/12/22/数学之美番外篇：平凡而又神奇的贝叶斯方法/","excerpt":"Probability is nothing but common sense reduced to calculation.（概率论只不过是把常识用数学公式表达了出来。） —— Pierre-Simon Laplace 记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了 —— 这果然是个牛逼的方法。 ——题记 前言这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。","text":"Probability is nothing but common sense reduced to calculation.（概率论只不过是把常识用数学公式表达了出来。） —— Pierre-Simon Laplace 记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了 —— 这果然是个牛逼的方法。 ——题记 前言这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。 1. 历史托马斯·贝叶斯（Thomas Bayes）同学的详细生平在这里。以下摘一段 wikipedia 上的简介： 所谓的贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆概问题。 实际上，贝叶斯当时的论文只是对这个问题的一个直接的求解尝试，并不清楚他当时是不是已经意识到这里面包含着的深刻的思想。然而后来，贝叶斯方法席卷了概率论，并将应用延伸到各个问题领域，所有需要作出概率预测的地方都可以见到贝叶斯方法的影子，特别地，贝叶斯是机器学习的核心方法之一。这背后的深刻原因在于，现实世界本身就是不确定的，人类的观察能力是有局限性的（否则有很大一部分科学就没有必要做了——设想我们能够直接观察到电子的运行，还需要对原子模型争吵不休吗？），我们日常所观察到的只是事物表面上的结果，沿用刚才那个袋子里面取球的比方，我们往往只能知道从里面取出来的球是什么颜色，而并不能直接看到袋子里面实际的情况。这个时候，我们就需要提供一个猜测（hypothesis，更为严格的说法是“假设”，这里用“猜测”更通俗易懂一点），所谓猜测，当然就是不确定的（很可能有好多种乃至无数种猜测都能满足目前的观测），但也绝对不是两眼一抹黑瞎蒙——具体地说，我们需要做两件事情：1. 算出各种不同猜测的可能性大小。2. 算出最靠谱的猜测是什么。第一个就是计算特定猜测的后验概率，对于连续的猜测空间则是计算猜测的概率密度函数。第二个则是所谓的模型比较，模型比较如果不考虑先验概率的话就是最大似然方法。 1.1 一个例子：自然语言的二义性下面举一个自然语言的不确定性的例子。当你看到这句话： The girl saw the boy with a telescope. 你对这句话的含义有什么猜测？平常人肯定会说：那个女孩拿望远镜看见了那个男孩（即你对这个句子背后的实际语法结构的猜测是：The girl saw-with-a-telescope the boy ）。然而，仔细一想，你会发现这个句子完全可以解释成：那个女孩看见了那个拿着望远镜的男孩（即：The girl saw the-boy-with-a-telescope ）。那为什么平常生活中我们每个人都能够迅速地对这种二义性进行消解呢？这背后到底隐藏着什么样的思维法则？我们留到后面解释。 1.2 贝叶斯公式贝叶斯公式是怎么来的？ 我们还是使用 wikipedia 上的一个例子： 一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？ 一些认知科学的研究表明（《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面随机游走，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。 你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？ 我们来算一算：假设学校里面人的总数是 U 个。60% 的男生都穿长裤，于是我们得到了 U * P(Boy) * P(Pants|Boy)个穿长裤的（男生）（其中男生的概率 P(Boy) = 60%，这里可以简单的理解为男生的比例；P(Pants|Boy) 是条件概率，即在 Boy 这个条件下穿长裤的概率是多大，这里是 100% ，因为所有男生都穿长裤）。40% 的女生里面又有一半（50%）是穿长裤的，于是我们又得到了 U * P(Girl) * P(Pants|Girl) 个穿长裤的（女生）。加起来一共是 U P(Boy) P(Pants|Boy) + U P(Girl) P(Pants|Girl) 个穿长裤的，其中有 U * P(Girl) * P(Pants|Girl) 个女生。两者一比就是你要求的答案。 下面我们把这个答案形式化一下：我们要求的是 P(Girl|Pants) （穿长裤的人里面有多少女生），我们计算的结果是 U P(Girl) P(Pants|Girl) / [U P(Boy) P(Pants|Boy) + U P(Girl) P(Pants|Girl)] 。容易发现这里校园内人的总数是无关的，可以消去。于是得到 P(Girl|Pants) = P(Girl) * P(Pants|Girl) / [P(Boy) * P(Pants|Boy) + P(Girl) * P(Pants|Girl)] 注意，如果把上式收缩起来，分母其实就是 P(Pants) ，分子其实就是 P(Pants, Girl) 。而这个比例很自然地就读作：在穿长裤的人（ P(Pants) ）里面有多少（穿长裤）的女孩（ P(Pants, Girl) ）。 上式中的 Pants 和 Boy/Girl 可以指代一切东西，所以其一般形式就是： P(B|A) = P(A|B) * P(B) / [P(A|B) * P(B) + P(A|~B) * P(~B) ] 收缩起来就是： P(B|A) = P(AB) / P(A) 其实这个就等于： P(B|A) * P(A) = P(AB) 难怪拉普拉斯说概率论只是把常识用数学公式表达了出来。 然而，后面我们会逐渐发现，看似这么平凡的贝叶斯公式，背后却隐含着非常深刻的原理。 2. 拼写纠正经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查/纠正器的文章（原文在这里，这篇文章很深入浅出，强烈建议读一读），里面用到的就是贝叶斯方法，这里我们不打算复述他写的文章，而是简要地将其核心思想介绍一下。 首先，我们需要询问的是：“问题是什么？” 问题是我们看到用户输入了一个不在字典中的单词，我们需要去猜测：“这个家伙到底真正想输入的单词是什么呢？”用刚才我们形式化的语言来叙述就是，我们需要求： P(我们猜测他想输入的单词 | 他实际输入的单词) 这个概率。并找出那个使得这个概率最大的猜测单词。显然，我们的猜测未必是唯一的，就像前面举的那个自然语言的歧义性的例子一样；这里，比如用户输入： thew ，那么他到底是想输入 the ，还是想输入 thaw ？到底哪个猜测可能性更大呢？幸运的是我们可以用贝叶斯公式来直接出它们各自的概率，我们不妨将我们的多个猜测记为 h1 h2 .. （ h 代表 hypothesis），它们都属于一个有限且离散的猜测空间 H （单词总共就那么多而已），将用户实际输入的单词记为 D （ D 代表 Data ，即观测数据），于是 P(我们的猜测1 | 他实际输入的单词) 可以抽象地记为： P(h1 | D) 类似地，对于我们的猜测2，则是 P(h2 | D)。不妨统一记为： P(h | D) 运用一次贝叶斯公式，我们得到： P(h | D) = P(h) * P(D | h) / P(D) 对于不同的具体猜测 h1 h2 h3 .. ，P(D) 都是一样的，所以在比较 P(h1 | D) 和 P(h2 | D) 的时候我们可以忽略这个常数。即我们只需要知道： P(h | D) ∝ P(h) * P(D | h) //注：∝ 这个符号的意思是“正比例于”，不是无穷大，注意符号右端是有一个小缺口的。 这个式子的抽象含义是：对于给定观测数据，一个猜测是好是坏，取决于“这个猜测本身独立的可能性大小（先验概率，Prior ）”和“这个猜测生成我们观测到的数据的可能性大小”（似然，Likelihood ）的乘积。具体到我们的那个 thew 例子上，含义就是，用户实际是想输入 the 的可能性大小取决于 the 本身在词汇表中被使用的可能性（频繁程度）大小（先验概率）和 想打 the 却打成 thew 的可能性大小（似然）的乘积。 下面的事情就很简单了，对于我们猜测为可能的每个单词计算一下 P(h) * P(D | h) 这个值，然后取最大的，得到的就是最靠谱的猜测。 一点注记： Norvig 的拼写纠正器里面只提取了编辑距离为 2 以内的所有已知单词。这是为了避免去遍历字典中每个单词计算它们的 P(h) * P(D | h) ，但这种做法为了节省时间带来了一些误差。但话说回来难道我们人类真的回去遍历每个可能的单词来计算他们的后验概率吗？不可能。实际上，根据认知神经科学的观点，我们首先根据错误的单词做一个 bottom-up 的关联提取，提取出有可能是实际单词的那些候选单词，这个提取过程就是所谓的基于内容的提取，可以根据错误单词的一些模式片段提取出有限的一组候选，非常快地缩小的搜索空间（比如我输入 explaination ，单词里面就有充分的信息使得我们的大脑在常数时间内把可能性 narrow down 到 explanation 这个单词上，至于具体是根据哪些线索——如音节——来提取，又是如何在生物神经网络中实现这个提取机制的，目前还是一个没有弄清的领域）。然后，我们对这有限的几个猜测做一个 top-down 的预测，看看到底哪个对于观测数据（即错误单词）的预测效力最好，而如何衡量预测效率则就是用贝叶斯公式里面的那个 P(h) * P(D | h) 了——虽然我们很可能使用了一些启发法来简化计算。后面我们还会提到这样的 bottom-up 的关联提取。 3. 模型比较与奥卡姆剃刀3.1 再访拼写纠正介绍了贝叶斯拼写纠正之后，接下来的一个自然而然的问题就来了：“为什么？” 为什么要用贝叶斯公式？为什么贝叶斯公式在这里可以用？我们可以很容易地领会为什么贝叶斯公式用在前面介绍的那个男生女生长裤裙子的问题里是正确的。但为什么这里？ 为了回答这个问题，一个常见的思路就是想想：非得这样吗？ 因为如果你想到了另一种做法并且证明了它也是靠谱的，那么将它与现在这个一比较，也许就能得出很有价值的信息。那么对于拼写纠错问题你能想到其他方案吗？ 不管怎样，一个最常见的替代方案就是，选择离 thew 的编辑距离（Edit distance）最近的。然而 the 和 thaw 离 thew 的编辑距离都是 1 。这可咋办捏？你说，不慌，那还是好办。我们就看到底哪个更可能被错打为 thew 就是了。我们注意到字母 e 和字母 w 在键盘上离得很紧，无名指一抽筋就不小心多打出一个 w 来，the 就变成 thew 了。而另一方面 thaw 被错打成 thew 的可能性就相对小一点，因为 e 和 a 离得较远而且使用的指头相差一个指头（一个是中指一个是小指，不像 e 和 w 使用的指头靠在一块——神经科学的证据表明紧邻的身体设施之间容易串位）。OK，很好，因为你现在已经是在用最大似然方法了，或者直白一点，你就是在计算那个使得 P(D | h) 最大的 h 。 而贝叶斯方法计算的是什么？是 P(h) * P(D | h) 。多出来了一个 P(h) 。我们刚才说了，这个多出来的 P(h) 是特定猜测的先验概率。为什么要掺和进一个先验概率？刚才说的那个最大似然不是挺好么？很雄辩地指出了 the 是更靠谱的猜测。有什么问题呢？既然这样，我们就从给最大似然找茬开始吧——我们假设两者的似然程度是一样或非常相近，这样不就难以区分哪个猜测更靠谱了吗？比如用户输入tlp ，那到底是 top 还是 tip ？（这个例子不怎么好，因为 top 和 tip 的词频可能仍然是接近的，但一时想不到好的英文单词的例子，我们不妨就假设 top 比 tip 常见许多吧，这个假设并不影响问题的本质。）这个时候，当最大似然不能作出决定性的判断时，先验概率就可以插手进来给出指示——“既然你无法决定，那么我告诉你，一般来说 top 出现的程度要高许多，所以更可能他想打的是 top ”）。 以上只是最大似然的一个问题，即并不能提供决策的全部信息。 最大似然还有另一个问题：即便一个猜测与数据非常符合，也并不代表这个猜测就是更好的猜测，因为这个猜测本身的可能性也许就非常低。比如 MacKay 在《Information Theory : Inference and Learning Algorithms》里面就举了一个很好的例子：-1 3 7 11 你说是等差数列更有可能呢？还是 -X^3 / 11 + 9/11*X^2 + 23/11 每项把前项作为 X 带入后计算得到的数列？此外曲线拟合也是，平面上 N 个点总是可以用 N-1 阶多项式来完全拟合，当 N 个点近似但不精确共线的时候，用 N-1 阶多项式来拟合能够精确通过每一个点，然而用直线来做拟合/线性回归的时候却会使得某些点不能位于直线上。你说到底哪个好呢？多项式？还是直线？一般地说肯定是越低阶的多项式越靠谱（当然前提是也不能忽视“似然”P(D | h) ，明摆着一个多项式分布您愣是去拿直线拟合也是不靠谱的，这就是为什么要把它们两者乘起来考虑。），原因之一就是低阶多项式更常见，先验概率（ P(h) ）较大（原因之二则隐藏在 P(D | h) 里面），这就是为什么我们要用样条（Spline interpolation）来插值，而不是直接搞一个 N-1 阶多项式来通过任意 N 个点的原因。 以上分析当中隐含的哲学是，观测数据总是会有各种各样的误差，比如观测误差（比如你观测的时候一个 MM 经过你一不留神，手一抖就是一个误差出现了），所以如果过分去寻求能够完美解释观测数据的模型，就会落入所谓的数据过配（overfitting）的境地，一个过配的模型试图连误差（噪音）都去解释（而实际上噪音又是不需要解释的），显然就过犹不及了。所以 P(D | h) 大不代表你的 h （猜测）就是更好的 h。还要看 P(h) 是怎样的。所谓奥卡姆剃刀精神就是说：如果两个理论具有相似的解释力度，那么优先选择那个更简单的（往往也正是更平凡的，更少繁复的，更常见的）。 过分匹配的另一个原因在于当观测的结果并不是因为误差而显得“不精确”而是因为真实世界中对数据的结果产生贡献的因素太多太多，跟噪音不同，这些偏差是一些另外的因素集体贡献的结果，不是你的模型所能解释的——噪音那是不需要解释——一个现实的模型往往只提取出几个与结果相关度很高，很重要的因素（cause）。这个时候观察数据会倾向于围绕你的有限模型的预测结果呈正态分布，于是你实际观察到的结果就是这个正态分布的随机取样，这个取样很可能受到其余因素的影响偏离你的模型所预测的中心，这个时候便不能贪心不足地试图通过改变模型来“完美”匹配数据，因为那些使结果偏离你的预测的贡献因素不是你这个有限模型里面含有的因素所能概括的，硬要打肿脸充胖子只能导致不实际的模型，举个教科书例子：身高和体重的实际关系近似于一个二阶多项式的关系，但大家都知道并不是只有身高才会对体重产生影响，物理世界影响体重的因素太多太多了，有人身材高大却瘦得跟稻草，有人却是横长竖不长。但不可否认的是总体上来说，那些特殊情况越是特殊就越是稀少，呈围绕最普遍情况（胖瘦适中）的正态分布，这个分布就保证了我们的身高——体重相关模型能够在大多数情况下做出靠谱的预测。但是——刚才说了，特例是存在的，就算不是特例，人有胖瘦，密度也有大小，所以完美符合身高——体重的某个假想的二阶多项式关系的人是不存在的，我们又不是欧几里德几何世界当中的理想多面体，所以，当我们对人群随机抽取了 N 个样本（数据点）试图对这 N 个数据点拟合出一个多项式的话就得注意，它肯定得是二阶多项式，我们要做的只是去根据数据点计算出多项式各项的参数（一个典型的方法就是最小二乘）；它肯定不是直线（我们又不是稻草），也不是三阶多项式四阶多项式.. 如果硬要完美拟合 N 个点，你可能会整出一个 N-1 阶多项式来——设想身高和体重的关系是 5 阶多项式看看？ 3.2 模型比较理论（Model Comparasion）与贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）实际上，模型比较就是去比较哪个模型（猜测）更可能隐藏在观察数据的背后。其基本思想前面已经用拼写纠正的例子来说明了。我们对用户实际想输入的单词的猜测就是模型，用户输错的单词就是观测数据。我们通过： P(h | D) ∝ P(h) * P(D | h) 来比较哪个模型最为靠谱。前面提到，光靠 P(D | h) （即“似然”）是不够的，有时候还需要引入 P(h) 这个先验概率。奥卡姆剃刀就是说 P(h) 较大的模型有较大的优势，而最大似然则是说最符合观测数据的（即 P(D | h) 最大的）最有优势。整个模型比较就是这两方力量的拉锯。我们不妨再举一个简单的例子来说明这一精神：你随便找枚硬币，掷一下，观察一下结果。好，你观察到的结果要么是“正”，要么是“反”（不，不是少林足球那枚硬币:P ），不妨假设你观察到的是“正”。现在你要去根据这个观测数据推断这枚硬币掷出“正”的概率是多大。根据最大似然估计的精神，我们应该猜测这枚硬币掷出“正”的概率是 1 ，因为这个才是能最大化 P(D | h) 的那个猜测。然而每个人都会大摇其头——很显然，你随机摸出一枚硬币这枚硬币居然没有反面的概率是“不存在的”，我们对一枚随机硬币是否一枚有偏硬币，偏了多少，是有着一个先验的认识的，这个认识就是绝大多数硬币都是基本公平的，偏得越多的硬币越少见（可以用一个 beta分布来表达这一先验概率）。将这个先验正态分布 p(θ) （其中 θ 表示硬币掷出正面的比例，小写的 p 代表这是概率密度函数）结合到我们的问题中，我们便不是去最大化 P(D | h) ，而是去最大化 P(D | θ) * p(θ) ，显然 θ = 1 是不行的，因为 P(θ=1) 为 0 ，导致整个乘积也为 0 。实际上，只要对这个式子求一个导数就可以得到最值点。 以上说的是当我们知道先验概率 P(h) 的时候，光用最大似然是不靠谱的，因为最大似然的猜测可能先验概率非常小。然而，有些时候，我们对于先验概率一无所知，只能假设每种猜测的先验概率是均等的，这个时候就只有用最大似然了。实际上，统计学家和贝叶斯学家有一个有趣的争论，统计学家说：我们让数据自己说话。言下之意就是要摒弃先验概率。而贝叶斯支持者则说：数据会有各种各样的偏差，而一个靠谱的先验概率则可以对这些随机噪音做到健壮。事实证明贝叶斯派胜利了，胜利的关键在于所谓先验概率其实也是经验统计的结果，譬如为什么我们会认为绝大多数硬币是基本公平的？为什么我们认为大多数人的肥胖适中？为什么我们认为肤色是种族相关的，而体重则与种族无关？先验概率里面的“先验”并不是指先于一切经验，而是仅指先于我们“当前”给出的观测数据而已，在硬币的例子中先验指的只是先于我们知道投掷的结果这个经验，而并非“先天”。 然而，话说回来，有时候我们必须得承认，就算是基于以往的经验，我们手头的“先验”概率还是均匀分布，这个时候就必须依赖用最大似然，我们用前面留下的一个自然语言二义性问题来说明这一点： The girl saw the boy with a telescope. 到底是 The girl saw-with-a-telescope the boy 这一语法结构，还是 The girl saw the-boy-with-a-telescope 呢？两种语法结构的常见程度都差不多（你可能会觉得后一种语法结构的常见程度较低，这是事后偏见，你只需想想 The girl saw the boy with a book 就知道了。当然，实际上从大规模语料统计结果来看后一种语法结构的确稍稍不常见一丁点，但是绝对不足以解释我们对第一种结构的强烈倾向）。那么到底为什么呢？ 我们不妨先来看看 MacKay 在书中举的一个漂亮的例子： 图中有多少个箱子？特别地，那棵书后面是一个箱子？还是两个箱子？还是三个箱子？还是.. 你可能会觉得树后面肯定是一个箱子，但为什么不是两个呢？如下图： 很简单，你会说：要是真的有两个箱子那才怪了，怎么就那么巧这两个箱子刚刚好颜色相同，高度相同呢？ 用概率论的语言来说，你刚才的话就翻译为：猜测 h 不成立，因为 P(D | h) 太小（太巧合）了。我们的直觉是：巧合（小概率）事件不会发生。所以当一个猜测（假设）使得我们的观测结果成为小概率事件的时候，我们就说“才怪呢，哪能那么巧捏？！” 现在我们可以回到那个自然语言二义性的例子，并给出一个完美的解释了：如果语法结构是 The girl saw the-boy-with-a-telecope 的话，怎么那个男孩偏偏手里拿的就是望远镜——一个可以被用来 saw-with 的东东捏？这也忒小概率了吧。他咋就不会拿本书呢？拿什么都好。怎么偏偏就拿了望远镜？所以唯一的解释是，这个“巧合”背后肯定有它的必然性，这个必然性就是，如果我们将语法结构解释为 The girl saw-with-a-telescope the boy 的话，就跟数据完美吻合了——既然那个女孩是用某个东西去看这个男孩的，那么这个东西是一个望远镜就完全可以解释了（不再是小概率事件了）。 自然语言二义性很常见，譬如上文中的一句话： 参见《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题 就有二义性：到底是参见这两本书的第 12 章，还是仅仅是第二本书的第 12 章呢？如果是这两本书的第 12 章那就是咄咄怪事了，怎么恰好两本书都有第 12 章，都是讲同一个问题，更诡异的是，标题还相同呢？ 注意，以上做的是似然估计（即只看 P(D | h) 的大小），不含先验概率。通过这两个例子，尤其是那个树后面的箱子的例子我们可以看到，似然估计里面也蕴含着奥卡姆剃刀：树后面的箱子数目越多，这个模型就越复杂。单个箱子的模型是最简单的。似然估计选择了更简单的模型。 这个就是所谓的贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor），因为这个剃刀工作在贝叶斯公式的似然（P(D | h) ）上，而不是模型本身（ P(h) ）的先验概率上，后者是传统的奥卡姆剃刀。关于贝叶斯奥卡姆剃刀我们再来看一个前面说到的曲线拟合的例子：如果平面上有 N 个点，近似构成一条直线，但绝不精确地位于一条直线上。这时我们既可以用直线来拟合（模型1），也可以用二阶多项式（模型2）拟合，也可以用三阶多项式（模型3），.. ，特别地，用 N-1 阶多项式便能够保证肯定能完美通过 N 个数据点。那么，这些可能的模型之中到底哪个是最靠谱的呢？前面提到，一个衡量的依据是奥卡姆剃刀：越是高阶的多项式越是繁复和不常见。然而，我们其实并不需要依赖于这个先验的奥卡姆剃刀，因为有人可能会争辩说：你怎么就能说越高阶的多项式越不常见呢？我偏偏觉得所有阶多项式都是等可能的。好吧，既然如此那我们不妨就扔掉 P(h) 项，看看 P(D | h) 能告诉我们什么。我们注意到越是高阶的多项式，它的轨迹弯曲程度越是大，到了八九阶简直就是直上直下，于是我们不仅要问：一个比如说八阶多项式在平面上随机生成的一堆 N 个点偏偏恰好近似构成一条直线的概率（即 P(D | h) ）有多大？太小太小了。反之，如果背后的模型是一条直线，那么根据该模型生成一堆近似构成直线的点的概率就大得多了。这就是贝叶斯奥卡姆剃刀。 这里只是提供一个关于贝叶斯奥卡姆剃刀的科普，强调直观解释，更多理论公式请参考 MacKay 的著作 《Information Theory : Inference and Learning Algorithms》第 28 章。 3.3 最小描述长度原则贝叶斯模型比较理论与信息论有一个有趣的关联： P(h | D) ∝ P(h) * P(D | h) 两边求对数，将右式的乘积变成相加： ln P(h | D) ∝ ln P(h) + ln P(D | h) 显然，最大化 P(h | D) 也就是最大化 ln P(h | D)。而 ln P(h) + ln P(D | h) 则可以解释为模型（或者称“假设”、“猜测”）h 的编码长度加上在该模型下数据 D 的编码长度。使这个和最小的模型就是最佳模型。 而究竟如何定义一个模型的编码长度，以及数据在模型下的编码长度则是一个问题。更多可参考 Mitchell 的 《Machine Learning》的 6.6 节，或 Mackay 的 28.3 节） 3.4 最优贝叶斯推理所谓的推理，分为两个过程，第一步是对观测数据建立一个模型。第二步则是使用这个模型来推测未知现象发生的概率。我们前面都是讲的对于观测数据给出最靠谱的那个模型。然而很多时候，虽然某个模型是所有模型里面最靠谱的，但是别的模型也并不是一点机会都没有。譬如第一个模型在观测数据下的概率是 0.5 。第二个模型是 0.4 ，第三个是 0.1 。如果我们只想知道对于观测数据哪个模型最可能，那么只要取第一个就行了，故事到此结束。然而很多时候我们建立模型是为了推测未知的事情的发生概率，这个时候，三个模型对未知的事情发生的概率都会有自己的预测，仅仅因为某一个模型概率稍大一点就只听他一个人的就太不民主了。所谓的最优贝叶斯推理就是将三个模型对于未知数据的预测结论加权平均起来（权值就是模型相应的概率）。显然，这个推理是理论上的制高点，无法再优了，因为它已经把所有可能性都考虑进去了。 只不过实际上我们是基本不会使用这个框架的，因为计算模型可能非常费时间，二来模型空间可能是连续的，即有无穷多个模型（这个时候需要计算模型的概率分布）。结果还是非常费时间。所以这个被看作是一个理论基准。 4. 无处不在的贝叶斯以下我们再举一些实际例子来说明贝叶斯方法被运用的普遍性，这里主要集中在机器学习方面，因为我不是学经济的，否则还可以找到一堆经济学的例子。 4.1 中文分词贝叶斯是机器学习的核心方法之一。比如中文分词领域就用到了贝叶斯。Google 研究员吴军在《数学之美》系列中就有一篇是介绍中文分词的，这里只介绍一下核心的思想，不做赘述。 分词问题的描述为：给定一个句子（字串），如： 南京市长江大桥 如何对这个句子进行分词（词串）才是最靠谱的。例如： 南京市/长江大桥 南京/市长/江大桥 这两个分词，到底哪个更靠谱呢？ 我们用贝叶斯公式来形式化地描述这个问题，令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们就是需要寻找使得 P(Y|X) 最大的 Y ，使用一次贝叶斯可得： P(Y|X) ∝ P(Y)*P(X|Y) 用自然语言来说就是 这种分词方式（词串）的可能性 乘以 这个词串生成我们的句子的可能性。我们进一步容易看到：可以近似地将 P(X|Y) 看作是恒等于 1 的，因为任意假想的一种分词方式之下生成我们的句子总是精准地生成的（只需把分词之间的分界符号扔掉即可）。于是，我们就变成了去最大化 P(Y) ，也就是寻找一种分词使得这个词串（句子）的概率最大化。而如何计算一个词串： W1, W2, W3, W4 .. 的可能性呢？我们知道，根据联合概率（Joint probability distribution）的公式展开：P(W1, W2, W3, W4 ..) = P(W1) P(W2|W1) P(W3|W2, W1) P(W4|W1,W2,W3) .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），数据稀疏问题也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元语言模型（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) P(W2|W1) P(W3|W2) * P(W4|W3) .. （假设每个词只依赖于它前面的一个词）。而统计 P(W2|W1) 就不再受到数据稀疏问题的困扰了。对于我们上面提到的例子“南京市长江大桥”，如果按照自左到右的贪婪方法分词的话，结果就成了“南京市长/江大桥”。但如果按照贝叶斯分词的话（假设使用 3-gram），由于“南京市长”和“江大桥”在语料库中一起出现的频率为 0 ，这个整句的概率便会被判定为 0 。 从而使得“南京市/长江大桥”这一分词方式胜出。 一点注记：有人可能会疑惑，难道我们人类也是基于这些天真的假设来进行推理的？不是的。事实上，统计机器学习方法所统计的东西往往处于相当表层（shallow）的层面，在这个层面机器学习只能看到一些非常表面的现象，有一点科学研究的理念的人都知道：越是往表层去，世界就越是繁复多变。从机器学习的角度来说，特征（feature）就越多，成百上千维度都是可能的。特征一多，好了，高维诅咒就产生了，数据就稀疏得要命，不够用了。而我们人类的观察水平显然比机器学习的观察水平要更深入一些，为了避免数据稀疏我们不断地发明各种装置（最典型就是显微镜），来帮助我们直接深入到更深层的事物层面去观察更本质的联系，而不是在浅层对表面现象作统计归纳。举一个简单的例子，通过对大规模语料库的统计，机器学习可能会发现这样一个规律：所有的“他”都是不会穿 bra 的，所有的“她”则都是穿的。然而，作为一个男人，却完全无需进行任何统计学习，因为深层的规律就决定了我们根本不会去穿 bra 。至于机器学习能不能完成后者（像人类那样的）这个推理，则是人工智能领域的经典问题。至少在那之前，声称统计学习方法能够终结科学研究（原文）的说法是纯粹外行人说的话。 4.2 统计机器翻译统计机器翻译因为其简单，自动（无需手动添加规则），迅速成为了机器翻译的事实标准。而统计机器翻译的核心算法也是使用的贝叶斯方法。 问题是什么？统计机器翻译的问题可以描述为：给定一个句子 e ，它的可能的外文翻译 f 中哪个是最靠谱的。即我们需要计算：P(f|e) 。一旦出现条件概率贝叶斯总是挺身而出： P(f|e) ∝ P(f) * P(e|f) 这个式子的右端很容易解释：那些先验概率较高，并且更可能生成句子 e 的外文句子 f 将会胜出。我们只需简单统计（结合上面提到的 N-Gram 语言模型）就可以统计任意一个外文句子 f 的出现概率。然而 P(e|f) 却不是那么好求的，给定一个候选的外文局子 f ，它生成（或对应）句子 e 的概率是多大呢？我们需要定义什么叫 “对应”，这里需要用到一个分词对齐的平行语料库，有兴趣的可以参考 《Foundations of Statistical Natural Language Processing》第 13 章，这里摘选其中的一个例子：假设 e 为：John loves Mary 。我们需要考察的首选 f 是：Jean aime Marie （法文）。我们需要求出 P(e|f) 是多大，为此我们考虑 e 和 f 有多少种对齐的可能性，如： John (Jean) loves (aime) Marie (Mary) 就是其中的一种（最靠谱的）对齐，为什么要对齐，是因为一旦对齐了之后，就可以容易地计算在这个对齐之下的 P(e|f) 是多大，只需计算： P(John|Jean) * P(loves|aime) * P(Marie|Mary) 即可。 然后我们遍历所有的对齐方式，并将每种对齐方式之下的翻译概率 ∑ 求和。便可以获得整个的 P(e|f) 是多大。 一点注记： 还是那个问题：难道我们人类真的是用这种方式进行翻译的？highly unlikely 。这种计算复杂性非常高的东西连三位数乘法都搞不定的我们才不会笨到去使用呢。根据认知神经科学的认识，很可能我们是先从句子到语义（一个逐层往上（bottom-up）抽象的 folding 过程），然后从语义根据另一门语言的语法展开为另一门语言（一个逐层往下（top-down）的具体化 unfolding 过程）。如何可计算地实现这个过程，目前仍然是个难题。（我们看到很多地方都有 bottom-up/top-down 这样一个对称的过程，实际上有人猜测这正是生物神经网络原则上的运作方式，对视觉神经系统的研究尤其证明了这一点，Hawkins 在 《On Intelligence》 里面提出了一种 HTM （Hierarchical Temporal Memory）模型正是使用了这个原则。） 4.3 贝叶斯图像识别(Analysis by Synthesis)贝叶斯方法是一个非常 general 的推理框架。其核心理念可以描述成：Analysis by Synthesis （通过合成来分析）。06 年的认知科学新进展上有一篇 paper 就是讲用贝叶斯推理来解释视觉识别的，一图胜千言，下图就是摘自这篇 paper ： 首先是视觉系统提取图形的边角特征，然后使用这些特征自底向上地激活高层的抽象概念（比如是 E 还是 F 还是等号），然后使用一个自顶向下的验证来比较到底哪个概念最佳地解释了观察到的图像。 4.4 EM 算法与基于模型的聚类聚类（Cluster analysis）是一种无监督的机器学习问题，问题描述：给你一堆数据点，让你将它们最靠谱地分成一堆一堆的。聚类算法很多，不同的算法适应于不同的问题，这里仅介绍一个基于模型的聚类，该聚类算法对数据点的假设是，这些数据点分别是围绕 K 个核心的 K 个正态分布源所随机生成的，使用 Han JiaWei 的《Data Ming： Concepts and Techniques》中的图： 图中有两个正态分布核心，生成了大致两堆点。我们的聚类算法就是需要根据给出来的那些点，算出这两个正态分布的核心在什么位置，以及分布的参数是多少。这很明显又是一个贝叶斯问题，但这次不同的是，答案是连续的且有无穷多种可能性，更糟的是，只有当我们知道了哪些点属于同一个正态分布圈的时候才能够对这个分布的参数作出靠谱的预测，现在两堆点混在一块我们又不知道哪些点属于第一个正态分布，哪些属于第二个。反过来，只有当我们对分布的参数作出了靠谱的预测时候，才能知道到底哪些点属于第一个分布，那些点属于第二个分布。这就成了一个先有鸡还是先有蛋的问题了。为了解决这个循环依赖，总有一方要先打破僵局，说，不管了，我先随便整一个值出来，看你怎么变，然后我再根据你的变化调整我的变化，然后如此迭代着不断互相推导，最终收敛到一个解。这就是 EM 算法。 EM 的意思是“Expectation-Maximazation”，在这个聚类问题里面，我们是先随便猜一下这两个正态分布的参数：如核心在什么地方，方差是多少。然后计算出每个数据点更可能属于第一个还是第二个正态分布圈，这个是属于 Expectation 一步。有了每个数据点的归属，我们就可以根据属于第一个分布的数据点来重新评估第一个分布的参数（从蛋再回到鸡），这个是 Maximazation 。如此往复，直到参数基本不再发生变化为止。这个迭代收敛过程中的贝叶斯方法在第二步，根据数据点求分布的参数上面。 4.5 最大似然与最小二乘 学过线性代数的大概都知道经典的最小二乘方法来做线性回归。问题描述是：给定平面上 N 个点，（这里不妨假设我们想用一条直线来拟合这些点——回归可以看作是拟合的特例，即允许误差的拟合），找出一条最佳描述了这些点的直线。 一个接踵而来的问题就是，我们如何定义最佳？我们设每个点的坐标为 (Xi, Yi) 。如果直线为 y = f(x) 。那么 (Xi, Yi) 跟直线对这个点的“预测”：(Xi, f(Xi)) 就相差了一个 ΔYi = |Yi – f(Xi)| 。最小二乘就是说寻找直线使得 (ΔY1)^2 + (ΔY2)^2 + .. （即误差的平方和）最小，至于为什么是误差的平方和而不是误差的绝对值和，统计学上也没有什么好的解释。然而贝叶斯方法却能对此提供一个完美的解释。 我们假设直线对于坐标 Xi 给出的预测 f(Xi) 是最靠谱的预测，所有纵坐标偏离 f(Xi) 的那些数据点都含有噪音，是噪音使得它们偏离了完美的一条直线，一个合理的假设就是偏离路线越远的概率越小，具体小多少，可以用一个正态分布曲线来模拟，这个分布曲线以直线对 Xi 给出的预测 f(Xi) 为中心，实际纵坐标为 Yi 的点 (Xi, Yi) 发生的概率就正比于 EXP[-(ΔYi)^2]。（EXP(..) 代表以常数 e 为底的多少次方）。 现在我们回到问题的贝叶斯方面，我们要想最大化的后验概率是： P(h|D) ∝ P(h) * P(D|h) 又见贝叶斯！这里 h 就是指一条特定的直线，D 就是指这 N 个数据点。我们需要寻找一条直线 h 使得 P(h) P(D|h) 最大。很显然，P(h) 这个先验概率是均匀的，因为哪条直线也不比另一条更优越。所以我们只需要看 P(D|h) 这一项，这一项是指这条直线生成这些数据点的概率，刚才说过了，生成数据点 (Xi, Yi) 的概率为 EXP[-(ΔYi)^2] 乘以一个常数。而 P(D|h) = P(d1|h) P(d2|h) .. 即假设各个数据点是独立生成的，所以可以把每个概率乘起来。于是生成 N 个数据点的概率为 EXP[-(ΔY1)^2] EXP[-(ΔY2)^2] EXP[-(ΔY3)^2] .. = EXP{-[(ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + ..]} 最大化这个概率就是要最小化 (ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + .. 。 熟悉这个式子吗？ 5. 朴素贝叶斯方法朴素贝叶斯方法是一个很特别的方法，所以值得介绍一下。我们用朴素贝叶斯在垃圾邮件过滤中的应用来举例说明。 5.1 贝叶斯垃圾邮件过滤器问题是什么？问题是，给定一封邮件，判定它是否属于垃圾邮件。按照先例，我们还是用 D 来表示这封邮件，注意 D 由 N 个单词组成。我们用 h+ 来表示垃圾邮件，h- 表示正常邮件。问题可以形式化地描述为求： P(h+|D) = P(h+) * P(D|h+) / P(D)P(h-|D) = P(h-) * P(D|h-) / P(D) 其中 P(h+) 和 P(h-) 这两个先验概率都是很容易求出来的，只需要计算一个邮件库里面垃圾邮件和正常邮件的比例就行了。然而 P(D|h+) 却不容易求，因为 D 里面含有 N 个单词 d1, d2, d3, .. ，所以P(D|h+) = P(d1,d2,..,dn|h+) 。我们又一次遇到了数据稀疏性，为什么这么说呢？P(d1,d2,..,dn|h+) 就是说在垃圾邮件当中出现跟我们目前这封邮件一模一样的一封邮件的概率是多大！开玩笑，每封邮件都是不同的，世界上有无穷多封邮件。瞧，这就是数据稀疏性，因为可以肯定地说，你收集的训练数据库不管里面含了多少封邮件，也不可能找出一封跟目前这封一模一样的。结果呢？我们又该如何来计算 P(d1,d2,..,dn|h+) 呢？ 我们将 P(d1,d2,..,dn|h+) 扩展为： P(d1|h+) P(d2|d1, h+) P(d3|d2,d1, h+) .. 。熟悉这个式子吗？这里我们会使用一个更激进的假设，我们假设 di 与 di-1 是完全条件无关的，于是式子就简化为 P(d1|h+) P(d2|h+) P(d3|h+) .. 。这个就是所谓的条件独立假设，也正是朴素贝叶斯方法的朴素之处。而计算 P(d1|h+) P(d2|h+) P(d3|h+) * .. 就太简单了，只要统计 di 这个单词在垃圾邮件中出现的频率即可。关于贝叶斯垃圾邮件过滤更多的内容可以参考这个条目，注意其中提到的其他资料。 一点注记：这里，为什么有这个数据稀疏问题，还是因为统计学习方法工作在浅层面，世界上的单词就算不再变多也是非常之多的，单词之间组成的句子也是变化多端，更不用说一篇文章了，文章数目则是无穷的，所以在这个层面作统计，肯定要被数据稀疏性困扰。我们要注意，虽然句子和文章的数目是无限的，然而就拿邮件来说，如果我们只关心邮件中句子的语义（进而更高抽象层面的“意图”（语义，意图如何可计算地定义出来是一个人工智能问题），在这个层面上可能性便大大缩减了，我们关心的抽象层面越高，可能性越小。单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。神经科学的发现也表明大脑的皮层大致有一种层级结构，对应着越来越抽象的各个层面，至于如何具体实现一个可放在计算机内的大脑皮层，仍然是一个未解决问题，以上只是一个原则（principle）上的认识，只有当 computational 的 cortex 模型被建立起来了之后才可能将其放入电脑。 5.2 为什么朴素贝叶斯方法令人诧异地好——一个理论解释朴素贝叶斯方法的条件独立假设看上去很傻很天真，为什么结果却很好很强大呢？就拿一个句子来说，我们怎么能鲁莽地声称其中任意一个单词出现的概率只受到它前面的 3 个或 4 个单词的影响呢？别说 3 个，有时候一个单词的概率受到上一句话的影响都是绝对可能的。那么为什么这个假设在实际中的表现却不比决策树差呢？有人对此提出了一个理论解释，并且建立了什么时候朴素贝叶斯的效果能够等价于非朴素贝叶斯的充要条件，这个解释的核心就是：有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。具体的数学公式请参考这篇 paper（The Optimality of Naive Bayes） 。 6. 层级贝叶斯模型 层级贝叶斯模型是现代贝叶斯方法的标志性建筑之一。前面讲的贝叶斯，都是在同一个事物层次上的各个因素之间进行统计推理，然而层次贝叶斯模型在哲学上更深入了一层，将这些因素背后的因素（原因的原因，原因的原因，以此类推）囊括进来。一个教科书例子是：如果你手头有 N 枚硬币，它们是同一个工厂铸出来的，你把每一枚硬币掷出一个结果，然后基于这 N 个结果对这 N 个硬币的 θ （出现正面的比例）进行推理。如果根据最大似然，每个硬币的 θ 不是 1 就是 0 （这个前面提到过的），然而我们又知道每个硬币的 p(θ) 是有一个先验概率的，也许是一个 beta 分布。也就是说，每个硬币的实际投掷结果 Xi 服从以 θ 为中心的正态分布，而 θ 又服从另一个以 Ψ 为中心的 beta 分布。层层因果关系就体现出来了。进而 Ψ 还可能依赖于因果链上更上层的因素，以此类推。 6.1 隐马可夫模型（HMM） 吴军在数学之美系列里面介绍的隐马可夫模型（Hidden Markov model）就是一个简单的层级贝叶斯模型： 那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做“隐含马尔可夫模型”（Hidden Markov Model）来解决这些问题。以语音识别为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,… 吴军的文章中这里省掉没说的是，s1, s2, s3, .. 这个句子的生成概率同时又取决于一组参数，这组参数决定了 s1, s2, s3, .. 这个马可夫链的先验生成概率。如果我们将这组参数记为 λ ，我们实际上要求的是：P(S|O, λ) （其中 O 表示 o1,o2,o3,.. ，S表示 s1,s2,s3,..） 当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公式并且省掉一个常数项，可以把上述公式等价变换成 P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…) 其中 P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…的可能性, 而P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的可能性，所以这个公式的意义是用发送信号为s1,s2,s3…这个数列的可能性乘以 s1,s2,s3.. 本身可以一个句子的可能性，得出概率。 这里，s1,s2,s3…本身可以一个句子的可能性其实就取决于参数 λ ，也就是语言模型。所以简而言之就是发出的语音信号取决于背后实际想发出的句子，而背后实际想发出的句子本身的独立先验概率又取决于语言模型。 7. 贝叶斯网络吴军已经对贝叶斯网络作了科普。更详细的理论参考所有机器学习的书上都有。 【参考资料】一堆机器学习，一堆概率统计，一堆 Google ，和一堆 Wikipedia 条目，一堆 paper 。 部分书籍参考《机器学习与人工智能资源导引》。 本文转载自 《数学之美番外篇：平凡而又神奇的贝叶斯方法》 刘未鹏mindhacks.cn","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Bayesian","slug":"Bayesian","permalink":"http://github.com/tags/Bayesian/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】RxJava 入门详解","slug":"【Android】RxJava 入门详解","date":"2016-12-19T11:03:00.000Z","updated":"2016-12-22T03:23:45.927Z","comments":true,"path":"2016/12/19/【Android】RxJava 入门详解/","link":"","permalink":"http://github.com/2016/12/19/【Android】RxJava 入门详解/","excerpt":"本文转载自 给 Android 开发者的 RxJava 详解 —— by 扔物线 前言我从去年开始使用 RxJava ，到现在一年多了。今年加入了 Flipboard 后，看到 Flipboard 的 Android 项目也在使用 RxJava ，并且使用的场景越来越多 。而最近这几个月，我也发现国内越来越多的人开始提及 RxJava 。有人说『RxJava 真是太好用了』，有人说『RxJava 真是太难用了』，另外更多的人表示：我真的百度了也谷歌了，但我还是想问： RxJava 到底是什么？ 鉴于 RxJava 目前这种既火爆又神秘的现状，而我又在一年的使用过程中对 RxJava 有了一些理解，我决定写下这篇文章来对 RxJava 做一个相对详细的、针对 Android 开发者的介绍。 这篇文章的目的有两个： 给对 RxJava 感兴趣的人一些入门的指引 给正在使用 RxJava 但仍然心存疑惑的人一些更深入的解析 在正文开始之前的最后，放上 GitHub 链接和引入依赖的 gradle 代码：RxJava ： https://github.com/ReactiveX/RxJavaRxAndroid： https://github.com/ReactiveX/RxAndroid 引入依赖： //（版本号是文章发布时的最新稳定版）compile 'io.reactivex:rxjava:1.0.14' compile 'io.reactivex:rxandroid:1.0.1'","text":"本文转载自 给 Android 开发者的 RxJava 详解 —— by 扔物线 前言我从去年开始使用 RxJava ，到现在一年多了。今年加入了 Flipboard 后，看到 Flipboard 的 Android 项目也在使用 RxJava ，并且使用的场景越来越多 。而最近这几个月，我也发现国内越来越多的人开始提及 RxJava 。有人说『RxJava 真是太好用了』，有人说『RxJava 真是太难用了』，另外更多的人表示：我真的百度了也谷歌了，但我还是想问： RxJava 到底是什么？ 鉴于 RxJava 目前这种既火爆又神秘的现状，而我又在一年的使用过程中对 RxJava 有了一些理解，我决定写下这篇文章来对 RxJava 做一个相对详细的、针对 Android 开发者的介绍。 这篇文章的目的有两个： 给对 RxJava 感兴趣的人一些入门的指引 给正在使用 RxJava 但仍然心存疑惑的人一些更深入的解析 在正文开始之前的最后，放上 GitHub 链接和引入依赖的 gradle 代码：RxJava ： https://github.com/ReactiveX/RxJavaRxAndroid： https://github.com/ReactiveX/RxAndroid 引入依赖： //（版本号是文章发布时的最新稳定版）compile 'io.reactivex:rxjava:1.0.14' compile 'io.reactivex:rxandroid:1.0.1' RxJava 到底是什么一个词：异步。 RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。 然而，对于初学者来说，这太难看懂了。因为它是一个『总结』，而初学者更需要一个『引言』。 其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。 RxJava 好在哪换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / … ？』 一个词：简洁。 异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 举个例子？假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种： new Thread() &#123; @Override public void run() &#123; super.run(); for (File folder : folders) &#123; File[] files = folder.listFiles(); for (File file : files) &#123; if (file.getName().endsWith(\".png\")) &#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的： Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(\".png\"); &#125; &#125;) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); 那位说话了：『你这代码明明变多了啊！简洁个毛啊！』大兄弟你消消气，我说的是逻辑的简洁，不是单纯的代码量少（逻辑简洁才是提升读写代码速度的必杀技对不？）。观察一下你会发现， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显（试想如果还要求只选取前 10 张图片，常规方式要怎么办？如果有更多这样那样的要求呢？再试想，在这一大堆需求实现完两个月之后需要改功能，当你翻回这里看到自己当初写下的那一片迷之缩进，你能保证自己将迅速看懂，而不是对着代码重新捋一遍思路？）。 另外，如果你的 IDE 是 Android Studio ，其实每次打开某个 Java 文件的时候，你会看到被自动 Lambda 化的预览，这将让你更加清晰地看到程序逻辑： Observable.from(folders) .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;) .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(\".png\") &#125;) .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;); 如果你习惯使用 Retrolambda ，你也可以直接把代码写成上面这种简洁的形式。而如果你看到这里还不知道什么是 Retrolambda ，我不建议你现在就去学习它。原因有两点：1. Lambda 是把双刃剑，它让你的代码简洁的同时，降低了代码的可读性，因此同时学习 RxJava 和 Retrolambda 可能会让你忽略 RxJava 的一些技术细节；2. Retrolambda 是 Java 6/7 对 Lambda 表达式的非官方兼容方案，它的向后兼容性和稳定性是无法保障的，因此对于企业项目，使用 Retrolambda 是有风险的。所以，与很多 RxJava 的推广者不同，我并不推荐在学习 RxJava 的同时一起学习 Retrolambda。事实上，我个人虽然很欣赏 Retrolambda，但我从来不用它。 在Flipboard 的 Android 代码中，有一段逻辑非常复杂，包含了多次内存操作、本地文件操作和网络操作，对象分分合合，线程间相互配合相互等待，一会儿排成人字，一会儿排成一字。如果使用常规的方法来实现，肯定是要写得欲仙欲死，然而在使用 RxJava 的情况下，依然只是一条链式调用就完成了。它很长，但很清晰。 所以， RxJava 好在哪？就好在简洁，好在那把什么复杂逻辑都能穿成一条线的简洁。 API 介绍和原理简析这个我就做不到一个词说明了……因为这一节的主要内容就是一步步地说明 RxJava 到底怎样做到了异步，怎样做到了简洁。 1. 概念：扩展的观察者模式RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。 观察者模式先简述一下观察者模式，已经熟悉的可以跳过这一段。 观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用注册(Register)或者称为订阅(Subscribe)的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 OnClickListener 。对设置 OnClickListener 来说， View 是被观察者， OnClickListener 是观察者，二者通过 setOnClickListener() 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 OnClickListener 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷：『你在作案的时候务必通知我』。 OnClickListener 的模式大致如下图： 如图所示，通过 setOnClickListener() 方法，Button 持有 OnClickListener 的引用（这一过程没有在图上画出）；当用户点击时，Button 自动调用 OnClickListener 的 onClick() 方法。另外，如果把这张图中的概念抽象出来（Button -&gt; 被观察者、OnClickListener -&gt; 观察者、setOnClickListener() -&gt; 订阅，onClick() -&gt; 事件），就由专用的观察者模式（例如只用于监听控件点击）转变成了通用的观察者模式。如下图： 而 RxJava 作为一个工具库，使用的就是通用形式的观察者模式。 RxJava 的观察者模式RxJava 有四个基本概念： Observable (可观察者，即被观察者) Observer (观察者) subscribe (订阅) Event (事件) Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。 与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。 onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。 onError(): 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 RxJava 的观察者模式大致如下图： 2. 基本实现基于以上的概念， RxJava 的基本实现主要有三点： 1) 创建 ObserverObserver 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式： Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的： Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点： onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。 unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 2) 创建 ObservableObservable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则： Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello\"); subscriber.onNext(\"Hi\"); subscriber.onNext(\"Aloha\"); subscriber.onCompleted(); &#125;&#125;); 可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 这个例子很简单：事件的内容是字符串，而不是一些复杂的对象；事件的内容是已经定好了的，而不像有的观察者模式一样是待确定的（例如网络请求的结果在请求返回之前是未知的）；所有事件在一瞬间被全部发送出去，而不是夹杂一些确定或不确定的时间间隔或者经过某种触发器来触发的。总之，这个例子看起来毫无实用价值。但这是为了便于说明，实质上只要你想，各种各样的事件发送规则你都可以自己来写。至于具体怎么做，后面都会讲到，但现在不行。只有把基础原理先说明白了，上层的运用才能更容易说清楚。 create() 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如： just(T...) : 将传入的参数依次发送出来。 Observable observable = Observable.just(\"Hello\", \"Hi\", \"Aloha\");// 将会依次调用：// onNext(\"Hello\");// onNext(\"Hi\");// onNext(\"Aloha\");// onCompleted(); from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 String[] words = &#123;\"Hello\", \"Hi\", \"Aloha\"&#125;;Observable observable = Observable.from(words);// 将会依次调用：// onNext(\"Hello\");// onNext(\"Hi\");// onNext(\"Aloha\");// onCompleted(); 上面 just(T...) 的例子和 from(T[]) 的例子，都和之前的 create(OnSubscribe) 的例子是等价的。 3) Subscribe (订阅)创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单： observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 有人可能会注意到， subscribe() 这个方法有点怪：它看起来是『observalbe 订阅了 observer / subscriber』而不是『observer / subscriber 订阅了 observalbe』，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成 observer.subscribe(observable) / subscriber.subscribe(observable) ，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。 Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）： // 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public Subscription subscribe(Subscriber subscriber) &#123; subscriber.onStart(); onSubscribe.call(subscriber); return subscriber;&#125; 可以看到，subscriber() 做了3件事： 调用 Subscriber.onStart() 。这个方法在前面已经介绍过，是一个可选的准备方法。 调用 Observable 中的 OnSubscribe.call(Subscriber) 。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe() 方法执行的时候。 将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe(). 整个过程中对象间的关系如下图： 除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。形式如下： Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; // onNext() @Override public void call(String s) &#123; Log.d(tag, s); &#125;&#125;;Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; // onError() @Override public void call(Throwable throwable) &#123; // Error handling &#125;&#125;;Action0 onCompletedAction = new Action0() &#123; // onCompleted() @Override public void call() &#123; Log.d(tag, \"completed\"); &#125;&#125;;// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()observable.subscribe(onNextAction);// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()observable.subscribe(onNextAction, onErrorAction);// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 简单解释一下这段代码中出现的 Action1 和 Action0。 Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。 Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。 注：正如前面所提到的，Observer 和 Subscriber 具有相同的角色，而且 Observer 在 subscribe() 过程中最终会被转换成 Subscriber 对象，因此，从这里开始，后面的描述我将用 Subscriber 来代替 Observer ，这样更加严谨。 4) 场景示例下面举两个例子： 为了把原理用更清晰的方式表述出来，本文中挑选的都是功能尽可能简单的例子，以至于有些示例代码看起来会有『画蛇添足』『明明不用 RxJava 可以更简便地解决问题』的感觉。当你看到这种情况，不要觉得是因为 RxJava 太啰嗦，而是因为在过早的时候举出真实场景的例子并不利于原理的解析，因此我刻意挑选了简单的情景。 a. 打印字符串数组 将字符串数组 names 中的所有字符串依次打印出来： String[] names = ...;Observable.from(names) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String name) &#123; Log.d(tag, name); &#125; &#125;); b. 由 id 取得图片并显示 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;); 正如上面两个例子这样，创建出 Observable 和 Subscriber ，再用 subscribe() 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。 然而， 在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。 3. 线程控制 —— Scheduler (一)在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 1) Scheduler 的 API (一)在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 文字叙述总归难理解，上代码： Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.d(tag, \"number:\" + number); &#125; &#125;); 上面这段代码中，由于 subscribeOn(Schedulers.io()) 的指定，被创建的事件的内容 1、2、3、4 将会在 IO线程 发出；而由于 observeOn(AndroidScheculers.mainThread()) 的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。 而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句： int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程.subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;); 那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。 2) Scheduler 的原理 (一)RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 subscribe() 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。 好吧这一节其实我屁也没说，只是为了让你安心，让你知道我不是忘了讲原理，而是把它放在了更合适的地方。 4. 变换终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。 RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。 1) API首先看一个 map() 的例子： Observable.just(\"images/logo.png\") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap &#125; &#125;) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap showBitmap(bitmap); &#125; &#125;); 这里出现了一个叫做 Func1 的类。它和 Action1 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。 可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换： map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 map() 的示意图： flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单： Student[] students = ...;Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String name) &#123; Log.d(tag, name); &#125; ...&#125;;Observable.from(students) .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student student) &#123; return student.getName(); &#125; &#125;) .subscribe(subscriber); 很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现： Student[] students = ...;Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() &#123; @Override public void onNext(Student student) &#123; List&lt;Course&gt; courses = student.getCourses(); for (int i = 0; i &lt; courses.size(); i++) &#123; Course course = courses.get(i); Log.d(tag, course.getName()); &#125; &#125; ...&#125;;Observable.from(students) .subscribe(subscriber); 依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？ 这个时候，就需要用 flatMap() 了： Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; Log.d(tag, course.getName()); &#125; ...&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); 从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的： 使用传入的事件对象创建一个 Observable 对象； 并不发送这个 Observable, 而是将它激活，于是它开始发送事件； 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。 这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。 flatMap() 示意图： 扩展：由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）： networkClient.token() // 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token .flatMap(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() &#123; @Override public Observable&lt;Messages&gt; call(String token) &#123; // 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表 return networkClient.messages(); &#125; &#125;) .subscribe(new Action1&lt;Messages&gt;() &#123; @Override public void call(Messages messages) &#123; // 处理显示消息列表 showMessages(messages); &#125; &#125;); 传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 flatMap() ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。 throttleFirst() : 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器： RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); 妈妈再也不怕我的用户手抖点开两个重复的界面啦。 此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。 2) 变换的原理：lift()这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）： // 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) &#123; return Observable.create(new OnSubscribe&lt;R&gt;() &#123; @Override public void call(Subscriber subscriber) &#123; Subscriber newSubscriber = operator.call(subscriber); newSubscriber.onStart(); onSubscribe.call(newSubscriber); &#125; &#125;);&#125; 这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）—— subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。 当含有 lift() 时： lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； 而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe； 当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； 而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。 精简掉细节的话，也可以这么说：在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。 如果你更喜欢具象思维，可以看图： 或者可以看动图： 两次和多次的 lift() 同理，如下图： 举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考： observable.lift(new Observable.Operator&lt;String, Integer&gt;() &#123; @Override public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) &#123; // 将事件序列中的 Integer 对象转换为 String 对象 return new Subscriber&lt;Integer&gt;() &#123; @Override public void onNext(Integer integer) &#123; subscriber.onNext(\"\" + integer); &#125; @Override public void onCompleted() &#123; subscriber.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; subscriber.onError(e); &#125; &#125;; &#125;&#125;); 讲述 lift() 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 lift() 的原理，RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 lift() 包装方法（如 map() flatMap() 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。 3) compose: 对 Observable 整体的变换除了 lift() 之外， Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 lift() 变换。你可以这么写： observable1 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber1);observable2 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber2);observable3 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber3);observable4 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber1); 你觉得这样太不软件工程了，于是你改成了这样： private Observable liftAll(Observable observable) &#123; return observable .lift1() .lift2() .lift3() .lift4();&#125;...liftAll(observable1).subscribe(subscriber1);liftAll(observable2).subscribe(subscriber2);liftAll(observable3).subscribe(subscriber3);liftAll(observable4).subscribe(subscriber4); 可读性、可维护性都提高了。可是 Observable 被一个方法包起来，这种方式对于 Observale 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 compose() 来解决了： public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; &#123; @Override public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) &#123; return observable .lift1() .lift2() .lift3() .lift4(); &#125;&#125;...Transformer liftAll = new LiftAllTransformer();observable1.compose(liftAll).subscribe(subscriber1);observable2.compose(liftAll).subscribe(subscriber2);observable3.compose(liftAll).subscribe(subscriber3);observable4.compose(liftAll).subscribe(subscriber4); 像上面这样，使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call() 方法直接对自身进行处理，也就不必被包在方法的里面了。 compose() 的原理比较简单，不附图喽。 5. 线程控制：Scheduler (二)除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。 1) Scheduler 的 API (二)前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map()、 flatMap() 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？ 答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。上代码： Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定 .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(mapOperator) // 新线程，由 observeOn() 指定 .observeOn(Schedulers.io()) .map(mapOperator2) // IO 线程，由 observeOn() 指定 .observeOn(AndroidSchedulers.mainThread) .subscribe(subscriber); // Android 主线程，由 observeOn() 指定 如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。 不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。 又有好事的（其实还是当初的我）问了：如果我非要调用多次 subscribeOn() 呢？会有什么效果？ 这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。 2) Scheduler 的原理（二）其实， subscribeOn() 和 observeOn() 的内部实现，也是用的 lift()。具体看图（不同颜色的箭头表示不同的线程）： subscribeOn() 原理图： observeOn() 原理图： 从图中可以看出，subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn() 的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。 最后，我用一张图来解释当多个 subscribeOn() 和 observeOn() 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）： 图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。 3) 延伸：doOnSubscribe()然而，虽然超过一个的 subscribeOn() 对事件处理的流程没有影响，但在流程之前却是可以利用的。 在前面讲 Subscriber 的时候，提到过 Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。 而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。 示例代码： Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); 如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。 RxJava 的适用场景和使用方式1. 与 Retrofit 的结合 Retrofit 是 Square 的一个著名的网络请求库。没有用过 Retrofit 的可以选择跳过这一小节也没关系，我举的每种场景都只是个例子，而且例子之间并无前后关联，只是个抛砖引玉的作用，所以你跳过这里看别的场景也可以的。 Retrofit 除了提供了传统的 Callback 形式的 API，还有 RxJava 版本的 Observable 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。 以获取一个 User 对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求： @GET(\"/user\")public void getUser(@Query(\"userId\") String userId, Callback&lt;User&gt; callback); 在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应： getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 而使用 RxJava 形式的 API，定义同样的请求是这样的： @GET(\"/user\")public Observable&lt;User&gt; getUser(@Query(\"userId\") String userId); 使用的时候是这样的： getUser(userId) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 看到区别了吗？ 当 RxJava 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。 对比来看， Callback 形式和 Observable 形式长得不太一样，但本质都差不多，而且在细节上 Observable 形式似乎还比 Callback 形式要差点。那 Retrofit 为什么还要提供 RxJava 的支持呢？ 因为它好用啊！从这个例子看不出来是因为这只是最简单的情况。而一旦情景复杂起来， Callback 形式马上就会开始让人头疼。比如： 假设这么一种情况：你的程序取到的 User 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 Callback 方式大概可以这么写： getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; processUser(user); // 尝试修正 User 数据 userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 有问题吗？ 很简便，但不要这样做。为什么？因为这样做会影响性能。数据库的操作很重，一次读写操作花费 10~20ms 是很常见的，这样的耗时很容易造成界面的卡顿。所以通常情况下，如果可以的话一定要避免在主线程中处理数据库。所以为了提升性能，这段代码可以优化一下： getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; new Thread() &#123; @Override public void run() &#123; processUser(user); // 尝试修正 User 数据 runOnUiThread(new Runnable() &#123; // 切回 UI 线程 @Override public void run() &#123; userView.setUser(user); &#125; &#125;); &#125;).start(); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 性能问题解决，但……这代码实在是太乱了，迷之缩进啊！杂乱的代码往往不仅仅是美观问题，因为代码越乱往往就越难读懂，而如果项目中充斥着杂乱的代码，无疑会降低代码的可读性，造成团队开发效率的降低和出错率的升高。 这时候，如果用 RxJava 的形式，就好办多了。 RxJava 形式的代码是这样的： getUser(userId) .doOnNext(new Action1&lt;User&gt;() &#123; @Override public void call(User user) &#123; processUser(user); &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 后台代码和前台代码全都写在一条链中，明显清晰了很多。 再举一个例子：假设 /user 接口并不能直接访问，而需要填入一个在线获取的 token ，代码应该怎么写？ Callback 方式，可以使用嵌套的 Callback： @GET(\"/token\")public void getToken(Callback&lt;String&gt; callback);@GET(\"/user\")public void getUser(@Query(\"token\") String token, @Query(\"userId\") String userId, Callback&lt;User&gt; callback);...getToken(new Callback&lt;String&gt;() &#123; @Override public void success(String token) &#123; getUser(token, userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125; &#125;; &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;); 倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。 而使用 RxJava 的话，代码是这样的： @GET(\"/token\")public Observable&lt;String&gt; getToken();@GET(\"/user\")public Observable&lt;User&gt; getUser(@Query(\"token\") String token, @Query(\"userId\") String userId);...getToken() .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123; @Override public Observable&lt;User&gt; onNext(String token) &#123; return getUser(token, userId); &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 用一个 flatMap() 就搞定了逻辑，依然是一条链。看着就很爽，是吧？ 2016/03/31 更新，加上我写的一个 Sample 项目： rengwuxian RxJava Samples 好，Retrofit 部分就到这里。 2. RxBindingRxBinding 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 OnClickListener 、设置 TextWatcher 这样的注册绑定对象的 API。 举个设置点击监听的例子。使用 RxBinding ，可以把事件监听用这样的方法来设置： Button button = ...;RxView.clickEvents(button) // 以 Observable 形式来反馈点击事件 .subscribe(new Action1&lt;ViewClickEvent&gt;() &#123; @Override public void call(ViewClickEvent event) &#123; // Click handling &#125; &#125;); 看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 setOnClickListener() 来实现的。然而，仅仅这一个形式的改变，却恰好就是 RxBinding 的目的：扩展性。通过 RxBinding 把点击监听转换成 Observable 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 throttleFirst() ，用于去抖动，也就是消除手抖导致的快速连环点击： RxView.clickEvents(button) .throttleFirst(500, TimeUnit.MILLISECONDS) .subscribe(clickAction); 如果想对 RxBinding 有更多了解，可以去它的 GitHub 项目 下面看看。 3. 各种异步操作前面举的 Retrofit 和 RxBinding 的例子，是两个可以提供现成的 Observable 的库。而如果你有某些异步操作无法用这些库来自动生成 Observable，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现，有了之前几章的例子，这里应该不用再举例了。 4. RxBusRxBus 名字看起来像一个库，但它并不是一个库，而是一种模式。它的思想是使用 RxJava 来实现了 EventBus ，而让你不再需要使用 Otto 或者 GreenRobot 的 EventBus。至于什么是 RxBus，可以看这篇文章。顺便说一句，Flipboard 已经用 RxBus 替换掉了 Otto ，目前为止没有不良反应。 最后对于 Android 开发者来说， RxJava 是一个很难上手的库，因为它对于 Android 开发者来说有太多陌生的概念了。可是它真的很牛逼。因此，我写了这篇《给 Android 开发者的 RxJava 详解》，希望能给始终搞不明白什么是 RxJava 的人一些入门的指引，或者能让正在使用 RxJava 但仍然心存疑惑的人看到一些更深入的解析。无论如何，只要能给各位同为 Android 工程师的你们提供一些帮助，这篇文章的目的就达到了。 关于作者朱凯（扔物线），Flipboard 北京 Android 工程师。 为什么写这个？与两三年前的境况不同，中国现在已经不缺初级 Android 工程师，但中级和高级工程师严重供不应求。因此我决定从今天开始不定期地发布我的技术分享，只希望能够和大家共同提升，通过我们的成长来解决一点点国内互联网公司人才稀缺的困境，也提升各位技术党的收入。所以，不仅要写这篇，我还会写更多。至于内容的定位，我计划只定位真正的干货，一些边边角角的小技巧和炫酷的黑科技应该都不会写，总之希望每篇文章都能帮读者提升真正的实力。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://github.com/tags/RxJava/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】APK瘦身记，实现将近一半的压缩效果","slug":"【Android】APK瘦身记，实现将近一半的压缩效果","date":"2016-11-30T02:31:55.000Z","updated":"2016-12-22T05:01:06.038Z","comments":true,"path":"2016/11/30/【Android】APK瘦身记，实现将近一半的压缩效果/","link":"","permalink":"http://github.com/2016/11/30/【Android】APK瘦身记，实现将近一半的压缩效果/","excerpt":"本文转载自知乎： APK瘦身记，如何实现高达53%的压缩效果 —— by 阿里聚安全 一、我是怎么思考这件事情的APK是Android系统安装包的文件格式，关于这个话题其实是一个老生常谈的题目，不论是公司内部，还是外部网络，前人前辈已经总结出很多方法和规律。不过随着移动端技术近两年的飞速发展，一些新的思维方式和优化方法也逐渐涌现和成熟起来。笔者在实践过程中踩过一些坑，收获了一些经验，在这里做个思考和总结，所以随笔给大家，希望对大家从事相关工作的时候有所帮助和参考，同时也是抛砖引玉，希望大家共同探讨这个开放性的话题。 关于为什么APK要瘦身，这个不多说，只从三个方面唠叨一下，对于用户（或者客户）来说，APK越大，在下载安装过程中，他们耗费的流量会越多，安装等待时间也会越长；对于产品本身，意味着下载转化率会越低（因为竞品中，用户有更多机会选择那个体验最好，功能最多，性能最好，包最小的）；对于研发来说，是一种优化改进技术的机会。","text":"本文转载自知乎： APK瘦身记，如何实现高达53%的压缩效果 —— by 阿里聚安全 一、我是怎么思考这件事情的APK是Android系统安装包的文件格式，关于这个话题其实是一个老生常谈的题目，不论是公司内部，还是外部网络，前人前辈已经总结出很多方法和规律。不过随着移动端技术近两年的飞速发展，一些新的思维方式和优化方法也逐渐涌现和成熟起来。笔者在实践过程中踩过一些坑，收获了一些经验，在这里做个思考和总结，所以随笔给大家，希望对大家从事相关工作的时候有所帮助和参考，同时也是抛砖引玉，希望大家共同探讨这个开放性的话题。 关于为什么APK要瘦身，这个不多说，只从三个方面唠叨一下，对于用户（或者客户）来说，APK越大，在下载安装过程中，他们耗费的流量会越多，安装等待时间也会越长；对于产品本身，意味着下载转化率会越低（因为竞品中，用户有更多机会选择那个体验最好，功能最多，性能最好，包最小的）；对于研发来说，是一种优化改进技术的机会。 欲瘦身，我们先找找胖的原因和问题。按目标－路径－资源的思维模式，找原因和问题有如下几条路径，一是拍脑袋，按自己的经验和判断，甚至是主观想象；二是去搜索引擎找关键字，逛各种技术论坛听技术大牛们怎么说，看各类技术文章抽取提炼；三是用一种可测量的工具或者方法发现问题。 前两种不赘述，我这里说说第三种方法。用一种可测量的工具或者方法来分析，所谓工欲善其事，必先利其器。这个器可以可以自己锻造，也可以用现成的。这里推荐一个在线apk分析工具，因为是外部工具，所以大家请在使用过程中，不要上传未发布出去的产品，为了数据安全，笔者这里拿一个github上开源的Android项目作为瘦身示例。 二、寻找问题NimbleDroid 是美国哥伦比亚大学的博士创业团队研发出来的分析Android app性能指标的系统，分析的方式有静态和动态两种方式，其中静态分析可以分析出APK安装包中大文件排行榜，各种知名SDK的大小以及占代码整体的比例，各种类型文件的大小以及占排行，各种知名SDK的方法数以及占所有dex中方法数的比例，废话不多说，下面上高清无码大图看看颜值吧。 如果想使用分析功能分析自己的产品，请登录并上传自己产品的apk包，所有功能目前均免费使用，如果是想分析Google Play上已经发布的产品，可以直接点击”Play Apps”查看，还可以使用搜索功能根据应用名和包名查看结果。再次强调下，请不要上传任何未发布的产品。 登录 上传apk文件 分析结果摘要 可以看到一些概览的信息，apk文件大小，总的方法数 文件大小分析详情页，大文件列表 这里列出的是apk文件中超过100k的文件排行，这里的文件大小指的是apk文件中的大小 各种知名SDK的大小以及占代码整体的比例，这里目前能识别出Android Support，Jackson JSON parser, Google Play Services, Paypal, Glide, OkHttp, Facebook SDK, Fabric, Gson等等，Application表示App中自己编写的代码部分 各种类型文件的大小以及排行 各种知名SDK占所有dex中方法数的比例 各种知名SDK的方法数排行榜 看完这个apk内剖图是不是有一种神清气爽的感觉！我把这个分析工具比做我们家买的智能体重秤，可以称体重，脂肪含量，骨重，骨密度，肌肉含量等等，那么，我们是不是发现了一些问题，进而把这些问题和我们之前靠经验和一拍脑袋的原因可以用逻辑联系在一起。 那么，我们接下来可以通过分析数据整理出我们的优化目标 大文件排行榜里，有11张png文件的大小超过了100k，记住，这可是压缩之后的啊； 大文件排行榜里，resources.arsc的大小接近2M，这也是一个优化点； 大文件排行榜里，classes.dex接近3M，classes.dex是代码的载体，这块的优化需要细分，再去看看细分SDK的排行榜； 组件占比环图里，Android Support, Jackson JSON Parser和Google Play Services是三方库的前三甲； 文件类型排行榜里，png, dex 和arsc是前三甲； 三、梳理优化目标所以我们的目标是没有蛀牙，不对，是下面的目标： png图片优化； resources.arsc文件的优化； 代码优化 3.1 图片优化的尝试首先是第一个目标，图片的优化，慢点，我们看看这些图为什么这么大先，准确的说，为什么这些图在apk（其实就是zip文件）里这么大，好了，上工具分析。 这次用了一些简单的工具组合，系统自带的cmd就好。 命令执行的结果如下 恩，所有的png文件居然是STORE的方式存储到apk里的，关于zip里的STORE和DEFLATE，详见Wikipedia ) 通俗的说，当文件是STORED的方式存储到zip，表示这个文件并没有经过压缩，如果是Defl:N的方式，表示通过DEFLATED normal的方式压缩存储到zip。 这看起来有点不合理，png原封不动的放入zip，当然最后产出的apk会比较大。那么，如何解决呢？笔者首先尝使用android gradle plugin的方式，发现aaptOptions和packagingOptions都未能解决问题。在github上发现一个开源项目AndResGuard，试了集成到项目中，再看结果如下： 优化前： 10536027字节 优化后： 普通zip压缩： 8786265字节 （压缩了将近17%） 采用7zip压缩：8567150字节 （压缩了将近19%） 再看看这个工具做了什么，对比下开启资源混淆前后 优化前 优化后 资源（png, xml, jpg等）名称混淆，资源路径名称混淆以及名称长度压缩； 原来以STORED形式存储到zip中的png文件被改成了DEFLATED（普通压缩存储）方式； 意外发现resources.arsc, META-INF/.SF 以及 META-INF/.MF变小了，而且是解压之后的文件大小也变小了。 用apk反编译神器jadx内窥apk寻找真相 原来apk中资源（png, xml，以及properties文件）的相对路径会存放到META-INF/.SF 以及 META-INF/.MF中并为每个资源文件计算SHA1值并存储在这两个文件中，至于为啥这么做以及这两个SHA1有啥区别和作用请参考网络上关于这方面知识的文章，已超出本文的主题所以这里不再赘述。 对于resources.arsc文件 很容易看出来它是资源文件索引表，所以，看到这里大家应该明白这三个文件为啥会变小了吧。 3.2 一次意外的发现顺着resources.arsc往下看，发现一个有趣的东西， 这又将成为一个优化点，去除那些没用的翻译资源，引入一些第三方的SDK，往往这些SDK带了很多翻译资源在里面，比如android support库，去掉后我们来看看效果。 假设我们只保留英文，当然只是个实验，现实中看具体情况了， 采用7zip压缩：8220738字节 （压缩了将近22%，再增加3个点） 当然，真实的项目里不可能这样，但是蚊子肉也是肉啊！ 其实，我想说的是这提供了一种优化思路，就是利用gradle的配置干掉无用的资源，同样的可以用在so本地库上，分辨率（gradle配置已deprecated）上。 gradle配置示例如下： 记得包在android{}中间哦。那么，有人要问了，abi里肿么没有x86？据说intel提供了一个解决方案叫houdini，是一个运行在x86设备上的中间件，可以将arm转码为x86的指令，不过效率很低，有些运算型的，比如计算MD5和SHA1，甚至不如java，笔者曾经做过测试对比，又是另外一个话题，此处不赘述，感兴趣的读者可以移步。 到此为止，我们已经在朝第一个目标迈进，不经意间发现了第一个目标和第二个目标之间的关系，所以利用资源混淆工具，达成了第二个目标。 利用7zip压缩，我们对整个包进行了2个点的压缩，这是一个超出预期的成果。 3.3图片优化的方法关于第一个目标，我们的路径还没有结束，拍脑袋想出来的路径是压缩png，非alpha图转成jpg，还有什么？所以去各种技术论坛逛了一圈，请教了各种技术大牛，梳理的路径如下： 1、手动lint检查，手动删除代码中没有引用到的资源，实际效果不等。 在Android Studio中打开“Analyze” 然后选择”Inspect Code…”，范围选择整个项目，然后点击”OK” 配置如下图 2、gradle脚本中开启shrinkResources 脚本参考如下 shrinkResources配合minifyEnabled使用效果更佳，详见shrinkResources用法以及注意 采用7zip压缩：8115283字节 （压缩了将近23%，再增加1个点） 3、使用图片压缩工具，压缩png图的大小，将非alpha的图转换成jpg形式，关于这点同事以及网络上的大牛们已经整理的很详细了，我这里做简单总结，欲知详情，请见附录的参考。 使用tinypng，我只想说咱们在公司做产品，此方案慎用，上传任何未发布产品的内容到外部网络，都有可能引起数据泄漏，所以慎用此方案。下面说替代方案。 WASTED pngquant ImageAlpha ImageOptim 以上工具太散，有没有集成化的工具，答案是“有” @心伦 童鞋开发的imagemin @姐夫童鞋开发的MSImageResourcesHelper png转成jpg格式，具体效果不等。 4、终极大杀器，png转成webp，关于webp，更多详情请参考谷歌官方文档以及安卓开发者在线参考 先上效果图： 采用7zip压缩：4926912字节 （压缩了将近53%，再增加30个点） 没看错吧，是30个点，目前apk的大小是原始apk大小的一半不到，而我做的，一行代码木有改动，仅用了一些工具而已！ 说人话，我木有吃减肥药，木有绝食，体重却轻了一半！！！ 但是，目前却没能用到项目中，因为有两个坑 在三星的部分机型上，部分有alpha背景部分的图会有一条很明显的黑线，这里就不上图了，这个问题目前通过白名单的方式不去做成webp的图来处理； 在小米2刷成4.xx的手机上，未能正确识别xml文件中描述的webp图片，导致界面起来后加载xml布局文件，文件加载webp失败，报错说resource file not found，导致app发生崩溃。跟踪发现是小米机器代理了类Resource为MIUIResource，但是这个MIUIResource未能正确识别webp，所以导致加载资源文件失败，初步判定，目前暂时没有解决方案，所以只能忍痛放弃这个优化方案。 关于第一个目标，图片资源的优化，就写到这里了。 3.4 代码优化第二个目标已达成，剩下第三个目标，代码的优化，梳理如下优化路径： 1、开启proguard的代码优化将 proguardFiles getDefaultProguardFile('proguard-android.txt'),'proguard-project.txt' 改为 proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),'proguard-project.txt' 开启代码优化后的注意点请参见附录。 2、去除无用的库如果apk支持的最低版本是API14,而代码中没有用到高于api14的api就可以考虑拿掉整个android support库。 3、用更小的库替代方案如果只用到了谷歌统计，那么就不要把整个google play services都集成进来，只集成需要的部分。 4、定期清理废弃的代码定期删除无用的逻辑和过期的业务功能模块，以及废弃的A/B test代码。 5、业务模块采用插件化框架，代码动态从云端拉取插件化，这是另外一个课题了，这里不赘述。 apk瘦身记最终的成果 10536027字节压缩到4926912字节, 压缩了将近53% 总结 脚本中开启资源混淆和资源压缩 用7zip代替zip gradle脚本中开启代码混淆优化和无用资源删除 用更小的图，使用压缩工具压缩图片大小 去除无用的资源，语言，本地so库，二方三方库和分辨率 用更小的库 尝试将android support库彻底踢出你的项目 定期清理代码 尝试用H5编写界面，图片云端获取 尝试插件化业务模块 寻找到zip文件夹中所有用STORE形式存储的文件（不限于raw目录下），尝试压缩，以及替代方案加载这些资源 尝试webp的图片加载方案，寻求突破 最后，继续学习和尝试新的优化方案 以此文献给“唯瘦身与产品不可辜负”的技术们！！！ 附录 如何做到将apk大小减少6M Android APP终极瘦身指南 APK瘦身实践","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"APK","slug":"APK","permalink":"http://github.com/tags/APK/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"基于社区发现算法和图分析Neo4j解读《权力的游戏》","slug":"基于社区发现算法和图分析Neo4j解读《权力的游戏》","date":"2016-11-21T03:08:00.000Z","updated":"2016-12-09T07:27:27.747Z","comments":true,"path":"2016/11/21/基于社区发现算法和图分析Neo4j解读《权力的游戏》/","link":"","permalink":"http://github.com/2016/11/21/基于社区发现算法和图分析Neo4j解读《权力的游戏》/","excerpt":"导读几个月前，数学家 Andrew Beveridge 和Jie Shan在数学杂志上发表《权力的网络》，主要分析畅销小说《冰与火之歌》第三部《冰雨的风暴》中人物关系，其已经拍成电视剧《权力的游戏》系列。他们在论文中介绍了如何通过文本分析和实体提取构建人物关系的网络。紧接着，使用社交网络分析算法对人物关系网络分析找出最重要的角色；应用社区发现算法来找到人物聚类。 其中的分析和可视化是用Gephi做的，Gephi是非常流行的图分析工具。但作者觉得使用Neo4j来实现更有趣。 导入原始数据到Neo4j原始数据可从网络上下载，格式如下： Source,Target,WeightAemon,Grenn,5Aemon,Samwell,31Aerys,Jaime,18...","text":"导读几个月前，数学家 Andrew Beveridge 和Jie Shan在数学杂志上发表《权力的网络》，主要分析畅销小说《冰与火之歌》第三部《冰雨的风暴》中人物关系，其已经拍成电视剧《权力的游戏》系列。他们在论文中介绍了如何通过文本分析和实体提取构建人物关系的网络。紧接着，使用社交网络分析算法对人物关系网络分析找出最重要的角色；应用社区发现算法来找到人物聚类。 其中的分析和可视化是用Gephi做的，Gephi是非常流行的图分析工具。但作者觉得使用Neo4j来实现更有趣。 导入原始数据到Neo4j原始数据可从网络上下载，格式如下： Source,Target,WeightAemon,Grenn,5Aemon,Samwell,31Aerys,Jaime,18... 上面是人物关系的之邻接表以及关系权重。作者使用简单的数据模型： (:Character &#123;name&#125;)-[:INTERACTS]-&gt;(:Character &#123;name&#125;) 带有标签Character的节点代表小说中的角色，用单向关系类型INTERACTS代表小说中的角色有过接触。节点属性会存储角色的名字name，两角色间接触的次数作为关系的属性：权重（weight）。 首先创建节点c，并做唯一限制性约束，c.name唯一，保证schema的完整性： CREATE CONSTRAINT ON (c:Character) ASSERT c.name IS UNIQUE; 一旦约束创建即相应的创建索引，这将有助于通过角色的名字查询的性能。作者使用Neo4j的Cypher（Cypher是一种声明式图查询语言，能表达高效查询和更新图数据库）LOAD CSV语句导入数据： LOAD CSV WITH HEADERS FROM &quot;https://www.macalester.edu/~abeverid/data/stormofswords.csv&quot; AS rowMERGE (src:Character &#123;name: row.Source&#125;)MERGE (tgt:Character &#123;name: row.Target&#125;)MERGE (src)-[r:INTERACTS]-&gt;(tgt)SET r.weight = toInt(row.Weight) 这样得到一个简单的数据模型： CALL apoc.meta.graph() 我们能可视化整个图形，但是这并不能给我们很多信息，比如哪些是最重要的人物，以及他们相互接触的信息： MATCH p=(:Character)-[:INTERACTS]-(:Character)RETURN p 人物网络分析作者使用Neo4j的图查询语言Cypher来做《权力的游戏》图分析，应用到了网络分析的一些工具，具体见《网络，人群和市场：关于高度连接的世界》。 人物数量万事以简单开始。先看看上图上由有多少人物： MATCH (c:Character) RETURN count(c) count(c) 107 概要统计统计每个角色接触的其它角色的数目： MATCH (c:Character)-[:INTERACTS]-&gt;()WITH c, count(*) AS numRETURN min(num) AS min, max(num) AS max, avg(num) AS avg_characters, stdev(num) AS stdev min max avg_characters stdev 1 24 4.957746478873241 6.227672391875085 图（网络）的直径网络的直径或者测底线或者最长最短路径： // Find maximum diameter of network// maximum shortest path between two nodesMATCH (a:Character), (b:Character) WHERE id(a) &gt; id(b)MATCH p=shortestPath((a)-[:INTERACTS*]-(b))RETURN length(p) AS len, extract(x IN nodes(p) | x.name) AS pathORDER BY len DESC LIMIT 4 len path 6 [Illyrio, Belwas, Daenerys, Robert, Tywin, Oberyn, Amory] 6 [Illyrio, Belwas, Daenerys, Robert, Sansa, Bran, Jojen] 6 [Illyrio, Belwas, Daenerys, Robert, Stannis, Davos, Shireen] 6 [Illyrio, Belwas, Daenerys, Robert, Sansa, Bran, Luwin] 我们能看到网络中有许多长度为6的路径。 最短路径作者使用Cypher 的shortestPath函数找到图中任意两个角色之间的最短路径。让我们找出凯特琳·史塔克（Catelyn Stark ）和卓戈·卡奥（Kahl Drogo）之间的最短路径： // Shortest path from Catelyn Stark to Khal DrogoMATCH (catelyn:Character &#123;name: &quot;Catelyn&quot;&#125;), (drogo:Character &#123;name: &quot;Drogo&quot;&#125;)MATCH p=shortestPath((catelyn)-[INTERACTS*]-(drogo))RETURN p 所有最短路径联结凯特琳·史塔克（Catelyn Stark ）和卓戈·卡奥（Kahl Drogo）之间的最短路径可能还有其它路径，我们可以使用Cypher的allShortestPaths函数来查找： // All shortest paths from Catelyn Stark to Khal DrogoMATCH (catelyn:Character &#123;name: &quot;Catelyn&quot;&#125;), (drogo:Character &#123;name: &quot;Drogo&quot;&#125;)MATCH p=allShortestPaths((catelyn)-[INTERACTS*]-(drogo))RETURN p 关键节点在网络中，如果一个节点位于其它两个节点所有的最短路径上，即称为关键节点。下面我们找出网络中所有的关键节点： // Find all pivotal nodes in networkMATCH (a:Character), (b:Character)MATCH p=allShortestPaths((a)-[:INTERACTS*]-(b)) WITH collect(p) AS paths, a, bMATCH (c:Character) WHERE all(x IN paths WHERE c IN nodes(x)) AND NOT c IN [a,b]RETURN a.name, b.name, c.name AS PivotalNode SKIP 490 LIMIT 10 a.name b.name PivotalNode Aegon Thoros Daenerys Aegon Thoros Robert Drogo Ramsay Robb Styr Daario Daenerys Styr Daario Jon Styr Daario Robert Qhorin Podrick Jon Qhorin Podrick Sansa Orell Theon Jon Illyrio Bronn Belwas 从结果表格中我们可以看出有趣的结果：罗柏·史塔克（Robb）是卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）的关键节点。这意味着，所有联结卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）的最短路径都要经过罗柏·史塔克（Robb）。我们可以通过可视化卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）之间的所有最短路径来验证： MATCH (a:Character &#123;name: &quot;Drogo&quot;&#125;), (b:Character &#123;name: &quot;Ramsay&quot;&#125;)MATCH p=allShortestPaths((a)-[:INTERACTS*]-(b))RETURN p 节点中心度节点中心度给出网络中节点的重要性的相对度量。有许多不同的方式来度量中心度，每种方式都代表不同类型的“重要性”。 度中心性(Degree Centrality)度中心性是最简单度量，即为某个节点在网络中的联结数。在《权力的游戏》的图中，某个角色的度中心性是指该角色接触的其他角色数。作者使用Cypher计算度中心性： MATCH (c:Character)-[:INTERACTS]-()RETURN c.name AS character, count(*) AS degree ORDER BY degree DESC character degree Tyrion 36 Jon 26 Sansa 26 Robb 25 Jaime 24 Tywin 22 Cersei 20 Arya 19 Joffrey 18 Robert 18 从上面可以发现，在《权力的游戏》网络中提利昂·兰尼斯特（Tyrion）和最多的角色有接触。鉴于他的心计，我们觉得这是有道理的。 加权度中心性（Weighted Degree Centrality）作者存储一对角色接触的次数作为INTERACTS关系的weight属性。对该角色的INTERACTS关系的所有weight相加得到加权度中心性。作者使用Cypher计算所有角色的这个度量： MATCH (c:Character)-[r:INTERACTS]-()RETURN c.name AS character, sum(r.weight) AS weightedDegree ORDER BY weightedDegree DESC character weightedDegree Tyrion 551 Jon 442 Sansa 383 Jaime 372 Bran 344 Robb 342 Samwell 282 Arya 269 Joffrey 255 Daenerys 232 介数中心性（Betweenness Centrality）介数中心性：在网络中，一个节点的介数中心性是指其它两个节点的所有最短路径都经过这个节点，则这些所有最短路径数即为此节点的介数中心性。介数中心性是一种重要的度量，因为它可以鉴别出网络中的“信息中间人”或者网络聚类后的联结点。 为了计算介数中心性，作者使用Neo4j 3.x或者apoc库。安装apoc后能用Cypher调用其170+的程序： MATCH (c:Character)WITH collect(c) AS charactersCALL apoc.algo.betweenness([&apos;INTERACTS&apos;], characters, &apos;BOTH&apos;) YIELD node, scoreSET node.betweenness = scoreRETURN node.name AS name, score ORDER BY score DESC name score Jon 1279.7533534055322 Robert 1165.6025171231624 Tyrion 1101.3849724234349 Daenerys 874.8372110508583 Robb 706.5572832464792 Sansa 705.1985623519137 Stannis 571.5247305125714 Jaime 556.1852522889822 Arya 443.01358430043337 Tywin 364.7212195528086 紧度中心性（Closeness centrality）紧度中心性是指到网络中所有其他角色的平均距离的倒数。在图中，具有高紧度中心性的节点在聚类社区之间被高度联结，但在社区之外不一定是高度联结的。 MATCH (c:Character)WITH collect(c) AS charactersCALL apoc.algo.closeness([&apos;INTERACTS&apos;], characters, &apos;BOTH&apos;) YIELD node, scoreRETURN node.name AS name, score ORDER BY score DESC name score Tyrion 0.004830917874396135 Sansa 0.004807692307692308 Robert 0.0047169811320754715 Robb 0.004608294930875576 Arya 0.0045871559633027525 Jaime 0.004524886877828055 Stannis 0.004524886877828055 Jon 0.004524886877828055 Tywin 0.004424778761061947 Eddard 0.004347826086956522 使用python-igraphNeo4j与其它工具（比如，R和Python数据科学工具）完美结合。我们继续使用apoc运行 PageRank和社区发现（community detection）算法。这里接着使用python-igraph计算分析。Python-igraph移植自R的igraph图形分析库。 使用pip install python-igraph安装它。 从Neo4j构建一个igraph实例为了在《权力的游戏》的数据的图分析中使用igraph，首先需要从Neo4j拉取数据，用Python建立igraph实例。作者使用 Neo4j 的Python驱动库py2neo。我们能直接传入Py2neo查询结果对象到igraph的TupleList构造器，创建igraph实例： from py2neo import Graphfrom igraph import Graph as IGraphgraph = Graph()query = '''MATCH (c1:Character)-[r:INTERACTS]-&gt;(c2:Character)RETURN c1.name, c2.name, r.weight AS weight'''ig = IGraph.TupleList(graph.run(query), weights=True) 现在有了igraph对象，可以运行igraph实现的各种图算法来。 PageRank作者使用igraph运行的第一个算法是PageRank。PageRank算法源自Google的网页排名。它是一种特征向量中心性(eigenvector centrality)算法。 在igraph实例中运行PageRank算法，然后把结果写回Neo4j，在角色节点创建一个pagerank属性存储igraph计算的值： pg = ig.pagerank()pgvs = []for p in zip(ig.vs, pg): print(p) pgvs.append(&#123;\"name\": p[0][\"name\"], \"pg\": p[1]&#125;)pgvswrite_clusters_query = '''UNWIND &#123;nodes&#125; AS nMATCH (c:Character) WHERE c.name = n.nameSET c.pagerank = n.pg'''graph.run(write_clusters_query, nodes=pgvs) 现在可以在Neo4j的图中查询最高PageRank值的节点： MATCH (n:Character)RETURN n.name AS name, n.pagerank AS pagerank ORDER BY pagerank DESC LIMIT 10 name pagerank Tyrion 0.042884981999963316 Jon 0.03582869669163558 Robb 0.03017114665594764 Sansa 0.030009716660108578 Daenerys 0.02881425425830273 Jaime 0.028727587587471206 Tywin 0.02570016262642541 Robert 0.022292016521362864 Cersei 0.022287327589773507 Arya 0.022050209663844467 社区发现算法用来找出图中的社区聚类。作者使用igraph实现的随机游走算法（ walktrap）来找到在社区中频繁有接触的角色社区，在社区之外角色不怎么接触。 在igraph中运行随机游走的社区发现算法，然后把社区发现的结果导入Neo4j，其中每个角色所属的社区用一个整数来表示： clusters = IGraph.community_walktrap(ig, weights=\"weight\").as_clustering()nodes = [&#123;\"name\": node[\"name\"]&#125; for node in ig.vs]for node in nodes: idx = ig.vs.find(name=node[\"name\"]).index node[\"community\"] = clusters.membership[idx]write_clusters_query = '''UNWIND &#123;nodes&#125; AS nMATCH (c:Character) WHERE c.name = n.nameSET c.community = toInt(n.community)'''graph.run(write_clusters_query, nodes=nodes) 我们能在Neo4j中查询有多少个社区以及每个社区的成员数： MATCH (c:Character)WITH c.community AS cluster, collect(c.name) AS membersRETURN cluster, members ORDER BY cluster ASC cluster members 0 [Aemon, Alliser, Craster, Eddison, Gilly, Janos, Jon, Mance, Rattleshirt, Samwell, Val, Ygritte, Grenn, Karl, Bowen, Dalla, Orell, Qhorin, Styr] 1 [Aerys, Amory, Balon, Brienne, Bronn, Cersei, Gregor, Jaime, Joffrey, Jon Arryn, Kevan, Loras, Lysa, Meryn, Myrcella, Oberyn, Podrick, Renly, Robert, Robert Arryn, Sansa, Shae, Tommen, Tyrion, Tywin, Varys, Walton, Petyr, Elia, Ilyn, Pycelle, Qyburn, Margaery, Olenna, Marillion, Ellaria, Mace, Chataya, Doran] 2 [Arya, Beric, Eddard, Gendry, Sandor, Anguy, Thoros] 3 [Brynden, Catelyn, Edmure, Hoster, Lothar, Rickard, Robb, Roose, Walder, Jeyne, Roslin, Ramsay] 4 [Bran, Hodor, Jojen, Luwin, Meera, Rickon, Nan, Theon] 5 [Belwas, Daario, Daenerys, Irri, Jorah, Missandei, Rhaegar, Viserys, Barristan, Illyrio, Drogo, Aegon, Kraznys, Rakharo, Worm] 6 [Davos, Melisandre, Shireen, Stannis, Cressen, Salladhor] 7 [Lancel] 角色“大合影” 《权力的游戏》的权力图。节点的大小正比于介数中心性，颜色表示社区（由随机游走算法获得），边的厚度正比于两节点接触的次数。现在已经计算好这些图的分析数据，让我们对其进行可视化，让数据看起来更有意义。 Neo4j自带浏览器可以对Cypher查询的结果进行很好的可视化，但如果我们想把可视化好的图嵌入到其它应用中，可以使用Javascript可视化库Vis.js。从Neo4j拉取数据，用Vis.js的neovis.js构建可视化图。Neovis.js提供简单的API配置，例如： var config = &#123; container_id: \"viz\", server_url: \"localhost\", labels: &#123; \"Character\": \"name\" &#125;, label_size: &#123; \"Character\": \"betweenness\" &#125;, relationships: &#123; \"INTERACTS\": null &#125;, relationship_thickness: &#123; \"INTERACTS\": \"weight\" &#125;, cluster_labels: &#123; \"Character\": \"community\" &#125;&#125;;var viz = new NeoVis(config);viz.render(); 其中： 节点带有标签Character，属性name； 节点的大小正比于betweenness属性； 可视化中包括INTERACTS关系； 关系的厚度正比于weight属性； 节点的颜色是根据网络中社区community属性决定； 从本地服务器localhost拉取Neo4j的数据； 在一个id为viz的DOM元素中展示可视化。 Resources A. Beveridge and J. Shan, “Network of Thrones” Math Horizons Magazine , Vol. 23, No. 4 (2016), pp. 18-22. J. Kleinberg and D. Easley, Networks, Crowds, and Markets: Reasoning About a Highly Connected World. Cambridge University Press (2010)All code is available on Github. 【参考资料】 Analyzing the Graph of Thrones – by William Lyon 基于社区发现算法和图分析Neo4j解读《权力的游戏》上篇 基于社区发现算法和图分析Neo4j解读《权力的游戏》下篇","categories":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://github.com/tags/Neo4j/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}]},{"title":"【D3.js】力导向布局 + 圆形图片展示的人物关系","slug":"【D3.js】力导向布局 + 圆形图片展示的人物关系","date":"2016-11-18T08:06:00.000Z","updated":"2016-11-18T08:28:03.413Z","comments":true,"path":"2016/11/18/【D3.js】力导向布局 + 圆形图片展示的人物关系/","link":"","permalink":"http://github.com/2016/11/18/【D3.js】力导向布局 + 圆形图片展示的人物关系/","excerpt":"前言使用d3的力学图（力导向图）与生活中常见的人物关系图结合，已经有了很好的例子： 【 D3.js 进阶系列 — 2.0 】 力学图 + 人物关系图，博主实现了下面这种样式，已经相当不错了。 但是对于想把节点的方形图片换成圆形头像，网上的资料却很少，本例子就在上面的实例的基础上实现圆形头像，让人物关系图看起来更漂亮了一个档次。两个主要文件如下：","text":"前言使用d3的力学图（力导向图）与生活中常见的人物关系图结合，已经有了很好的例子： 【 D3.js 进阶系列 — 2.0 】 力学图 + 人物关系图，博主实现了下面这种样式，已经相当不错了。 但是对于想把节点的方形图片换成圆形头像，网上的资料却很少，本例子就在上面的实例的基础上实现圆形头像，让人物关系图看起来更漂亮了一个档次。两个主要文件如下： # index.html&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Force&lt;/title&gt; &lt;style&gt;.nodetext &#123; font-size: 12px ; font-family: SimSun; fill:#000000;&#125;.linetext &#123; font-size: 12px ; font-family: SimSun; fill:#1f77b4; fill-opacity:0.0;&#125;.circleImg &#123; stroke: #ff7f0e; stroke-width: 1.5px;&#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=\"http://d3js.org/d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; var width = 900; var height = 800; var img_w = 77; var img_h = 80; var radius = 30; //圆形半径 var svg = d3.select(\"body\").append(\"svg\") .attr(\"width\",width) .attr(\"height\",height); d3.json(\"relation.json\",function(error,root)&#123; if( error )&#123; return console.log(error); &#125; console.log(root); //D3力导向布局 var force = d3.layout.force() .nodes(root.nodes) .links(root.edges) .size([width,height]) .linkDistance(200) .charge(-1500) .start(); //边 var edges_line = svg.selectAll(\"line\") .data(root.edges) .enter() .append(\"line\") .style(\"stroke\",\"#ccc\") .style(\"stroke-width\",1); //边上的文字（人物之间的关系） var edges_text = svg.selectAll(\".linetext\") .data(root.edges) .enter() .append(\"text\") .attr(\"class\",\"linetext\") .text(function(d)&#123; return d.relation; &#125;); // 圆形图片节点（人物头像） var nodes_img = svg.selectAll(\"image\") .data(root.nodes) .enter() .append(\"circle\") .attr(\"class\", \"circleImg\") .attr(\"r\", radius) .attr(\"fill\", function(d, i)&#123; //创建圆形图片 var defs = svg.append(\"defs\").attr(\"id\", \"imgdefs\") var catpattern = defs.append(\"pattern\") .attr(\"id\", \"catpattern\" + i) .attr(\"height\", 1) .attr(\"width\", 1) catpattern.append(\"image\") .attr(\"x\", - (img_w / 2 - radius)) .attr(\"y\", - (img_h / 2 - radius)) .attr(\"width\", img_w) .attr(\"height\", img_h) .attr(\"xlink:href\", d.image) return \"url(#catpattern\" + i + \")\"; &#125;) .on(\"mouseover\",function(d,i)&#123; //显示连接线上的文字 edges_text.style(\"fill-opacity\",function(edge)&#123; if( edge.source === d || edge.target === d )&#123; return 1.0; &#125; &#125;); &#125;) .on(\"mouseout\",function(d,i)&#123; //隐去连接线上的文字 edges_text.style(\"fill-opacity\",function(edge)&#123; if( edge.source === d || edge.target === d )&#123; return 0.0; &#125; &#125;); &#125;) .call(force.drag); var text_dx = -20; var text_dy = 20; var nodes_text = svg.selectAll(\".nodetext\") .data(root.nodes) .enter() .append(\"text\") .attr(\"class\",\"nodetext\") .attr(\"dx\",text_dx) .attr(\"dy\",text_dy) .text(function(d)&#123; return d.name; &#125;); force.on(\"tick\", function()&#123; //限制结点的边界 root.nodes.forEach(function(d,i)&#123; d.x = d.x - img_w/2 &lt; 0 ? img_w/2 : d.x ; d.x = d.x + img_w/2 &gt; width ? width - img_w/2 : d.x ; d.y = d.y - img_h/2 &lt; 0 ? img_h/2 : d.y ; d.y = d.y + img_h/2 + text_dy &gt; height ? height - img_h/2 - text_dy : d.y ; &#125;); //更新连接线的位置 edges_line.attr(\"x1\",function(d)&#123; return d.source.x; &#125;); edges_line.attr(\"y1\",function(d)&#123; return d.source.y; &#125;); edges_line.attr(\"x2\",function(d)&#123; return d.target.x; &#125;); edges_line.attr(\"y2\",function(d)&#123; return d.target.y; &#125;); //更新连接线上文字的位置 edges_text.attr(\"x\",function(d)&#123; return (d.source.x + d.target.x) / 2 ; &#125;); edges_text.attr(\"y\",function(d)&#123; return (d.source.y + d.target.y) / 2 ; &#125;); //更新结点图片和文字 nodes_img.attr(\"cx\",function(d)&#123; return d.x &#125;); nodes_img.attr(\"cy\",function(d)&#123; return d.y &#125;); nodes_text.attr(\"x\",function(d)&#123; return d.x &#125;); nodes_text.attr(\"y\",function(d)&#123; return d.y + img_w/2; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; # relation.json&#123;\"nodes\":[&#123; \"name\": \"云天河\" , \"image\" : \"tianhe.png\" &#125;,&#123; \"name\": \"韩菱纱\" , \"image\" : \"lingsha.png\" &#125;,&#123; \"name\": \"柳梦璃\" , \"image\" : \"mengli.png\" &#125;,&#123; \"name\": \"慕容紫英\" , \"image\" : \"ziying.png\" &#125;,&#123; \"name\": \"云天青\" , \"image\" : \"tianqing.png\" &#125;,&#123; \"name\": \"夙玉\" , \"image\" : \"suyu.png\" &#125;,&#123; \"name\": \"玄霄\" , \"image\" : \"xuanxiao.png\" &#125;,&#123; \"name\": \"夙瑶\" , \"image\" : \"suyao.png\" &#125;,&#123; \"name\": \"太清\" , \"image\" : \"taiqing.png\" &#125;,&#123; \"name\": \"宗炼\" , \"image\" : \"zonglian.png\" &#125;,&#123; \"name\": \"婵幽\" , \"image\" : \"chanyou.png\" &#125;,&#123; \"name\": \"奚仲\" , \"image\" : \"xizhong.png\" &#125;,&#123; \"name\": \"归邪\" , \"image\" : \"guixie.png\" &#125;],\"edges\":[&#123; \"source\": 0 , \"target\": 1 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 0 , \"target\": 2 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 0 , \"target\": 3 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 1 , \"target\": 2 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 1 , \"target\": 3 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 2 , \"target\": 3 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 0 , \"target\": 4 , \"relation\":\"父子\" &#125;,&#123; \"source\": 0 , \"target\": 5 , \"relation\":\"母子\" &#125;,&#123; \"source\": 4 , \"target\": 5 , \"relation\":\"夫妻\" &#125;,&#123; \"source\": 0 , \"target\": 6 , \"relation\":\"义兄弟\" &#125;,&#123; \"source\": 4 , \"target\": 6 , \"relation\":\"同门\" &#125;,&#123; \"source\": 5 , \"target\": 6 , \"relation\":\"同门\" &#125;,&#123; \"source\": 4 , \"target\": 7 , \"relation\":\"同门\" &#125;,&#123; \"source\": 5 , \"target\": 7 , \"relation\":\"同门\" &#125;,&#123; \"source\": 6 , \"target\": 7 , \"relation\":\"同门\" &#125;,&#123; \"source\": 4 , \"target\": 8 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 5 , \"target\": 8 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 6 , \"target\": 8 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 7 , \"target\": 8 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 8 , \"target\": 9 , \"relation\":\"同门\" &#125;,&#123; \"source\": 3 , \"target\": 9 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 2 , \"target\": 10 , \"relation\":\"母子\" &#125;,&#123; \"source\": 10 , \"target\": 11 , \"relation\":\"主臣\" &#125;,&#123; \"source\": 10 , \"target\": 12 , \"relation\":\"主臣\" &#125;,&#123; \"source\": 11 , \"target\": 12 , \"relation\":\"同僚\" &#125;]&#125; 【参考资料】 【 D3.js 进阶系列 — 2.0 】 力学图 + 人物关系图 how to make an image round in d3.js 用D3画简单的力导图","categories":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}],"tags":[{"name":"D3","slug":"D3","permalink":"http://github.com/tags/D3/"}],"keywords":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}]},{"title":"【Android】微信热修复 Tinker 的集成和使用","slug":"【Android】微信热修复 Tinker 的集成和使用","date":"2016-11-17T03:51:55.000Z","updated":"2016-12-22T06:52:41.389Z","comments":true,"path":"2016/11/17/【Android】微信热修复 Tinker 的集成和使用/","link":"","permalink":"http://github.com/2016/11/17/【Android】微信热修复 Tinker 的集成和使用/","excerpt":"简介 Tinker： n. 〈英〉小炉匠，补锅匠，修补匠 Tinker 是微信官方开源的 Android 热修复框架，支持在无需升级APK的前提下更新 dex, library and resources 文件。它也就是今年9月24才刚刚开源，几天功夫star数就超过3000，可见在开发者中的影响力有多大，也说明这是一个刚需。 Tinker GitHub: https://github.com/Tencent/tinker 使用步骤一个小坑很多人遇到的第一个错误就是提示 tinkerId is not set ，这个在tinker-sample-android的app/build.gradle 中默认设置为Git的提交版本号，如下 def getTinkerIdValue() &#123; return hasProperty(\"TINKER_ID\") ? TINKER_ID : gitSha()&#125; 如果不是通过git clone方式下载的就可能出现这个错误，其实可以简单粗暴的方式解决，那就是在app/build.gradle中把tinker id写死： def getTinkerIdValue() &#123; return hasProperty(\"TINKER_ID\") ? TINKER_ID : \"tinker_id_2333\"&#125; 下面介绍一下如何一步步的把Tinker集成到自己的项目中，以及会遇到哪些问题该如何解决。","text":"简介 Tinker： n. 〈英〉小炉匠，补锅匠，修补匠 Tinker 是微信官方开源的 Android 热修复框架，支持在无需升级APK的前提下更新 dex, library and resources 文件。它也就是今年9月24才刚刚开源，几天功夫star数就超过3000，可见在开发者中的影响力有多大，也说明这是一个刚需。 Tinker GitHub: https://github.com/Tencent/tinker 使用步骤一个小坑很多人遇到的第一个错误就是提示 tinkerId is not set ，这个在tinker-sample-android的app/build.gradle 中默认设置为Git的提交版本号，如下 def getTinkerIdValue() &#123; return hasProperty(\"TINKER_ID\") ? TINKER_ID : gitSha()&#125; 如果不是通过git clone方式下载的就可能出现这个错误，其实可以简单粗暴的方式解决，那就是在app/build.gradle中把tinker id写死： def getTinkerIdValue() &#123; return hasProperty(\"TINKER_ID\") ? TINKER_ID : \"tinker_id_2333\"&#125; 下面介绍一下如何一步步的把Tinker集成到自己的项目中，以及会遇到哪些问题该如何解决。 一、工程根目录的build.gradle中添加依赖在项目的build.gradle中，添加tinker-patch-gradle-plugin的依赖 buildscript &#123; dependencies &#123; classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.3') &#125;&#125; 此时如果gradle Sync不成功可能是因为没有加入 jcenter仓库 buildscript &#123; repositories &#123; mavenLocal() jcenter() //注意这里，因为maven仓库里没有 &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.2' classpath \"com.tencent.tinker:tinker-patch-gradle-plugin:$&#123;TINKER_VERSION&#125;\" &#125; // default values for all sub projects&#125; 二、在app/build.gradle中的dependencies节点添加依赖dependencies &#123; //可选，用于生成application类 provided('com.tencent.tinker:tinker-android-anno:1.7.3') //tinker的核心库 compile('com.tencent.tinker:tinker-android-lib:1.7.3') &#125; 三、复制官方sample工程app/build.gradle中的其他相关配置把官方 tinker-sample-android 工程中的app/build.gradle复制到自己的app/build.gradle中，特别是最下面的task 代码块，否则无法生成patch。 四、替换自己的Application类这一块需要特殊说明一下，tinker为了达到修改应用自己的Application的目的，使用代码框架封装继承DefaultApplicationLike的方式来实现对Application的修改，主要为了减少反射的使用和提高兼容性，具体说明参考 Tinker Wiki：自定义Application类。 在替换更改之前，强烈建议先把项目中的Application类做个备份。因为需要采用Annotation自动生成Application，原来的Application类需要删掉。 然后我们修改项目的 Application ，使之继承DefaultApplicationLike; 这块的确有点奇葩,这个DefaultApplicationLike不是继承自Application，需要用注解来设置项目中真正的Application，Tinker插件会自动生成真正的Application。 @DefaultLifeCycle(application = \"com.cuc.android.aps.MyApplication\",//通过注解，由tinker自动生成MyApplication flags = ShareConstants.TINKER_ENABLE_ALL, //tinkerFlags loaderClass = \"com.tencent.tinker.loader.TinkerLoader\", //loaderClassName, 我们这里使用默认 loadVerifyFlag = false) public class ApplicationFromTinkerLike extends DefaultApplicationLike &#123; public ApplicationFromTinkerLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent, Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager); &#125;&#125; 上边的com.cuc.android.aps.MyApplication就是真正的Application,不用我们自己写,是自动生成的。然后修改manifest.xml将application指向com.cuc.android.aps.MyApplication就行，开始会报错，build一下项目就好了。 五、在刚改好的 ApplicationFromTinkerLike 中重载onBaseContextAttached方法并在该方法中增加以下代码调用初始化tinker @Overridepublic void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); //you must install multiDex whatever tinker is installed! MultiDex.install(base); TinkerInstaller.install(this);&#125; 或者，我们可以直接将Sample工程中的文件（特别是Utils包下的）拷贝到我们自己的工程中，就像我一样，方便后期使用。比如SampleResultService、TinkerManager这几个类 然后重载onBaseContextAttached方法，可以像我一样写成下面这样 @Overridepublic void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); //you must install multiDex whatever tinker is installed! MultiDex.install(base); MyApplicationContext.application = (MyApplication) getApplication(); MyApplicationContext.context = getApplication(); TinkerManager.setTinkerApplicationLike(this); TinkerManager.initFastCrashProtect(); //should set before tinker is installed TinkerManager.setUpgradeRetryEnable(true); //optional set logIml, or you can use default debug log TinkerInstaller.setLogIml(new MyLogImp()); //installTinker after load multiDex //or you can put com.tencent.tinker.** to main dex TinkerManager.installTinker(this);&#125; 至此，自定义Application，也就是将Application中的实现移动到SampleApplicationLike中已经完成。 六、可以开始写测试patch的代码啦使用下面代码来load patch TinkerInstaller.onReceiveUpgradePatch(this.getApplication(), Environment.getExternalStorageDirectory().getAbsolutePath() + \"/patch_signed_7zip.apk\"); 在自己的工程中增加两个按钮，其中一个按钮用来显示EditText中的内容，另一个按钮用来加载补丁，在加载补丁按钮点击事件中执行加载patch的操作，为后期修复代码bug做准备，代码为：Button toastInfo = (Button) top.findViewById(R.id.toastInfo);toastInfo.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //清除补丁 Toast.makeText(SysUtils.getApp(),\"clean patch!\",Toast.LENGTH_LONG).show(); Tinker.with(SysUtils.getApp()).cleanPatch(); &#125;&#125;);Button loadPatchButton = (Button) top.findViewById(R.id.loadPatch);loadPatchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //加载补丁（加载成功以后patch文件会自动删掉） TinkerInstaller.onReceiveUpgradePatch(SysUtils.getApp(), Environment.getExternalStorageDirectory().getAbsolutePath() + \"/patch_signed_7zip.apk\"); &#125;&#125;); 打patch包的步骤1、调用assembleDebug编译原始包AndroidStudio 命令行下运行 $ ./gradlew assembleDebug 编译过的包会保存在build/bakApk中。然后我们将它安装到手机，可以看到补丁并没有加载。 2、修改代码，添加新功能或者更改功能例如在MainActivity中添加一个I am on patch onCreate的Toast. 3、然后修改build.gradle中的参数将步骤一编译保存的安装包路径拷贝到tinkerPatch中的tinkerOldApkPath参数中，根据需要也得同时修改tinkerApplyResourcePath ，tinkerApplyMappingPath 。 /** * you can use assembleRelease to build you base apk * use tinkerPatchRelease -POLD_APK= -PAPPLY_MAPPING= -PAPPLY_RESOURCE= to build patch * add apk from the build/bakApk */ext &#123; //for some reason, you may want to ignore tinkerBuild, such as instant run debug build? tinkerEnabled = true //for normal build //old apk file to build patch apk tinkerOldApkPath = \"$&#123;bakPath&#125;/app-debug-1116-15-53-17.apk\" //proguard mapping file to build patch apk tinkerApplyMappingPath = \"$&#123;bakPath&#125;/app-debug-1116-15-53-17-mapping.txt\" //resource R.txt to build patch apk, must input if there is resource changed tinkerApplyResourcePath = \"$&#123;bakPath&#125;/app-debug-1116-15-53-17-R.txt\" //only use for build all flavor, if not, just ignore this field tinkerBuildFlavorDirectory = \"$&#123;bakPath&#125;/app-debug-1107-10-33-32\"&#125; 4、调用tinkerPatchDebug, 生成补丁包$ ./gradlew tinkerPatchDebug 补丁包与相关日志会保存在/build/outputs/tinkerPatch/中，我们将其中的patch_signed_7zip.apk推送到手机的sdcard中。 $ adb push ./app/build/outputs/tinkerPatch/debug/patch_signed_7zip.apk /storage/sdcard0/ 5、运行app，执行LOAD PATCH代码块如果看到patch success, please restart process的toast，即可锁屏或者KILL 应用进程。 6、重新启动App我们可以看到，补丁包的确已经加载成功了。 使用Tinker的注意事项 1、Tinker_id的大版本升级问题 2、如果生成patch失败，并且原因如下： Warning: ignoreWarning is false, but we found loader classes are found in old secondary dex. 那么需要把相应的报错类声明在项目的keep_in_main_dex.txt 文件中，保证它编译时会被放置到主dex中。参考Tinker Issue #96 。 【参考资料】 Tinker 官方接入指南 微信Android热补丁实践演进之路 微信Tinker的一切都在这里，包括源码(一) 【腾讯Bugly干货分享】微信热补丁Tinker的实践演进之路 将Tinke集成到自己的项目 Android 微信热修复Tinker接入过程以及使用方法 Tinker 逆向分析","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"hotfix","slug":"hotfix","permalink":"http://github.com/tags/hotfix/"},{"name":"Tinker","slug":"Tinker","permalink":"http://github.com/tags/Tinker/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【D3】Link Nodes by Name","slug":"【D3】Link Nodes by Name","date":"2016-11-16T08:08:00.000Z","updated":"2016-11-18T08:27:59.326Z","comments":true,"path":"2016/11/16/【D3】Link Nodes by Name/","link":"","permalink":"http://github.com/2016/11/16/【D3】Link Nodes by Name/","excerpt":"Source : http://bl.ocks.org/mbostock/533daf20348023dfdd76 This example shows how to link nodes in a force-directed graph using a named identifier rather than a numeric index.","text":"Source : http://bl.ocks.org/mbostock/533daf20348023dfdd76 This example shows how to link nodes in a force-directed graph using a named identifier rather than a numeric index. # index.html&lt;!DOCTYPE html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;style&gt;.node &#123; stroke: #000; stroke-width: 1.5px;&#125;.link &#123; stroke: #999; stroke-width: 1.5px;&#125;&lt;/style&gt;&lt;svg width=\"960\" height=\"500\"&gt;&lt;/svg&gt;&lt;script src=\"//d3js.org/d3.v4.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var svg = d3.select(\"svg\"), width = +svg.attr(\"width\"), height = +svg.attr(\"height\");var simulation = d3.forceSimulation() .force(\"charge\", d3.forceManyBody().strength(-200)) .force(\"link\", d3.forceLink().id(function(d) &#123; return d.id; &#125;).distance(40)) .force(\"x\", d3.forceX(width / 2)) .force(\"y\", d3.forceY(height / 2)) .on(\"tick\", ticked);var link = svg.selectAll(\".link\"), node = svg.selectAll(\".node\");d3.json(\"graph.json\", function(error, graph) &#123; if (error) throw error; simulation.nodes(graph.nodes); simulation.force(\"link\").links(graph.links); link = link .data(graph.links) .enter().append(\"line\") .attr(\"class\", \"link\"); node = node .data(graph.nodes) .enter().append(\"circle\") .attr(\"class\", \"node\") .attr(\"r\", 6) .style(\"fill\", function(d) &#123; return d.id; &#125;);&#125;);function ticked() &#123; link.attr(\"x1\", function(d) &#123; return d.source.x; &#125;) .attr(\"y1\", function(d) &#123; return d.source.y; &#125;) .attr(\"x2\", function(d) &#123; return d.target.x; &#125;) .attr(\"y2\", function(d) &#123; return d.target.y; &#125;); node.attr(\"cx\", function(d) &#123; return d.x; &#125;) .attr(\"cy\", function(d) &#123; return d.y; &#125;);&#125;&lt;/script&gt; # graph.json&#123; \"nodes\": [ &#123;\"id\": \"red\"&#125;, &#123;\"id\": \"orange\"&#125;, &#123;\"id\": \"yellow\"&#125;, &#123;\"id\": \"green\"&#125;, &#123;\"id\": \"blue\"&#125;, &#123;\"id\": \"violet\"&#125; ], \"links\": [ &#123;\"source\": \"red\", \"target\": \"yellow\"&#125;, &#123;\"source\": \"red\", \"target\": \"blue\"&#125;, &#123;\"source\": \"red\", \"target\": \"green\"&#125; ]&#125;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}],"tags":[{"name":"D3","slug":"D3","permalink":"http://github.com/tags/D3/"}],"keywords":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}]},{"title":"Android 热修复原理和实现","slug":"Android 热修复原理和实现","date":"2016-11-10T05:06:00.000Z","updated":"2017-01-13T10:48:48.227Z","comments":true,"path":"2016/11/10/Android 热修复原理和实现/","link":"","permalink":"http://github.com/2016/11/10/Android 热修复原理和实现/","excerpt":"查看原文： Android 热修复，没你想的那么难 —— by kymjs张涛 一种动态加载最简单的实现方式，代码实现起来非常简单，重要的是这种思路和原理 。 《插件化从放弃到捡起》第一章，首先看一张图： 这张图是我所理解的 Android 插件化技术的三个技术点以及它们的应用场景。今天以 【Qzone 热修复方案】为例，跟大家讲一讲插件化中 热修复方案 的实现。","text":"查看原文： Android 热修复，没你想的那么难 —— by kymjs张涛 一种动态加载最简单的实现方式，代码实现起来非常简单，重要的是这种思路和原理 。 《插件化从放弃到捡起》第一章，首先看一张图： 这张图是我所理解的 Android 插件化技术的三个技术点以及它们的应用场景。今天以 【Qzone 热修复方案】为例，跟大家讲一讲插件化中 热修复方案 的实现。 原理ClassLoader在 Java 中，要加载一个类需要用到ClassLoader。Android 中有三个 ClassLoader, 分别为URLClassLoader、PathClassLoader、DexClassLoader。其中: URLClassLoader : 只能用于加载jar文件，但是由于 dalvik 不能直接识别jar，所以在 Android 中无法使用这个加载器。 PathClassLoader :它只能加载已经安装的apk。因为 PathClassLoader 只会去读取 /data/dalvik-cache 目录下的 dex 文件。例如我们安装一个包名为com.hujiang.xxx的 apk,那么当 apk 安装过程中，就会在/data/dalvik-cache目录下生产一个名为data@app@com.hujiang.xxx-1.apk@classes.dex的 ODEX 文件。在使用 PathClassLoader 加载 apk 时，它就会去这个文件夹中找相应的 ODEX 文件，如果 apk 没有安装，自然会报ClassNotFoundException。 DexClassLoader : 是最理想的加载器。它的构造函数包含四个参数，分别为： 1、dexPath, 指目标类所在的APK或jar文件的路径.类装载器将从该路径中寻找指定的目标类,该类必须是APK或jar的全路径.如果要包含多个路径,路径之间必须使用特定的分割符分隔,特定的分割符可以使用System.getProperty(“path.separtor”)获得. 2、dexOutputDir, 由于dex文件被包含在APK或者Jar文件中,因此在装载目标类之前需要先从APK或Jar文件中解压出dex文件,该参数就是制定解压出的dex 文件存放的路径.在Android系统中,一个应用程序一般对应一个Linux用户id,应用程序仅对属于自己的数据目录路径有写的权限,因此,该参数可以使用该程序的数据路径. 3、libPath, 指目标类中所使用的C/C++库存放的路径 4、classload, 是指该装载器的父装载器,一般为当前执行类的装载器 从framework源码中的dalvik.system包下，找到DexClassLoader源码，并没有什么卵用，实际内容是在它的父类BaseDexClassLoader中，顺带一提，这个类最低在API14开始有用。包含了两个变量： /** originally specified path (just used for &#123;@code toString()&#125;) */private final String originalPath; /** structured lists of path elements */private final DexPathList pathList; 可以看到注释：pathList就是多dex的结构列表，查看其源码 /*package*/ final class DexPathList &#123; private static final String DEX_SUFFIX = \".dex\"; private static final String JAR_SUFFIX = \".jar\"; private static final String ZIP_SUFFIX = \".zip\"; private static final String APK_SUFFIX = \".apk\"; /** class definition context */ private final ClassLoader definingContext; /** list of dex/resource (class path) elements */ private final Element[] dexElements; /** list of native library directory elements */ private final File[] nativeLibraryDirectories; 可以看到 dexElements 注释，dexElements 就是一个dex列表，那么我们就可以把每个 Element 当成是一个 dex。 此时我们整理一下思路，DexClassLoader 包含有一个dex数组Element[] dexElements，其中每个dex文件是一个Element，当需要加载类的时候会遍历 dexElements，如果找到类则加载，如果找不到从下一个 dex 文件继续查找。 那么我们的实现就是把这个插件 dex 插入到 Elements 的最前面，这么做的好处是不仅可以动态的加载一个类，并且由于 DexClassLoader 会优先加载靠前的类，所以我们同时实现了宿主 apk 的热修复功能。 ODEX过程上文就是整个热修复的原理了，就是向Classloader列表中插入一个dex。但是如果你这儿实现了，会发现一个问题，就是 ODEX 过程中引发的问题。在讲这个蛋疼的过程之前，有几个问题是要搞懂的。为什么 Android 不能识别 .class 文件，而只能识别 dex 文件。因为 dex 是对 class 的优化，它对 class 做了极大的压缩，比如以下是一个 class 文件的结构(摘自邓凡平老师博客) dex 将整个 Android 工程中所有的 class 压缩到一个(或几个) dex 文件中，合并了每个 class 的常量、class 版本信息等，例如每个 class 中都有一个相同的字符串，在 dex 中就只存一份就够了。所以，在Android 上，dalvik 虚拟机是无法识别一个普通 class 文件的，因为无法识别这个 class 文件的结构。 以下是一个 dex 文件的结构 : 感兴趣的可以阅读《深入理解Android》这本书。 继续往下，其实 dalvik 虚拟机也并不是直接读取 dex 文件的，而是在一个 APK 安装的时候，会首先做一次优化，会生成一个 ODEX 文件，即 Optimized dex。 为什么还要优化，依旧是为了效率。 只不过，Class -&gt; dex 是为了平台无关的优化；而 dex -&gt; odex 则是针对不同平台，不同手机的硬件配置做针对性的优化。就是在这一过程中，虚拟机在启动优化的时候，会有一个选项就是 verify 选项，当 verify 选项被打开的时候，就会执行一次校验，校验的目的是为了判断，这个类是否有引用其他 dex 中的类，如果没有，那么这个类会被打上一个 CLASS_ISPREVERIFIED 的标志。一旦被打上这个标志，就无法再从其他 dex 中替换这个类了。而这个选项开启，则是由虚拟机控制的。 字节码操作那么既然知道了原因，解决的办法自然也有了。你不是没有引用其他 dex 中的类就会被标记吗，那咱们就引用一个其他 dex 中的类。 ClassReader:该类用来解析编译过的class字节码文件。ClassWriter:该类用来重新构建编译后的类，比如说修改类名、属性以及方法，甚至可以生成新的类的字节码文件。ClassAdapter:该类也实现了ClassVisitor接口，它将对它的方法调用委托给另一个ClassVisitor对象。 /** * 当对象初始化的时候注入Inject类 * * @Note https://www.ibm.com/developerworks/cn/java/j-lo-asm30/ * @param inputStream 需要注入的Class的文件输入流 * @return 返回注入以后的Class文件二进制数组 */private static byte[] referHackWhenInit(InputStream inputStream) &#123; //该类用来解析编译过的class字节码文件。 ClassReader cr = new ClassReader(inputStream); //该类用来重新构建编译后的类，比如说修改类名、属性以及方法，甚至可以生成新的类的字节码文件 ClassWriter cw = new ClassWriter(cr, 0); //类的访问者,可以用来创建对一个Class的改动操作 ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) &#123; @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions); //如果方法名是&lt;init&gt;,每个类的构造函数函数名叫&lt;init&gt; if (\"&lt;init&gt;\".equals(name)) &#123; //在原本的visitMethod操作中添加自己定义的操作 mv = new MethodVisitor(Opcodes.ASM4, mv) &#123; @Override void visitInsn(int opcode) &#123; //Opcodes可以看做为关键字 if (opcode == Opcodes.RETURN) &#123; //visitLdcInsn() 将一个值写入到栈中,可以是一个Class类名/method方法名/desc方法描述 //这里相当于插入了一条语句:Class a = Inject.class; super.visitLdcInsn(Type.getType(\"Lcom/hujiang/hotfix/Inject;\")); &#125; //执行opcode对应的其他操作 super.visitInsn(opcode); &#125; &#125; &#125; //责任链完成,返回 return mv; &#125; &#125;; //accept这个方法接受一个实现了 ClassVisitor接口的对象实例作为参数，然后依次调用 ClassVisitor接口的各个方法 //用户无法控制各个方法调用顺序,但是可以提供不同的 Visitor(访问者) 来对字节码树进行不同的修改 //在这里,调用这一步的目的是为了让上面的visitMethod方法被调用 cr.accept(cv, 0); return cw.toByteArray();&#125; 代码实现可以参考 nuwa 中的实现，首先是 dex 怎样去插入到Classloader列表中，其实就是一段反射： public static void injectDexAtFirst(String dexPath, String defaultDexOptPath) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123; DexClassLoader dexClassLoader = new DexClassLoader(dexPath, defaultDexOptPath, dexPath, getPathClassLoader()); Object baseDexElements = getDexElements(getPathList(getPathClassLoader())); Object newDexElements = getDexElements(getPathList(dexClassLoader)); Object allDexElements = combineArray(newDexElements, baseDexElements); Object pathList = getPathList(getPathClassLoader()); ReflectionUtils.setField(pathList, pathList.getClass(), \"dexElements\", allDexElements);&#125; 首先分别获取到宿主应用和补丁的 dex 中的PathList.dexElements, 并把两个 dexElements 数组做拼接，将补丁数组放在前面，最后将拼接后生成的数组再赋值回Classloader. nuwa 更主要的是他的 groovy 脚本，完整代码：这里，由于代码很多，就只跟大家讲两个关键的点的实现以及目的，具体的内容可以直接查看源码。 //获得所有输入文件,即preDex的所有jar文件Set&lt;File&gt; inputFiles = preDexTask.inputs.files.filesinputFiles.each &#123; inputFile -&gt; def path = inputFile.absolutePath //如果不是support包或者引入的依赖库,则开始生成代码修改部分的hotfix包 if (HotFixProcessors.shouldProcessPreDexJar(path)) &#123; HotFixProcessors.processJar(classHashFile, inputFile, patchDir, classHashMap, includePackage, excludeClass) &#125;&#125; 其中HotFixProcessors.processJar()是脚本的第一个作用，就是找出哪些类是发生了改变，应该生成对应的补丁。循环遍历工程中的全部类,声明忽略的直接跳过.对每个类计算hash,并写入到hashFile文件中.通过比较hashFile文件与原先host工程的hashFile(即这里的classHashMap参数),得到所有修改过的类生成这些类的class文件,以及所有修改过的class文件的集合jar文件。 Set&lt;File&gt; inputFiles = dexTask.inputs.files.filesinputFiles.each &#123; inputFile -&gt; def path = inputFile.absolutePath if (path.endsWith(\".class\") &amp;&amp; !path.contains(\"/R\\$\") &amp;&amp; !path.endsWith(\"/R.class\") &amp;&amp; !path.endsWith(\"/BuildConfig.class\")) &#123; if (HotFixSetUtils.isIncluded(path, includePackage)) &#123; if (!HotFixSetUtils.isExcluded(path, excludeClass)) &#123; def bytes = HotFixProcessors.processClass(inputFile) path = path.split(\"$&#123;dirName&#125;/\")[1] def hash = DigestUtils.shaHex(bytes) classHashFile.append(HotFixMapUtils.format(path, hash)) if (HotFixMapUtils.notSame(classHashMap, path, hash)) &#123; HotFixFileUtils.copyBytesToFile(inputFile.bytes, HotFixFileUtils.touchFile(patchDir, path)) &#125; &#125; &#125; &#125;&#125; 这一段是脚本的第二个作用，也就是上文字节码操作的目的，为了防止类被虚拟机打上CLASS_ISPREVERIFIED，所以需要执行字节码写入。其中HotFixProcessors.processClass()就是实际写入字节码的代码。 好像差个结尾同样的方案，除了 nuwa 还有一个开源的实现，HotFix 两者是差不多的，所以看一个就可以了。 看到有很多朋友问，如果混淆后代码怎么办？在 Gradle 插件编译过程中，有一个proguardTask，看名字应该就知道他是负责 proguard 任务的，我们可以保存首次执行时的混淆规则(也就是线上出BUG的包)，这个混淆规则保存在工程目录中的一个mapping文件，当我们需要执行热修复补丁生成的时候，将线上包的mapping规则拿出来应用到本次编译中，就可以生成混淆后的类跟线上混淆后的类相同的类名的补丁了。具体实现可以看 nuwa 项目的applymapping()方法。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"hotfix","slug":"hotfix","permalink":"http://github.com/tags/hotfix/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"使用Neo4j进行全栈Web开发","slug":"使用Neo4j进行全栈Web开发","date":"2016-11-10T03:08:00.000Z","updated":"2017-01-13T11:05:23.357Z","comments":true,"path":"2016/11/10/使用Neo4j进行全栈Web开发/","link":"","permalink":"http://github.com/2016/11/10/使用Neo4j进行全栈Web开发/","excerpt":"在开发一个全栈web应用时，作为整个栈的底层，你可以在多种数据库之间进行选择。作为事实的数据源，你当然希望选择一种可靠的数据库，但同时也希望它能够允许你以良好的方式进行数据建模。在本文中，我将为你介绍Neo4j，当你的数据模型包含大量关联数据以及关系时，它可以成为你的web应用栈的基础的一个良好选择。 Neo4j是什么？ Neo4j是一个图形数据库，这也就意味着它的数据并非保存在表或集合中，而是保存为节点以及节点之间的关系。在Neo4j中，节点以及关系都能够包含保存值的属性，此外： 可以为节点设置零或多个标签（例如Author或Book） 每个关系都对应一种类型（例如WROTE或FRIEND_OF） 关系总是从一个节点指向另一个节点（但可以在不考虑指向性的情况下进行查询）","text":"在开发一个全栈web应用时，作为整个栈的底层，你可以在多种数据库之间进行选择。作为事实的数据源，你当然希望选择一种可靠的数据库，但同时也希望它能够允许你以良好的方式进行数据建模。在本文中，我将为你介绍Neo4j，当你的数据模型包含大量关联数据以及关系时，它可以成为你的web应用栈的基础的一个良好选择。 Neo4j是什么？ Neo4j是一个图形数据库，这也就意味着它的数据并非保存在表或集合中，而是保存为节点以及节点之间的关系。在Neo4j中，节点以及关系都能够包含保存值的属性，此外： 可以为节点设置零或多个标签（例如Author或Book） 每个关系都对应一种类型（例如WROTE或FRIEND_OF） 关系总是从一个节点指向另一个节点（但可以在不考虑指向性的情况下进行查询） 为什么要选择Neo4j？在考虑为web应用选择某个数据库时，我们需要考虑对它有哪些方面的期望，其中最重要的一些条件包括： 它是否易于使用？ 它是否允许你方便地回应对需求的变更？ 它是否支持高性能查询？ 是否能够方便地对其进行数据建模？ 它是否支持事务？ 它是否支持大规模应用？ 它是否足够有趣（很遗憾的是对于数据库的这方面要求经常被忽略）？ 从这几个方面来说，Neo4j是一个合适的选择。Neo4j…… 自带一套易于学习的查询语言（名为 Cypher） 不使用schema，因此可以满足你的任何形式的需求 与关系型数据库相比，对于高度关联的数据（图形数据）的查询快速要快上许多 它的实体与关系结构非常自然地切合人类的直观感受 支持兼容ACID的事务操作 提供了一个高可用性模型，以支持大规模数据量的查询，支持备份、数据局部性以及冗余 提供了一个可视化的查询控制台，你不会对它感到厌倦的 什么时候不应使用Neo4j？作为一个图形NoSQL数据库，Neo4j提供了大量的功能，但没有什么解决方案是完美的。在以下这些用例中，Neo4j就不是非常适合的选择： 记录大量基于事件的数据（例如日志条目或传感器数据） 对大规模分布式数据进行处理，类似于Hadoop 二进制数据存储 适合于保存在关系型数据库中的结构化数据 在上面的示例中，你看到了由Author、City、Book和Category以及它们之间的关系所组成的一个图形。如果你希望通过Cypher语句在Neo4j web控制台中列出这些数据结果，可以执行以下语句： MATCH (city:City)&lt;-[:LIVES_IN]-(:Author)-[:WROTE]-&gt; (book:Book)-[:HAS_CATEGORY]-&gt;(category:Category) WHERE city.name = “Chicago” RETURN * 请注意这种ASCII风格的语法，它在括号内表示节点名称，并用箭头表示一个节点指向另一个节点的关系。Cypher通过这种方式允许你匹配某个指定的子图形模式。 当然，Neo4j的功能不仅仅在于展示漂亮的图片。如果你希望按照作者所处的地点（城市）计算书籍的分类数目，你可以通过使用相同的MATCH模式，返回一组不同的列，例如： MATCH (city:City)&lt;-[:LIVES_IN]-(:Author)-[:WROTE]-&gt; (book:Book)-[:HAS_CATEGORY]-&gt;(category:Category) RETURN city.name, category.name, COUNT(book) 执行这条语句将返回以下结果： city.name category.name COUNT(category) Chicago Fantasy 1 Chicago Non-Fiction 2 虽然Neo4j也能够处理“大数据”，但它毕竟不是Hadoop、HBase或Cassandra，通常来说不会在Neo4j数据库中直接处理海量数据（以PB为单位）的分析。但如果你乐于提供关于某个实体及其相邻数据关系（比如你可以提供一个web页面或某个API返回其结果），那么它是一种良好的选择。无论是简单的CRUD访问，或是复杂的、深度嵌套的资源视图都能够胜任。 你应该选择哪种技术栈以配合Neo4j？所有主流的编程语言都通过HTTP API的方式支持Neo4j，或者采用基本的HTTP类库，或是通过某些原生的类库提供更高层的抽象。此外，由于Neo4j是以Java语言编写的，因此所有包含JVM接口的语言都能够充分利用Neo4j中的高性能API。 Neo4j本身也提供了一个“技术栈”，它允许你选择不同的访问方式，包括简单访问乃至原生性能等等。它提供的特性包括： 通过一个HTTP API执行Cypher查询，并获取JSON格式的结果 一种“非托管扩展”机制，允许你为Neo4j数据库编写自己的终结点 通过一个高层Java API指定节点与关系的遍历 通过一个低层的批量加载API处理海量初始数据的获取 通过一个核心Java API直接访问节点与关系，以获得最大的性能 一个应用程序示例最近我正好有机会将一个项目扩展为基于Neo4j的应用程序。该应用程序（可以访问graphgist.neo4j.com查看）是关于GraphGist的一个门户网站。GraphGist是一种通过交互式地渲染（在你的浏览器中）生成的文档，它基于一个简单的文本文件（AsciiDoctor），其中用文字描述以及图片描述了整个数据模型、架构以及用例查询，可以在线执行它们，并使它们保持可视化。它非常类似一个iPython notebook或是一张交互式的白纸。GraphGist也允许读者在浏览器中编写自己定义的查询，以查看整个数据集。 Neo4j的原作者Neo Technology希望为GraphGist提供一个由社区创建的展示项目。当然，后端技术选用了Neo4j，而整个技术栈的其余部分，我的选择是： Node.js配合Express.js，其中引入了neo4j包 Angular.js Swagger UI 所有代码都已开源，可以在GitHub上任意浏览。 从概念上讲，GraphGist门户网站是一个简单的应用，它提供了一个GraphGist列表，允许用户查看每个GraphGist的详细内容。数据领域是由Gist、Keyword/Domain/Use Case（作为Gist分类）以及Person（作为Gist的作者）所组成的： 现在你已经熟悉这个模型了，在继续深入学习之前，我想为你快速地介绍一下Cypher这门查询语言。举例来说，如果我们需要返回所有的Gist和它们的关键字，可以通过以下语句实现： MATCH (gist:Gist)-[:HAS_KEYWORD]-&gt;(keyword:Keyword)RETURN gist.title, keyword.name 这段语句将返回一张表，其中的每一行是由每个Gist和Keyword的组合构成的，正如同SQL join的行为一样。现在我们更深入一步，假设我们想要找到某个人所编写的Gist对应的所有Domain，我们可以执行下面这条查询语句： MATCH (person:Person)-[:WRITER_OF]-&gt;(gist:Gist)-[:HAS_DOMAIN]-&gt;(domain:Domain)WHERE person.name = “John Doe”RETURN domain.name, COUNT(gist) 该语句将返回另一个结果表，其中的每一行包含Domain的名称，以及这个Person对于这一Domain所编写的全部Gist的数量。这里无需使用GROUP BY语句，因为当我们使用例如COUNT()这样的聚合函数时，Neo4j会自动在RETURN语句中对其它列进行分组操作。 现在你对Cypher已经有一点感觉了吧？那么让我们来看一个来自实际应用中的查询。在创建这个门户时，如果能够通过某种方式，只需对数据库进行一次请求就能够返回我们所需的所有数据，并且以一种我们需要的格式进行结构组织，那将十分有用。 让我们开始创建这个用于门户的API（可以在GitHub上找到）的查询吧。首先，我们需要按照Gist的title属性进行匹配，并匹配所有相关的Gist节点： // Match Gists based on title MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; // Optionally match Gists with the same keyword // and pass on these related Gists with the // most common keywords first OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) 这里有几个要注意的地方。首先，WHERE语句是通过一个正则表达式（即=~操作符）和一个参数对title属性进行匹配的。参数（Parameter）是Neo4j的一项特性，它能够将查询与其所代表的数据进行分离。使用参数能够让Neo4j对查询和查询计划进行缓存，这也意味着你无需担心遭遇查询注入攻击。其次，我们在这里使用了一个OPTIONAL MATCH语句，它表示我们希望始终返回原始的Gist，即使它并没有相关的Gist。 现在让我们对之前的查询进行扩展，将RETURN语句替换为WITH语句： MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) WITH gist, related_gist, COUNT(DISTINCT keyword.name) AS keyword_count ORDER BY keyword_count DESC RETURN gist, COLLECT(DISTINCT &#123;related: &#123; id: related_gist.id, title: related_gist.title, poster_image: related_gist.poster_image, url: related_gist.url &#125;, weight: keyword_count &#125;) AS related 在RETURN语句中的COLLECT()作用是将由Gist和相关Gist所组成的节点转换为一个结果集，让其中每一行Gist只出现一次，并对应一个相关Gist的节点数组。在COLLECT()语句中，我们在相关Gist中仅指定了所需的部分数据，以减小整个响应的大小。 最后，我们将产生这样一条查询语句，这也是最后一次使用WITH语句了： MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) WITH gist, related_gist, COUNT(DISTINCT keyword.name) AS keyword_count ORDER BY keyword_count DESC WITH gist, COLLECT(DISTINCT &#123;related: &#123; id: related_gist.id, title: related_gist.title, poster_image: related_gist.poster_image, url: related_gist.url &#125;, weight: keyword_count &#125;) AS related // Optionally match domains, use cases, writers, and keywords for each Gist OPTIONAL MATCH (gist)-[:HAS_DOMAIN]-&gt;(domain:Domain) OPTIONAL MATCH (gist)-[:HAS_USECASE]-&gt;(usecase:UseCase) OPTIONAL MATCH (gist)&lt;-[:WRITER_OF]-(writer:Person) OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword:Keyword) // Return one Gist per row with arrays of domains, use cases, writers, and keywords RETURN gist, related, COLLECT(DISTINCT domain.name) AS domains, COLLECT(DISTINCT usecase.name) AS usecases, COLLECT(DISTINCT keyword.name) AS keywords COLLECT(DISTINCT writer.name) AS writers, ORDER BY gist.title 在这个查询中，我们将选择性地匹配所有相关的Domain、Use Case、Keyword和Person节点，并且将它们全部收集起来，与我们对相关Gist的处理方式相同。现在我们的结果不再是平坦的、反正规化的，而是包含一列Gist，其中每个Gist都对应着相关Gist的数组，形成了一种“has many”的关系，并且没有任何重复数据。太酷了！ 不仅如此，如果你觉得用表的形式返回数据太老土，那么Cypher也可以返回对象： RETURN &#123;gist: gist, domains: collect(DISTINCT domain.name) AS domains, usecases: collect(DISTINCT usecase.name) AS usecases, writers: collect(DISTINCT writer.name) AS writers, keywords: collect(DISTINCT keyword.name) AS keywords, related_gists: related &#125; ORDER BY gist.title 通常来说，在稍具规模的web应用程序中，需要进行大量的数据库调用以返回HTTP响应所需的数据。虽然你可以并行地执行查询，但通常来说你需要首先返回某个查询的结果集，才能发送另一个数据库请求以获取相关的数据。在SQL中，你可以通过生成复杂的、开销很大的表join语句，通过一个查询从多张表中返回结果。但只要你在同一个查询中进行了多次SQL join，这个查询的复杂性将会飞快地增长。更不用说数据库仍然需要进行表或索引扫描才能够获得相应的数据了。而在Neo4j中，通过关系获取实体的方式是直接使用对应于相关节点的指针，因此服务器可以随意进行遍历。 尽管如此，这种方式也存在着诸多缺陷。虽然这种方式能够通过一个查询返回所有数据，但这个查询会相当长。我至今也没有找到一种方式能够对进行模块化以便重用。进一步考虑：我们可以在其它场合同样调用这个终结点，但让它显示相关Gist的更多信息。我们可以选择修改这个查询以返回更多的数据，但也意味着对于原始的用例来说，它返回了额外的不必要数据。 我们是幸运的，因为有这么多优秀的数据库可以选择。虽然关系型数据库对于保存结构化数据来说依然是最佳的选择，但NoSQL数据库更适合于管理半结构化数据、非结构化数据以及图形数据。如果你的数据模型中包括大量的关联数据，并且希望使用一种直观的、有趣的并且快速的数据库进行开发，那么你就应当尝试一下Neo4j。 本文由Brian Underwood撰写，而Michael Hunger也为本文作出了许多贡献。 关于作者Brian Underwood是一位软件工程师，喜爱任何与数据相关的东西。作为一名Neo4j 的Developer Advocate，以及neo4j ruby gem的维护者，Brian经常通过一些演讲，以及在他的博客上的文章宣传图形数据库的强大与简洁。Brian如今正与他的妻儿在全球旅行。可以在Twitter 上找到Brian，或在LinkedIn上联系他。 查看英文原文：Full Stack Web Development Using Neo4j","categories":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://github.com/tags/Neo4j/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}]},{"title":"D3.js加载本地json文件的问题","slug":"D3.js加载本地json文件的问题","date":"2016-11-09T13:13:20.000Z","updated":"2016-12-22T05:04:49.471Z","comments":true,"path":"2016/11/09/D3.js加载本地json文件的问题/","link":"","permalink":"http://github.com/2016/11/09/D3.js加载本地json文件的问题/","excerpt":"问题打开本地html文件时，报错如下 XMLHttpRequest cannot load file:/cities.csv. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https, chrome-extension-resource.Uncaught NetworkError: Failed to execute &apos;send&apos; on &apos;XMLHttpRequest&apos;: Failed to load 分析原因是因为浏览器为了安全性考虑，默认对跨域访问禁止，不允许直接读取本地文件。 解决给浏览器传入启动参数（allow-file-access-from-files），允许跨域访问。Windows下，运行（CMD+R）或右键桌面快捷方式-&gt;属性-&gt;目标：","text":"问题打开本地html文件时，报错如下 XMLHttpRequest cannot load file:/cities.csv. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https, chrome-extension-resource.Uncaught NetworkError: Failed to execute &apos;send&apos; on &apos;XMLHttpRequest&apos;: Failed to load 分析原因是因为浏览器为了安全性考虑，默认对跨域访问禁止，不允许直接读取本地文件。 解决给浏览器传入启动参数（allow-file-access-from-files），允许跨域访问。Windows下，运行（CMD+R）或右键桌面快捷方式-&gt;属性-&gt;目标： &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot; --allow-file-access-from-files","categories":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}],"tags":[{"name":"D3","slug":"D3","permalink":"http://github.com/tags/D3/"}],"keywords":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}]},{"title":"【Android】Broadcast广播机制总结","slug":"【Android】Broadcast广播机制总结","date":"2016-10-25T08:06:00.000Z","updated":"2016-12-21T04:04:54.088Z","comments":true,"path":"2016/10/25/【Android】Broadcast广播机制总结/","link":"","permalink":"http://github.com/2016/10/25/【Android】Broadcast广播机制总结/","excerpt":"原文链接： Android总结篇系列：Android广播机制 1. Android广播机制概述Android广播分为两个方面：广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。广播作为Android组件间的通信方式，可以使用的场景如下： 同一app内部的同一组件内的消息通信（单个或多个线程之间）； 同一app内部的不同组件之间的消息通信（单个进程）； 同一app具有多个进程的不同组件之间的消息通信； 不同app之间的组件之间消息通信； Android系统在特定情况下与App之间的消息通信。 从实现原理看上，Android中的广播使用了观察者模式，基于消息的发布/订阅事件模型。因此，从实现的角度来看，Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：","text":"原文链接： Android总结篇系列：Android广播机制 1. Android广播机制概述Android广播分为两个方面：广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。广播作为Android组件间的通信方式，可以使用的场景如下： 同一app内部的同一组件内的消息通信（单个或多个线程之间）； 同一app内部的不同组件之间的消息通信（单个进程）； 同一app具有多个进程的不同组件之间的消息通信； 不同app之间的组件之间消息通信； Android系统在特定情况下与App之间的消息通信。 从实现原理看上，Android中的广播使用了观察者模式，基于消息的发布/订阅事件模型。因此，从实现的角度来看，Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下： 广播接收者BroadcastReceiver通过Binder机制向AMS(Activity Manager Service)进行注册； 广播发送者通过binder机制向AMS发送广播； AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中； 消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。 对于不同的广播类型，以及不同的BroadcastReceiver注册方式，具体实现上会有不同。但总体流程大致如上。 由此看来，广播发送者和广播接收者分别属于观察者模式中的消息发布和订阅两端，AMS属于中间的处理中心。广播发送者和广播接收者的执行是异步的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到。显然，整体流程与EventBus非常类似。 在上文说列举的广播机制具体可以使用的场景中，现分析实际应用中的适用性： 第一种情形：同一app内部的同一组件内的消息通信（单个或多个线程之间），实际应用中肯定是不会用到广播机制的（虽然可以用），无论是使用扩展变量作用域、基于接口的回调还是Handler-post/Handler-Message等方式，都可以直接处理此类问题，若适用广播机制，显然有些“杀鸡牛刀”的感觉，会显太“重”； 第二种情形：同一app内部的不同组件之间的消息通信（单个进程），对于此类需求，在有些教复杂的情况下单纯的依靠基于接口的回调等方式不好处理，此时可以直接使用EventBus等，相对而言，EventBus由于是针对统一进程，用于处理此类需求非常适合，且轻松解耦。可以参见文件《Android各组件/控件间通信利器之EventBus》。 第三、四、五情形：由于涉及不同进程间的消息通信，此时根据实际业务使用广播机制会显得非常适宜。下面主要针对Android广播中的具体知识点进行总结。 2. BroadcastReceiver自定义BroadcastReceiver自定义广播接收器需要继承基类BroadcastReceivre，并实现抽象方法onReceive(context, intent)方法。广播接收器接收到相应广播后，会自动回到onReceive(..)方法。默认情况下，广播接收器也是运行在UI线程，因此，onReceive方法中不能执行太耗时的操作。否则将因此ANR。一般情况下，根据实际业务需求，onReceive方法中都会涉及到与其他组件之间的交互，如发送Notification、启动service等。下面代码片段是一个简单的广播接收器的自定义： public class MyBroadcastReceiver extends BroadcastReceiver &#123; public static final String TAG = \"MyBroadcastReceiver\"; public static int m = 1; @Override public void onReceive(Context context, Intent intent) &#123; Log.w(TAG, \"intent:\" + intent); String name = intent.getStringExtra(\"name\"); Log.w(TAG, \"name:\" + name + \" m=\" + m); m++; Bundle bundle = intent.getExtras(); &#125;&#125; BroadcastReceiver注册类型BroadcastReceiver总体上可以分为两种注册类型：静态注册和动态注册。 1). 静态注册：直接在AndroidManifest.xml文件中进行注册。规则如下： &lt;receiver android:enabled=[\"true\" | \"false\"]android:exported=[\"true\" | \"false\"]android:icon=\"drawable resource\"android:label=\"string resource\"android:name=\"string\"android:permission=\"string\"android:process=\"string\" &gt;. . .&lt;/receiver&gt; 其中，需要注意的属性 android:exported — 此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）； android:name — 此broadcastReceiver类名； android:permission — 如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收； android:process — broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程） 常见的注册形式有: &lt;receiver android:name=\".MyBroadcastReceiver\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 其中，intent-filter由于指定此广播接收器将用于接收特定的广播类型。本示例中给出的是用于接收网络状态改变或开启启动时系统自身所发出的广播。当此App首次启动时，系统会自动实例化MyBroadcastReceiver，并注册到系统中。 之前常说：静态注册的广播接收器即使app已经退出，主要有相应的广播发出，依然可以接收到，但此种描述自Android 3.1开始有可能不再成立。具体分析详见本文后面部分。 2). 动态注册：动态注册时，无须在AndroidManifest中注册组件。直接在代码中通过调用Context的registerReceiver函数，可以在程序中动态注册BroadcastReceiver。registerReceiver的定义形式如下： registerReceiver(BroadcastReceiver receiver, IntentFilter filter)registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) 典型的写法示例如下： public class MainActivity extends Activity &#123; public static final String BROADCAST_ACTION = \"com.example.corn\"; private BroadcastReceiver mBroadcastReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mBroadcastReceiver = new MyBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BROADCAST_ACTION); registerReceiver(mBroadcastReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(mBroadcastReceiver); &#125;&#125; 注：Android中所有与观察者模式有关的设计中，一旦涉及到register，必定在相应的时机需要unregister。因此，上例在onDestroy()回到中需要unregisterReceiver(mBroadcastReceiver)。 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中。当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。 3. 广播发送及广播类型经常说”发送广播“和”接收“，表面上看广播作为Android广播机制中的实体，实际上这一实体本身是并不是以所谓的”广播“对象存在的，而是以”意图“（Intent）去表示。定义广播的定义过程，实际就是相应广播”意图“的定义过程，然后通过广播发送者将此”意图“发送出去。被相应的BroadcastReceiver接收后将会回调onReceive()函数。 下段代码片段显示的是一个普通广播的定义过程，并发送出去。其中setAction(..)对应于BroadcastReceiver中的intentFilter中的action。 Intent intent = new Intent();intent.setAction(BROADCAST_ACTION);intent.putExtra(\"name\", \"qqyumidi\");sendBroadcast(intent); 根据广播的发送方式，可以将其分为以下几种类型： Normal Broadcast：普通广播 System Broadcast : 系统广播 Ordered broadcast：有序广播 Sticky Broadcast：粘性广播(在 android 5.0/api 21中deprecated,不再推荐使用，相应的还有粘性有序广播，同样已经deprecated) Local Broadcast：App应用内广播 下面分别总结下各种类型的发送方式及其特点。 1). Normal Broadcast：普通广播此处将普通广播界定为：开发者自己定义的intent，以context.sendBroadcast_”AsUser”(intent, …)形式。具体可以使用的方法有：sendBroadcast(intent)/sendBroadcast(intent, receiverPermission)/sendBroadcastAsUser(intent, userHandler)/sendBroadcastAsUser(intent, userHandler,receiverPermission)。普通广播会被注册了的相应的感兴趣（intent-filter匹配）接收，且顺序是无序的。如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。 2). System Broadcast: 系统广播Android系统中内置了多个系统广播，只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开启启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，有系统自动发出。 3). Ordered broadcast：有序广播有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, …)。 对于有序广播，其主要特点总结如下： a. 多个具当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。 b. 先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。 4)Sticky Broadcast：粘性广播在 android 5.0/api 21中deprecated,不再推荐使用，相应的还有粘性有序广播，同样已经deprecated。既然已经deprecated，此处不再多做总结。 5)Local Broadcast：App应用内广播（此处的App应用以App应用进程为界）由前文阐述可知，Android中的广播可以跨进程甚至跨App直接通信，且注册是exported对于有intent-filter的情况下默认值是true，由此将可能出现安全隐患如下： 其他App可能会针对性的发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收到广播并处理； 其他App可以注册与当前App一致的intent-filter用于接收广播，获取广播具体信息。 无论哪种情形，这些安全隐患都确实是存在的。由此，最常见的增加安全性的方案是： 对于同一App内部发送和接收广播，将exported属性人为设置成false，使得非本App内部发出的此广播不被接收； 在广播发送和接收时，都增加上相应的permission，用于权限验证； 发送广播时，指定特定广播接收器所在的包名，具体是通过intent.setPackage(packageName)指定在，这样此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。 App应用内广播可以理解成一种局部广播的形式，广播的发送者和接收者都同属于一个App。实际的业务需求中，App应用内广播确实可能需要用到。同时，之所以使用应用内广播时，而不是使用全局广播的形式，更多的考虑到的是Android广播机制中的安全性问题。 相比于全局广播，App应用内广播优势体现在： 安全性更高； 更加高效。 为此，Android v4兼容包中给出了封装好的LocalBroadcastManager类，用于统一处理App应用内的广播问题，使用方式上与通常的全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将主调context变成了LocalBroadcastManager的单一实例。 代码片段如下： //registerReceiver(mBroadcastReceiver, intentFilter);//注册应用内广播接收器localBroadcastManager = LocalBroadcastManager.getInstance(this);localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter); //unregisterReceiver(mBroadcastReceiver);//取消注册应用内广播接收器localBroadcastManager.unregisterReceiver(mBroadcastReceiver);Intent intent = new Intent();intent.setAction(BROADCAST_ACTION);intent.putExtra(\"name\", \"qqyumidi\");//sendBroadcast(intent);//发送应用内广播localBroadcastManager.sendBroadcast(intent); 4. 不同注册方式的广播接收器回调onReceive(context, intent)中的context具体类型 1). 对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext； 2). 对于全局广播的动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context； 3). 对于通过LocalBroadcastManager动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Application Context。 注：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册的ContextReceiver才有可能接收到（静态注册或其他方式动态注册的ContextReceiver是接收不到的）。 5. 不同Android API版本中广播机制相关API重要变迁1). Android5.0/API level 21开始粘滞广播和有序粘滞广播过期，以后不再建议使用； 2). ”静态注册的广播接收器即使app已经退出，主要有相应的广播发出，依然可以接收到，但此种描述自Android 3.1开始有可能不再成立“ Android 3.1开始系统在Intent与广播相关的flag增加了参数，分别是FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES。 FLAG_INCLUDE_STOPPED_PACKAGES：包含已经停止的包（停止：即包所在的进程已经退出） FLAG_EXCLUDE_STOPPED_PACKAGES：不包含已经停止的包 主要原因如下： 自Android3.1开始，系统本身则增加了对所有app当前是否处于运行状态的跟踪。在发送广播时，不管是什么广播类型，系统默认直接增加了值为FLAG_EXCLUDE_STOPPED_PACKAGES的flag，导致即使是静态注册的广播接收器，对于其所在进程已经退出的app，同样无法接收到广播。 详情参加Android官方文档：http://developer.android.com/about/versions/android-3.1.html#launchcontrols 由此，对于系统广播，由于是系统内部直接发出，无法更改此intent flag值，因此，3.1开始对于静态注册的接收系统广播的BroadcastReceiver，如果App进程已经退出，将不能接收到广播。 但是对于自定义的广播，可以通过复写此flag为FLAG_INCLUDE_STOPPED_PACKAGES，使得静态注册的BroadcastReceiver，即使所在App进程已经退出，也能能接收到广播，并会启动应用进程，但此时的BroadcastReceiver是重新新建的。 Intent intent = new Intent();intent.setAction(BROADCAST_ACTION);intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);intent.putExtra(\"name\", \"qqyumidi\");sendBroadcast(intent); 注1：对于动态注册类型的BroadcastReceiver，由于此注册和取消注册实在其他组件（如Activity）中进行，因此，不受此改变影响。 注2：在3.1以前，相信不少app可能通过静态注册方式监听各种系统广播，以此进行一些业务上的处理（如即时app已经退出，仍然能接收到，可以启动service等..）,3.1后，静态注册接受广播方式的改变，将直接导致此类方案不再可行。于是，通过将Service与App本身设置成不同的进程已经成为实现此类需求的可行替代方案。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Broadcast","slug":"Broadcast","permalink":"http://github.com/tags/Broadcast/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"谷歌整体战略：关于人工智能、云服务和登月计划的未来","slug":"谷歌整体战略：关于人工智能、云服务和登月计划的未来","date":"2016-10-21T07:43:20.000Z","updated":"2016-12-21T04:00:42.906Z","comments":true,"path":"2016/10/21/谷歌整体战略：关于人工智能、云服务和登月计划的未来/","link":"","permalink":"http://github.com/2016/10/21/谷歌整体战略：关于人工智能、云服务和登月计划的未来/","excerpt":"CB Insights 今日发布了一篇关于谷歌业务战略的深度分析报告: Google Strategy Teardown: Betting The Future On AI, Cloud Services, And (Tamed) Moonshots，盘点了谷歌在人工智能、云服务、虚拟现实/增强现实、电信与能源、运输与物流、硬件和服务平台等众多领域的业务和战略。其中人工智能是贯穿谷歌所有方面的创新的线索。 自 1998 年谷歌在加利福尼亚州门洛帕克的一间车库变成一家公司以来，它已经发展成为了后 .com 时代企业创新的火炬手。谷歌对长远创新的亲睐体现在多个方面——从其广为人知的员工可用于个人项目的「20% 个人时间」政策（这个政策导致了 Gmail 和 AdSense 的诞生），到其在 2009 年成立的准独立的风险资本部分 Google Ventures，再到其面向未来创新的「登月计划」的 Google X 创新实验室（已改称 X）。 但是，近些年来，该公司已经开始转变其实验性的方法、有风险的研发和分散式的公司结构了。 在 2011 年执掌谷歌后，CEO Larry Page（现为 Alphabet 的领导者）就宣布谷歌将在「更少的箭头后放更多木材」，要向更重要的方向投入更多资源：从民主化的自下而上的创新方法变成更为自上而下的重点式战略。 实际上，据报道「20% 个人时间」政策在近些年来已经受到了限制，需要更多的管理批准和监督。 与此同时，谷歌已经从核心的搜索和广告业务扩展到了更为广阔的业务领域，其涵盖了从消费硬件到汽车到电信到医疗到风险投资等众多领域。","text":"CB Insights 今日发布了一篇关于谷歌业务战略的深度分析报告: Google Strategy Teardown: Betting The Future On AI, Cloud Services, And (Tamed) Moonshots，盘点了谷歌在人工智能、云服务、虚拟现实/增强现实、电信与能源、运输与物流、硬件和服务平台等众多领域的业务和战略。其中人工智能是贯穿谷歌所有方面的创新的线索。 自 1998 年谷歌在加利福尼亚州门洛帕克的一间车库变成一家公司以来，它已经发展成为了后 .com 时代企业创新的火炬手。谷歌对长远创新的亲睐体现在多个方面——从其广为人知的员工可用于个人项目的「20% 个人时间」政策（这个政策导致了 Gmail 和 AdSense 的诞生），到其在 2009 年成立的准独立的风险资本部分 Google Ventures，再到其面向未来创新的「登月计划」的 Google X 创新实验室（已改称 X）。 但是，近些年来，该公司已经开始转变其实验性的方法、有风险的研发和分散式的公司结构了。 在 2011 年执掌谷歌后，CEO Larry Page（现为 Alphabet 的领导者）就宣布谷歌将在「更少的箭头后放更多木材」，要向更重要的方向投入更多资源：从民主化的自下而上的创新方法变成更为自上而下的重点式战略。 实际上，据报道「20% 个人时间」政策在近些年来已经受到了限制，需要更多的管理批准和监督。 与此同时，谷歌已经从核心的搜索和广告业务扩展到了更为广阔的业务领域，其涵盖了从消费硬件到汽车到电信到医疗到风险投资等众多领域。 去年十月份的 Alphabet 组织架构重组就是为了这个庞大的规划网引入更大的结构、透明度和财政责任。为了同样的目的，该公司还在今年七月份聘请了摩根士丹利在财务纪律（financial discipline）享有盛名的资深高管 Ruth Porat 作为首席财务官。 一年来，这些举措已经给山景城应对收购和研发的方法带来了明显的改变。新的股权激励将会将员工的奖励和个人单位绩效挂钩。在 X 实验室，负责人 Astro Teller 曾写了需要推进登月项目「毕业」——「毕业」是指项目最终成长为 Alphabet 企业家族中可扩展的团队和产品。以 GV 为例，该投资部门已经很长时间没有领导了，其规模以及尤其的种子交易截至今年目前为止已经缩减了。 由于该公司幅员辽阔，我们使用了 CB Insights 科技市场智能平台中的许多工具来提炼 Alphabet 组织范围内各个单位的收购、投资和研究/专利活动，从而获得了一个关于其未来战略的数据驱动的视角。鉴于该公司运营范围的辽阔，我们不会触及每一项计划和部门，而只关注推动谷歌系向前的主要和反复出现的主题，其中包括： 推进云和硬件：Alphabet 推动增长的领域已经不再限于广告了，也在研发、收购和投资有可能实现收入和带来利润的业务和领域，例如高级移动和智能家居硬件，尤其是云和企业服务。比如谷歌在 Nest 之后最大的收购 Apigee 就是一家已经上市的企业云公司。 人工智能优先（AI-first）战略：该公司正在利用其人工智能/机器学习的专家人才（包括那些通过 DeepMind 收购吸纳进来的）来差异化自己在上述部门以及搜索和广告、整个面向消费者的网页服务和其它 Alphabet 单位的产品。谷歌新款的高端移动和智能家居设备就是提供一些人工智能服务的渠道。 关注增强现实/虚拟现实、自动驾驶和数字医疗：投资、收购和山景城的专利数据范围包括自动驾驶、可穿戴、人工智能驱动的医疗和为全球更大范围的人口提供网络接入。 收购再次回升：该公司在 2016 年第 3 季度进行了 9 次收购，是自 2014 年第 3 季度以来最多的。这说明了该公司的兼并收购（M&amp;A）意愿的复兴，因为其已经表现出了进一步拓展移动硬件（包括 Pixel 手机和智能家居中枢）、企业云服务、交通/物流、虚拟现实等领域的打算。 GV 已经大大退出了种子市场：GV 已经基本上不再投资年轻的创业公司了。其种子投资上的行为已经较去年同期下降了 85%，在 2016 年上半年完全没有任何新的种子交易。 规范其它登月项目：控制开支和强迫登月项目概划盈利的途径。这让该公司启用了资深人士和重组了团队以实现业务化，另外还招募了一些外部行业资深人士来推动 Loon 和自动汽车项目的商业化。 目录 谷歌核心的一些背景 收购 投资 谷歌 GV 谷歌资本 专利数据分析 按领域划分的 Alphabet 计划 人工智能 云与企业 消费硬件和平台 增强现实/虚拟现实 电信与能源 交通与物流 医疗保健和数字健康 金融科技 结语 谷歌核心的一些背景在我们深入到 Alphabet 未来战略背后的数据之前，我们必须快速了解其目前最成熟和最盈利的业务线：谷歌搜索和广告。 提醒一下，现在的谷歌包含搜索、地图、云和企业、谷歌品牌的硬件和操作系统（Chrome、安卓等）和 YouTube。其它所有单位（从投资部门（GV、Google Capital）到 X 部门）现在都直接隶属于 Alphabet。但我们将统一使用「谷歌」进行指代，不管它现在确实属于谷歌还是在 Alphabet 之前属于谷歌。 2016 年第 2 季度，该公司的总收入（top-line）和净收入（bottom-line）增长超出了分析预期。主要在谷歌的核心广告业务的推动下，Alphabet 的季度收入跃升了 21%，增长至 215 亿美元，利润则增长了 24%，超出了市场预估。这种强劲的势头的推动力来自向移动平台的成功过渡，其中包括新的移动广告格式和更好的效果评估。 尽管上个季度的结果大部分是积极的，但也存在一些可能会影响长期前景的趋势。首先，谷歌广告业务的收入中来自其自家网站的份额在 2016 年第 2 季度首次达到了巅峰的 80%，而在 2011 年时这个比例是 70%。这意味着未来的广告增长将前所未有地更加依赖于谷歌向其自己网站（例如搜索结果和谷歌新闻等等）的流量引导，而不是向网络成员的网站。 移动广告通常比桌面广告的利润低，所以谷歌的成功是在每次点击的收入（CPC，当消费者点击广告商的广告时，广告商向谷歌的平均付费）更低的情况下实现的，其巨大的增量抵消一些这种情况的影响。2016 年第 2 季度在自家网站的 CPC 仅有两年前自家网站的 CPC 的 76%。 应用程序和连接设备数量的激增也带来了挑战，因为在 Facebook 和微信等应用程序占用大量用户在线时间，以及新一代设备（如智能家居中心）导流搜索流量成为潜在竞争对手的情况下，还不清楚谷歌的搜索引擎是否会继续占领主导地位（例如通过亚马逊的 Echo 智能家居设备和其 Alexa 语音助手直接进行的搜索）。 事实上，谷歌在全球数字广告支出中所占的份额持续下降，因为像 Facebook 这样的国内竞争对手以及百度和阿里巴巴等国际竞争对手都在持续增加市场份额。 谷歌的广告业务使公司长期以来一直保持稳定，同时它的财务手段也成为其登月计划（moonshot）的支撑。然而，尽管 Alphabet 的业务数量庞大，其财务业绩和增长前景仍然严重依赖于谷歌的原有业务（广告占了 Alphabet 2016 年第二季度收入的 89％）。其核心业务的卓越表现在其它不稳定的业务中是显而易见的，但是山景城（加利福尼亚州的一个县）已经敏锐地觉察到谷歌的收入来源是缺乏多样性的。当我们通过它的子公司深入了解 Alphabet 的活动时，我们将看到寻找新的增长途径是如何塑造了该公司的战略的收购。 收购传统认为谷歌是最有收购能力的科技公司之一，但它的收购步伐速度放缓，并导致了 Alphabet 架构下的机构重组。 自 2001 年以来，该公司已经进行了近 200 次收购，引进外部人才和扩展新的部门，并在这个过程中创造了 Larry Page 的另一句「牙刷测试（toothbrush test）」技术格言，来确定并购目标是否值得。（目标是必须开发客户认为每天都不可缺少的产品。） 我们的收购跟踪工具包括在山景城稳定的收购流中的每个收购记录。Alphabet 今年迄今（16 年 10 月 10 日）已经收购了 13 家公司，仅在上个月就进行了 3 次收购，其中包括 6.5 亿美元收购上市云公司 Apigee。我们使用 CB Insights Acquirer Analytics 工具跟踪谷歌自 2010 年以来的并购活动： 在这十年的大部分时间里，谷歌一直是技术并购的主导力量；活动在 2014 年达到顶峰，因为谷歌在第二季度收购了十多家公司，远远领先于那一年其它科技巨头的收购规模。然而，该公司的收购步伐大幅放缓，Alphabet 重组，并在 2016 年上半年大幅下降。最近一个季度的收购活动增加，虽然是否为昙花一现还有待观察，也或许是山景城适应了 Alphabet 的新收购速度释放的信号。到目前为止，2016 年第四季度，Alphabet 只收购了 Famebit，一个可以帮助商业品牌与 YouTube 上的视频创作者建立联系的平台。 除了最新的财务紧张问题，近十年来大规模收购带来的低迷结果可能也促使了公司收购活动的暂停。该公司快速地收购了至少 7 家机器人公司——Schaft , Industrial Perception , Meka Robotics, Redwood Robotics ,Bot &amp; Dolly , Holomni , 以及最著名的波士顿动力（Boston Dynamics）——触发了 2014 年的炒作高峰（如趋势图所示，如下），但这些公司从来没有合并成为一个高效的机器人公司。前安卓负责人 Andy Rubin 带领了机器人浪潮，但 Rubin 于 2014 年 10 月离开公司创办全球硬件创业孵化器 Playground Global。失去了有远见的人物可能会阻碍机器人部门的发展，不管是在谷歌或是在 Alphabet，这个名为 Replicant 的机器人部门从未真正合并成为一个完整的公司。 相反，在 Alphabet 创立后，Replicant 直接进入管理层的视线，新公司 Alphabet 对其各公司的创收潜力进行了严格的审查。虽然像波士顿动力公司这样的子公司在 YouTube 上备受推崇，但是漫长的商业化道路导致该公司在 2016 年初被出售。最近，谷歌 2014 年对智能家居的重要战略环节——收购 Revolv，Dropcam（5.55 亿美元）和 Nest（3.2 亿美元，迄今为止收购的最大的初创公司）也被管理不善和员工流失的指控所困扰。Nest 的紧张局势随着 Nest 联合创始人兼首席执行官 Tony Fadell 在 6 月份的离开而公之于众。Fadell 辞职的事件中反复提到了智能家居领导层之间的摩擦，最引人注目的是 Dropcam 创始人 Greg Duffy 在 Medium 上的一篇博客（他的 Dropcam 团队被纳入 Nest 智能家居部门）： 将 Dropcam 卖给 Alphabet 是我的错误……可以说，我与当前 Nest 的领导在管理方式上有极大的差异。 Nest 的问题可以看作是旧的管理结构的失败，即在公司扩展到新的市场和产品线时，没有正确地管理其各个子公司，在 Googleplex 背景下协调达成一致的目标和企业文化。事实上，Nest 部门（现在是一个独立的 Alphabet 公司）远离了该公司的新智能家居硬件的努力方向（刚于 2016 年 10 月 4 日的智能硬件大会上发布 Google Home）。作为 Alphabet 的事实上的智能家居公司，Nest 可能是成为亚马逊 Echo 设备的竞争者的最好的选择。然而，亚马逊设备对谷歌公司的主要搜索业务的明显威胁，以及与亚马逊竞争的日益激烈，可能导致谷歌得出结论：必须将开发智能家居作为公司核心，并由谷歌的执行官直接监督。 此外，这样的产品需要与谷歌的核心搜索和虚拟助理服务紧密集成。Nest 作为谷歌的非核心公司想要实现这一点，跨越部门间的界限和达成共识将有更多的麻烦。 新成立的 Alphabet 结构可能有助于更成功的并购和不同业务的整合。Alphabet 旗下的不同部门将可以根据它们自己的战略利益和路线规划进行收购游说；但也会面临一个更为清晰的组织结构，能让 Alphabet 称霸天下，也会迫使其减少对投机项目的投入。 尽管谷歌的机器人和智能家居的投资已经变成了警示性的故事，但谷歌在许多其它领域的收购却带来了毫无疑问更为积极的结果。2014 年谷歌收购的 DeepMind（金额在 5 亿到 6 亿美元之间）已经通过其高调的 AlphaGo 和 WaveNet 项目巩固了谷歌在人工智能研究方面的声誉，而且其技术也已经在谷歌的数据中心和翻译工具等产品中得到了应用。 除了智能家居，谷歌与亚马逊的激烈竞争也带来了对云和企业服务的收购，以及一种完全不同的战略方法。谷歌正确地将云平台作为了其优先事项，因为其过去在这方面落后于亚马逊的 AWS 和微软的 Azure（尽管谷歌最近得到了一些战略性的云客户，其中包括苹果和 Spotify）。 在这个领域，谷歌严重依赖于收购来补充其内部研发和在其平台之上提供增值服务。特别地，CEO Sundar Pichai 曾说过该公司的目标是通过稳健的、对开发者友好的服务进行竞争，而不是单纯的规模。我们的收购方分析数据也突出了这方面的努力： 一个主要的例子是谷歌在今年 9 月对 Api.ai 的收购，这是一家帮助开发者开发对话式智能接口的创业公司。这能很好地和人工智能交织在一起，而人工智能则是谷歌的差异化战略的另一支柱（更多细节请参看行业部分）。 谷歌在这一领域的其它收购还包括 2014 年的 Stackdriver、Appurify、Firebase 和 Zync Render，以及过去两个月的 Apigee 和 Orbitera。事实上，谷歌 2016 年的一半以上的收购都涉及到企业应用或 B2B 云服务。其中许多都发生在 Recode 3 月份的谷歌在寻找企业云领域的目标上最活跃的报道之后。 据最近离开谷歌的人说，那些收购请求出现最频繁的是这个领域：企业。 在云的推动下，谷歌得以关注服务中端市场的多个目标，旨在增加多样化的企业能力，这和对 Nest 的数十亿美元的重磅收购不同。其 1 亿美元收购的计费服务公司 Orbitera 是这种追赶策略以及其对一个灵活的、「多云（multi-cloud）」世界（其中企业将越来越依赖于多个供应商）的支持的象征。 另外值得一提的是，和押注前沿的有希望但未得到证明的领域相比（比如，自动驾驶汽车和机器人），Alphabet 的一系列云和企业收购更倾向于有明显的赚钱机会的较为成熟的公司。 Alphabet 六月份对 Webpass 的收购也是来自于对成熟的电信领域的收购。Alphabet 运营 Fiber 业务的 Access &amp; Energy 部门已经宣布了利用 Webpass 的无线技术降低资本开支和部署时间的计划（伴随着 Fiber 业务成本高昂的扩张）。在这样的背景中，Webpass 看起来像是又一个带来了即时影响的收购——降低了开始并提升了盈利能力。 不可否认，自 Alphabet 诞生以来的这短短一年时间，数据就已经深远地影响了这个新组织在平衡「登月项目」和财政责任上的尝试，并且明晰了其实现收入的路径。 投资：谷歌，GV 和谷歌资本Alphabet 的投资活动一直被竞争者和观察家们关注。一部分投资由下属的谷歌或其分支直接发起（例如 DeepMind 直接投资了远程医疗初创公司 Babylon）。但大部分投资来自 Alphabet 的两家主要投资机构：专注于早期初创企业的 GV（前谷歌风投）和对扩张期公司投资的谷歌资本（Google Capital）。 这些投资分支一直强调其投资策略与谷歌本身互相独立。在 2015 年 9 月，集团的运营策略发生了改变，GV 和谷歌资本成为了新控股公司下的两家分支公司。（但他们共同接受 Aphabet 的高级副总裁 David Drummond 的监督，此人同时监管集团的企业并购业务。）我们相应地单独分析他们的活动，但它们仍会同时出现在一些深入的剖析中。 正如上图显示的，三家机构的投资活动数量在近期有很大波动。GV 的交易活动在 Alphabet 成立之前已经开始下降，而投资的增长来自于谷歌资本和谷歌本身的战略投资。 谷歌从谷歌开始，公司的主要战略投资包括几次大型交易到一些「前沿」领域如增强现实，太空运输和探索。谷歌在 2014 年 10 月领投了隐形增强现实设备 Magic Leap 5.42 亿美元的一轮投资，在 2015 年 1 月又参与了 Space X 10 亿美元的 D 轮融资。有消息称谷歌正准备在未来对这家宇航公司继续投资 90 亿美元，以获得 7.5% 股权。 这种投资活动的规模强调了山景城对于先进科技领域的重视。谷歌认为 AR/VR 是未来计算视觉呈现的核心。其 Magic Leap 的交易宣示了公司策略的进一步多元化（谷歌已有包括在 2016 年 10 月发布的消费级产品 Daydream 移动 VR 头盔，和其他早期产品，如 Cardboard，Google Glass 和 Tango）。 与此同时，谷歌向 SpaceX 进行了大笔投资，这将帮助 Alphabet 的「登月计划」为谷歌提供地理信息（Terra Bella，前 Skybox Imaging 项目），同时帮助提升全球互联网覆盖面积（Access and Energy，前 Project Loon 等计划）。廉价高效的地球卫星发射将会为对这两个方面提供便利，而 SpaceX 的首席执行官埃隆·马斯克对此也志趣相投，他决心建立一个以卫星为媒介的全球通信网络。谷歌直接资助了卫星服务公司 O3b Networks ── 而 O3b 已被欧洲卫星通信公司 SES 以 14 亿美元的价格收购──这些投资也与上述活动相关。 除了战略投资，在 2016 年 4 月谷歌建立了 Area 120，一个为公司内部员工准备的创业孵化器。这些措施是为了防止公司人才的外流。孵化器的名字中提及挤出 20% 的时间进行创业，就像谷歌的其他传统一样，这已经变成了一个正式的，明确的计划。 GVAlphabet 风投机构自 2009 年成立以来，已经成为了风投生态中的重要一环，它一直是最为活跃的风投公司。我们接下来分析 GV。 有这样一个事实：Bill Maris，作为创始人和首席执行官在 8 月初离开了 GV。有匿名消息称这次人员变动与上级公司 Alphabet 的重组有关（在 Maris 治下的 GV 以自主决定权而闻名）。目前事件的双方仍公开表示友好，Maris 这样评论： 我的离开是因为所有事情都很棒……我与 Alphabet 之间没有问题。但 Alphabet 的改变对所有人都有一点影响。我们（GV）从第一天开始就是独立的。 虽然如此，在后 Aphabet 时代里，创始人的离去仍将成为主题，这一幕也许将会在公司的其他部门继续呈现。 通过 CB Insight 的投资分析工具分析 GV 近期的投资活动，我们可以看到 GV 的投资速度自 2013 年末到 2014 年初的顶峰（约每季度 30 笔投资）以后，有逐渐下降的趋势。这与我们之前 GV 正在减少新投资活动的结论相同。 GV 在 2009 年以 10 亿美元资本起家，每年膨胀 50 亿美元。随着 GV 资金来源的充裕，它逐渐参与进了大型投资，如 2014 年优步 12 亿美元的 D 轮投资和 Jet.com 在 2015 年的 B 轮投资。CB Insight 的投资分析工具显示了 GV 持续增长的中型交易，在 2016 年第一季度，公司一跃进入了大型投资的行列，包括 2 月份对 Oscar（40 亿美元）和 Magic Leap（7.94 亿美元）的投资。总的来说，数据显示 GV 的大型投资脱离了 2015 年以前的中位数，出现了急剧上升。 交易数量的减少和投资金额的增加表明 GV 已完全退出天使轮投资市场，这个曾经它赖以为生的领域。在过去的两年里，它的天使轮投资活动每年减少 85%，在 2016 年上半年则完全没有这种投资出现。 Bill Maris 在去年 12 月承认了这种变化，认为在前期投资中的机会正在减少。在 今年 8 月 Maris 离职的采访中，他同样指出 GV 目前对于投资形式存在限制： 当你有 25 亿美元的资金，进行种子轮投资就是浪费时间了。 同时，GV 融资项目的区域也越来越固定了──以美国为中心。公司 2014 年启动了 12.5 亿美元的欧洲投资专项资金，由五位合伙人进行管理。然而，在后 Alphabet 时代，这个项目在 2015 年 12 月宣告终止，其中资金被回收并投入 GV 品牌再造项目。 在大约一年半之前，欧洲的分部进行了不到十项投资，其中最大的交易是对宾馆预定网站 Secret Escapes 6000 万美元的 C 轮融资（Octopus Investments 是这次投资的另一个领投者）。 从行业上看，GV 一直被其「独立」的策略所束缚，公司表面上追求高风险，但潜在高回报的登月式的项目，实际上却与传统风投公司别无二致。Maris 的个人魅力渲染了谷歌对于登月式项目的追求。医疗领域的投资为这种看法做出了注解，正如 Maris 在 2015 年文件中所说： 如果你今天问我，我们会活到 500 岁吗？答案是肯定的……如果有人让你在很多钱和能活很久中进行选择，你会怎么选？ 的确，GV 一直在强调他们会投资医疗初创企业。他们的投资范围从数字医疗公司（Flatiron Health）到供应商（One Medical），也包括新方向如基因医疗（Editas，Foundation Medicine，23andMe）。近年来，公司正在这些公司上投入越来越多的资金。在 2015 年 3 月，Maris 在接受彭博社的采访时披露，其时 GV 已将 36% 的资金投入生命科学领域，而在 2013 年，这个数字只有 6%。 GV 的投资和 Alphabet 其他部门 Verily 与 Calico 的投资共同正在为变革性医疗研究助力。如此重视医疗行业无疑是因为 Bill Maris 拥有生命科学背景；事实上，这位前生物科学公司管理人直接推动了 Calico，Alphabet 神秘的抗衰老研究部门。在 CB Insight 中，我们可以深入了解 GV 对于其他领域的投资，跨度从 AR/VR 领域到无人机，互联网金融，网络安全，再到人工智能。GV 的投资组合与 Alphabet 令人眼花缭乱的资本操作有着很多重合。至少 6 家 GV 投资的公司最终都被山景城收购，其中值得注意的是 2014 年的 Nest。 另一方面，优步突然变成了 GV 甚至 Alphabet 投资策略中潜在的不和谐音符。随着竞争对手的压力，优步开始将重心转向他们的自动驾驶汽车，而谷歌此前也投资了拼车应用 Waze（收购于 2013 年）探索共乘车市场。随着这些步骤的实施，在共乘车服务上他们正在对优步形成威胁。 作为回应，优步正在逐渐稀释管理层中 Alphabet 的地位，交易负责人 David Drummond 离开了优步董事会。这家打车公司同时驱逐了董事会观察员 David Krane，后者是 GV 的合伙人，现已成为 Bill Maris 的继任者。 谷歌资本谷歌资本是 Alphabet 风投家庭中年轻的一员，于 2013 年创立。因其资金充裕，公司的投资方向明显不同于集团内老一代的同僚，谷歌资本主要参与初创企业的后期融资阶段。据称，他们每年的投资数量为 30 亿美元。一个健康的数字，但略微少于 GV。正如其宣称的，谷歌资本将自身定位于盈利导向（而不是战略导向）的投资者。当然，其不断增长的资金仍正在利用专业知识，招募基础和其母公司谷歌的威望作为其核心卖点。集团的其他公司承诺给对谷歌资本共享资源。Edward Kim，被投资公司 Gusto 的首席技术官赞赏这种工作方式： 他们真的从谷歌内部找到了一个人，一个能够解决我们问题的人。相比资金，他们其实带来了更多技术上的帮助。 自成立以来，谷歌资本一直维持比 GV 更低的活跃度。他们每季度的成交数量维持在 1 至 3 笔，只在 2015 年第三季度超过了这一数字。 谷歌资本通常参与 2500 万至 10 亿美元的融资轮，这不属于很大的交易。其中一些包括 CloudFlare 的 D 轮融资（11 亿美元），FanDuel 的 E 轮融资（27.5 亿美元），和 Oscar 的 C 轮融资（40 亿美元）。 谷歌资本的投资方式反映了硅谷大多数高端投资公司的习惯，与那些著名对冲基金，或老虎基金与富达投资的科技投资共同基金相似。 GV 很少在谷歌资本投资之前对同一家公司进行投资。前者确实出现在了谷歌资本投资的一些公司的共同投资人名单上，但这一般都是在追逐利益时出现的巧合。当然，随着 GV 正在逐渐远离早期投资市场，两家投资机构的重叠区域可能会越来越多。 谷歌资本目前最值得一提的交易是对 Care.com 的首次公开市场投资。今年 6 月，谷歌资本宣布了对这家护理服务公司 4635 万美元的投资，该公司于 2014 年 1 月份上市。这次交易意味着公司的投资部门跨越私人与公开市场，这与那些共同基金和对冲基金的业务相同，正如谷歌资本的合伙人 Laela Sturdy 在回答公司对私人和公开市场领域之间的立场的问题时所说的： Care.com 体现了本公司的投资喜好。我们一直专注于成长阶段的公司，我们唯一的目标是帮助他们成长为拥有谷歌体量的巨头。 我们可能会看到未来谷歌资本进行更多的 PIPE（私募资本投资公开市场），又或许他们将固守传统的私人投资领域。 专利数据分析使用 CBInsights 专利数据，我们还筛选出公司研究活动的趋势。这项分析在执行时有几个注意事项，主要是，专利申请过程在应用发布前有一个明显的时间差。这个延迟时间从几个月到两年不等。我也拿谷歌做过该方面分析，排除了其外部收购公司带有的专利。 另外值得注意的是，谷歌一直以来对专利所持的态度。过去，公司高管包括 Larry Page 和 Sergey Brin 他们自己都反对申请过多的专利，这会威胁到硅谷的创新精神。乔布斯发布第一台 iPhone 时，谷歌只有 38 项专利。到了 2011 年，谷歌高级副总裁总法律顾问 Kent Walker 描述了公司对专利制度的普遍厌恶，他们希望见到改革措施： 专利不是创新。这是一种阻止他人创新的特权。 然而，随着智能手机的诉讼在本世纪初加剧，谷歌被迫转变了立场。2012 年，它以 125 亿美元的价格收购了摩托罗拉手机业务，这是迄今为止该公司最大的收购，该收购为谷歌不断增长的 IP 库带来了丰富的手机专利。谷歌自己也开始迅速提交专利应用申请。 关键数据突出在与谷歌前沿产品计划相关的专利上。Mountain View 的专利点亮了其谷歌眼镜计算设备及其他可穿戴设备研究。「Balloon」也在 2014 年问世，它从今年年初到现在一直处于下面这张列表的首位，Project Loon 的气球动力互连网络开发一直在持续。 关键词「车辆（vehicle）」上升的频率也反应出谷歌在自动驾汽车领域上的投入，他们一直在扩大自动驾驶的测试团队，还在寻找汽车制造商合作伙伴。2012 年，带有汽车关键词的应用数量激增，而且最近几年一直在增长，包括专利数据可能还不完整的 2014 年，所以当这些档案公布于世时，汽车应用的数量实际上甚至会更多。 很多这些专利产生计划（moonshot），当然包括自动驾驶机车项目，已经占领了谷歌的 X 实验室。自从 2010 年建立以来，X 实验室一直在尝试成为一个成功的致力于尖端前沿的企业研究机构，其他像 PARC 和贝尔实验室最终都因其母公司而失败了（至少在资金上）。 我们的趋势工具挖掘了数百万条媒体关于技术趋势的报告后显示，「moonshot」一词的流行度一时间接近了「Google X」。换句话说，谷歌的实验室与 moonshot 概念紧密相关，像传统的企业创新实验室运营商一样，Alphabet 已经不再避开专利系统了。 下一节中，我们将细究遗爱谷歌的一些优先项目，以及它们是如何融合进 Alphabet 的特定产业策略中的。 Alphabet 在各领域的战略和其投资部门很像，Alphabet 其他的子公司（包括谷歌）的业务都涉足了不同的领域。这里，我们对 Alphabet 涉足的重点领域进行分组深入分析。再次强调，下面的列表中不包括这家公司的所有业务活动，而是综合概述了其目前的兴趣领域。 人工智能今年 10 月在其最新高端 Pixel 智能手机的发布会展示中，谷歌 CEOSundar Pichai 说世界正在从「移动至上」转向「人工智能至上」。谷歌与人工智能这一时髦领域有着密切的联系，而且占领这一领域的欲望越来越强烈，并成为了最活跃的人工智能公司卖家。 在其公司内部，谷歌大脑以一个 X 项目成功凸显。去年，Astro Teller 将谷歌大脑描述成「谷歌的生产价值所在，可以抵得上 GoogleX 的总成本了，」这个小组开发了 tensorflow，并提高了从翻译到语音搜索的核心技术。在 Alphabet 今年第二季度盈利的电话会议上，Sundar Pichai 也对投资人重复强调了机器学习的重要性。 机器学习是驱动未来的引擎… 谷歌内部目前有超过 100 个团队在使用机器学习，从街景到 gmail 到语音搜索等等。 除了实体产品外，一个脱胎于 DeepMind 的系统已经帮助其耗电量巨大的数据中心减少了成本和实现了环境保护功能，将能源使用效率提升了 15%。 谷歌正在将机器智能和学习部署到它的所有业务上，我们也在几个关键领域对其人工智能方面的业务活动做出分析。 云&amp; 企业谷歌的云和企业服务已快速上升至其优先项目中了，这一点在其疯狂的收购中可见一斑。进一步推进有利可盈的服务市场延伸了 Alphabet 所强调的能直接带来财务上涨的机会的逻辑（上一季度，亚马逊 AWS 部门产生近 100 亿美元收入） 在 Alphabet 成立谷歌云事业部 Google Cloud Enterprise 后，谷歌立即挖来了 VMWare 的前 CEODiane Greene 任职谷歌的云计算事业部的高级副总裁。谷歌云包括了 Google for Work、云平台（针对 AWS）、和 Google App。谷歌已经开始重新定位其品牌。2016 年 9 月，Google for Work 品牌更名为 G Suite。视频群聊和没人爱的 Google+网络也正在转向企业用户。我们已经看到，谷歌正在收购和建立众多对开发人员友好的服务来区分其平台。然而，谷歌也在很多业务中利用了机器学习技术，以便在与对手的竞争中抢占先机。 谷歌大脑和公司的人工智能收购业务有助于推动这些进展，同时也肩负着提醒旁观者 Mountain View 在人工智能领域的领先地位的责任。然而据我们的趋势分析显示，就其云产品而言，谷歌在媒体报道上依然落后于微软 Azure 和 AWS。 虽然谷歌一直落后于亚马逊、微软，甚至是 IBM，但早期的回报总是积极性的。今年第二季度谷歌的「其他收入」（包括云及许可费用，硬件、及其他非广告业务）为 22 亿美元，并以 33% 的年增长率上升。公司高管们很快就注意到了，云服务是这一增长的主要驱动力，而且将仍然是谷歌找到创收新途径的战略基石。 消费硬件&amp;平台我们已经涉足了这个领域，但是 Alphabet 面向消费者的项目一直在努力平衡他们在金融实用主义上对激进项目的偏好。Nest 最近的已经出现在各个角落，但是其他部门的业务还在面临自己的困难。 谷歌搞出了 X，而 Advanced Technology and Projects（ATAP）的研发部门也在开发「epic shit（史诗级项目）」，并与公司保持适当的整合。但是，像其他的部门一样，针对于消费者的研发部门今年也经历了更换重要领导。 谷歌自从把摩托罗拉前总裁 Rick Osterloh 拉回董事会主持新一轮洗牌时，汇集了像 ATAP, Chromecast, Nexus, Pixel 智能手机和谷歌眼镜（后者原先由 Tony Fadell 负责）不同的面向消费者团队。这个新的硬件部门最近搁置了 Project Ara，自 2013 起来一度大肆宣传的模块化智能手机。 谷歌一直对其自主手机硬件品牌产品 Nexus 和 Pixel 不太满意，现在 Pixel 取代了 Nexus，并与运营商签约了正式分销协议。 谷歌的消费设备跨越各种智能手机、平板电脑、笔记本电脑，以及一个运行 Andromeda 的混合设备，一个统一了安卓和 Chrome 的操作系统。该公司继续在很大程度上轮流依赖于多家制造商伙伴（三星、HTC、华为等等）为其生产设备。 显然，谷歌谷歌刚刚宣布了 Pixel 线的品牌制造厂商，并促成了合作伙伴 HTC 与富士康合作（据说导致华为退出该项目）。 这些新手机与 Home 和 Daydream 一起在 10 月的「Made by Google」大会上发布。该产品的闪电问世为 Osterloh 的新硬件部门定下了基调，以谷歌为中心的品牌推广透露着该公司有点模仿微软 Surface 产品线的意味，更加接近苹果在硬件设计和软件服务上的业务布局。新的 Pixel 设备的溢价定价比对了之前 Apple 的 iPhone7 系产品的定价。谷歌又一次在一个成熟的行业中追逐一块高利润的馅饼。 谷歌也在展望对话智能平台的未来，从 Allo 的即时讯息到智能家居。此外，新的 Pixel 智能手机已经有内置捆绑人工智能的功能，包括新的虚拟谷歌助手，以及 Pixel 用户的照片和视频无限存储。至少现在，谷歌正在为其品牌 Pixel 和家居设备保留了语音助手（通过 Allo 的机器人聊天可以用上这个语音助手，但是没有整合进来）。 谷歌一直在利用人工智能来区分其消费云产品，比如其带有自然语言搜索和自动脸与对象识别的照片产品 在硬件和即时讯息这两个业务上，谷歌已经晚了一步，但是这些举措都对山景（Mountain View）产品在人工智能技术和作为搜索平台中心上奠定重要地位起到了关键作用。每个通过一个 Alexa-或者 Siri 驱动的设备的查询都威胁到了谷歌当前收入模型的基础。即便谷歌在这里取得了成功，一个以语音为中心的搜索形式仍有可能颠覆其已经依赖了十几年的传统网页搜索广告的显示模式。 同时，如果谷歌能将其设备和服务通过其人工智能技术含量区分开来，它将有机会创造出一个新的、潜在的高利润业务线，甚至可以通过拓展市场份额加强其与苹果和亚马逊的对抗。 增强现实（AR）/虚拟现实（VR）Alphabet 的增强现实/虚拟现实的经典战略已经开展成了多个并行运行的项目。该公司在这项业务上已经从预算虚拟现实（Cardboard），到 AR（谷歌眼镜）硬件再到 VR（Daydream）和 AR（Tango）平台，还有其前面提到的 Magic Leap。在我们的增强与虚拟现实研究简报中，我们已经研究了谷歌和其他科技公司。从产品创新来看，Daydream 头戴设备很有趣，它一改之前笨重的塑料套而使用了轻便的布状织物，是一款面向大众消费者的虚拟现实概念的新设计产品。 事实上，围绕谷歌 AR/VR 的讨论大部分都是讨论 VR 而不是 AR，这并不意外，因为它的 AR 可穿戴产品 Google Glass 失败了，而 Daydream 成为了谷歌在此领域中的旗手。 通信 &amp; 能源Alphabet 通过外部投资（SpaceX、O2b Networks）、收购（Titan Aerospace，现在是 Project Skybender）以及一些内部项目，投入了数十亿美元改进全球互联网的接通性。Google Fiber 要做的事已经演变成了对市场中传统电信服务提供商的打击，也就是那些为大半城市群提供千兆网络和电视服务的一方。 然而，Fiber 已经被部署光纤网络的成本困扰一段时间了，更不要提来自在位者的条例和法规难题了（Fiber 曾被指为 Alphabet「Other Bets」中最大的单项支出，Other Bets 是该集团对登月项目经济报告的涵盖性术语。）一旦资本支出自由流通，Fiber 如今正被邀请接受 Alphabet 的经济审查，8 月份来自高层的一份措辞严厉的要求就可见一般： Alphabet CEO 拉里·佩奇命令 Fiber 减少客户攫取成本到目前的 1/10，同时要求 Fiber 主管 Craig Barratt 砍掉一半职员，从 1000 到 500。 就像我们上面提到的，对 Webpass 的收购就像一剂药膏，直接缓和了这些损失。 其他项目包括谷歌的 Project Fi mobile virtual network operator（MVNO），谷歌称该项目是一项实验，动机是改进现任运营商。一个 MVNO，本质上也就是从无线和市场手机服务商那里购买带宽放到自己品牌、价位和支撑方案下面。 Link、Skybender 和 Loon 项目针对的是偏远地区和新兴市场的完全不同的人群，但这显然是「所有人都接入网络」理念的延展。和其它 X 单元一样，Loon 项目最近已经走出了 X，得到了来自 WildBlue 的行业老兵 Tom Moore 的领导，以推动该项目实现商业化。Loon 项目也利用了谷歌的机器学习之力，部署了能够优化气球的位置和方向的算法。 只要这些「登月项目」从 X 毕业，就很容易预想它们会被收纳到 Alphabet 的 Access &amp; Energy 的旗帜之下。有传言说这个 A&amp;E 单位将会换个新名字，但目前仍然还会包括 Alphabet 在能源方面的工作。Sunroof 项目是其中的一项计划，Makani 机载风力涡轮机（在 2013 年收购）如果成功，也是另一个自然的候选项目。 交通和物流谷歌自动驾驶汽车项目于 2010 年在 Google X 成立；其表现和公众知名度使之成为了 Google X 这个部门事实上的代言人。该公司已经相应地进行了投资，有传言说谷歌为这个长期项目准备了 100 亿美元。 就在 Alphabet 的重组之前，该项目也雇佣了自己的行业老兵——来自 Hyundai America 和 TrueCar 的 John Krafcik。这被广泛地解读成是使该项目正式实现独立的开始。在 4 月份的一个采访中，Astro Teller 将其描述成是「正在从 X 毕业的过程中」。（尽管 X 已经从谷歌分离，但该汽车项目目前仍然保留了原来的名字）。 事实上，这个谷歌汽车项目的测试场地已经从山景城扩展到了德克萨斯州、亚利桑那州和华盛顿州。在 5 月份时，它也与一家主要的汽车制造商（Fiat Chrysler）确定了首次合作关系，并且还在 7 月份引入了一个法律领导。 但是，一些长期的团队成员已经离开了这一项目。8 月份时候我们看到项目 CTO Chris Urmson 离开，一些工程师也离开了并创立了 Otto 和 Nuro.ai 等公司。随着其他玩家的加入，谷歌在这一领域的独特地位已经受到了挑战，正如我们 Trends 趋势工具对自动驾驶相关热点的跟踪那样： 在物流方面，Alphabet 有谷歌 Express 同日送达服务，这项服务在今年 2 月份已经扩展到生鲜杂货店。 在 X 旗下，还有 Wing 无人机项目，该项目最近和 Chipotle 进行了合作在弗吉尼亚理工测试卷饼送递服务。 和其它部门一样，这两个快递项目都是针对电子商务巨头亚马逊的无人机和其它物流项目的防御，以应对其对谷歌的产品搜索流量的威胁。它们也将 Alphabet 带入了与 Instacart、FreshDirect 和 Uber 的竞争中。我们已经将 Uber 评价为了自动驾驶和驾乘共享的有力竞争者。Wing 项目也与越来越多自动快递无人机创业公司形成了竞争关系。 医疗保健和数字健康正如我们所见，Bill Maris 领导的 GV 已经投资了很多医疗保健和数字健康领域的创业公司。尽管我们目前还不清楚在 GV 的新领导下，这个趋势是否还会继续，但 Alphabet 旗下已经有两个从事生命科学研究的分支机构了。 其中 Verify（即原来的谷歌生命科学（Google Life Sciences））自 2015 年 12 月以来启动很多项目，包括智能葡萄糖感应隐形眼镜、纳米诊断和用于抵抗震颤的 stabilized spoons（收购自 Lift Labs）。Verily 也与一些顶级的医疗保健品牌建立了合作，其中包括 Johnson &amp; Johnson（Verb Surgical）、GlaxoSmithKline（Galvani Bioelectronics）和 Dexcom（连续血糖监测）。 Verily 是另一个还没有明确的商业化规划的 Alphabet 部门。Verily 已经出现了人才流失的状况，一些人回到了谷歌的怀抱，一些人则成了竞争对手。充满怀疑的观察者也在质疑 Verily 项目的有效性和实用性，其中包括斯坦福大学疾病预防学教授。 人们需要搞明白这些玩意对于市场和公司的意义──一个新世界──或者我们正在谈论的东西将很快展现影响……后者是难以想象的。 同时 Calico 展现了登月哲学的真正精神，通过研究年龄基因和挑战衰老疾病来延长人类寿命。不同于 Alphabet 的其他分支，Calico 从集团外雇佣了医疗专家。在 2015 年 9 月，谷歌披露了这家分公司的预算达到了 24 亿美元，在必要的情况下可以增至 49 亿美元。 Calico 一直笼罩在谜团之中，它只有很少的具体产品，却更重视进行长期研究项目（Verily 在其基因研究中所言）。Calico 的网站内容简单，但仍然显示他们正与许多著名公司合作，包括 AbbVie，AncestryDNA，同时还有很多大学。 金融科技我们曾详细介绍了 Alphabet 突然切入金融科技领域，所以这里只是简要介绍一下。在投资领域，GV 和谷歌资本在科技金融的投资中占有重要地位。 保险技术是其中的焦点，Alphabet 在 2015 年中参与了至少 6 次这方面的合作与投资。这包括 Nest 与 American Family 的合作，和现在已经结束的 Google Compare，CoverHound 和 Compare.com 的伙伴关系。 今年六月，谷歌又宣布禁止在其所有网站上出现发薪日贷款的广告。在支付领域，谷歌停止了实物的 Google Wallet 卡服务，但仍在继续运营 Android Pay 平台。后者面临的竞争对手不仅是苹果，还包括 Android 授权的很多公司包括三星，他们也都在自己的手机上开发出了自己的支付平台。 结语总而言之，Alphabet 目前正在公司结构的转型期。公司的目标已经转变为面向更协调的目标和多元化的盈利。Alphabet 已经在努力使长期以来分工不甚明确的各个分支目标更加清晰。观察家和股东们都欢迎新的分支，硬件和软件团队，并满意公司专注于领导行业的目标。 当然，公司内部仍有冗余，大量 X 计划在过渡期间仍然存在。Alphabet 目前正将重心转向利润和商业潜力，同时以更为集中的方式应对竞争对手的挑战，它已选择了一个主要武器：人工智能。人工智能将是 Alphabet 在未来新市场中的杀手锏。但深耕人工智能是否能为谷歌带来成功仍有待观察。这主要取决于执行，以及人工智能的应用能否在运输，云服务，医疗和消费级硬件等各项领域中同时展现出竞争力。 ✄ ———————————————————————© 本文由机器之心编译，转载请联系微信公众号获得授权。✄ ———————————————————————","categories":[],"tags":[{"name":"Google","slug":"Google","permalink":"http://github.com/tags/Google/"}],"keywords":[]},{"title":"深入了解Android Studio和Gradle","slug":"深入了解Android Studio和Gradle","date":"2016-10-18T09:08:00.000Z","updated":"2016-10-18T10:07:30.387Z","comments":true,"path":"2016/10/18/深入了解Android Studio和Gradle/","link":"","permalink":"http://github.com/2016/10/18/深入了解Android Studio和Gradle/","excerpt":"原文链接： 重新认识AndroidStudio和Gradle，这些都是我们应该知道的 — by 井方哥 前言主要从AndroidStudio的环境安装升级，Gradle，Eclipse转AS,多渠道配置，Maven私服，Action,Option，快捷键等几个方面出发，讲一些操作技巧以及我对AndroidStudio使用的一些理解与经验。本文较全面的讲述了我们在开发中必须要了解的，比较多而全，可能不能马上记住，目的在于大家看我之后能有一个认识，在需要使用的时候知道有这么个东西。希望对你的开发工作有所帮助，不足之处，请批评指正。 一、Install&amp;Settings&amp;Update1、GradleGradle官方会不断更新，我们可以使用本地安装的方式，并配置path，我们就可以使用Terminal直接输入gradle命令执行构建任务。当然如果我们想快速更新，可以修改配置文件。 首先，修改project\\gradle\\warpper\\gradle-wapper.properties 文件，其中distributionUrl的值： distributionUrl=https\\://services.gradle.org/distributions/gradle-2.4-all.zip 这里实际是从网络下载配置的版本，会自动检测，如果不是的就会下载。 然后修改 project的build.gradle dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files&#125;","text":"原文链接： 重新认识AndroidStudio和Gradle，这些都是我们应该知道的 — by 井方哥 前言主要从AndroidStudio的环境安装升级，Gradle，Eclipse转AS,多渠道配置，Maven私服，Action,Option，快捷键等几个方面出发，讲一些操作技巧以及我对AndroidStudio使用的一些理解与经验。本文较全面的讲述了我们在开发中必须要了解的，比较多而全，可能不能马上记住，目的在于大家看我之后能有一个认识，在需要使用的时候知道有这么个东西。希望对你的开发工作有所帮助，不足之处，请批评指正。 一、Install&amp;Settings&amp;Update1、GradleGradle官方会不断更新，我们可以使用本地安装的方式，并配置path，我们就可以使用Terminal直接输入gradle命令执行构建任务。当然如果我们想快速更新，可以修改配置文件。 首先，修改project\\gradle\\warpper\\gradle-wapper.properties 文件，其中distributionUrl的值： distributionUrl=https\\://services.gradle.org/distributions/gradle-2.4-all.zip 这里实际是从网络下载配置的版本，会自动检测，如果不是的就会下载。 然后修改 project的build.gradle dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files&#125; 注意：这两个配置是一一对应的，比如gradle-2.4-all对应的就是1.3.0。后者的意思是这个project配置的gradle构建版本为1.3.0，前者的意思是这个project使用的gradle的版本为2.4。我们会发现，如果我们修改前者，如果本地没有安装这个版本的gradle，会自动从gradle官网下载。但是，如果我们修改后者，它会自动从jcenter()仓库下载一些plugin之类的。 2、AS具体的安装和更新网上有许多的详细教程，我只想说以下三点。 Android Studio是Google官方基于IntelliJ IDEA开发的一款Android应用开发工具,绝逼比Eclipse强大，还没有转的尽快吧: 关闭AndroidStudio的自检升级，如果准备好升级还是自己选择想升级的版本升级靠谱； 升级前导出AndroidStudio的配置文件settings.jar(C:\\Users\\Administrator.AndroidStudio1.4\\config目录下，或者操作File|Export Setings导出)，升级后导入Settings.jar，这样就不需要重新配置，有必要的话给自己备份一个，说不定老天无缘无故挂了重装很方便。 具体细节的配置可以阅读，强烈建议直接打开AS的设置窗口，多转几次就熟悉了里边的各种配置啦。也可以参考这边文章，（1.4版本，有点旧了，差不多够用）打造你的开发工具，settings必备 二、Gradle1 简述Groovy语言Groovy是一种开发语言，是在Java平台上的，具有向Python，Ruby语言特性的灵活动态语言,Groovy保重了这些特性像Java语法一样被Java开发者使用。编译最终都会转成java的.class文件。他们的关系如下图。我想这大概也是Gradle构建系统为什么要选择Groovy的原因，它具有java语言的特性，开发者容易理解使用。一定要明白我们在build.gradle里边不是简单的配置，而是直接的逻辑开发。如果你熟练掌握Groovy，那么你在build.grale里边可以做任何你想做的事。 2 Gradle编程框架Gradle是一个工具，同时它也是一个编程框架。使用这个工具可以完成app的编译打包等工作，也可以干别的工作！Gradle里边有许多不同的插件，对应不同的工程结构、打包方式和输出文件类型。我们经常使用到的便是maven\\java\\com.android.application\\android-library等。当按照要求配置好gradle的环境后，执行gradle的task，便会自动编译打包输出你想要的.apk.aar.jar文件,如果你足够牛逼，你有gradle就够了，直接拿记事本开发； 如下图，是Gradle的工作流程。 Initializtion 初始化，执行settings.gradle(我们看到都是include”,实际里边可深了） Hook 通过API来添加，这中间我们可以自己编程干些自己想做的事情 Configuration 解析每个project的build.gradle，确定project以及内部Task关系，形成一个有向图 Execution 执行任务，输入命令 gradle xxx ,按照顺序执行该task的所有依赖以自己本身 3 关于gradle的task每个构建由一个或者多个project构成，一个project代表一个jar，一个moudle等等。一个project包含若干个task，包含多少由插件决定，而每一个task就是更细的构建任务，比如创建一个jar、生成Javadoc、上传aar到maven仓库。我们可以通过执行如下命令查看所有的task: gradle tasks --all 当然，我们也可以在AS中可以看到所有的task，双击就可以执行单个的task. 当然，我们也可以在build.gradle中写自己的task。关于详细的task介绍可以查看网络资料进行学习，推荐Gradle入门系列，基本花上半天到一天的时候简单的过一遍就有一个大概的了解。 4 Gradle环境下Android的文件结构 project-name gradle module-name build //构建生成文件 intermediates//构建打包的资源文件 assets//资源文件 exploded-aar//如果我们依赖了许多的aar或者依赖工程，最终都“copy”到了这个目录下 mainfests//合并的mainfest outputs apk//输出我们需要的.apk文件 lint-results.html//lint检查报告 reports tests//单元测试报告 ivy.xml//moudle的配置（task任务）、依赖关系等 libs //本地的依赖jar包等 src //本moudule所有的代码和资源文件 androidTest //需要android环境的单元测试，比如UI的单元测试 Test //普通的java单元测试 main //主渠道 java //java code jni //navtive jni so gen res assets AndroidManifest.xml +build.gradle //module build.gradle // for all module gradle.propeties //全局配置文件 local.properties //SDK、NDK配置 config.gradle//自定义的配置文件 settings.gradle//module管理 6 关于几个buid.gradle、gradle.propeties文件 build.gradle文件(主工程的Top-level) apply from:\"config.gradle\"//可以给所有的moudle引入一个配置文件buildscript &#123; repositories &#123; jcenter()&#125;dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter()//引入远程仓库 maven &#123; url MAVEN_URL &#125;//引入自己的私有maven仓库 &#125;&#125; gradle.properties(全局配置文件） # This can really make a significant difference if you are building a very complex project with many sub-module dependencies:#sub-moudle并行构建org.gradle.parallel=true#后台进程构建org.gradle.daemon=true#私有maven仓库地址MAVEN_URL= http://xxx.xx.1.147:8081/nexus/content/repositories/thirdparty/ build.gradle(module) apply plugin: 'com.android.application'//插件 决定是apk\\aar\\jar等android &#123;compileSdkVersion 23buildToolsVersion \"24.0.0\"// 此处注释保持默认打开，关闭后可使不严格的图片可以通过编译,但会导致apk包变大//aaptOptions.cruncherEnabled = false//aaptOptions.useNewCruncher = false packagingOptions &#123; exclude 'META-INF/NOTICE.txt'// 这里是具体的冲突文件全路径 exclude 'META-INF/LICENSE.txt'&#125;//默认配置defaultConfig &#123; applicationId \"com.locove.meet\" minSdkVersion 16 targetSdkVersion 23 versionCode 1 versionName \"1.0\" multiDexEnabled=true//65536问题&#125;sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs']//重新配置路径 &#125;&#125;buildTypes &#123; release &#123; // zipAlign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources false // 混淆 minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.releaseConfig &#125;&#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.google.code.gson:gson:2.2.+' testCompile 'junit:junit:4.12'&#125; 7 gradle编译文件和缓存文件 gradle缓存文件：C:\\Users\\Administrator.gradle\\caches\\modules-2\\files-2.1 idea缓存文件： C:\\Users\\Administrator.AndroidStudio1.4 三、构建过程简析这里参考了QQ音乐技术团队Android构建过程分析 下图是文章末尾的一张构建流程图： 解压合并资源： 主要是assets目录，res目录，Androidmainfest.xml目录。其中合并的时候会涉及到优先级的问题，详情请查看该篇文章。 AAPT(Android Asset Packaging Tool)打包 R.java文件 资源ID app.ap 压缩包 对png图进行优化等 源码编译： 生成.class字节码，在这里可以进行删除无用类，字节码优化，重命名（包名），还有一点就是代码混淆。 生成dex、打包签名、zipalign","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"Hiker Guide","slug":"Hiker中文使用教程","date":"2016-10-17T07:47:20.000Z","updated":"2017-01-13T10:54:10.160Z","comments":true,"path":"2016/10/17/Hiker中文使用教程/","link":"","permalink":"http://github.com/2016/10/17/Hiker中文使用教程/","excerpt":"Hiker An attractive, exquisite theme for Hexo. named “Hiker”, short for “HikerNews”. ☞ Live Preview | Hiker 中文版使用文档","text":"Hiker An attractive, exquisite theme for Hexo. named “Hiker”, short for “HikerNews”. ☞ Live Preview | Hiker 中文版使用文档 Installation Get it from GitHub $ git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker Enable Modify theme setting in _config.yml to hiker. # Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: hiker Update $ cd themes/Hiker$ git pull ConfigurationTheme configuration example# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Header Menumenu: Home: / Archives: archives Categories: categories Tags: tags About: aboutrss: /atom.xmlsince: 2013# Set default keywords (Use a comma to separate)keywords: \"\"# Put your favicon.ico into `hexo-site/themes/hiker/source/` directory.avatar: css/images/mylogo.jpg# Homepage# eg. home_background_image: css/images/home-bg.jpghome_background_image: css/images/home-bg.jpghome_logo_image: enable: false border: false url: css/images/homelogo.jpg# AboutPage backgroundabout_big_image: css/images/pose.jpg# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- category- tag- tagcloud- archive- recent_posts# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname:# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default# Article theme color# Available value:# random | orange | blue | red | green | blacktheme_color: random# display widgets at the bottom of index pages (pagination == 2)index_widgets:# - category# - tagcloud# - archive# widget behaviorarchive_type: 'monthly'show_count: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/google_site_verification:baidu_site_verification:qihu_site_verification:# Miscellaneousgoogle_analytics:gauges_analytics:twitter:google_plus:fb_admins:fb_app_id: menu - Navigation menu rss - RSS link excerpt_link - “Read More” link at the bottom of excerpted articles. false to hide the link. fancybox - Enable Fancybox sidebar - Sidebar style. You can choose left, right, bottom or false. widgets - Widgets displaying in sidebar google_analytics - Google Analytics ID favicon - Favicon path twitter - Twiiter ID google_plus - Google+ ID FeaturesHomepage backgroundYou could place the image file in YOUR_HEXO_SITE\\themes\\hiker\\source\\css\\images directory. and modify home_background_image in hiker/_config.yml. # Homepage# eg. home_background_image: css/images/home-bg.jpghome_background_image: css/images/home-bg.jpg If you DON’T want any image as your homepage background, just set home_background_image empty in hiker/_config.yml, then you have an default homepage with random decorative pattern. Code Highlight ThemeHiker use Tomorrow Theme for your code block. We have six options in total: default, normal, night, night blue, night bright, night eighties Above preview picture is default theme. the image below show other five Highlight themes. Modify highlight_theme in hiker/_config.yml. # Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default Blog Theme ColorHiker provide five color themes for your blog. orange blue red green black You can modify theme_color in hiker/_config.yml. # Article theme color# Available value:# random | orange | blue | red | green | blacktheme_color: random Night modeJust for article reading. In article page, you can click the logo image of header to switch to Night mode. FancyboxHiker uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. ![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting.Hiker provides 5 built-in widgets: category tag tagcloud archives recent_posts All of them are enabled by default. You can edit them in widget setting. Comment supportHiker has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to hiker hiker/_config.yml: # comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname: Browser support ContributingAll kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. Looking forward to your pull request.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/tags/Hexo/"}],"keywords":[]},{"title":"Chrome自带的开发者工具进阶技巧","slug":"Chrome自带的开发者工具进阶技巧","date":"2016-09-28T10:50:00.000Z","updated":"2016-10-18T06:45:25.373Z","comments":true,"path":"2016/09/28/Chrome自带的开发者工具进阶技巧/","link":"","permalink":"http://github.com/2016/09/28/Chrome自带的开发者工具进阶技巧/","excerpt":"原文链接： Things you probably didn’t know you could do with Chrome’s Developer Console作者：Swagat Kumar Swain Chrome自带开发者工具。它的功能十分丰富，包括元素、网络、安全等等。今天我们主要介绍JavaScript控制台部分的功能。 我最早写代码的时候，也就是在JS控制台里输出一些服务器返回的内容，或者一些变量的值。但是后来通过一些深入的学习和了解，我发现Chrome的JS控制台原来还有这么多神奇的功能。 在这里我总结了一些特别有用的功能。要是你凑巧在Chrome里浏览这篇文章的话，现在就打开开发者工具，跟着随手试试吧！ 1.选取DOM元素要是你用过两天jQuery的话，一定对 $(&#39;.className&#39;) 或者 $(&#39;#id&#39;) 这种选择器不会陌生。上面这俩货分别是jQuery的类选择器和ID选择器。 在一个网页没有引入jQuery的情况下，在控制台里你也可以通过类似的方法选取DOM. 不管 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;) 还是 $(&#39;.class #id&#39;) 等类似的选择器，都相当于原生JS的document.querySelector(&#39;&#39;) 方法。这个方法返回第一个匹配选择规则的DOM元素。 在Chrome的控制台里，你可以通过 $$(&#39;tagName&#39;) 或者 $$(&#39;.className&#39;) 记得是两个\\$\\$符号来选择所有匹配规则的DOM元素。选择返回的结果是一个数组，可以通过数组的方法来访问其中的单个元素。 举个栗子 $$(&#39;className&#39;) 会返回给你所有包含 className 类属性的元素，之后你可以通过 $$(&#39;className&#39;)[0] 和$$(&#39;className&#39;)[1] 来访问其中的某个元素。","text":"原文链接： Things you probably didn’t know you could do with Chrome’s Developer Console作者：Swagat Kumar Swain Chrome自带开发者工具。它的功能十分丰富，包括元素、网络、安全等等。今天我们主要介绍JavaScript控制台部分的功能。 我最早写代码的时候，也就是在JS控制台里输出一些服务器返回的内容，或者一些变量的值。但是后来通过一些深入的学习和了解，我发现Chrome的JS控制台原来还有这么多神奇的功能。 在这里我总结了一些特别有用的功能。要是你凑巧在Chrome里浏览这篇文章的话，现在就打开开发者工具，跟着随手试试吧！ 1.选取DOM元素要是你用过两天jQuery的话，一定对 $(&#39;.className&#39;) 或者 $(&#39;#id&#39;) 这种选择器不会陌生。上面这俩货分别是jQuery的类选择器和ID选择器。 在一个网页没有引入jQuery的情况下，在控制台里你也可以通过类似的方法选取DOM. 不管 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;) 还是 $(&#39;.class #id&#39;) 等类似的选择器，都相当于原生JS的document.querySelector(&#39;&#39;) 方法。这个方法返回第一个匹配选择规则的DOM元素。 在Chrome的控制台里，你可以通过 $$(&#39;tagName&#39;) 或者 $$(&#39;.className&#39;) 记得是两个\\$\\$符号来选择所有匹配规则的DOM元素。选择返回的结果是一个数组，可以通过数组的方法来访问其中的单个元素。 举个栗子 $$(&#39;className&#39;) 会返回给你所有包含 className 类属性的元素，之后你可以通过 $$(&#39;className&#39;)[0] 和$$(&#39;className&#39;)[1] 来访问其中的某个元素。 2.一秒钟让Chrome变成所见即所得的编辑器你可能经常会困惑你到底能不能直接在浏览器里更改网页的文本内容。答案是肯定的，你可以只通过一行简单的指令把Chrome变成所见即所得的编辑器，直接在网页上随心所欲地删改文字。 你不需要再傻傻地右键审查元素，编辑源代码了。打开Chrome的开发者控制台，输入 document.body.contentEditable=true 然后奇迹就发生啦，你竟然可以在网页里直接编辑，或者随意拖动图片的位置了！要是你正在用Chrome现在就可以试试！ 3.获取某个DOM元素绑定的事件在调试的时候，你肯定需要知道某个元素上面绑定了什么触发事件。Chrome的开发者控制台可以让你很轻松地找到它们。 getEventListeners($(&#39;selector&#39;)) 方法以数组对象的格式返回某个元素绑定的所有事件。你可以在控制台里展开对象查看详细的内容。 要是你需要选择其中的某个事件，可以通过下面的方法来访问： getEventListeners($('selector')).eventName[0].listener 这里的 eventName 表示某种事件类型，例如： getEventListeners($('#firstName')).click[0].listener 上面的例子会返回ID为 firstName 元素绑定的click事件。 4.监测事件当你需要监视某个DOM触发的事件时，也可以用到控制台。例如下面这些方法： monitorEvents($(&#39;selector&#39;)) 会监测某个元素上绑定的所有事件，一旦该元素的某个事件被触发就会在控制台里显示出来。 monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;) 可以监听某个元素上绑定的具体事件。第二个参数代表事件类型的名称。例如 monitorEvents($(&#39;#firstName&#39;),&#39;click&#39;) 只监测ID为firstName的元素上的click事件。 monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….]) 同上。可以同时检测具体指定的多个事件类型。 unmonitorEvents($(&#39;selector&#39;)) 用来停止对某个元素的事件监测。 5.用计时器来获取某段代码块的运行时间通过 console.time(‘labelName’) 来设定一个计时器，其中的 labelName 是计时器的名称。通过console.timeEnd(‘labelName’) 方法来停止并输出某个计时器的时间。例如： console.time('myTime'); //设定计时器开始 - myTimeconsole.timeEnd('mytime'); //结束并输出计时时长 - myTime//输出: myTime:123.00 ms 再举一个通过计时器来计算代码块运行时间的例子： console.time('myTime'); //开始计时 - myTimefor(var i=0; i &lt; 100000; i++)&#123; 2+4+5;&#125;console.timeEnd('mytime'); //结束并输出计时时长 - myTime//输出 - myTime:12345.00 ms 6.以表格的形式输出数组假设我们有一个像下面这样的数组： var myArray=[&#123;a:1,b:2,c:3&#125;,&#123;a:1,b:2,c:3,d:4&#125;,&#123;k:11,f:22&#125;,&#123;a:1,b:2,c:3&#125;] 要是你直接在控制台里输入数组的名称，Chrome会以文本的形式返回一个数组对象。但你完全可以通过console.table(variableName) 方法来以表格的形式输出每个元素的值。例如下图： 7.通过控制台方法来检查元素你可以直接在控制台里输入下面的方法来检查元素 inspect($(&#39;selector&#39;)) 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。例如 inspect($(&#39;#firstName&#39;)) 选择所有ID是 firstName 的元素，inspect($(&#39;a&#39;)[3]) 检查并返回页面上第四个 p元素。\\$0, \\$1, \\$2等等会返回你最近检查过的几个元素，例如 \\$0 会返回你最后检查的元素，\\$1 则返回倒数第二个。 8.列出某个元素的所有属性你也可以通过控制台列出某个元素的所有属性： dir($(‘selector’)) 会返回匹配选择器的DOM元素的所有属性，你可以展开输出的结果查看详细内容。 9.获取最后计算结果的值你可以把控制台当作计算器使用。当你在Chrome控制台里进行计算时，可以通过$_来获取最后的计算结果值，还是直接看例子吧： 2+3+49 //- The Answer of the SUM is 9$_9 // Gives the last Result$_ * $_81 // As the last Result was 9Math.sqrt($_)9 // As the last Result was 81$_9 // As the Last Result is 9 10.清空控制台输出当你需要这么做的时候，只需要输入 clear() 然后回车就好啦！ Chrome开发者工具的强大远远超出你的想象！这只是其中的一部分小技巧而已，希望能够帮到你！","categories":[],"tags":[{"name":"WebDevelopment","slug":"WebDevelopment","permalink":"http://github.com/tags/WebDevelopment/"}],"keywords":[]},{"title":"【Android】抽象布局 — include、merge 、ViewStub","slug":"【Android】抽象布局 — include、merge 、ViewStub","date":"2016-09-19T03:47:00.000Z","updated":"2017-06-15T10:21:19.994Z","comments":true,"path":"2016/09/19/【Android】抽象布局 — include、merge 、ViewStub/","link":"","permalink":"http://github.com/2016/09/19/【Android】抽象布局 — include、merge 、ViewStub/","excerpt":"在布局优化中，Androi的官方提到了这三种布局&lt;include/&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 一、布局重用&lt;include/&gt;&lt;include /&gt;标签能够重用布局文件，简单的使用如下： &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=\"@color/app_bg\" android:gravity=\"center_horizontal\"&gt; &lt;include layout=\"@layout/titlebar\"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=\"wrap_content\" android:text=\"@string/hello\" android:padding=\"10dp\" /&gt; &lt;/LinearLayout&gt;","text":"在布局优化中，Androi的官方提到了这三种布局&lt;include/&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 一、布局重用&lt;include/&gt;&lt;include /&gt;标签能够重用布局文件，简单的使用如下： &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=\"@color/app_bg\" android:gravity=\"center_horizontal\"&gt; &lt;include layout=\"@layout/titlebar\"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=\"wrap_content\" android:text=\"@string/hello\" android:padding=\"10dp\" /&gt; &lt;/LinearLayout&gt; 1) &lt;include /&gt;标签必须使用单独的layout属性。 2) 可以使用其他属性。&lt;include /&gt;标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖。 3) 在include标签中所有的android:layout_*都是有效的，前提是必须要写layout_width和layout_height两个属性。 4) 布局中可以包含两个相同的include标签，引用时可以使用如下方法解决 比如这个布局文件：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"android:layout_width=\"fill_parent\"android:layout_height=\"fill_parent\"android:scrollbars=\"vertical\" &gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:focusable=\"true\" android:focusableInTouchMode=\"true\" android:orientation=\"vertical\" android:padding=\"10dip\" &gt; &lt;include android:id=\"@+id/discovered_servers\" layout=\"@layout/discovered_servers_element\" /&gt; &lt;include android:id=\"@+id/bookmarks\" layout=\"@layout/bookmarks_element\" /&gt; //注意以下这个include和上面的include &lt;include android:id=\"@+id/bookmarks_favourite\" layout=\"@layout/bookmarks_element\" /&gt; &lt;include android:id=\"@+id/new_conn\" layout=\"@layout/new_conn_element\" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 这里我们include了两次res/layout/bookmarks_element.xml，这个子布局内容如下： &lt;!-- res/layout/bookmarks_element.xml 布局 --&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;TextView android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:paddingBottom=\"10dip\" android:paddingTop=\"10dip\" android:text=\"@string/bookmarks\" android:textAppearance=\"?android:attr/textAppearanceLarge\" /&gt; &lt;LinearLayout android:id=\"@+id/bookmarks_list\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:padding=\"10dip\" /&gt;&lt;/merge&gt; 如果向下面这样调用是错的， LinearLayout fav_bookmarks = findViewById(R.id.bookmarks_list); // WRONG!!!! 正确的方法是这样： View bookmarks_container_2 = findViewById(R.id.bookmarks_favourite); bookmarks_container_2.findViewById(R.id.bookmarks_list); 二、减少视图层级&lt;merge/&gt;&lt;merge /&gt;标签用于减少View树的层次来优化Android的布局。先来用个例子演示一下： 首先主需要一个配置文件activity_main.xml &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"merge标签使用\" /&gt;&lt;/RelativeLayout&gt; 再来一个最简单的Activity，文件名MainActivity.java package com.example.merge;import android.app.Activity;import android.os.Bundle;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 按着上面的代码创建工程，运行后使用“DDMS -&gt; Dump View Hierarchy for UI Automator”工具，截图如下: merge 使用前： 最下面两层RelativeLayout与TextView就是 activity_main.xml 布局中的内容，上面的FrameLayout是Activity setContentView添加的顶层视图。下面使用merge标签可以查看下区别。 布局文件 activity_main.xml 修改内容如下： &lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"merge标签使用\" /&gt;&lt;/merge&gt; 使用“DDMS -&gt; Dump View Hierarchy for UI Automator”工具，截图如下: merge 使用后 可以看到，FrameLayout下面直接就是TextView，与之前的相比少了一层 RelativeLayout 而实现的效果相同。 那么，什么情况考虑使用&lt;merge /&gt;标签？ 一种是向上面的例子一样，子视图不需要指定任何针对父视图的布局属性，例子中TextView仅仅需要直接添加到父视图上用于显示就行。 另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题，官方文档 Android Layout Tricks #3: Optimize by merging 中的例子演示的就是这种情况。 &lt;merge /&gt;标签有什么限制没？ &lt;merge /&gt;只能作为XML布局的根标签使用。 当 Inflate 以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。 三、需要时使用&lt;ViewStub /&gt;限于篇幅，这里只大概总结一下ViewStub的使用方法，详细介绍和使用写到后面的文章中。 &lt;ViewStub /&gt;标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用&lt;ViewStub /&gt;标签，以减少内存使用量，加快渲染速度。&lt;ViewStub /&gt;是一个不可见的，大小为0的View。&lt;ViewStub /&gt;标签使用如下： &lt;ViewStub android:id=\"@+id/stub_import\" android:inflatedId=\"@+id/panel_import\" android:layout=\"@layout/progress_overlay\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" /&gt; 当你想加载布局时，可以使用下面其中一种方法： ((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); or View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了。 注：ViewStub 目前有个缺陷就是还不支持 &lt;merge /&gt; 标签。 更多&lt;ViewStub /&gt;标签介绍可以参考官网教程《Android Layout Tricks #3: Optimize with stubs》 【参考资料】： 1、Android抽象布局 — include、merge 、ViewStub2、Tech Stuff: Android &lt;include/&gt; layout pitfalls3、Android 性能优化 四 布局优化merge标签的使用4、Android之merge布局5、 Android实战技巧：ViewStub的应用","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】设计模式：深入理解单例模式","slug":"【Java】设计模式：深入理解单例模式","date":"2016-09-08T06:18:20.000Z","updated":"2017-05-23T06:52:09.721Z","comments":true,"path":"2016/09/08/【Java】设计模式：深入理解单例模式/","link":"","permalink":"http://github.com/2016/09/08/【Java】设计模式：深入理解单例模式/","excerpt":"什么是设计模式？简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，今天就先来分享下最常用的单例模式。 引言对于单例模式，有工作经验的人基本上都使用过。面试的时候提到设计模式基本上都会提到单例模式，但是很多人对单例模式也是一知半解，当然也包括我哈哈哈=_=。所以我们有必要深入理解一下所谓的「单例模式」。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式结构图： 使用单例的优点： 单例类只有一个实例 共享资源，全局使用 节省创建时间，提高性能","text":"什么是设计模式？简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，今天就先来分享下最常用的单例模式。 引言对于单例模式，有工作经验的人基本上都使用过。面试的时候提到设计模式基本上都会提到单例模式，但是很多人对单例模式也是一知半解，当然也包括我哈哈哈=_=。所以我们有必要深入理解一下所谓的「单例模式」。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式结构图： 使用单例的优点： 单例类只有一个实例 共享资源，全局使用 节省创建时间，提高性能 它的七种写法单例模式有多种写法各有利弊，现在我们来看看各种模式写法。 1、饿汉式public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 这种方式和名字很贴切，饥不择食，在类装载的时候就创建，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。 Java Runtime就是使用这种方式，它的源代码如下： public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don't let anyone else instantiate this class */ private Runtime() &#123;&#125; //以下代码省略&#125; 总结：「饿汉式」是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用「饿汉式」的单例模式就是不合适的，这时候就需要用到「懒汉式」的方式去按需延迟加载单例。 2、懒汉式（非线程安全）public class Singleton &#123; private static Singleton instance; private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。在多线程访问的时候，很可能会造成多次实例化，就不再是单例了。 「懒汉式」与「饿汉式」的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用「懒汉式」就是非常不错的选择。 3、懒汉式（线程安全）public class Singleton &#123; private static Singleton instance; private Singleton ()&#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这两种「懒汉式」单例，名字起的也很贴切，一直等到对象实例化的时候才会创建，确实够懒，不用鞭子抽就不知道走了，典型的时间换空间，每次获取实例的时候才会判断，看是否需要创建，浪费判断时间，如果一直没有被使用，就不会被创建，节省空间。 因为这种方式在getInstance()方法上加了同步锁，所以在多线程情况下会造成线程阻塞，把大量的线程锁在外面，只有一个线程执行完毕才会执行下一个线程。 Android中的 InputMethodManager 使用了这种方式，我们看看它的源码： public final class InputMethodManager &#123; static InputMethodManager sInstance; /** * Retrieve the global InputMethodManager instance, creating it if it * doesn't already exist. * @hide */ public static InputMethodManager getInstance() &#123; synchronized (InputMethodManager.class) &#123; if (sInstance == null) &#123; IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE); IInputMethodManager service = IInputMethodManager.Stub.asInterface(b); sInstance = new InputMethodManager(service, Looper.getMainLooper()); &#125; return sInstance; &#125; &#125;&#125; 4、双重校验锁（DCL）上面的方法「懒汉式（线程安全）」毫无疑问存在性能的问题 — 如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！ 让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码，就成了下面的双重校验锁（Double Check Lock）： public class Singleton &#123; /** * 注意此处使用的关键字 volatile， * 被volatile修饰的变量的值，将不会被本地线程缓存， * 所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。 */ private volatile static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 这种写法在getSingleton()方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字，不了解volatile关键字的可以查看 Java多线程（三）volatile域 和 java中volatile关键字的含义 两篇文章，可以看到双重检查模式是正确使用volatile关键字的场景之一。 「双重校验锁」：既可以达到线程安全，也可以使性能不受很大的影响，换句话说在保证线程安全的前提下，既节省空间也节省了时间，集合了「饿汉式」和两种「懒汉式」的优点，取其精华，去其槽粕。 对于volatile关键字，还是存在很多争议的。由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。 还有就是在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java1.5及以上的版本。 5、静态内部类另外，在很多情况下JVM已经为我们提供了同步控制，比如： 在static {...}区块中初始化的数据 访问final字段时 因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现「懒汉式」的延迟加载和线程安全。 public class Singleton &#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static final Singleton sInstance = new Singleton(); &#125; &#125; 第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。 然而这还不是最简单的方式，《Effective Java》中作者推荐了一种更简洁方便的使用方式，就是使用「枚举」。 6、枚举《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 public enum Singleton &#123; //定义一个枚举的元素，它就是 Singleton 的一个实例 INSTANCE; public void doSomeThing() &#123; // do something... &#125; &#125; 使用方法如下： public static void main(String args[]) &#123; Singleton singleton = Singleton.instance; singleton.doSomeThing();&#125; 枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。 7. 使用容器public class SingletonManager &#123; private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;(); private Singleton() &#123; &#125; public static void registerService(String key, Objectinstance) &#123; if (!objMap.containsKey(key) ) &#123; objMap.put(key, instance) ; &#125; &#125; public static ObjectgetService(String key) &#123; return objMap.get(key) ; &#125;&#125; 这种事用SingletonManager 将多种单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。 总结对于以上七种单例，分别是「饿汉式」、「懒汉式(非线程安全)」、「懒汉式(线程安全)」、「双重校验锁」、「静态内部类」、「枚举」和「容器类管理」。很多时候取决人个人的喜好，虽然双重检查有一定的弊端和问题，但我就是钟爱双重检查，觉得这种方式可读性高、安全、优雅（个人观点）。所以代码里常常默写这样的单例，写的时候真感觉自己是个伟大的建筑师哈哈哈哈（真不要脸(￢_￢)（逃。 【参考资料】：1、Android设计模式之单例模式2、十分钟认识单例模式的多种姿势3、设计模式（二）单例模式的七种写法4、深入Java单例模式5、java中volatile关键字的含义","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"},{"name":"Design Pattern","slug":"Java/Design-Pattern","permalink":"http://github.com/categories/Java/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://github.com/tags/Design-Pattern/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"},{"name":"Design Pattern","slug":"Java/Design-Pattern","permalink":"http://github.com/categories/Java/Design-Pattern/"}]},{"title":"【Go语言】基本类型排序和 slice 排序","slug":"【Go语言】基本类型排序和 slice 排序","date":"2016-09-07T08:36:00.000Z","updated":"2016-10-18T04:56:08.221Z","comments":true,"path":"2016/09/07/【Go语言】基本类型排序和 slice 排序/","link":"","permalink":"http://github.com/2016/09/07/【Go语言】基本类型排序和 slice 排序/","excerpt":"Go 是通过 sort 包提供排序和搜索，因为 Go 暂时不支持泛型（将来也不好说支不支持），所以，Go 的 sort 和 search 使用起来跟类型是有关的，或是需要像 c 一样写比较函数等，稍微显得也不是很方便。 引言 Go 的排序思路和 C 和 C++ 有些差别。 C 默认是对数组进行排序， C++ 是对一个序列进行排序， Go 则更宽泛一些，待排序的可以是任何对象， 虽然很多情况下是一个 slice (分片， 类似于数组)，或是包含 slice 的一个对象。 排序(接口)的三个要素： 待排序元素个数 n ； 第 i 和第 j 个元素的比较函数 cmp ； 第 i 和 第 j 个元素的交换 swap ； 乍一看条件 3 是多余的， c 和 c++ 都不提供 swap 。 c 的 qsort 的用法： qsort(data, n, sizeof(int), cmp_int); data 是起始地址， n 是元素个数， sizeof(int) 是每个元素的大小， cmp_int 是一个比较两个 int 的函数。 c++ 的 sort 的用法： sort(data, data+n, cmp_int); data 是第一个元素的位置， data+n 是最后一个元素的下一个位置， cmp_int 是比较函数。","text":"Go 是通过 sort 包提供排序和搜索，因为 Go 暂时不支持泛型（将来也不好说支不支持），所以，Go 的 sort 和 search 使用起来跟类型是有关的，或是需要像 c 一样写比较函数等，稍微显得也不是很方便。 引言 Go 的排序思路和 C 和 C++ 有些差别。 C 默认是对数组进行排序， C++ 是对一个序列进行排序， Go 则更宽泛一些，待排序的可以是任何对象， 虽然很多情况下是一个 slice (分片， 类似于数组)，或是包含 slice 的一个对象。 排序(接口)的三个要素： 待排序元素个数 n ； 第 i 和第 j 个元素的比较函数 cmp ； 第 i 和 第 j 个元素的交换 swap ； 乍一看条件 3 是多余的， c 和 c++ 都不提供 swap 。 c 的 qsort 的用法： qsort(data, n, sizeof(int), cmp_int); data 是起始地址， n 是元素个数， sizeof(int) 是每个元素的大小， cmp_int 是一个比较两个 int 的函数。 c++ 的 sort 的用法： sort(data, data+n, cmp_int); data 是第一个元素的位置， data+n 是最后一个元素的下一个位置， cmp_int 是比较函数。 基本类型排序(int、float64 和 string)1、升序排序对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。 package main import ( \"fmt\" \"sort\") func main() &#123; intList := [] int &#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; float8List := [] float64 &#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125; stringList := [] string &#123;\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"&#125; sort.Ints(intList) sort.Float64s(float8List) sort.Strings(stringList) fmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList) &#125; 2、降序排序int 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。 go 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写： package main import ( \"fmt\" \"sort\") func main() &#123; intList := [] int &#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; float8List := [] float64 &#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125; stringList := [] string &#123;\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"&#125; sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(float8List))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList)&#125; 3、深入理解排序sort 包中有一个 sort.Interface 接口，该接口有三个方法 Len() 、 Less(i,j) 和 Swap(i,j) 。 通用排序函数 sort.Sort 可以排序任何实现了 sort.Inferface 接口的对象(变量)。对于 [] int 、[] float64 和 [] string 除了使用特殊指定的函数外，还可以使用改装过的类型 IntSclice 、 Float64Slice 和 StringSlice ， 然后直接调用它们对应的 Sort() 方法；因为这三种类型也实现了 sort.Interface 接口， 所以可以通过 sort.Reverse 来转换这三种类型的 Interface.Less 方法来实现逆向排序， 这就是前面最后一个排序的使用。 下面使用了一个自定义(用户定义)的 Reverse 结构体， 而不是 sort.Reverse 函数， 来实现逆向排序。 package main import ( \"fmt\" \"sort\") // 自定义的 Reverse 类型type Reverse struct &#123; sort.Interface // 这样，Reverse可以接纳任何实现了sort.Interface的对象&#125; // Reverse 只是将其中的 Inferface.Less 的顺序对调了一下func (r Reverse) Less(i, j int) bool &#123; return r.Interface.Less(j, i)&#125; func main() &#123; ints := []int&#123;5, 2, 6, 3, 1, 4&#125; sort.Ints(ints) // 特殊排序函数，升序 fmt.Println(\"after sort by Ints:\\t\", ints) doubles := []float64&#123;2.3, 3.2, 6.7, 10.9, 5.4, 1.8&#125; sort.Float64s(doubles) fmt.Println(\"after sort by Float64s:\\t\", doubles) // [1.8 2.3 3.2 5.4 6.7 10.9] strings := []string&#123;\"hello\", \"good\", \"students\", \"morning\", \"people\", \"world\"&#125; sort.Strings(strings) fmt.Println(\"after sort by Strings:\\t\", strings) // [good hello mornig people students world] ipos := sort.SearchInts(ints, -1) // int 搜索 fmt.Printf(\"pos of 5 is %d th\\n\", ipos) dpos := sort.SearchFloat64s(doubles, 20.1) // float64 搜索 fmt.Printf(\"pos of 5.0 is %d th\\n\", dpos) fmt.Printf(\"doubles is asc ? %v\\n\", sort.Float64sAreSorted(doubles)) doubles = []float64&#123;3.5, 4.2, 8.9, 100.98, 20.14, 79.32&#125; // sort.Sort(sort.Float64Slice(doubles)) // float64 排序方法 2 // fmt.Println(\"after sort by Sort:\\t\", doubles) // [3.5 4.2 8.9 20.14 79.32 100.98] (sort.Float64Slice(doubles)).Sort() // float64 排序方法 3 fmt.Println(\"after sort by Sort:\\t\", doubles) // [3.5 4.2 8.9 20.14 79.32 100.98] sort.Sort(Reverse&#123;sort.Float64Slice(doubles)&#125;) // float64 逆序排序 fmt.Println(\"after sort by Reversed Sort:\\t\", doubles) // [100.98 79.32 20.14 8.9 4.2 3.5]&#125; sort.Ints / sort.Float64s / sort.Strings 分别来对整型/浮点型/字符串型slice进行排序。然后是有个测试是否有序的函数。还有分别对应的 search 函数，不过，发现搜索函数只能定位到如果存在的话的位置，不存在的话，位置是不对的。 关于一般的数组排序，程序中显示了，有 3 种方法！目前提供的三种类型 int，float64 和 string 呈现对称的，也就是你有的，对应的我也有。关于翻转排序或是逆向排序，就是用个翻转结构体，重写 Less() 函数即可。上面的 Reverse 是个通用的结构体。 上面说了那么多， 只是对基本类型进行排序， 该到说说 struct 结构体类型的排序的时候了， 实际中这个用得到的会更多。 结构体类型的排序结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。 1、模拟 IntSlice 排序package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; // 按照 Person.Age 从大到小排序type PersonSlice [] Person func (a PersonSlice) Len() int &#123; // 重写 Len() 方法 return len(a)&#125;func (a PersonSlice) Swap(i, j int)&#123; // 重写 Swap() 方法 a[i], a[j] = a[j], a[i]&#125;func (a PersonSlice) Less(i, j int) bool &#123; // 重写 Less() 方法， 从大到小排序 return a[j].Age &lt; a[i].Age&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonSlice(people)) // 按照 Age 的逆序排序 fmt.Println(people) sort.Sort(sort.Reverse(PersonSlice(people))) // 按照 Age 的升序排序 fmt.Println(people) &#125; 这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。 这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。 2、封装成 Wrapperpackage main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; type PersonWrapper struct &#123; //注意此处 people [] Person by func(p, q * Person) bool&#125; func (pw PersonWrapper) Len() int &#123; // 重写 Len() 方法 return len(pw.people)&#125;func (pw PersonWrapper) Swap(i, j int)&#123; // 重写 Swap() 方法 pw.people[i], pw.people[j] = pw.people[j], pw.people[i]&#125;func (pw PersonWrapper) Less(i, j int) bool &#123; // 重写 Less() 方法 return pw.by(&amp;pw.people[i], &amp;pw.people[j])&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return q.Age &lt; p.Age // Age 递减排序 &#125;&#125;) fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return p.Name &lt; q.Name // Name 递增排序 &#125;&#125;) fmt.Println(people) &#125; 这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。 3、进一步封装感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下： package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; type PersonWrapper struct &#123; people [] Person by func(p, q * Person) bool&#125; type SortBy func(p, q *Person) bool func (pw PersonWrapper) Len() int &#123; // 重写 Len() 方法 return len(pw.people)&#125;func (pw PersonWrapper) Swap(i, j int)&#123; // 重写 Swap() 方法 pw.people[i], pw.people[j] = pw.people[j], pw.people[i]&#125;func (pw PersonWrapper) Less(i, j int) bool &#123; // 重写 Less() 方法 return pw.by(&amp;pw.people[i], &amp;pw.people[j])&#125; // 封装成 SortPerson 方法func SortPerson(people [] Person, by SortBy)&#123; sort.Sort(PersonWrapper&#123;people, by&#125;)&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return q.Age &lt; p.Age // Age 递减排序 &#125;&#125;) fmt.Println(people) SortPerson(people, func (p, q *Person) bool &#123; return p.Name &lt; q.Name // Name 递增排序 &#125;) fmt.Println(people) &#125; 在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。 4、另一种思路package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Weight int&#125; type PersonSlice []Person func (s PersonSlice) Len() int &#123; return len(s) &#125;func (s PersonSlice) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i] &#125; type ByName struct&#123; PersonSlice &#125; // 将 PersonSlice 包装起来到 ByName 中 func (s ByName) Less(i, j int) bool &#123; return s.PersonSlice[i].Name &lt; s.PersonSlice[j].Name &#125; // 将 Less 绑定到 ByName 上 type ByWeight struct&#123; PersonSlice &#125; // 将 PersonSlice 包装起来到 ByWeight 中func (s ByWeight) Less(i, j int) bool &#123; return s.PersonSlice[i].Weight &lt; s.PersonSlice[j].Weight &#125; // 将 Less 绑定到 ByWeight 上 func main() &#123; s := []Person&#123; &#123;\"apple\", 12&#125;, &#123;\"pear\", 20&#125;, &#123;\"banana\", 50&#125;, &#123;\"orange\", 87&#125;, &#123;\"hello\", 34&#125;, &#123;\"world\", 43&#125;, &#125; sort.Sort(ByWeight&#123;s&#125;) fmt.Println(\"People by weight:\") printPeople(s) sort.Sort(ByName&#123;s&#125;) fmt.Println(\"\\nPeople by name:\") printPeople(s) &#125; func printPeople(s []Person) &#123; for _, o := range s &#123; fmt.Printf(\"%-8s (%v)\\n\", o.Name, o.Weight) &#125;&#125; 对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。 参考资料：1、go语言的排序和搜索","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/tags/Go语言/"}],"keywords":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}]},{"title":"【Android 】TextView 局部文字变色","slug":"【Android 】TextView 局部文字变色","date":"2016-09-07T07:02:45.000Z","updated":"2016-12-22T05:06:00.866Z","comments":true,"path":"2016/09/07/【Android 】TextView 局部文字变色/","link":"","permalink":"http://github.com/2016/09/07/【Android 】TextView 局部文字变色/","excerpt":"TextView 对于富文本效果的实现支持不支持呢？比如“局部文字颜色的变动”，“局部字体的变动” 一、需求效果 二、解决方案针对这类问题，Android提供了 SpannableStringBuilder，方便我们自定义富文本的实现。 textView = (TextView) findViewById(R.id.textview);SpannableStringBuilder builder = new SpannableStringBuilder(textView.getText().toString());//ForegroundColorSpan 为文字前景色，BackgroundColorSpan为文字背景色ForegroundColorSpan redSpan = new ForegroundColorSpan(Color.RED);ForegroundColorSpan whiteSpan = new ForegroundColorSpan(Color.WHITE);ForegroundColorSpan blueSpan = new ForegroundColorSpan(Color.BLUE);ForegroundColorSpan greenSpan = new ForegroundColorSpan(Color.GREEN);ForegroundColorSpan yellowSpan = new ForegroundColorSpan(Color.YELLOW); builder.setSpan(redSpan, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(whiteSpan, 1, 2, Spannable.SPAN_INCLUSIVE_INCLUSIVE);builder.setSpan(blueSpan, 2, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(greenSpan, 3, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(yellowSpan, 4,5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);textView.setText(builder);","text":"TextView 对于富文本效果的实现支持不支持呢？比如“局部文字颜色的变动”，“局部字体的变动” 一、需求效果 二、解决方案针对这类问题，Android提供了 SpannableStringBuilder，方便我们自定义富文本的实现。 textView = (TextView) findViewById(R.id.textview);SpannableStringBuilder builder = new SpannableStringBuilder(textView.getText().toString());//ForegroundColorSpan 为文字前景色，BackgroundColorSpan为文字背景色ForegroundColorSpan redSpan = new ForegroundColorSpan(Color.RED);ForegroundColorSpan whiteSpan = new ForegroundColorSpan(Color.WHITE);ForegroundColorSpan blueSpan = new ForegroundColorSpan(Color.BLUE);ForegroundColorSpan greenSpan = new ForegroundColorSpan(Color.GREEN);ForegroundColorSpan yellowSpan = new ForegroundColorSpan(Color.YELLOW); builder.setSpan(redSpan, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(whiteSpan, 1, 2, Spannable.SPAN_INCLUSIVE_INCLUSIVE);builder.setSpan(blueSpan, 2, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(greenSpan, 3, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(yellowSpan, 4,5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);textView.setText(builder); 除了上述代码中使用的 ForegroundColorSpan 和 BackgroundColorSpan之外，还有以下这些Span可以使用： AbsoluteSizeSpan(int size) —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小 RelativeSizeSpan(float proportion) —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out) ScaleXSpan(float proportion) —— 缩放字体，与上面的类似，默认为1,设置后就是原来的乘以proportion，大于1时放大(zoon in)，小于时缩小(zoom out) BackgroundColorSpan(int color) —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int) ForegroundColorSpan(int color) —— 前景着色，也就是字的着色，参数与背景着色一致 TypefaceSpan(String family) —— 字体，参数是字体的名字比如“sans”, “sans-serif”等 StyleSpan(Typeface style) —— 字体风格，比如粗体，斜体，参数是android.graphics.Typeface里面定义的常量，如Typeface.BOLD，Typeface.ITALIC等等。StrikethroughSpan—-如果设置了此风格，会有一条线从中间穿过所有的字，就像被划掉一样 三、动手试试比如实现下图中TextView的样式 然后代码如下： TextView tv = (TextView)view.findViewById(R.id.toast_text);String str1 = \"提交成功！\\n积分\";String str2 = \"+\" + score1;String str3 = \"！审核通过后再\";String str4 = \"+\" + score2;SpannableStringBuilder builder = new SpannableStringBuilder(str1 + str2 + str3 + str4 + \"！\");builder.setSpan(new ForegroundColorSpan(Color.parseColor(\"#ffffa200\")), str1.length(), (str1 + str2).length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);builder.setSpan(new ForegroundColorSpan(Color.parseColor(\"#ffffa200\")), (str1 + str2 + str3).length(), (str1 + str2 + str3 + str4).length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);tv.setText(builder); 参考资料：1、Android-修改TextView中部分文字的颜色2、Android TextView 设置部分文字背景色和文字颜色","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】获取View的截图","slug":"【Android】获取View的截图","date":"2016-08-30T02:32:00.000Z","updated":"2016-10-18T04:55:33.990Z","comments":true,"path":"2016/08/30/【Android】获取View的截图/","link":"","permalink":"http://github.com/2016/08/30/【Android】获取View的截图/","excerpt":"引言 在Android应用开发过程中，可能会遇到需要对整个界面或者某一部分进行截图的需求。 Android中对View的截图也有以下两种方式，值得注意的是两个方法都不适用于SurfaceView： 使用DrawingCache如果使用DrawingCache，则对要截图的View有一个要求：View本身已经显示在界面上。如果View没有添加到界面上或者没有显示（绘制）过，则buildDrawingCache会失败。这种方式比较适合对应用界面或者某一部分的截图。步骤很简单： view.setDrawingCacheEnabled(true); view.buildDrawingCache(); //启用DrawingCache并创建位图 //创建一个DrawingCache的拷贝，因为DrawingCache得到的位图在禁用后会被回收 Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache()); view.setDrawingCacheEnabled(false); //禁用DrawingCahce否则会影响性能","text":"引言 在Android应用开发过程中，可能会遇到需要对整个界面或者某一部分进行截图的需求。 Android中对View的截图也有以下两种方式，值得注意的是两个方法都不适用于SurfaceView： 使用DrawingCache如果使用DrawingCache，则对要截图的View有一个要求：View本身已经显示在界面上。如果View没有添加到界面上或者没有显示（绘制）过，则buildDrawingCache会失败。这种方式比较适合对应用界面或者某一部分的截图。步骤很简单： view.setDrawingCacheEnabled(true); view.buildDrawingCache(); //启用DrawingCache并创建位图 //创建一个DrawingCache的拷贝，因为DrawingCache得到的位图在禁用后会被回收 Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache()); view.setDrawingCacheEnabled(false); //禁用DrawingCahce否则会影响性能 完整的截图功能函数如下： /** * 获取一个 View 的缓存视图 * * @param view * @return */ private Bitmap getCacheBitmapFromView(View view) &#123; final boolean drawingCacheEnabled = true; view.setDrawingCacheEnabled(drawingCacheEnabled); view.buildDrawingCache(drawingCacheEnabled); final Bitmap drawingCache = view.getDrawingCache(); Bitmap bitmap; if (drawingCache != null) &#123; bitmap = Bitmap.createBitmap(drawingCache); view.setDrawingCacheEnabled(false); &#125; else &#123; bitmap = null; &#125; return bitmap; &#125; 直接调用View.draw如果需要截图的View并没有添加到界面上，可能是通过java代码创建的或者inflate创建的，此时调用DrawingCache方法是获取不到位图的。因为View在添加到容器中之前并没有得到实际的大小（如果LayoutWidth是MatchParent，它还没有Parent…），所以首先需要指定View的大小： private void layoutView(View v, int width, int height) &#123; // validate view.width and view.height v.layout(0, 0, width, height); int measuredWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int measuredHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY); // validate view.measurewidth and view.measureheight v.measure(measuredWidth, measuredHeight); v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());i &#125; 使用方式如下： int viewWidth = webView.getMeasuredWidth(); int viewHeight = webView.getMeasuredHeight(); if (viewWidth &gt; 0 &amp;&amp; viewHeight &gt; 0) &#123; b = Bitmap.createBitmap(viewWidth, viewHeight, Config.ARGB_8888); Canvas cvs = new Canvas(b); webView.draw(cvs); &#125; 对于WebView的截图有一点特殊，网页内容并不能在布局完成后立即渲染出来，大概需要300ms的时间（对于不同性能的设备、网页复杂程度和Webkit版本可能不同）。 如果创建后台的WebView需要截图的话，应该在创建时就对其进行布局操作，这样加载完成后大部分就已经渲染完毕了（除非有异步的js处理）。 【参考资料】： 1、Android应用截图两种方法2、知乎和简书的夜间模式实现套路","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】如何加速 AndroidStudio 的编译效率","slug":"【Android】如何加速 AndroidStudio 的编译效率","date":"2016-08-26T07:20:00.000Z","updated":"2016-10-18T04:55:51.767Z","comments":true,"path":"2016/08/26/【Android】如何加速 AndroidStudio 的编译效率/","link":"","permalink":"http://github.com/2016/08/26/【Android】如何加速 AndroidStudio 的编译效率/","excerpt":"引言如果你之前用eclipse开发过Android app的话，转到android studio的第一反应也许就是：”编译速度有点慢“，表现的最明显的一点就是，每次android studio使用gradle编译，即便是更改的代码量很少，也会按照预先设置的task的顺序，依次走完编译的各项流程。这时候如果电脑CPU配置不高的时候，就会超级卡界面，更别说改代码了。 所以 这点就让人很痛苦， 然而问题总还是要被解决的，作者曾经亲眼看到过使用android studio仅仅用了2.5秒就编译完毕(在代码更改很少的情况下)。 现在把如何优化gradle编译速度的方法记录在此，希望可以 帮助到广大的同行们。 准备工作首先，保证项目使用的Gradle是最新的，我这里用的是2.10版本。因为Gradle 2.4之后在编译效率上面有了一个非常大的提高，看下图官方的速度对比。","text":"引言如果你之前用eclipse开发过Android app的话，转到android studio的第一反应也许就是：”编译速度有点慢“，表现的最明显的一点就是，每次android studio使用gradle编译，即便是更改的代码量很少，也会按照预先设置的task的顺序，依次走完编译的各项流程。这时候如果电脑CPU配置不高的时候，就会超级卡界面，更别说改代码了。 所以 这点就让人很痛苦， 然而问题总还是要被解决的，作者曾经亲眼看到过使用android studio仅仅用了2.5秒就编译完毕(在代码更改很少的情况下)。 现在把如何优化gradle编译速度的方法记录在此，希望可以 帮助到广大的同行们。 准备工作首先，保证项目使用的Gradle是最新的，我这里用的是2.10版本。因为Gradle 2.4之后在编译效率上面有了一个非常大的提高，看下图官方的速度对比。 然后先在你的项目build.gradle文件内(不是app里面的gradle文件), 就是这里： 添加一个task， 代码如下: task wrapper(type: Wrapper) &#123; gradleVersion = '2.10' //你安装的最新Gradle版本&#125; 加进去以后是这个样子： // Top-level build file where you can add configuration options common to all sub-projects/modules.// Running 'gradle wrapper' will generate gradlew - Getting gradle wrapper working and using it will save you a lot of pain.task wrapper(type: Wrapper) &#123; gradleVersion = '2.10'&#125;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.0' &#125; ext &#123; compileSdkVersion = 21 buildToolsVersion =\"23.0.2\" minSdkVersion = 18 targetSdkVersion = 21 sourceCompatibility = JavaVersion.VERSION_1_7 targetCompatibility = JavaVersion.VERSION_1_7 &#125;&#125; 然后打开terminal, 输入./gradlew wrapper，Windows 下输入： gradlew wrapper 然后gradle就会自动去下载2.4版本,这也是官方推荐的手动设置gradle的方法 守护进程，并行编译通过以上步骤,我们设置好了 Android Studio 使用最新的 Gradle 版本，下一步就是正式开启优化之路了。我们需要将gradle作为守护进程一直在后台运行，这样当我们需要编译的时候，gradle就会立即跑过来然后 吭哧吭哧的开始干活。除了设置gradle一直开启之外，当你的工作空间存在多个project的时候，还需要设置gradle对这些projects并行编译，而不是单线的依次进行编译操作。 说了那么多， 那么怎么设置守护进程和并行编译呢？其实非常简单，gradle本身已经有了相关的配置选项，在你电脑的GRADLE_HOME这个环境变量所指的那个文件夹内，有一个.gradle/gradle.properties文件。 在这个文件里，放入下面两句话就OK了: org.gradle.daemon=trueorg.gradle.parallel=true 有一个地方需要注意的是,android studio 本身在编译的时候,已经是使用守护进程中的gradle了,那么这里加上了org.gradle.daemon=true就是保证了你在使用命令行编译apk的时候也是使用的守护进程. 你也可以将上述的配置文件放到你project中的根目录下,以绝对确保在任何情况下,这个project都会使用守护进程进行编译.不过有些特殊的情况下也许你应该注意守护进程的使用,具体的细节参考官网When should I not use the Gradle Daemon? 在使用并行编译的时候必须要注意的就是,你的各个project之间不要有依赖关系,否则的话,很可能因为你的Project A 依赖Project B, 而Project B还没有编译出来的时候,gradle就开始编译Project A 了.最终 导致编译失败.具体可以参考官网Multi-Project Building and Testing。 还有一些额外的gradle设置也许会引起你的兴趣,例如你想增加堆内存的空间,或者指定使用哪个jvm虚拟机等等(代码如下) org.gradle.jvmargs=-Xmx768morg.gradle.java.home=/path/to/jvm 如果你想详细的了解gradle的配置,请猛戳官网 Gradle User Guide。 【参考资料】：1、Boosting the performance for Gradle in your Android projects2、译文：优化android studio编译效率的方法3、How/when to generate Gradle wrapper files?","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Go】为什么 Go 语言把类型声明放在后面？","slug":"【Go】为什么 Go 语言把类型声明放在后面？","date":"2016-08-18T08:36:00.000Z","updated":"2016-10-18T04:56:04.881Z","comments":true,"path":"2016/08/18/【Go】为什么 Go 语言把类型声明放在后面？/","link":"","permalink":"http://github.com/2016/08/18/【Go】为什么 Go 语言把类型声明放在后面？/","excerpt":"关于类型，官网上有一段仔细地介绍了一下函数指针的部分，现在的设计比起 C 的语法，清晰很多。 也就是说，类型放在后面是为了更加清晰易懂。Rob Pike 曾经在 Go 官方博客解释过这个问题（查看原文：Go’s Declaration Syntax），简略翻译如下（水平有限翻译的不对的地方见谅）： 引言Go语言新人常常会很疑惑为什么这门语言的声明语法（declaration syntax）会和传统的C家族语言不同。在这篇博文里，我们会进行一个比较，并做出解答。 C 的语法首先，先看看 C 的语法。C 采用了一种聪明而不同寻常的声明语法。声明变量时，只需写出一个带有目标变量名的表达式，然后在表达式里指明该表达式本身的类型即可。比如： int x; 上面的代码声明了 x 变量，并且其类型为 int——即，表达式 x 为 int 类型。一般而言，为了指明新变量的类型，我们得写出一个表达式，其中含有我们要声明的变量，这个表达式运算的结果值属于某种基本类型，我们把这种基本类型写到表达式的左边。所以，下述声明： int *p;int a[3];","text":"关于类型，官网上有一段仔细地介绍了一下函数指针的部分，现在的设计比起 C 的语法，清晰很多。 也就是说，类型放在后面是为了更加清晰易懂。Rob Pike 曾经在 Go 官方博客解释过这个问题（查看原文：Go’s Declaration Syntax），简略翻译如下（水平有限翻译的不对的地方见谅）： 引言Go语言新人常常会很疑惑为什么这门语言的声明语法（declaration syntax）会和传统的C家族语言不同。在这篇博文里，我们会进行一个比较，并做出解答。 C 的语法首先，先看看 C 的语法。C 采用了一种聪明而不同寻常的声明语法。声明变量时，只需写出一个带有目标变量名的表达式，然后在表达式里指明该表达式本身的类型即可。比如： int x; 上面的代码声明了 x 变量，并且其类型为 int——即，表达式 x 为 int 类型。一般而言，为了指明新变量的类型，我们得写出一个表达式，其中含有我们要声明的变量，这个表达式运算的结果值属于某种基本类型，我们把这种基本类型写到表达式的左边。所以，下述声明： int *p;int a[3]; 指明了 p 是一个int类型的指针，因为 *p的类型为int。而 a 是一个 int 数组，因为 a[3]的类型为 int（别管这里出现的索引值，它只是用于指明数组的长度）。 我们接下来看看函数声明的情况。C 的函数声明中关于参数的类型是写在括号外的，像下面这样： int main(argc, argv) int argc; char *argv[];&#123; /* ... */ &#125; 如前所述，我们可以看到 main 之所以是函数，是因为表达式 main(argc, argv) 返回 int。在现代记法中我们是这么写的： int main(int argc, char *argv[]) &#123; /* ... */ &#125; 尽管看起来有些不同，但是基本的结构是一样的。 总的来看，当类型比较简单时，C的语法显得很聪明。但是遗憾的是一旦类型开始复杂，C的这套语法很快就能让人迷糊了。著名的例子如函数指针，我们得按下面这样来写： int (*fp)(int a, int b); 在这儿，fp 之所以是一个指针是因为如果你写出 (*fp)(a, b) 这样的表达式将会调用一个函数，其返回 int 类型的值。如果当 fp 的某个参数本身又是一个函数，情况会怎样呢？ int (*fp)(int (*ff)(int x, int y), int b) 这读起来可就点难了。 当然了，我们声明函数时是可以不写明参数的名称的，因此 main 函数可以声明为： int main(int, char *[]) 回想一下，之前 argv 是下面这样的 char *argv[] 你有没有发现你是从声明的「中间」去掉变量名而后构造出其变量类型的？尽管这不是很明显，但你声明某个 char *[]类型的变量的时候，竟然需要把名字插入到变量类型的中间。我们再来看看，如果我们不命名 fp 的参数会怎样： int (*fp)(int (*)(int, int), int) 这东西难懂的地方可不仅仅是要记得参数名原本是放这中间的 int (*)(int, int) 它更让人混淆的地方还在于甚至可能都搞不清这竟然是个函数指针声明。我们接着看看，如果返回值也是个函数指针类型又会怎么样 int (*(*fp)(int (*)(int, int), int))(int, int) 这已经很难看出是关于 fp 的声明了。 你自己还可以构建出比这更复杂的例子，但这已经足以解释 C 的声明语法引入的某些复杂性了。还有一点需要指出，由于类型语法和声明语法是一样的，要解析中间带有类型的表达式可能会有些难度。这也就是为什么，C 在做类型转换的时候总是要把类型用括号括起来的原因，像这样 (int)M_PI Go 的语法非C家族的语言通常在声明时使用一种不同的类型语法。一般是名字先出现，然后常常跟着一个冒号。按照这样来写，我们上面所举的例子就会变成下面这样： x: intp: pointer to inta: array[3] of int 这样的声明即便有些冗长，当至少是清晰的——你只需从左向右读就行。Go 语言所采用的方案就是以此为基础的，但为了追求简洁性，Go 语言丢掉了冒号并去掉了部分关键词，成了下面这样： x intp *inta [3]int 在 [3]int 和表达式中 a的用法没有直接的对应关系（我们在下一节会回过头来探讨指针的问题）。至此，你获得了代码清晰性方面的提升，但付出的代价是语法上需要区别对待。 下面我们来考虑函数的问题。虽然在 Go 语言里，main 函数实际上没有参数，但是我们先誊抄一下之前的 main 函数的声明： func main(argc int, argv *[]byte) int 粗略一看和 C 没什么不同，不过自左向右读的话还不错。main 函数接受一个 int 和一个指针并返回一个int。如果此时把参数名去掉，它还是很清楚——因为参数名总在类型的前面，所以不会引起混淆。 func main(int, *[]byte) int 这种自左向右风格的声明的一个价值在于，当类型变得更复杂时，它依然相对简单。下面是一个函数变量的声明（相当于 C 语言里的函数指针） f func(func(int,int) int, int) int 或者当它返回一个函数时： f func(func(int,int) int, int) func(int, int) int 上面的声明读起来还是很清晰，自左向右，而且究竟哪一个变量名是当前被声明的也容易看懂——因为变量名永远在首位。类型语法和表达式语法带来的差别使得在 Go 语言里调用闭包也变得更简单： sum := func(a, b int) int &#123; return a+b &#125; (3, 4) 指针指针有些例外。注意在数组 (array )和切片 (slice) 中，Go 的类型语法把方括号放在了类型的左边，但是在表达式语法中却又把方括号放到了右边： var a []intx = a[1] 类似的，Go 的指针沿用了 C 的 * 记法，但是我们写的时候也是声明时 在变量名右边，但在表达式中却又得把 放到左左边： var p *intx = *p 不能写成下面这样 var p *intx = p* 因为后缀的 * 可能会和乘法运算混淆，也许我们可以改用 Pascal 的 ^ 标记，像这样 var p ^intx = p^ 我们也许还真的应该把 * 像上面这样改成 ^ （当然这么一改 xor 运算的符号也得改），因为在类型和表达式中的 * 前缀确实把好些事儿都搞得有点复杂，举个例子来说，虽然我们可以像下面这样写 []int(\"hi\") 但在转换时，如果类型是以 * 开头的，就得加上括号： (*int)(nil) 如果有一天我们愿意放弃用 *作为指针语法的话，那么上面的括号就可以省略了。 可见，Go 的指针语法是和 C 相似的。但这种相似也意味着我们无法彻底避免在文法中有时为了避免类型和表达式的歧义需要补充括号的情况。 总而言之，尽管存在不足，但我们相信 Go 的类型语法要比 C 的容易懂。特别是当类型比较复杂时。 我擦，这边文章被知识库收录而且上了首页，吓死宝宝了。赶紧改个Bug压压惊=_=","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/tags/Go语言/"}],"keywords":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}]},{"title":"【Machine Learning】机器学习：简明入门指南","slug":"【Machine Learning】机器学习：简明入门指南","date":"2016-08-14T09:32:55.000Z","updated":"2016-10-18T04:57:03.883Z","comments":true,"path":"2016/08/14/【Machine Learning】机器学习：简明入门指南/","link":"","permalink":"http://github.com/2016/08/14/【Machine Learning】机器学习：简明入门指南/","excerpt":"本文是一篇转载自伯乐在线的译文，英文原文是这里：Machine Learning is Fun! — by Adam Geitgey 在听到人们谈论机器学习的时候，你是不是对它的涵义只有几个模糊的认识呢？你是不是已经厌倦了在和同事交谈时只能一直点头？让我们改变一下吧！ 本指南的读者对象是所有对机器学习有求知欲但却不知道如何开头的朋友。我猜很多人已经读过了“机器学习” ——维基百科词条，倍感挫折，以为没人能给出一个高层次的解释。本文就是你们想要的东西。 本文目标在于平易近人，这意味着文中有大量的概括。但是谁在乎这些呢？只要能让读者对于ML更感兴趣，任务也就完成了。","text":"本文是一篇转载自伯乐在线的译文，英文原文是这里：Machine Learning is Fun! — by Adam Geitgey 在听到人们谈论机器学习的时候，你是不是对它的涵义只有几个模糊的认识呢？你是不是已经厌倦了在和同事交谈时只能一直点头？让我们改变一下吧！ 本指南的读者对象是所有对机器学习有求知欲但却不知道如何开头的朋友。我猜很多人已经读过了“机器学习” ——维基百科词条，倍感挫折，以为没人能给出一个高层次的解释。本文就是你们想要的东西。 本文目标在于平易近人，这意味着文中有大量的概括。但是谁在乎这些呢？只要能让读者对于ML更感兴趣，任务也就完成了。 何为机器学习？机器学习这个概念认为，对于待解问题，你无需编写任何专门的程序代码，遗传算法（generic algorithms）能够在数据集上为你得出有趣的答案。对于遗传算法，不用编码，而是将数据输入，它将在数据之上建立起它自己的逻辑。 举个例子，有一类算法称为分类算法，它可以将数据划分为不同的组别。一个用来识别手写数字的分类算法，不用修改一行代码，就可以用来将电子邮件分为垃圾邮件和普通邮件。算法没变，但是输入的训练数据变了，因此它得出了不同的分类逻辑。 机器学习算法是个黑盒，可以重用来解决很多不同的分类问题。 “机器学习”是一个涵盖性术语，覆盖了大量类似的遗传算法。 两类机器学习算法你可以认为机器学习算法分为两大类：监督式学习（Supervised Learning）和非监督式学习（Unsupervised Learning）。两者区别很简单，但却非常重要。 监督式学习假设你是一名房产经纪，生意越做越大，因此你雇了一批实习生来帮你。但是问题来了——你可以看一眼房子就知道它到底值多少钱，实习生没有经验，不知道如何估价。 为了帮助你的实习生（也许是为了解放你自己去度个假），你决定写个小软件，可以根据房屋大小、地段以及类似房屋的成交价等因素来评估你所在地区房屋的价值。 你把3个月来城里每笔房屋交易都写了下来，每一单你都记录了一长串的细节——卧室数量、房屋大小、地段等等。但最重要的是，你写下了最终的成交价： 这是我们的“训练数据”: 我们要利用这些训练数据来编写一个程序来估算该地区其他房屋的价值： 这就称为监督式学习。你已经知道每一栋房屋的售价，换句话说，你知道问题的答案，并可以反向找出解题的逻辑。 为了编写软件，你将包含每一套房产的训练数据输入你的机器学习算法。算法尝试找出应该使用何种运算来得出价格数字。 这就像是算术练习题，算式中的运算符号都被擦去了：天哪！一个阴险的学生将老师答案上的算术符号全擦去了。 看了这些题，你能明白这些测验里面是什么样的数学问题吗？你知道，你应该对算式左边的数字“做些什么”以得出算式右边的答案。 在监督式学习中，你是让计算机为你算出数字间的关系。而一旦你知道了解决这类特定问题所需要的数学方法后，你就可以解答同类的其它问题了。 非监督式学习让我们回到开头那个房地产经纪的例子。要是你不知道每栋房子的售价怎么办？即使你所知道的只是房屋的大小、位置等信息，你也可以搞出很酷的花样。这就是所谓的非监督式学习。 即使你不是想去预测未知的数据（如价格），你也可以运用机器学习完成一些有意思的事。 这就有点像有人给你一张纸，上面列出了很多数字，然后对你说:“我不知道这些数字有什么意义，也许你能从中找出规律或是能将它们分类，或是其它什么-祝你好运！” 你该怎么处理这些数据呢？首先，你可以用个算法自动地从数据中划分出不同的细分市场。也许你会发现大学附近的买房者喜欢户型小但卧室多的房子，而郊区的买房者偏好三卧室的大户型。这些信息可以直接帮助你的营销。 你还可以作件很酷的事，自动找出房价的离群数据，即与其它数据迥异的值。这些鹤立鸡群的房产也许是高楼大厦，而你可以将最优秀的推销员集中在这些地区，因为他们的佣金更高。 本文余下部分我们主要讨论监督式学习，但这并不是因为非监督式学习用处不大或是索然无味。实际上，随着算法改良，不用将数据和正确答案联系在一起，因此非监督式学习正变得越来越重要。 老学究请看:还有很多其它种类的机器学习算法。但初学时这样理解不错了。 太酷了，但是评估房价真能被看作“学习”吗？作为人类的一员，你的大脑可以应付绝大多数情况，并且没有任何明确指令也能够学习如何处理这些情况。如果你做房产经纪时间很长，你对于房产的合适定价、它的最佳营销方式以及哪些客户会感兴趣等等都会有一种本能般的“感觉”。强人工智能（Strong AI）研究的目标就是要能够用计算机复制这种能力。 但是目前的机器学习算法还没有那么好——它们只能专注于非常特定的、有限的问题。也许在这种情况下，“学习”更贴切的定义是“在少量范例数据的基础上找出一个等式来解决特定的问题”。 不幸的是，“机器在少量范例数据的基础上找出一个等式来解决特定的问题”这个名字太烂了。所以最后我们用“机器学习”取而代之。 当然，要是你是在50年之后来读这篇文章，那时我们已经得出了强人工智能算法，而本文看起来就像个老古董。未来的人类，你还是别读了，叫你的机器仆人给你做份三明治吧。 让我们写代码吧!前面例子中评估房价的程序，你打算怎么写呢？往下看之前，先思考一下吧。 如果你对机器学习一无所知，很有可能你会尝试写出一些基本规则来评估房价，如下： def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # In my area, the average house costs $200 per sqft price_per_sqft = 200 if neighborhood == \"hipsterton\": # but some areas cost a bit more price_per_sqft = 400 elif neighborhood == \"skid row\": # and some areas cost less price_per_sqft = 100 # start with a base price estimate based on how big the place is price = price_per_sqft * sqft # now adjust our estimate based on the number of bedrooms if num_of_bedrooms == 0: # Studio apartments are cheap price = price — 20000 else: # places with more bedrooms are usually # more valuable price = price + (num_of_bedrooms * 1000) return price 假如你像这样瞎忙几个小时，也许会取得一点成效，但是你的程序永不会完美，而且当价格变化时很难维护。 如果能让计算机找出实现上述函数功能的办法，这样岂不更好？只要返回的房价数字正确，谁会在乎函数具体干了些什么呢？ def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = &lt;computer, plz do some math for me&gt; return price 考虑这个问题的一种角度是将房价看做一碗美味的汤，而汤中成分就是卧室数、面积和地段。如果你能算出每种成分对最终的价格有多大影响，也许就能得到各种成分混合起来形成最终价格的具体比例。 这样可以将你最初的程序（全是疯狂的if else语句）简化成类似如下的样子： def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # a little pinch of this price += num_of_bedrooms * .841231951398213 # and a big pinch of that price += sqft * 1231.1231231 # maybe a handful of this price += neighborhood * 2.3242341421 # and finally, just a little extra salt for good measure price += 201.23432095 return price 请注意那些用粗体标注的神奇数字——.841231951398213, 1231.1231231,2.3242341421, 和201.23432095。它们称为权重。如果我们能找出对每栋房子都适用的完美权重，我们的函数就能预测所有的房价！ 找出最佳权重的一种笨办法如下所示： 步骤1：首先，将每个权重都设为1.0： def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # a little pinch of this price += num_of_bedrooms * 1.0 # and a big pinch of that price += sqft * 1.0 # maybe a handful of this price += neighborhood * 1.0 # and finally, just a little extra salt for good measure price += 1.0 return price 步骤2：将每栋房产带入你的函数运算，检验估算值与正确价格的偏离程度： 运用你的程序预测房屋价格。 例如：上表中第一套房产实际成交价为25万美元，你的函数估价为17.8万，这一套房产你就差了7.2万。 再将你的数据集中的每套房产估价偏离值平方后求和。假设数据集中有500套房产交易，估价偏离值平方求和总计为86,123,373美元。这就反映了你的函数现在的“正确”程度。 现在，将总计值除以500，得到每套房产的估价偏离平均值。将这个平均误差值称为你函数的代价。 如果你能调整权重使得这个代价变为0，你的函数就完美了。它意味着，根据输入的数据，你的程序对每一笔房产交易的估价都是分毫不差。而这就是我们的目标——尝试不同的权重值以使代价尽可能的低。 步骤3：不断重复步骤2，尝试所有可能的权重值组合。哪一个组合使得代价最接近于0，它就是你要使用的，你只要找到了这样的组合，问题就得到了解决! 思想扰动时间这太简单了，对吧？想一想刚才你做了些什么。你取得了一些数据，将它们输入至三个通用的简单步骤中，最后你得到了一个可以对你所在区域的房屋进行估价的函数。房价网，要当心咯！但是下面的事实可能会扰乱你的思想： 1.过去40年来，很多领域（如语言学/翻译学）的研究表明，这种通用的“搅动数据汤”（我编造的词）式的学习算法已经胜过了需要利用真人明确规则的方法。机器学习的“笨”办法最终打败了人类专家。 2.你最后写出的函数真是笨，它甚至不知道什么是“面积”和“卧室数”。它知道的只是搅动，改变数字来得到正确的答案。 3.很可能你都不知道为何一组特殊的权重值能起效。所以你只是写出了一个你实际上并不理解却能证明的函数。 4.试想一下，你的程序里没有类似“面积”和“卧室数”这样的参数，而是接受了一组数字。假设每个数字代表了你车顶安装的摄像头捕捉的画面中的一个像素，再将预测的输出不称为“价格”而是叫做“方向盘转动度数”，这样你就得到了一个程序可以自动操纵你的汽车了！ 太疯狂了，对吧？ 步骤3中的“尝试每个数字”怎么回事？好吧，当然你不可能尝试所有可能的权重值来找到效果最好的组合。那可真要花很长时间，因为要尝试的数字可能无穷无尽。 为避免这种情况，数学家们找到了很多聪明的办法（比如Gradient descent算法）来快速找到优秀的权重值，而不需要尝试过多。下面是其中一种： 首先，写出一个简单的等式表示前述步骤2，这是你的代价函数： 接着，让我们将这同一个等式用机器学习的数学术语（现在你可以忽略它们）进行重写： θ表示当前的权重值。 J(θ) 意为“当前权重值对应的代价”。 这个等式表示我们的估价程序在当前权重值下偏离程度的大小。如果将所有赋给卧室数和面积的可能权重值以图形形式显示，我们会得到类似下图的图表： 代价函数的图形像一支碗。纵轴表示代价。 图中蓝色的最低点就是代价最低的地方——即我们的程序偏离最小。最高点意味着偏离最大。所以，如果我们能找到一组权重值带领我们到达图中的最低点，我们就找到了答案！ 因此，我们只需要调整权重值使我们在图上能向着最低点“走下坡路”。如果对于权重的细小调节能一直使我们保持向最低点移动，那么最终我们不用尝试太多权重值就能到达那里。 如果你还记得一点微积分的话，你也许记得如果你对一个函数求导，结果会告诉你函数在任一点的斜率。换句话说，对于图上给定一点，它告诉我们那条路是下坡路。我们可以利用这一点朝底部进发。 所以，如果我们对代价函数关于每一个权重求偏导，那么我们就可以从每一个权重中减去该值。这样可以让我们更加接近山底。一直这样做，最终我们将到达底部，得到权重的最优值。（读不懂？不用担心，接着往下读）。 这种找出最佳权重的办法被称为批量梯度下降，上面是对它的高度概括。如果想搞懂细节，不要害怕，继续深入下去吧。 当你使用机器学习算法库来解决实际问题，所有这些都已经为你准备好了。但明白一些具体细节总是有用的。 还有什么你随便就略过了？上面我描述的三步算法被称为多元线性回归。你估算等式是在求一条能够拟合所有房价数据点的直线。然后，你再根据房价在你的直线上可能出现的位置用这个等式来估算从未见过的房屋的价格。这个想法威力强大，可以用它来解决“实际”问题。 但是，我为你展示的这种方法可能在简单的情况下有效，它不会在所有情况下都有用。原因之一是因为房价不会一直那么简单地跟随一条连续直线。 但是，幸运的是，有很多办法来处理这种情况。对于非线性数据，很多其他类型的机器学习算法可以处理（如神经网络或有核向量机）。还有很多方法运用线性回归更灵活，想到了用更复杂的线条来拟合。在所有的情况中，寻找最优权重值这一基本思路依然适用。 还有，我忽略了过拟合的概念。很容易碰上这样一组权重值，它们对于你原始数据集中的房价都能完美预测，但对于原始数据集之外的任何新房屋都预测不准。这种情况的解决之道也有不少（如正则化以及使用交叉验证数据集）。学会如何处理这一问题对于顺利应用机器学习至关重要。 换言之，基本概念非常简单，要想运用机器学习得到有用的结果还需要一些技巧和经验。但是，这是每个开发者都能学会的技巧。 机器学习法力无边吗？一旦你开始明白机器学习技术很容易应用于解决貌似很困难的问题（如手写识别），你心中会有一种感觉，只要有足够的数据，你就能够用机器学习解决任何问题。只需要将数据输入进去，就能看到计算机变戏法一样找出拟合数据的等式。 但是很重要的一点你要记住，机器学习只能对用你占有的数据实际可解的问题才适用。 例如，如果你建立了一个模型来根据每套房屋内盆栽数量来预测房价，它就永远不会成功。房屋内盆栽数量和房价之间没有任何的关系。所以，无论它怎么去尝试，计算机也推导不出两者之间的关系。 你只能对实际存在的关系建模。 怎样深入学习机器学习我认为，当前机器学习的最大问题是它主要活跃于学术界和商业研究组织中。对于圈外想要有个大体了解而不是想成为专家的人们，简单易懂的学习资料不多。但是这一情况每一天都在改善。 吴恩达教授（Andrew Ng）在Coursera上的机器学习免费课程非常不错。我强烈建议由此入门。任何拥有计算机科学学位、还能记住一点点数学的人应该都能理解。 另外，你还可以下载安装SciKit-Learn，用它来试验成千上万的机器学习算法。它是一个python框架，对于所有的标准算法都有“黑盒”版本。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/tags/Machine-Learning/"}],"keywords":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}]},{"title":"【Machine Learning】Github上关注最多的53个深度学习项目","slug":"【Machine Learning】Github上关注最多的53个深度学习项目","date":"2016-08-12T07:22:00.000Z","updated":"2016-10-18T04:56:59.609Z","comments":true,"path":"2016/08/12/【Machine Learning】Github上关注最多的53个深度学习项目/","link":"","permalink":"http://github.com/2016/08/12/【Machine Learning】Github上关注最多的53个深度学习项目/","excerpt":"Top Deep Learning ProjectsA list of popular github projects related to deep learning (ranked by stars). Last Update: 2016.08.09","text":"Top Deep Learning ProjectsA list of popular github projects related to deep learning (ranked by stars). Last Update: 2016.08.09 Project Name Stars Description TensorFlow 29622 Computation using data flow graphs for scalable machine learning. Caffe 11799 Caffe: a fast open framework for deep learning. Neural Style 10148 Torch implementation of neural style algorithm. Deep Dream 9042 Deep Dream. Keras 7502 Deep Learning library for Python. Convnets, recurrent neural networks, and more. Runs on Theano and TensorFlow. Roc AlphaGo 7170 An independent, student-led replication of DeepMind’s 2016 Nature publication, “Mastering the game of Go with deep neural networks and tree search” (Nature 529, 484-489, 28 Jan 2016). TensorFlow Models 6671 Models built with TensorFlow Neural Doodle 6275 Turn your two-bit doodles into fine artworks with deep neural networks, generate seamless textures from photos, transfer style from one image to another, perform example-based upscaling, but wait… there’s more! (An implementation of Semantic Style Transfer.) CNTK 5957 Computational Network Toolkit (CNTK). TensorFlow Examples 5872 TensorFlow tutorials and code examples for beginners. ConvNet JS 5231 Deep Learning in Javascript. Train Convolutional Neural Networks (or ordinary ones) in your browser. Torch 5133 Torch7, Deep Learning Library. OpenFace 4855 Face recognition with deep neural networks. MXNet 4685 Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Scala, Go, Javascript and more. Nupic 4364 Numenta Platform for Intelligent Computing: a brain-inspired machine intelligence platform, and biologically accurate neural network based on cortical learning algorithms. Theano 4286 Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. It can use GPUs and perform efficient symbolic differentiation. Leaf 4281 Open Machine Intelligence Framework for Hackers. Char RNN 3820 Multi-layer Recurrent Neural Networks (LSTM, GRU, RNN) for character-level language models in Torch. Neural Talk 3694 NeuralTalk is a Python+numpy project for learning Multimodal Recurrent Neural Networks that describe images with sentences. deeplearning4j 3673 Deep Learning for Java, Scala &amp; Clojure on Hadoop, Spark. TFLearn 3368 Deep learning library featuring a higher-level API for TensorFlow. TensorFlow Playground 3352 Play with neural networks! OpenAI Gym 3020 A toolkit for developing and comparing reinforcement learning algorithms. Magenta 2914 Magenta: Music and Art Generation with Machine Intelligence Colornet 2798 Neural Network to colorize grayscale images. Synaptic 2666 architecture-free neural network library for node.js and the browser Neural Talk 2 2550 Efficient Image Captioning code in Torch, runs on GPU. Image Analogies 2540 Generate image analogies using neural matching and blending. TensorFlow Tutorials 2413 From the basics to slightly more interesting applications of Tensorflow. Lasagne 2355 Lightweight library to build and train neural networks in Theano. PyLearn2 2153 A Machine Learning library based on Theano. LISA-lab Deep Learning Tutorials 2134 Deep Learning Tutorial notes and code. See the wiki for more info. Neon 2121 Fast, scalable, easy-to-use Python based Deep Learning Framework by Nervana™. Matlab Deep Learning Toolbox 2032 Matlab/Octave toolbox for deep learning. Includes Deep Belief Nets, Stacked Autoencoders, Convolutional Neural Nets, Convolutional Autoencoders and vanilla Neural Nets. Each method has examples to get you started. Deep Learning Flappy Bird 1721 Flappy Bird hack using Deep Reinforcement Learning (Deep Q-learning). Chainer 1573 A flexible framework of neural networks for deep learning. Neural Story Teller 1514 A recurrent neural network for generating little stories about images. DIGITS 1353 Deep Learning GPU Training System. Deep Jazz 1229 Deep learning driven jazz generation using Keras &amp; Theano! Brainstorm 1143 Fast, flexible and fun neural networks. Darknet 937 Open Source Neural Networks in C Theano Tutorials 904 Bare bones introduction to machine learning from linear regression to convolutional neural networks using Theano. RNN Music Composition 904 A recurrent neural network designed to generate classical music. Blocks 866 A Theano framework for building and training neural networks. TDB 860 Interactive, node-by-node debugging and visualization for TensorFlow. Scikit Neural Net 849 Deep neural networks without the learning cliff! Classifiers and regressors compatible with scikit-learn. Veles 760 Distributed machine learning platform (Python, CUDA, OpenCL) Deep Detect 759 Deep Learning API and Server in C++11 with Python bindings and support for Caffe. TensorFlow DeepQ 759 A deep Q learning demonstration using Google Tensorflow. Caffe on Spark 724 Caffe On Spark. Nolearn 702 Abstractions around neural net libraries, most notably Lasagne. DCGAN TensorFlow 568 A tensorflow implementation of Deep Convolutional Generative Adversarial Networks MatConvNet 479 MATLAB CNN toolbox for computer vision applications. DeepCL 413 OpenCL library to train deep convolutional neural networks. 中文版 项 目 名 称 Stars 项目介绍 TensorFlow 29622 使用数据流图计算可扩展机器学习问题 Caffe 11799 Caffe是一个高效的开源深度学习框架 Neural Style 10148 Torch实现的神经网络算法 Deep Dream 9042 Deep Dream，一款图像识别工具 Keras 7502 一款Python实现的深度学习库，包括卷积神经网络、递归神经网络等。运行在Theano和TensorFlow之上。 Roc AlphaGo 7170 学生主导的一个独立项目，从新实现了 DeepMind在2016 Nature发表的内容， 《用深度神经网络和树搜索学习围棋》 (Nature 529, 484-489, 28 Jan 2016). TensorFlow Models 6671 基于TensorFlow开发的模型 Neural Doodle 6275 运用深度神经网络将涂鸦变为优雅的艺术品，从照片生成无缝纹理，转变图片风格，进行基于实例的提升，等等…还有更多！（语义风格传递的实现） CNTK 5957 计算网络工具（Computational Network Toolkit，CNTK） TensorFlow Examples 5872 初学者的TensorFlow教程和代码示例。 ConvNet JS 5231 基于Javascript的深度学习库。在浏览器中训练卷积神经网络模型（或者普通模型）。 Torch 5133 Torch7，深度学习库。 OpenFace 4855 基于深度学习网络的面部识别。 MXNet 4685 轻巧、便携、灵活的分布式/移动深度学习框架，支持Python, R, Julia, Scala, Go, Javascript等等语言。 Nupic 4364 智能计算的Numenta平台：一个脑启发式的计算智能和机器智能平台，基于皮层学习算法的生物精确神经网络模型。 Theano 4286 Theano 是一个 Python 库,用来定义、优化和模拟数学表达式计算,用于高效的解决多维数组的计算问题。 Leaf 4281 黑客的开源机器智能框架。 Char RNN 3820 多层递归神经网络的字符级别语言模型，基于Torch开发。 Neural Talk 3694 NeuralTalk是一个Python+numpy项目，用多模式递归神经网络描述图像。 deeplearning4j 3673 基于Hadoop和Spark的Java, Scala &amp; Clojure深度学习工具。 TFLearn 3368 深度学习库，包括高层次的TensorFlow接口。 TensorFlow Playground 3352 神经网络模型示例。 OpenAI Gym 3020 一种用于开发和比较强化学习算法的工具包。 Magenta 2914 Magenta: 音乐和艺术的生成与机器智能 Colornet 2798 用神经网络模型给灰度图上色。 Synaptic 2666 基于node.js和浏览器的免架构神经网络库。 Neural Talk 2 2550 Torch开发的图像简介生成代码，运行在GPU上。 Image Analogies 2540 使用神经匹配和融合生成相似图形。 TensorFlow Tutorials 2413 Tensorflow，从基础原理到应用。 Lasagne 2355 基于Theano训练和构建神经网络的轻型函数库。 PyLearn2 2153 基于Theano的机器学习库。 LISA-lab Deep Learning Tutorials 2134 深度学习教程笔记和代码。详情参见wiki页面。 Neon 2121 Nervana™开发的一款快速、可扩展、易上手的Python深度学习框架. Matlab Deep Learning Toolbox 2032 Matlab/Octave的深度学习工具箱。包括深度信念网络、自动编码机、卷积神经网络、卷积自动编码机和vanilla神经网络等。每种方法都有入门示例。 Deep Learning Flappy Bird 1721 使用深度强化学习破解Flappy Bird游戏(深度 Q-学习). Chainer 1573 一款灵活的深度学习神经网络框架。 Neural Story Teller 1514 看图讲故事的递归神经网络模型。 DIGITS 1353 深度学习GPU训练系统。 Deep Jazz 1229 基于Keras和Theano生成jazz的深度学习模型！ Brainstorm 1143 快速、灵活、有趣的神经网络。 Darknet 937 C语言版本的开源神经网络。 Theano Tutorials 904 基于Theano的机器学习入门教程，从线性回归到卷积神经网络。 RNN Music Composition 904 一款生成古典音乐的递归神经网络工具。 Blocks 866 用于构建和训练神经网络模型的Theano框架。 TDB 860 TensorFlow的交互式、节点调试和可视化的工具。 Scikit Neural Net 849 深度神经网络入门工具，类似scikit-learn的分类器和回归模型。 Veles 760 分布式机器学习平台(Python, CUDA, OpenCL) Deep Detect 759 基于C++11的深度学习接口和服务器，与Python绑定并支持Caffe。 TensorFlow DeepQ 759 基于Google Tensorflow的深度Q学习演示。 Caffe on Spark 724 基于Spark的Caffe。 Nolearn 702 神经网络库的抽象，著名的Lasagne。 DCGAN TensorFlow 568 基于tensorflow实现的深度卷积生成对抗网络。 DeepCL 413 用于训练深度卷积神经网络模型的OpenCL库。 来源：Top Deep Learning Projects","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/tags/Machine-Learning/"}],"keywords":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}]},{"title":"【Android】使用shape的同时，动态替换shape的颜色属性","slug":"【Android】使用shape的同时，动态替换shape的颜色属性","date":"2016-08-08T10:10:00.000Z","updated":"2016-10-18T04:55:58.087Z","comments":true,"path":"2016/08/08/【Android】使用shape的同时，动态替换shape的颜色属性/","link":"","permalink":"http://github.com/2016/08/08/【Android】使用shape的同时，动态替换shape的颜色属性/","excerpt":"在实现布局的时候，有些按钮形状相同，只是颜色有差异，如果使用自定义shape实现了其中一种按钮，有没有可能不需要再为其他每个颜色都写一个shape文件呢？ 一、问题比如以下这三个按钮： 为第一个灰色按钮自定义背景如下：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" android:color=\"@color/gray\"&gt; &lt;corners android:radius=\"60dip\"/&gt; &lt;stroke android:width=\"0dp\" android:color=\"@color/gray\" /&gt; &lt;solid android:color=\"@color/gray\" /&gt;&lt;/shape&gt; 然后，如果再为每个颜色的按钮都写一个shape背景也太麻烦，重用性太差。","text":"在实现布局的时候，有些按钮形状相同，只是颜色有差异，如果使用自定义shape实现了其中一种按钮，有没有可能不需要再为其他每个颜色都写一个shape文件呢？ 一、问题比如以下这三个按钮： 为第一个灰色按钮自定义背景如下：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" android:color=\"@color/gray\"&gt; &lt;corners android:radius=\"60dip\"/&gt; &lt;stroke android:width=\"0dp\" android:color=\"@color/gray\" /&gt; &lt;solid android:color=\"@color/gray\" /&gt;&lt;/shape&gt; 然后，如果再为每个颜色的按钮都写一个shape背景也太麻烦，重用性太差。 二、解决方法参考 stackoverflow 这里， 在java代码里使用 GradientDrawable 动态设置GradientDrawable myGrad = (GradientDrawable)rectangle.getBackground();myGrad.setColor(Color.BLACK); 【参考资料】1、How to change solid color from the code?","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"BAT人才体系的职位层级、薪酬、晋升标准","slug":"BAT人才体系的职位层级、薪酬、晋升标准大全","date":"2016-08-02T03:06:00.000Z","updated":"2017-02-24T02:23:10.524Z","comments":true,"path":"2016/08/02/BAT人才体系的职位层级、薪酬、晋升标准大全/","link":"","permalink":"http://github.com/2016/08/02/BAT人才体系的职位层级、薪酬、晋升标准大全/","excerpt":"互联网圈有这么一句话：百度的技术，阿里的运营，腾讯的产品。那么代表互联网三座大山的BAT，内部人才体系有什么区别呢？可以先看看这个话题百度、腾讯和阿里内部的级别和薪资待遇是什么样的？ ★ 腾讯 ★1、职级腾讯职级体系分6级，最低1级，最高6级。同时按照岗位又划分为四大通道，内部也叫“族”，比如： 产品/项目通道，简称P族技术通道，简称T族市场通道，简称M族职能通道，简称S族 以T族为例，分别为： T1：助理工程师 （一般为校招新人） T2：工程师 T3：高级工程师 3-1相当于阿里的p6+到p7（能力强可能到p7） T4：专家工程师 T5：科学家 T6：首席科学家","text":"互联网圈有这么一句话：百度的技术，阿里的运营，腾讯的产品。那么代表互联网三座大山的BAT，内部人才体系有什么区别呢？可以先看看这个话题百度、腾讯和阿里内部的级别和薪资待遇是什么样的？ ★ 腾讯 ★1、职级腾讯职级体系分6级，最低1级，最高6级。同时按照岗位又划分为四大通道，内部也叫“族”，比如： 产品/项目通道，简称P族技术通道，简称T族市场通道，简称M族职能通道，简称S族 以T族为例，分别为： T1：助理工程师 （一般为校招新人） T2：工程师 T3：高级工程师 3-1相当于阿里的p6+到p7（能力强可能到p7） T4：专家工程师 T5：科学家 T6：首席科学家 目前全腾讯貌似就一个T6。 每一级之间又分为3个子级，3-1是任命组长/副组长的必要条件，其他线也是这样。T4基本为总监级，也不排除有T3-3的总监，因为T4非常难晋级。 2、晋升腾讯的晋级还是很困难的。尤其是T2 升T3，T3升T4。非常多的人卡在2-3,3-3没办法晋级。有的小伙伴做了3、4年的2-3 也升不上去啊。 3、薪水腾讯薪资架构：12+1+1=14薪 年终奖：看部门盈利情况，一般是3个月 职级待遇基本如下(2015年左右)： 级别越高base薪酬也越高，一年根据你的performance大概能发15.3个月至18个月的工资，T3.1的base 2w+，T3以上级别的员工都会有股票期权，腾讯09以前的员工赚钱主要靠股票，从08到现在股票up了500%+，T5+的base薪酬在600w~800w/年。 4、人才人才流动的可能： 深圳：很多腾讯员工都买了房，当你的房子，妻子的工作，儿子的学校，你的朋友圈，都在一个城市的时候，换城市就有困难了。所以只能挖一些比较浅的人走。 北京：人数不少 ，不过骨干员工不多。腾讯视频的主要团队在北京的倒是不少。 成都、大连：在这些二线城市，腾讯就是当地最好的互联网公司了，提供的待遇也是非常高的，不少人都对自己的薪资比较满意，工作环境也很满意。跳槽的可能性低了很多。 人才结构： 腾讯的研发序列硕士学历的占多度，211大学，985大学占多数。大家都知道腾讯研究院解散了。去年走出来很多人，腾讯人才创业比例不高。 在腾讯最常碰到的晋升问题就是天花板。可能新人进去，学东西会很多，但业务线就这些，没有那么多坑，自然也就很难晋升高级岗。 在腾讯最悲剧的时刻就是公司有收购和整合。搜狗合并，搜搜的人哭了，京东合作，易迅的人哭了。在腾讯跳出来碰到最大的问题就是，外面的公司太不完善了。 ★ 阿里巴巴 ★1、层级阿里的职称大部分都归纳在P序列 ,你的title+工种。比如P7产品经理=产品专家。 一般到P3为助理 P4=专员 P5=资深专员 P6=高级专员（也可能是高级资深） P7=专家 P8=资深专家（架构师） P9=高级专家（资深架构师） P10=研究员 P11=高级研究员 P12=科学家 P13=首席科学家 P14=马云 同时对应P级还有一套管理层的机制在： M1=P6 主管 M2=P7 经理 M3=P8 资深经理 M4 =P9 总监 M5= P10 资深总监 M6 =P11 副总裁 M7=P12 资深副总裁 M8=P13 子公司CEO 或集团其他O M9=P14 陆兆禧（前马云） 在阿里早些时候P级普遍偏低，专员可能是P2这样，后来有了一次P级通货膨胀，出现了更多的P级。在阿里只有P6（M1）后才算是公司的中层。不同的子公司给出P级的标准不一样。 比如：B2B的普遍P级较高，但是薪资水平低于天猫子公司的同级人员。同时到达该P级员工才有享受公司RSU的机会。（低于P6的除非项目出色有RSU奖励，否则1股都拿不到） 2、晋升晋升很简单： 晋升资格：上年度KPI达3.75。 主管提名。一般KPI不达3.75主管不会提名。 晋升委员会面试。（晋升委员会组成一般是合作方业务部门大佬、HRG、该业务线大佬等。） 晋升委员会投票。 P5升P6相对容易，再往上会越来越难，一般到P7都是团队技术leader了，P6到P7非常难，从员工到管理的那一步跨出去不容易，当然有同学说P一般都是专家，M才是管理，actually，专家线/管理线有时并不是分的那么清楚的。 3、薪水• 阿里薪资结构：一般是12+1+3=16薪 • 年底的奖金为0-6个月薪资，90%人可拿到3个月 • 股票是工作满2年才能拿，第一次拿50%，4年能全部拿完 ★ 百度 ★1、层级百度的级别架构分成四条线。 技术序列 T：T3 - T11 （一般对应阿里高一级序列，如：百度T3=阿里P4，T5/T6属于部门骨干，非常抢手，人人猎中相当一部分offer人选都来自这个序列） 产品运营序列 P：p3-P11 （产品和运营岗，对应阿里高1-1.5级序列 百度p3=阿里P4-P5之间) 后勤支持部门 S ：S3-S11 (主要是公共、行政、渠道等等，晋升比较困难) 管理序列 M：M1-M5 (每一级又分为2个子级 M1A、M1B , 最低的是M1A，至少是部门二把手了，李明远是M3.2，以前的汤和松都是这个级别，李彦宏是唯一的M5，其实从M3开始就有机会加入E——star，类似于阿里的合伙人会议，属于最高战略决策层。 2、薪资月薪14.6（12+0.6+2）,其他岗位：月薪14 T5以上为关键岗位，另外有股票、期权。T5、T6占比最大的级别，T8、T9占比最小，级别越高，每档之间的宽幅越大。 3、晋升基本上应届毕业生应该是T3，但是内部晋升非常激烈。公司那么大，部门和部门之间有业务竞争，肯定也有人才竞争。 通常应届毕业生入职1年多能升到T4，但如果你的部门业务足够核心，或许1年就可以了。3年升T5。从目前百度的情况来看，核心工程师集中在T5/6，但是从5/6到7是非常艰难的过程。 百度是很唯KPI至上的，其次部门很核心，再次老大话语权比较高，相对晋升容易些。 一般情况分2种： 自己提名，当你自己觉得已经具备下一level的素质，可以自己提名，提名后进入考察期，主管设定考察期目标，考察通过顺利晋升，考察不通过维持原层级不变； 主管提名，如果是主管提名，一般都是直接通过的，但是如果你现层级已经比较高了，那就不是直接提名这么简单了。 P.S.如果你能升到T7，基本上是TL的级别，写代码/直接做业务的时间就很少了。","categories":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/categories/BAT/"}],"tags":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/tags/BAT/"}],"keywords":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/categories/BAT/"}]},{"title":"【Android】dip和px之间到底如何转换","slug":"【Android】dip和px之间到底如何转换","date":"2016-07-22T04:02:00.000Z","updated":"2017-07-12T03:54:05.662Z","comments":true,"path":"2016/07/22/【Android】dip和px之间到底如何转换/","link":"","permalink":"http://github.com/2016/07/22/【Android】dip和px之间到底如何转换/","excerpt":"在Android xml布局文件中，我们既可以设置px，也可以设置dp（或者dip）。一般情况下，我们都会选择使用dp，这样可以保证不同屏幕分辨率的机器上布局一致。 但是在代码中，如何处理呢？很多控件的方法中都只提供了设置px的方法，例如setPadding，并没有提供设置dp的方法。这个时候，如果需要设置dp的话，就要将dp转换成px了。 一、名词介绍1. PPI = Pixels per inch，每英寸上的像素数,即 “像素密度” xhdpi: 2.0 hdpi: 1.5 mdpi: 1.0 (baseline) ldpi: 0.75 下图是Android官网dpi的定义（其实在计算机中dpi就是ppi，不明白可以看这里 dpi与ppi区别）： 同时也注意，是dpi，不是dip。 dpi是Dots Per Inch，每英寸点数。（一个量度单位，用于点阵数码影像，指每一英寸长度中，取样、可显示或输出点的数目。是现实概念）。 dip是Device Independent Pixels，设备独立像素。（又称设备无关像，是人为抽象概念 ）。 2. dp = 也就是dip（device independent pixels），设备独立像素。以160PPI屏幕为标准，则1dp=1px，在不同的像素密度的设备上会自动适配，比如: 在320x480分辨率，像素密度为160，1dp=1px 在480x800分辨率，像素密度为240，1dp=1.5px 计算公式：1dp*像素密度/160 = 实际像素数 3. sp = scaled pixels，放大像素，它是安卓的字体单位主要用于字体显示best for textsize。根据 google 的建议，TextView 的字号最好使用 sp 做单位，而且查看TextView的源码可知 Android 默认使用 sp 作为字号单位。","text":"在Android xml布局文件中，我们既可以设置px，也可以设置dp（或者dip）。一般情况下，我们都会选择使用dp，这样可以保证不同屏幕分辨率的机器上布局一致。 但是在代码中，如何处理呢？很多控件的方法中都只提供了设置px的方法，例如setPadding，并没有提供设置dp的方法。这个时候，如果需要设置dp的话，就要将dp转换成px了。 一、名词介绍1. PPI = Pixels per inch，每英寸上的像素数,即 “像素密度” xhdpi: 2.0 hdpi: 1.5 mdpi: 1.0 (baseline) ldpi: 0.75 下图是Android官网dpi的定义（其实在计算机中dpi就是ppi，不明白可以看这里 dpi与ppi区别）： 同时也注意，是dpi，不是dip。 dpi是Dots Per Inch，每英寸点数。（一个量度单位，用于点阵数码影像，指每一英寸长度中，取样、可显示或输出点的数目。是现实概念）。 dip是Device Independent Pixels，设备独立像素。（又称设备无关像，是人为抽象概念 ）。 2. dp = 也就是dip（device independent pixels），设备独立像素。以160PPI屏幕为标准，则1dp=1px，在不同的像素密度的设备上会自动适配，比如: 在320x480分辨率，像素密度为160，1dp=1px 在480x800分辨率，像素密度为240，1dp=1.5px 计算公式：1dp*像素密度/160 = 实际像素数 3. sp = scaled pixels，放大像素，它是安卓的字体单位主要用于字体显示best for textsize。根据 google 的建议，TextView 的字号最好使用 sp 做单位，而且查看TextView的源码可知 Android 默认使用 sp 作为字号单位。 二、换算公式 PPI 的运算方式是：PPI = √（长度像素数² + 宽度像素数²） / 屏幕对角线英寸数 dp和px的换算公式 ：dp*ppi/160 = px。比如1dp x 320ppi/160 = 2px。 sp 与 px 的换算公式：sp*ppi/160 = px 三、总结px = dp*ppi/160dp = px / (ppi / 160) px = sp*ppi/160sp = px / (ppi / 160) dp = sp? 四、转换代码 为了方便进行px和dp之间的转换，可以使用以下代码。 import android.content.Context; public class DensityUtil &#123; /** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; /** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; &#125; 【参考资料】1、px 与 dp, sp换算公式2、dp、sp、px傻傻分不清楚[完整]","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】Monkey压力测试与停止","slug":"【Android】Monkey压力测试与停止","date":"2016-07-19T03:09:00.000Z","updated":"2017-07-03T08:54:28.032Z","comments":true,"path":"2016/07/19/【Android】Monkey压力测试与停止/","link":"","permalink":"http://github.com/2016/07/19/【Android】Monkey压力测试与停止/","excerpt":"一、Monkey 是什么？Monkey测试是Android自动化测试的一种手段。该工具用于进行压力测试，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。 二、Monkey命令1）. 标准的monkey 命令[adb shell] monkey [options] &lt; eventcount &gt; , 例如： adb shell monkey -v 500 产生500次随机事件，作用在系统中所有activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。上面只是一个简单的例子，实际情况中通常会有很多的options 选项. 2）. 四大类 常用选项 事件选项 约束选项 调试选项 具体的命令解释可以看这里：android 压力测试命令monkey详解","text":"一、Monkey 是什么？Monkey测试是Android自动化测试的一种手段。该工具用于进行压力测试，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。 二、Monkey命令1）. 标准的monkey 命令[adb shell] monkey [options] &lt; eventcount &gt; , 例如： adb shell monkey -v 500 产生500次随机事件，作用在系统中所有activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。上面只是一个简单的例子，实际情况中通常会有很多的options 选项. 2）. 四大类 常用选项 事件选项 约束选项 调试选项 具体的命令解释可以看这里：android 压力测试命令monkey详解 一个简单的Monkey命令如下： adb shell monkey -p com.example.xystudy -s 500 -v 10000 工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。monkey 测试命令如下： /** * monkey 作用的包：com.ckt.android.junit * 产生时间序列的种子值：500 * 忽略程序崩溃、 忽略超时、 监视本地程序崩溃、 详细信息级别为2， 产生10000个事件 。 */adb shell monkey -p com.xy.android.junit -s 500 --ignore-crashes--ignore-timeouts --monitor-native-crashes -v -v 10000 &gt; E:\\monkey_log\\java_monkey_log.txt 三、强制停止Monkey测试adb shell ps | awk '/com\\.android\\.commands\\.monkey/ &#123; system(\"adb shell kill \" $2) &#125;' 【参考资料】1、android 压力测试命令monkey详解2、Monkey 的专项测试浅谈","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？","slug":"【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？","date":"2016-07-14T08:27:00.000Z","updated":"2016-10-18T04:55:00.540Z","comments":true,"path":"2016/07/14/【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？/","link":"","permalink":"http://github.com/2016/07/14/【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？/","excerpt":"英文原文： Auto Restart application after Crash/Force Close in Android. 手机上的Android应用，经常会出现“Force Close”的错误，这种情况一般是因为代码中没有正确获取到Exceptions。那么如果想让App在出现这种错误崩溃Crash以后自动重启，我们该怎么办呢？ 这篇教程我们将学到如何自动处理Exception，并且了解在App Crash以后如何自动重启。 其实方法很简单，这里我们需要用到 Thread.setDefaultUncaughtExceptionHandler()，当应用崩溃的时候代码就会自动调用 uncaughtException() 这个方法。","text":"英文原文： Auto Restart application after Crash/Force Close in Android. 手机上的Android应用，经常会出现“Force Close”的错误，这种情况一般是因为代码中没有正确获取到Exceptions。那么如果想让App在出现这种错误崩溃Crash以后自动重启，我们该怎么办呢？ 这篇教程我们将学到如何自动处理Exception，并且了解在App Crash以后如何自动重启。 其实方法很简单，这里我们需要用到 Thread.setDefaultUncaughtExceptionHandler()，当应用崩溃的时候代码就会自动调用 uncaughtException() 这个方法。 操作步骤如下： Step 1 像下面这样创建一个重启目标 Activity 的 Intent，并添加一些 Activity 启动的 Flags： Intent intent = new Intent(activity, RelaunchActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); 其中， Intent.FLAG_ACTIVITY_CLEAR_TOP ： 销毁目标Activity和它之上的所有Activity，重新创建目标Activity。 Intent.FLAG_ACTIVITY_CLEAR_TASK ： 启动Activity时，清除之前已经存在的Activity实例所在的task，这自然也就清除了之前存在的Activity实例！ Intent.FLAG_ACTIVITY_NEW_TASK ： 很少单独使用，通常与FLAG_ACTIVITY_CLEAR_TASK或FLAG_ACTIVITY_CLEAR_TOP联合使用。 Step 2 在 uncaughtException() 方法中，添加如下代码： PendingIntent pendingIntent = PendingIntent.getActivity( YourApplication.getInstance().getBaseContext(), 0, intent, intent.getFlags()); AlarmManager mgr = (AlarmManager) YourApplication.getInstance().getBaseContext() .getSystemService(Context.ALARM_SERVICE);mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, pendingIntent); activity.finish();System.exit(2); 这里的 PendingIntent 不同于常见的 Intent ，PendingIntent 是对 Intent 的一个包装，可以保存下来在将来某一刻执行。它存储了request code、intent 和 flags。 AlarmManager 是为了设置一个计时器来延迟两秒再执行 pendingIntent 的，也就是重启我们的Activity的任务。 Step 3 最后，在 Activity 的 onCreate() 方法中调用如下代码： Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler(this)); 【完整代码】 YourApplication.java import android.app.Application; /** * This custom class is used to Application level things. * * @author Chintan Rathod (http://www.chintanrathod.com) */public class YourApplication extends Application &#123; private static Context mContext; public static YourApplication instace; @Override public void onCreate() &#123; super.onCreate(); mContext = getApplicationContext(); instace = this; &#125; @Override public Context getApplicationContext() &#123; return super.getApplicationContext(); &#125; public static YourApplication getIntance() &#123; return instace; &#125;&#125; DefaultExceptionHandler.java import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.lang.Thread.UncaughtExceptionHandler;import java.text.SimpleDateFormat;import java.util.Date; import android.app.Activity;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.os.Environment;import android.util.Log; /** * This custom class is used to handle exception. * * @author Chintan Rathod (http://www.chintanrathod.com) */public class DefaultExceptionHandler implements UncaughtExceptionHandler &#123; private UncaughtExceptionHandler defaultUEH; Activity activity; public DefaultExceptionHandler(Activity activity) &#123; this.activity = activity; &#125; @Override public void uncaughtException(Thread thread, Throwable ex) &#123; try &#123; Intent intent = new Intent(activity, RelaunchActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pendingIntent = PendingIntent.getActivity( YourApplication.getInstance().getBaseContext(), 0, intent, intent.getFlags()); //Following code will restart your application after 2 seconds AlarmManager mgr = (AlarmManager) YourApplication.getInstance().getBaseContext() .getSystemService(Context.ALARM_SERVICE); mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, pendingIntent); //This will finish your activity manually activity.finish(); //This will stop your application and take out from it. System.exit(2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 【参考资料】： 1、Activity启动模式(二)之 Intent的Flag属性","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【SVN】使用patch命令保存更改","slug":"【SVN】使用patch命令保存更改","date":"2016-06-12T03:06:00.000Z","updated":"2016-10-18T04:57:14.094Z","comments":true,"path":"2016/06/12/【SVN】使用patch命令保存更改/","link":"","permalink":"http://github.com/2016/06/12/【SVN】使用patch命令保存更改/","excerpt":"使用svn管理工程代码时，有些时候的更改尚未整理好，需要暂时搁置，转而进行下一个任务，此时就需要将当前的更改（diff）暂时保存下来，忙完其他的任务之后再继续进行。但是如果不进行commit，怎么保存当前的更改呢？答案是使用 patch 命令！ 一、生成patch文件svn diff &gt; patchFile // 整个工程的变动生成patchsvn diff FILE_NAME &gt; patchFile // 某个文件单独变动的patch 二、svn回滚svn revert FILE // 单个文件回滚svn revert DIR --depth=infinity // 整个目录进行递归回滚svn revert . --depth=infinity // 当前目录进行递归回滚","text":"使用svn管理工程代码时，有些时候的更改尚未整理好，需要暂时搁置，转而进行下一个任务，此时就需要将当前的更改（diff）暂时保存下来，忙完其他的任务之后再继续进行。但是如果不进行commit，怎么保存当前的更改呢？答案是使用 patch 命令！ 一、生成patch文件svn diff &gt; patchFile // 整个工程的变动生成patchsvn diff FILE_NAME &gt; patchFile // 某个文件单独变动的patch 二、svn回滚svn revert FILE // 单个文件回滚svn revert DIR --depth=infinity // 整个目录进行递归回滚svn revert . --depth=infinity // 当前目录进行递归回滚 三、打patchpatch -p0 &lt; test.patch // -p0 选项要从当前目录查找目的文件（夹）patch -p1 &lt; test.patch // -p1 选项要从当前目录查找目的文件，不包含patch中的最上级目录（夹）","categories":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/categories/SVN/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/tags/SVN/"}],"keywords":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/categories/SVN/"}]},{"title":"【Java】按位存储：使用int存储boolean数组","slug":"【Java】按位存储：使用int存储boolean数组","date":"2016-06-02T03:55:00.000Z","updated":"2017-01-20T03:28:24.476Z","comments":true,"path":"2016/06/02/【Java】按位存储：使用int存储boolean数组/","link":"","permalink":"http://github.com/2016/06/02/【Java】按位存储：使用int存储boolean数组/","excerpt":"有一种场景，比如App设置页中会有一组开关选项，这个时候保存这些开关的状态，如果每个按钮都对应一个boolean值的话，太大材小用显得鸡肋，频繁读取SharedPreferences 存取效率自然快不过一次读取。 首先，敲定每个boolean值存储的位置private int mBroadcastCustomValue = 0; //用来存储的int值public static final int BROADCAST_TYPE_CUSTOM_BASE = 1;public static final int BROADCAST_TYPE_CUSTOM_TRAFFIC = 1 &lt;&lt; 1;public static final int BROADCAST_TYPE_CUSTOM_CAMERA = 1 &lt;&lt; 2;public static final int BROADCAST_TYPE_CUSTOM_SAFE = 1 &lt;&lt; 3; 一、添加Addprivate void addLevel(int level)&#123; mBroadcastCustomValue |= level; //add&#125;//调用方式如下addLevel(BROADCAST_TYPE_CUSTOM_BASE);","text":"有一种场景，比如App设置页中会有一组开关选项，这个时候保存这些开关的状态，如果每个按钮都对应一个boolean值的话，太大材小用显得鸡肋，频繁读取SharedPreferences 存取效率自然快不过一次读取。 首先，敲定每个boolean值存储的位置private int mBroadcastCustomValue = 0; //用来存储的int值public static final int BROADCAST_TYPE_CUSTOM_BASE = 1;public static final int BROADCAST_TYPE_CUSTOM_TRAFFIC = 1 &lt;&lt; 1;public static final int BROADCAST_TYPE_CUSTOM_CAMERA = 1 &lt;&lt; 2;public static final int BROADCAST_TYPE_CUSTOM_SAFE = 1 &lt;&lt; 3; 一、添加Addprivate void addLevel(int level)&#123; mBroadcastCustomValue |= level; //add&#125;//调用方式如下addLevel(BROADCAST_TYPE_CUSTOM_BASE); 二、删除Deleteprivate void deleteLevel(int level)&#123; mBroadcastCustomValue ^= mBroadcastCustomValue &amp; level; //delete&#125;//调用方式如下deleteLevel(BROADCAST_TYPE_CUSTOM_BASE); 三、读取Read/** * 从value中读取level的设置值，level即是某个boolean值的位置 */private boolean isLevelAccess(int value, int level)&#123; if((value &amp; level) == level)&#123; return true; &#125; return false;&#125;//调用方式如下boolean a = isLevelAccess(mBroadcastCustomValue, BROADCAST_TYPE_CUSTOM_BASE);","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】技术调研：用代码模拟屏幕点击、触摸事件","slug":"【Android】技术调研：用代码模拟屏幕点击、触摸事件","date":"2016-06-02T03:55:00.000Z","updated":"2017-01-20T03:24:31.816Z","comments":true,"path":"2016/06/02/【Android】技术调研：用代码模拟屏幕点击、触摸事件/","link":"","permalink":"http://github.com/2016/06/02/【Android】技术调研：用代码模拟屏幕点击、触摸事件/","excerpt":"在Android中，有些场景需要使用代码来模拟人的操作，比如微信自动抢红包、UI测试等都需要模拟实现点击事件（Click）、触摸事件（Touch）、键盘事件（KeyBoard）等。那么，有没有现成的方案可以实现呢？答案当然是肯定的啦，往下看。 经过调研发现，给系统模拟注入输入事件有如下几种方式： 一、使用shell命令使用android自带的adb shell，里面自带一个input工具，使用方法如下： adb shell #进入系统input keyevent KEYCODE_BACK #模拟按返回键input keyevent KEYCODE_HOME #模拟按Home键","text":"在Android中，有些场景需要使用代码来模拟人的操作，比如微信自动抢红包、UI测试等都需要模拟实现点击事件（Click）、触摸事件（Touch）、键盘事件（KeyBoard）等。那么，有没有现成的方案可以实现呢？答案当然是肯定的啦，往下看。 经过调研发现，给系统模拟注入输入事件有如下几种方式： 一、使用shell命令使用android自带的adb shell，里面自带一个input工具，使用方法如下： adb shell #进入系统input keyevent KEYCODE_BACK #模拟按返回键input keyevent KEYCODE_HOME #模拟按Home键 还可以直接输入点击屏幕的事件，模拟点击屏幕： input tap 100 200 #在屏幕坐标(100, 200)处点击 详细的用法如下： 二、使用 InstrumentationInstrumentation本身是Android用来做测试的工具，可以通过它监测系统与应用程序之间的交互。详情可以参考官方文档[Test Your App]。我们这里只关注怎么使用Instrumentation产生发送按键或者触屏事件。 它可以发送按键： Instrumentation mInst = new Instrumentation(); mInst.sendKeyDownUpSync(KeyEvent.KEYCODE_CAMERA); 也可以发送触屏事件：Instrumentation mInst = new Instrumentation(); mInst.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, x, y, 0); //x,y 即是事件的坐标mInst.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, x, y, 0); 与Shell工具一样，还有类似sendStringSync()发送文本，sendTrackballEventSync()发送轨迹球事件等方法。 sendCharacterSync(int keyCode) //用于发送指定KeyCode的按键sendKeyDownUpSync(int key) //用于发送指定KeyCode的按键sendPointerSync(MotionEvent event) //用于模拟TouchsendStringSync(String text) //用于发送字符串 需要注意的是，这些方法均不可以在UI主线程中执行，必须放到子线程中调用，否则就会报错。另外，使用上面的方法，需要在AndroidManifast.xml中申明如下权限： &lt;uses-permission android:name=\"android.permission.INJECT_EVENTS\"/&gt; 三、使用Android内部API在Android系统中，有些内部的API提供注入事件的方法。因为是内部API，在不同版本上可能变化比较大。使用如果想在普通App中使用，可能需要通过反射机制来调用。 在Android API 16之前，WindownManager有相应的方法提供注入事件的方法，如下： IBinder wmbinder = ServiceManager.getService(\"window\"); IWindowManager wm = IWindowManager.Stub.asInterface(wmbinder); //pointer wm.injectPointerEvent(myMotionEvent, false); //key wm.injectKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_A), false); wm.injectKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_A), false); //trackball wm.injectTrackballEvent(myMotionEvent, false); 在API 15之后，引入了InputManager，把上面的哪些injectXXXEvent()方法从WindowManager中移除了。使用方法类似： IBinder imBinder = ServiceManager.getService(\"input\"); IInputManager im = IInputManager.Stub.asInterface(imBinder);//inject key eventfinal KeyEvent keyEvent = new KeyEvent(downTime, eventTime, action, code, repeatCount, metaState, deviceId, scancode, flags | KeyEvent.FLAG_FROM_SYSTEM |KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_SOFT_KEYBOARD, source);event.setSource(InputDevice.SOURCE_ANY) im.injectInputEvent(keyEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);//inject pointer eventmotionEvent.setSource(InputDevice.SOURCE_TOUCHSCREEN); im.injectInputEvent(motionEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH); 从API 16开始，InputManager就成了一个公开的类了，可以通过如下方法获得InputManager实例： InputManager im = (InputManager) getSystemService(Context.INPUT_SERVICE); 注意，使用injectEvent()同样需要申明android:name=”android.permission.INJECT_EVENTS”权限。 四、可以考虑使用Monkey测试框架这种方案就是希望能够模拟Android Monkey的测试方法，不过博主并没有来得及对这方面进行深入的研究，可以参考这篇文章Android Monkey源码解析 【参考资料】：1、Android模拟产生事件2、Android 模拟键盘鼠标事件（Socket+Instrumentation实现）3、Android Monkey源码解析","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【MySQL】查询保持IN中的顺序","slug":"【MySQL】查询保持IN中的顺序","date":"2016-04-29T07:36:00.000Z","updated":"2016-10-18T04:57:07.725Z","comments":true,"path":"2016/04/29/【MySQL】查询保持IN中的顺序/","link":"","permalink":"http://github.com/2016/04/29/【MySQL】查询保持IN中的顺序/","excerpt":"select * from table_name where id in ()的时候，MySQL会自动按主键自增排序，要是按IN中给定的顺序来取，如何实现呢？ 比如下面这个查询结果，mysql会默认使用主键id的ASC自增排序结果集：","text":"select * from table_name where id in ()的时候，MySQL会自动按主键自增排序，要是按IN中给定的顺序来取，如何实现呢？ 比如下面这个查询结果，mysql会默认使用主键id的ASC自增排序结果集： 那么，如果我们想维持查询语句中IN(26613,26612,26611,26610,26609,26608,26607)的顺序可以么？当然可以，像下面这样，使用Order by field()： SELECT * from `models` where `id` in (26612,26611,26610) order by field(id,26612,26611,26610); 这样读取出来的顺序就是IN（）语句中的顺序。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/tags/MySQL/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/categories/MySQL/"}]},{"title":"【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决","slug":"【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决","date":"2016-04-29T03:37:09.000Z","updated":"2016-10-18T04:56:53.039Z","comments":true,"path":"2016/04/29/【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决/","link":"","permalink":"http://github.com/2016/04/29/【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决/","excerpt":"在Linux中执行.sh脚本，异常/bin/bash^M: bad interpreter: No such file or directory. 一、分析这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 二、解决1）在windows下转换：利用一些编辑器如UltraEdit或EditPlus等工具先将脚本编码转换，再放到Linux中执行。转换方式如下（UltraEdit）：File–&gt;Conversions–&gt;DOS-&gt;UNIX即可。","text":"在Linux中执行.sh脚本，异常/bin/bash^M: bad interpreter: No such file or directory. 一、分析这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 二、解决1）在windows下转换：利用一些编辑器如UltraEdit或EditPlus等工具先将脚本编码转换，再放到Linux中执行。转换方式如下（UltraEdit）：File–&gt;Conversions–&gt;DOS-&gt;UNIX即可。 2）直接在Linux中转换（推荐做法）： 首先要确保文件有可执行权限 #sh&gt; chmod a+x filename 然后修改文件格式 #sh&gt; vi filename 利用如下命令查看文件格式 :set ff 或 :set fileformat 可以看到如下信息 fileformat=dos 或 fileformat=unix 利用如下命令修改文件格式 :set ff=unix 或 :set fileformat=unix :wq (存盘退出) 最后再执行文件 #sh&gt;./filename","categories":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/categories/Linux/"}]},{"title":"”二分查找“算法的时间复杂度","slug":"”二分查找“算法的时间复杂度","date":"2016-04-06T06:03:00.000Z","updated":"2016-10-18T04:54:36.739Z","comments":true,"path":"2016/04/06/”二分查找“算法的时间复杂度/","link":"","permalink":"http://github.com/2016/04/06/”二分查找“算法的时间复杂度/","excerpt":"算法的时间复杂度无非就是for、while等包含起来的基本运算单元的循环次数 1、二分查找二分查找（binary search），也称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！","text":"算法的时间复杂度无非就是for、while等包含起来的基本运算单元的循环次数 1、二分查找二分查找（binary search），也称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！ //二分查找 Java 实现public static int binarySearch(Integer[] srcArray, int des) &#123; int low = 0; int high = srcArray.length - 1; while ((low &lt;= high) &amp;&amp; (low &lt;= srcArray.length - 1) &amp;&amp; (high &lt;= srcArray.length - 1)) &#123; int middle = (high + low) &gt;&gt; 1; if (des == srcArray[middle]) &#123; return middle; &#125; else if (des &lt; srcArray[middle]) &#123; high = middle - 1; &#125; else &#123; low = middle + 1; &#125; &#125; return -1;&#125; 2、时间复杂度比如：总共有n个元素，每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。由于n/2^k取整后&gt;=1，即令n/2^k=1，可得k=log2n,（是以2为底，n的对数），所以时间复杂度可以表示O()=O(logn)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"给大家推荐一款Sublime Text的主题”brogrammer-theme“","slug":"给大家推荐一款Sublime Text的主题”brogrammer-theme“","date":"2016-03-30T08:46:00.000Z","updated":"2017-01-20T03:26:22.247Z","comments":true,"path":"2016/03/30/给大家推荐一款Sublime Text的主题”brogrammer-theme“/","link":"","permalink":"http://github.com/2016/03/30/给大家推荐一款Sublime Text的主题”brogrammer-theme“/","excerpt":"先给大家看一下这个主题的颜值：","text":"先给大家看一下这个主题的颜值： 快看安装方法：1、下载：https://github.com/kenwheeler/brogrammer-theme/archive/master.zip 2、解压后将文件夹改名成Theme - Brogrammer，然后打开sublime text3，找到里面的 Preferences -&gt; Browse Packages，将改名后的文件夹copy到弹出的文件夹中 3、然后首选项-&gt;设置用户（Preferences -&gt; setting uer），将下列代码拷进去： &#123; &quot;color_scheme&quot;: &quot;Packages/brogrammer-theme-master/brogrammer.tmTheme&quot;, &quot;font_size&quot;: 10&#125; 【官方文档】： brogrammer-theme on Github Theme - Brogrammer on Package Control","categories":[],"tags":[],"keywords":[]},{"title":"【Android】Picasso加载本地图片如何清理缓存cache？","slug":"【Android】Picasso加载本地图片如何清理缓存cache？","date":"2016-03-08T07:03:00.000Z","updated":"2016-10-28T02:23:43.007Z","comments":true,"path":"2016/03/08/【Android】Picasso加载本地图片如何清理缓存cache？/","link":"","permalink":"http://github.com/2016/03/08/【Android】Picasso加载本地图片如何清理缓存cache？/","excerpt":"","text":"使用Picasso加载SD卡图片的时候，Picasso也会对该图片进行缓存。所以如果该图片即使已经变了，Picasso在加载时会仍然使用缓存，而不更新图片。 1、Picasso缓存策略我们都知道图片缓存使用的是Map键值对存储的，这里的Key就是加载的图片的Url，所以如果我们使用相同的ImageUrl去加载图片的话，如果使用了缓存，Picasso会直接读取缓存的内容，而不是从SD卡、或者网络Http中重新加载。 2、Picasso如何跳过缓存试了很多网上推荐的方法均不见起效，最后使用了下面这种策略，也就是加载图片时直接跳过缓存 Picasso.with(getContext()).load(imageUrl).memoryPolicy(MemoryPolicy.NO_CACHE).into(image); 注意其中的.memoryPolicy(MemoryPolicy.NO_CACHE)即是关键代码，其中 MemoryPolicy.NO_CACHE：是指图片加载时放弃在内存缓存中查找。 MemoryPolicy.NO_STORE：是指图片加载完不缓存在内存中。 ps：此处的方法并不是真正的清理缓存，而是跳过缓存直接从源头获取。 网上有几种错误的方法如下，经验证均不起效： 1、Picasso.with(getActivity()).invalidate(file);2、Picasso.with(getActivity()).load(url).skipMemoryCache().into(image); 最后还是在StackOverFlow的Clear Cache memory of Picasso查到了如上的解决办法。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"如何生成100个1-100以内的不重复的随机数","slug":"如何生成100个1-100以内的不重复的随机数","date":"2016-01-22T03:55:00.000Z","updated":"2016-10-18T04:58:09.102Z","comments":true,"path":"2016/01/22/如何生成100个1-100以内的不重复的随机数/","link":"","permalink":"http://github.com/2016/01/22/如何生成100个1-100以内的不重复的随机数/","excerpt":"这是个经典的面试题目：生成长度为100的数组，插入1-100以内的但均不重复的随机数 一、简单实现思路:(1) 把N个数放入Hashtable 或者arrayList 中. (2) 从上面的集合中随机抽取一个数放入int数组中. (3) 把取出的这个数从上面的集合中删除. (4) 循环 (2),(3) 步骤,直到int数组取满为止.","text":"这是个经典的面试题目：生成长度为100的数组，插入1-100以内的但均不重复的随机数 一、简单实现思路:(1) 把N个数放入Hashtable 或者arrayList 中. (2) 从上面的集合中随机抽取一个数放入int数组中. (3) 把取出的这个数从上面的集合中删除. (4) 循环 (2),(3) 步骤,直到int数组取满为止. 这是一种比较简单的实现思路，实现代码如下： import java.util.ArrayList;import java.util.Collections;import java.util.Random;public class Main &#123; private static int range = 100; private static ArrayList&lt;Integer&gt; originalList = new ArrayList&lt;Integer&gt;(); private static ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); static &#123; for (int i = 1; i &lt;= range; i++) &#123; originalList.add(i); &#125; &#125; public static void main(String args[]) &#123; for (int i = 0; i &lt; range; i++) &#123; int j = range - i; int r = (int) (new Random().nextInt(j)); result.add(originalList.get(r)); System.out.print(originalList.get(r) + \", \"); originalList.remove(r); &#125; Collections.sort(result); System.out.println(\"\\n\\n生成的数组大小是：\" + result.size() + \"------以下是排序结果，看是否有重复的随机数\"); for (Integer i : result) &#123; System.out.print(i + \", \"); &#125; &#125;&#125; 执行结果如下： 74, 75, 47, 76, 59, 94, 2, 33, 23, 66, 60, 13, 44, 34, 7, 92, 11, 86, 4, 38, 26, 55, 64, 99, 1, 54, 30, 72, 80, 87, 15, 24, 25, 37, 83, 49, 28, 81, 79, 35, 18, 68, 61, 46, 98, 58, 85, 29, 39, 48, 53, 14, 8, 91, 42, 36, 65, 62, 6, 52, 21, 78, 63, 73, 16, 88, 5, 69, 19, 51, 50, 43, 40, 70, 89, 10, 12, 71, 96, 45, 93, 9, 31, 22, 95, 20, 17, 3, 67, 90, 41, 82, 57, 84, 100, 32, 77, 27, 97, 56, 生成的数组大小是：100------以下是排序结果，看是否有重复的随机数1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 二、改进算法我们一般都会想到这种做法,但是当Hashtable或者ArrayList中放几千万,几亿数据时,这时从集合中删除元素将严重影响性能,如果突破此瓶颈? 网上找到一种更好的方法. (1) 把N个数放到容器A(int数组)中.(2) 从N个数中随机取出1个数放入容器B(int数组)中.(3) 把容器A中最后一个数与随机抽取的数对调 或者 把容器A中最后一个数覆盖随机抽取出来的数.(4) 这时从容器A(假设N个数,索引0 到 索引N-2)之间随机取一个数.再放入容器B中,重复此步骤. 说明：也就是第二次是从容器A中 第一个元素到倒数第二个元素 中随机取一个数.这种好处是,随机数所取范围逐步缩小,而且杜绝了大数据时集合执行删除操作时产生的瓶颈. 所以，向下面这样实现会更好： public class Main &#123; private static int range = 100; private static int[] result; public static void main(String args[]) &#123; result = getNumber(range); for (int i = 0; i &lt; range; i++) &#123; System.out.print(result[i] + \", \"); &#125; &#125; public static int[] getNumber(int total)&#123; int[] NumberBox = new int[total]; //容器A int[] rtnNumber = new int[total]; //容器B for (int i = 0; i &lt; total; i++)&#123; NumberBox[i] = i; //先把N个数放入容器A中 &#125; int end = total - 1; for (int j = 0; j &lt; total; j++)&#123; int num = new Random().nextInt(end + 1); //取随机数 rtnNumber[j] = NumberBox[num]; //把随机数放入容器B NumberBox[num] = NumberBox[end]; //把容器A中最后一个数覆盖所取的随机数 end--; //缩小随机数所取范围 &#125; return rtnNumber; //返回int型数组 &#125;&#125; 执行结果如下： 80, 9, 70, 22, 3, 63, 12, 81, 73, 41, 90, 83, 27, 71, 88, 5, 40, 18, 25, 37, 55, 60, 93, 87, 17, 89, 99, 84, 32, 96, 62, 98, 77, 30, 23, 35, 47, 24, 21, 53, 95, 7, 85, 2, 65, 1, 39, 43, 76, 46, 42, 91, 4, 26, 52, 86, 34, 54, 38, 78, 31, 11, 66, 36, 50, 75, 16, 68, 56, 33, 48, 15, 74, 69, 49, 6, 58, 10, 29, 92, 64, 59, 28, 61, 45, 19, 14, 13, 44, 72, 94, 20, 97, 51, 67, 79, 0, 82, 8, 57,","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】如何查看Activity Task栈的情况","slug":"【Android】如何查看Activity Task栈的情况","date":"2016-01-19T03:48:00.000Z","updated":"2016-10-18T04:55:43.216Z","comments":true,"path":"2016/01/19/【Android】如何查看Activity Task栈的情况/","link":"","permalink":"http://github.com/2016/01/19/【Android】如何查看Activity Task栈的情况/","excerpt":"我们都知道，每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。 如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。 一、查看task栈情况 在cmd命令行里或者Android Studio中的Terminal里敲入如下命令：adb shell dumpsys activity 然后会出现很长一段详细信息，滚到中间的地方，会看到Task栈的状态如下：","text":"我们都知道，每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。 如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。 一、查看task栈情况 在cmd命令行里或者Android Studio中的Terminal里敲入如下命令：adb shell dumpsys activity 然后会出现很长一段详细信息，滚到中间的地方，会看到Task栈的状态如下： 此外，这些信息的最底部还可以看到当前显示在前台的Activity是哪一个，还有使用设备的分辨率等信息","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"Java中的封装、继承与多态","slug":"Java中的封装、继承与多态","date":"2016-01-15T07:43:20.000Z","updated":"2016-10-18T04:57:38.022Z","comments":true,"path":"2016/01/15/Java中的封装、继承与多态/","link":"","permalink":"http://github.com/2016/01/15/Java中的封装、继承与多态/","excerpt":"这次我们来了解一下面向对象的三大基石封装，继承、多态，然后大致对比一下继承和多态的区别。 一、封装： 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。封装提供了一个有效的途径来保护数据不被意外的破坏。相比我们将数据（用域来实现）在程序中定义为公用的（public）我们将它们(fields)定义为私有的（privat）在很多方面会更好。","text":"这次我们来了解一下面向对象的三大基石封装，继承、多态，然后大致对比一下继承和多态的区别。 一、封装： 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。封装提供了一个有效的途径来保护数据不被意外的破坏。相比我们将数据（用域来实现）在程序中定义为公用的（public）我们将它们(fields)定义为私有的（privat）在很多方面会更好。 Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。 下面用表格的形式来展示四种访问权限之间的异同点，这样会更加形象。注意其中protected和default的区别，表格如下所示： 权限修饰符 同一个类 同一个包 不同包的子类 不同包的非子类 Private √ Default √ √ Protected √ √ √ Public √ √ √ √ 二、继承 通过继承可以实现代码的复用，使子类可以拥有父类的一些属性和方法。继承应该符合下列规则： 继承是可传递的。如果C从B中派生，B又从A中派生，那么C不仅继承了B中声明的成员，同样也继承了A中的成员。Object类作为所有类的基类。 派生类应当是对基类的扩展。派生类可以添加新的成员，但不能除去已经继承的成员的定义。构造函数和析构函数不能被继承。除此之外的其它成员，不论对它们定义了怎样的访问方式，都能被继承。基类中成员的访问方式只能决定派生类能否访问它们。 派生类如果定义了与继承而来的成员同名的新成员，就可以覆盖已继承的成员。但这并不因为这派生类删除了这些成员，只是不能再访问这些成员。 类可以定义为abstract抽象类，它的派生类就能够重载这些成员，从而实现类可以展示出多态性。 三、多态 多态就是指父类的某个方法被子类重写时，可以各自产生自己的功能行为。同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。 可以这么说：编译时看父类，运行时看子类。运行时的多态性就是指直到系统运行时，才根据实际情况决定实现何种操作。C#中，运行时的多态性通过虚成员实现。 父类A a = new 父类的子类B();a.方法();//这就是多态 实现多态的方式： 接口多态性。 继承多态性。 通过抽象类实现的多态性。 四、继承与多态的区别 网上看到一个有趣的说法是：继承是子类使用父类的方法，而多态则是父类使用子类的方法。 继承，子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。 多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。可以这么说：编译时看父类，运行时看子类。 【参考资料】：1、java类的访问权限2、继承、封装、多态3、java中继承和多态区别.4、重载，继承，重写和多态的区别","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"Java访问权限修饰符的区别","slug":"Java访问权限修饰符的区别","date":"2016-01-15T07:07:20.000Z","updated":"2016-10-18T04:57:34.963Z","comments":true,"path":"2016/01/15/Java访问权限修饰符的区别/","link":"","permalink":"http://github.com/2016/01/15/Java访问权限修饰符的区别/","excerpt":"Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。","text":"Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。 下面用表格的形式来展示四种访问权限之间的异同点，这样会更加形象。注意其中protected和default的区别，表格如下所示： 权限修饰符 同一个类 同一个包 不同包的子类 不同包的非子类 Private √ Default √ √ Protected √ √ √ Public √ √ √ √ 【参考资料】：1、java类的访问权限","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？","slug":"【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？","date":"2016-01-05T07:31:00.000Z","updated":"2017-05-05T09:17:14.292Z","comments":true,"path":"2016/01/05/【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？/","link":"","permalink":"http://github.com/2016/01/05/【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？/","excerpt":"走台阶算法（本质上是斐波那契数列）在面试中常会遇到，描述就如题目那样：总共100级台阶（任意级都行），小明每次可选择走1步、2步或者3步，问走完这100级台阶总共有多少种走法？ 一、 题目分析这个问题本质上是斐波那契数列，假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级,f(2)=2。如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)。将上面的斐波那契数列代码稍微改一下就是本题的答案。我们来看一下代码的实现。 二、斐波那契数列法public class Test &#123; static final int s = 100; //自定义的台阶数 static int compute(int stair)&#123; if ( stair &lt;= 0)&#123; return 0; &#125; if (stair == 1)&#123; return 1; &#125; if (stair == 2)&#123; return 2; &#125; return compute(stair-1) + compute(stair-2); &#125; public static void main(String args[]) &#123; System.out.println(\"共有\" + compute(s) + \"种走法\"); &#125;&#125;","text":"走台阶算法（本质上是斐波那契数列）在面试中常会遇到，描述就如题目那样：总共100级台阶（任意级都行），小明每次可选择走1步、2步或者3步，问走完这100级台阶总共有多少种走法？ 一、 题目分析这个问题本质上是斐波那契数列，假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级,f(2)=2。如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)。将上面的斐波那契数列代码稍微改一下就是本题的答案。我们来看一下代码的实现。 二、斐波那契数列法public class Test &#123; static final int s = 100; //自定义的台阶数 static int compute(int stair)&#123; if ( stair &lt;= 0)&#123; return 0; &#125; if (stair == 1)&#123; return 1; &#125; if (stair == 2)&#123; return 2; &#125; return compute(stair-1) + compute(stair-2); &#125; public static void main(String args[]) &#123; System.out.println(\"共有\" + compute(s) + \"种走法\"); &#125;&#125; 三、 走台阶问题的简单解决算法但我自己对于这个题目最早的想法是使用树（多叉树）的方式，100为根节点，每次选择的分支有两种（1、2），然后生成深度为1的树，再从每个2级节点延伸出1、2两个分支，直到所有节点的值&lt;=0，最后统计出所有值为0的叶子节点的数目，就是结果。 不过自己想法实际上把问题复杂化了，下面这种使用递归方式实现的算法本质上和我的思想差不多，但是很明显下面这个算法会简单很多。接下来我们来看看这个算法的实现方式。 public class Test &#123; static final int s = 100; //自定义的台阶数 static int len = 0, sum = 0; //最多也只有走100步就到了 static int step[] = new int[s]; static void compute(final int stair) &#123; if (stair &lt; 0) return; //表示已经走完了 if (stair == 0) &#123; printSum(); sum++; return; &#125; //每次到下一步选择时都可以走1-2步 for (int i = 1; i &lt;= 2; i++) &#123; step[len] = i; len++; //进行下一步的迭代，迭代完之后将每后加上的一步去掉，换成其它的步数(如从1换成2) compute(stair - i); len--; &#125; &#125; static void printSum() &#123; System.out.print(\"走法:\"); for (int i = 0; i &lt; len; i++) System.out.print(step[i] + \" \"); System.out.println(); &#125; public static void main(String args[]) &#123; compute(s); System.out.println(\"共有\" + sum + \"种走法\"); &#125; &#125; 【参考资料】： 面试题9:斐波那契数列 - xwdreamer - 博客园 PHP上台阶问题（斐波纳契数列应用）","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"新主题酝酿中...","slug":"新主题酝酿中","date":"2016-01-04T07:08:00.000Z","updated":"2017-02-17T06:10:53.991Z","comments":true,"path":"2016/01/04/新主题酝酿中/","link":"","permalink":"http://github.com/2016/01/04/新主题酝酿中/","excerpt":"人们对于“美”，都有着超乎自己想象的执念。 Website 冷淡简洁风格 jsdatav.is Akina theme 淡腾 louie iacool TA4.cn 波浪 EndSkin Wordpress主题 tagDiv &amp; （报纸）NEWSMAG 漂亮的蒙层 图集 from Dribbble","text":"人们对于“美”，都有着超乎自己想象的执念。 Website 冷淡简洁风格 jsdatav.is Akina theme 淡腾 louie iacool TA4.cn 波浪 EndSkin Wordpress主题 tagDiv &amp; （报纸）NEWSMAG 漂亮的蒙层 图集 from Dribbble from Dribbble from Dribbble from Dribbble","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}]},{"title":"好看的多说样式","slug":"好看的多说样式","date":"2016-01-03T07:08:00.000Z","updated":"2016-11-11T04:54:02.538Z","comments":true,"path":"2016/01/03/好看的多说样式/","link":"","permalink":"http://github.com/2016/01/03/好看的多说样式/","excerpt":"介于不想破坏主题评论框与整体的协调性，所以就把多说评论框的样式改成了跟主题自带评论一样的样子…下边是截图 多说样式 啊…简简单单就好，这个样式也是抄袭 jjlin 的，头像什么的都没有做动画 没意义我觉得","text":"介于不想破坏主题评论框与整体的协调性，所以就把多说评论框的样式改成了跟主题自带评论一样的样子…下边是截图 多说样式 啊…简简单单就好，这个样式也是抄袭 jjlin 的，头像什么的都没有做动画 没意义我觉得 下边是css代码 备份一下#ds-reset .ds-avatar img &#123;width:50px;height:auto ;border;border-radius: 50%;&#125;#ds-thread #ds-reset .ds-comment-body &#123;background:#f5f5f5;padding: 20px 20px;margin-left: 70px;border-radius: 4px;&#125;#ds-thread #ds-reset li.ds-post &#123;border-top: 0px dotted #ddd;&#125;#ds-thread #ds-reset ul.ds-children .ds-avatar img &#123;width: 40px;height: 40px;&#125;#ds-reset .ds-highlight &#123;color: #C76666 !important;&#125;#ds-thread #ds-reset .ds-comment-body, #ds-thread #ds-reset ul.ds-children .ds-comment-body &#123;padding-left: 20px;&#125;#ds-thread #ds-reset .ds-comment-header &#123;padding-top: 1px;padding-bottom: 10px;border-bottom: 1px dashed #ddd;&#125;a.ds-post-repost &#123;display:none&#125;#ds-thread #ds-reset .ds-comment-footer &#123;text-align: right;&#125;#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125;#ds-thread #ds-reset .ds-comments, #ds-thread #ds-reset .ds-paginator &#123;border-bottom: 0px dotted #ddd;&#125;#ds-reset .ds-avatar &#123;background-color: #FDFDFD;&#125;#ds-thread #ds-reset li.ds-tab a.ds-current &#123;background-color: rgb(50, 69, 93);padding: 10px;color: white;text-shadow: none;border:none&#125;#ds-thread #ds-reset .ds-textarea-wrapper &#123;background: #F5F5F5 !important;height: 110px;border: 0px solid #ccc;&#125;#ds-thread #ds-reset .ds-post-options &#123;margin-right: 0;border: 1px solid #FBFBFB;&#125;#ds-thread #ds-reset .ds-post-options .ds-sync &#123;display:none&#125;#ds-thread #ds-reset .ds-post-button &#123; background:#FF5B5B ;width:100px&#125;#ds-thread #ds-reset .ds-post-button:hover &#123;background:#484848&#125;#ds-thread #ds-reset .ds-replybox &#123;padding: 0 0 0 60px;&#125;#ds-reset .ds-avatar &#123; box-shadow: none;&#125;#ds-thread #ds-reset .ds-replybox .ds-avatar img &#123;width: 40px;height: 40px;&#125;#ds-thread #ds-reset .ds-comment-body p &#123;margin: 1em 0;&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}],"tags":[],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}]},{"title":"【Java】内部类（Inner Class）如何创建（new）","slug":"【Java】内部类（Inner Class）如何创建（new）","date":"2016-01-02T13:13:20.000Z","updated":"2016-10-18T04:56:45.206Z","comments":true,"path":"2016/01/02/【Java】内部类（Inner Class）如何创建（new）/","link":"","permalink":"http://github.com/2016/01/02/【Java】内部类（Inner Class）如何创建（new）/","excerpt":"简单来说，内部类（inner class）指那些类定义代码被置于其它类定义中的类；而对于一般的、类定义代码不嵌套在其它类定义中的类，称为顶层（top-level）类。对于一个内部类，包含其定义代码的类称为它的外部（outer）类。 那么对于内部类，该如何去使用呢？ 下面给出静态成员类（Static Member Class）和普通成员类（Member Class）使用的方式。 package cuc;import cuc.TestClass.Inner1;public class Main &#123; public static void main(String args[]) &#123; //静态的内部类 TestClass.Inner1 inner1 = new Inner1(); //和普通的顶层类new的方法一样 inner1.report(); //普通内部成员类 TestClass tc = new TestClass(); TestClass.Inner2 inner2 = tc.new Inner2(); //注意这里的使用方式 inner2.report(); &#125;&#125;","text":"简单来说，内部类（inner class）指那些类定义代码被置于其它类定义中的类；而对于一般的、类定义代码不嵌套在其它类定义中的类，称为顶层（top-level）类。对于一个内部类，包含其定义代码的类称为它的外部（outer）类。 那么对于内部类，该如何去使用呢？ 下面给出静态成员类（Static Member Class）和普通成员类（Member Class）使用的方式。 package cuc;import cuc.TestClass.Inner1;public class Main &#123; public static void main(String args[]) &#123; //静态的内部类 TestClass.Inner1 inner1 = new Inner1(); //和普通的顶层类new的方法一样 inner1.report(); //普通内部成员类 TestClass tc = new TestClass(); TestClass.Inner2 inner2 = tc.new Inner2(); //注意这里的使用方式 inner2.report(); &#125;&#125; 两种内部类的定义如下： package cuc;public class TestClass &#123; //静态成员类 public static class Inner1&#123; public void report()&#123; System.out.println(\"This is a inner class. (NOT static)\"); &#125; &#125; //普通内部成员类 public class Inner2&#123; public void report()&#123; System.out.println(\"This is a static inner class.\"); &#125; &#125;&#125; 【参考资料】：1、java - 内部类(Inner Class)详解","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】 加解密算法 HMAC 的使用","slug":"【Android】 加解密算法 HMAC 的使用","date":"2015-12-31T07:30:00.000Z","updated":"2017-09-13T11:08:21.005Z","comments":true,"path":"2015/12/31/【Android】 加解密算法 HMAC 的使用/","link":"","permalink":"http://github.com/2015/12/31/【Android】 加解密算法 HMAC 的使用/","excerpt":"1、HMAC算法&nbsp;&nbsp; HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 简而言之，HMAC就是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加上了密钥。因此MAC算法也经常被称作HMAC算法。关于hmac算法的详情可以参看RFC 2104(http://www.ietf.org/rfc/rfc2104.txt)，这里包含了HmacMD5算法的C语言实现。","text":"1、HMAC算法&nbsp;&nbsp; HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 简而言之，HMAC就是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加上了密钥。因此MAC算法也经常被称作HMAC算法。关于hmac算法的详情可以参看RFC 2104(http://www.ietf.org/rfc/rfc2104.txt)，这里包含了HmacMD5算法的C语言实现。 2、代码实现（Android）//这是HMAC的Android代码//之所以不是Java是因为代码中的Base64使用的是android.util包下的Base64类，而不是Java自带的Base64类。public class HMACTest &#123; private static final String LOG_TAG = \"HMACTest\"; private static final String REGISTER_HMAC_KEY = \"12a9cc3f-1fd9-48a3-1fd9-1fd9d027ac2\"; private String stringToSign(String data) &#123; try &#123; Mac mac = Mac.getInstance(\"HmacSHA1\"); SecretKeySpec secret = new SecretKeySpec( REGISTER_HMAC_KEY.getBytes(\"UTF-8\"), mac.getAlgorithm()); mac.init(secret); return Base64.encodeToString(mac.doFinal(data.getBytes()), Base64.NO_WRAP); &#125; catch (NoSuchAlgorithmException e) &#123; Log.e(LOG_TAG, \"Hash algorithm SHA-1 is not supported\", e); &#125; catch (UnsupportedEncodingException e) &#123; Log.e(LOG_TAG, \"Encoding UTF-8 is not supported\", e); &#125; catch (InvalidKeyException e) &#123; Log.e(LOG_TAG, \"Invalid key\", e); &#125; return \"\"; &#125; /* * 测试函数 */ public static void test() &#123; HMACTest hmac = new HMACTest(); String str = \"Bello, Miss.Seven\"; System.out.println(\"加密前：\" + str); System.out.println(\"加密后：\" + hmac.stringToSign(str)); &#125;&#125; 参考资料 消息摘要算法-HMAC算法 Java 加解密技术系列之 HMAC","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息","slug":"【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息","date":"2015-12-25T02:57:55.000Z","updated":"2017-09-06T03:13:22.869Z","comments":true,"path":"2015/12/25/【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息/","link":"","permalink":"http://github.com/2015/12/25/【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息/","excerpt":"","text":"​ Android App打包成Apk后，其实是一个压缩文件，可以将后缀名apk改为zip然后用winrar打开也能看到里面的文件结构。还能看到AndroidManifest.xml。但是里面的内容经过编码显示为乱码，不方便查看。 aapt工具：&nbsp;&nbsp;这里我们可以使用aapt工具来查看。aapt.exe工具即Android Asset Packaging Tool，在SDK的build-tools目录下。 &nbsp;&nbsp;该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件，尽管你可能没有直接使用过aapt工具，但是build scripts和IDE插件会使用这个工具打包apk文件构成一个Android 应用程序。在使用aapt之前需要在环境变量里面配置SDK-tools路径，或者是路径+aapt的方式进入aapt。 &nbsp;&nbsp;也就是说平时我们不会用这个东西，但是打包成Apk的时候其实是用到了的，只不过IDE替我们做了这一步，那么我们就用这个工具来查看VersionCode和VersionName。 操作流程：1、首先找到aapt工具，在Android SDK文件夹下的build-tools包里，如下：cd D:\\Android\\SDK\\build-tools\\23.0.0_rc3 2、然后使用aapt dump bading XXX.apkaapt dump badging C:\\Users\\kuguan\\Desktop\\app-release_1.0.9.apk 就能看到PackageName，VersionCode，LauncherActivity等信息，如下图： 应用包名PackageName： LauncherActivity：","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】不用循环语句如何输入打印数组元素","slug":"【Java】不用循环语句如何输入打印数组元素","date":"2015-12-09T05:58:20.000Z","updated":"2016-10-18T04:56:25.580Z","comments":true,"path":"2015/12/09/【Java】不用循环语句如何输入打印数组元素/","link":"","permalink":"http://github.com/2015/12/09/【Java】不用循环语句如何输入打印数组元素/","excerpt":"","text":"Java中可以使用Arrays.toString()来输出数组，免了使用各种循环来挨个print的痛苦。 package javacc.test;import java.util.Arrays; public class Test &#123; public static void main(String[] args) &#123; int[] array = &#123;0,1,4,7,2,5,8,3,6,9&#125;; System.out.println(Arrays.toString(array)); //注意这里的 Arrays.toString() &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】Activity与Fragment的生命周期的关系","slug":"【Android】Activity与Fragment的生命周期的关系","date":"2015-11-25T06:31:55.000Z","updated":"2016-11-28T08:18:13.210Z","comments":true,"path":"2015/11/25/【Android】Activity与Fragment的生命周期的关系/","link":"","permalink":"http://github.com/2015/11/25/【Android】Activity与Fragment的生命周期的关系/","excerpt":"一、问题描述： 假设有两个Activity（1和2）,每个Activity拥有一个Fragment，并分别有一个Button，点击Button1可以start Activity2，然后点击Button2可以finish掉自己（即Activity2）,然后返回到Activity1。根据这个简单模型描述一下Activity和Fragment的生命周期之间的依赖关系？","text":"一、问题描述： 假设有两个Activity（1和2）,每个Activity拥有一个Fragment，并分别有一个Button，点击Button1可以start Activity2，然后点击Button2可以finish掉自己（即Activity2）,然后返回到Activity1。根据这个简单模型描述一下Activity和Fragment的生命周期之间的依赖关系？ 二、生命周期知识Activity和Fragment的生命周期图谱可以参考我的另外一篇博客：【Android】Fragment的生命周期详解，他们的关系大致如下图： 三、代码验证 MainActivity和SecondActivity的布局是这样的，里面各添加了一个Fragment： /** * MainActivity布局xml文件 */&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;Button android:id=\"@+id/button\" android:text=\"开启第二个Activity\" android:layout_gravity=\"center\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt;&lt;/Button&gt; &lt;LinearLayout android:id=\"@+id/linearlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:background=\"#339999\"&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; /** * MainActivity.java代码，SecondActivity的代码与之类似，这里就不贴那么多了 */public class MainActivity extends Activity &#123; private static final String LOG_TAG = \"MainActivity\"; private Button mButton; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.w(LOG_TAG, \"==============onCreate()\"); FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); FirstFragment firstFragment = new FirstFragment(); fragmentTransaction.add(R.id.linearlayout, firstFragment); fragmentTransaction.commit(); mButton = (Button) findViewById(R.id.button); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.w(LOG_TAG, \"------------------mButton onClick-------------------\"); startActivity(new Intent(MainActivity.this, SecondActivity.class)); &#125; &#125;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.w(LOG_TAG, \"==============onStart()\"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.w(LOG_TAG, \"==============onRestart()\"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.w(LOG_TAG, \"==============onResume()\"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.w(LOG_TAG, \"==============onPause()\"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.w(LOG_TAG, \"==============onStop()\"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.w(LOG_TAG, \"==============onDestroy()\"); &#125;&#125; /** * FirstFragment.java代码， SecondFragment和它差不多一样 */public class FirstFragment extends Fragment &#123; private static final String LOG_TAG = \"FirstFragment\"; private static final String ARG_PARAM1 = \"param1\"; private static final String ARG_PARAM2 = \"param2\"; private String mParam1; private String mParam2; public FirstFragment() &#123; &#125; @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); Log.w(LOG_TAG, \"onAttach...\"); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.w(LOG_TAG, \"onCreate...\"); if (getArguments() != null) &#123; mParam1 = getArguments().getString(ARG_PARAM1); mParam2 = getArguments().getString(ARG_PARAM2); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; Log.w(LOG_TAG, \"onCreateView...\"); return inflater.inflate(R.layout.fragment_first, container, false); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); Log.w(LOG_TAG, \"onActivityCreated...\"); &#125; @Override public void onStart() &#123; super.onStart(); Log.w(LOG_TAG, \"onStart...\"); &#125; @Override public void onResume() &#123; super.onResume(); Log.w(LOG_TAG, \"onResume...\"); &#125; @Override public void onPause() &#123; super.onPause(); Log.w(LOG_TAG, \"onPause...\"); &#125; @Override public void onStop() &#123; super.onStop(); Log.w(LOG_TAG, \"onStop...\"); &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); Log.w(LOG_TAG, \"onDestroyView...\"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.w(LOG_TAG, \"onDestroy...\"); &#125; @Override public void onDetach() &#123; super.onDetach(); Log.w(LOG_TAG, \"onDetach...\"); &#125;&#125; 四、运行结果1、第一次打开以后： com.example.kuguan.anlearning W/MainActivity﹕ ==============onCreate()com.example.kuguan.anlearning W/FirstFragment﹕ onAttach...com.example.kuguan.anlearning W/FirstFragment﹕ onCreate...com.example.kuguan.anlearning W/FirstFragment﹕ onCreateView...com.example.kuguan.anlearning W/FirstFragment﹕ onActivityCreated...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume... 2、点击MainActivity中的按钮“打开第二个Activity”以后： com.example.kuguan.anlearning W/MainActivity﹕ ----------------mButton onClick-----------------com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/SecondFragment﹕ onAttach...com.example.kuguan.anlearning W/SecondFragment﹕ onCreate...com.example.kuguan.anlearning W/SecondFragment﹕ onCreateView...com.example.kuguan.anlearning W/SecondFragment﹕ onActivityCreated...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onStart()com.example.kuguan.anlearning W/SecondFragment﹕ onStart...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onResume()com.example.kuguan.anlearning W/SecondFragment﹕ onResume...com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop() 3、点击SecondActivity的按钮“finish”之后： com.example.kuguan.anlearning W/SecondActivity﹕ -----------------mButton onClick------------------com.example.kuguan.anlearning W/SecondFragment﹕ onPause...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onPause()com.example.kuguan.anlearning W/MainActivity﹕ ==============onRestart()com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume...com.example.kuguan.anlearning W/SecondFragment﹕ onStop...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onStop()com.example.kuguan.anlearning W/SecondFragment﹕ onDestroyView...com.example.kuguan.anlearning W/SecondFragment﹕ onDestroy...com.example.kuguan.anlearning W/SecondFragment﹕ onDetach...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onDestroy() 4、点击back键使MainActivity退到后台： com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop()com.example.kuguan.anlearning W/FirstFragment﹕ onDestroyView...com.example.kuguan.anlearning W/FirstFragment﹕ onDestroy...com.example.kuguan.anlearning W/FirstFragment﹕ onDetach...com.example.kuguan.anlearning W/MainActivity﹕ ==============onDestroy() 5、在MianActivity显示的时候，按HOME键： com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop() 6、然后再点击Icon打开： com.example.kuguan.anlearning W/MainActivity﹕ ==============onRestart()com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume... 【参考资料】：1、Fragment和Activity","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】Fragment的生命周期详解","slug":"【Android】Fragment的生命周期详解","date":"2015-11-25T03:43:55.000Z","updated":"2016-10-18T04:55:08.663Z","comments":true,"path":"2015/11/25/【Android】Fragment的生命周期详解/","link":"","permalink":"http://github.com/2015/11/25/【Android】Fragment的生命周期详解/","excerpt":"作为Android开发的基础知识，大家可能都了解Activity的生命周期，但是Fragment的生命周期和Activity生命周期之间的关系到底是怎么样的呢？相互调用机制又如何呢？ 一、我们首先观察一下Activity的生命周期：","text":"作为Android开发的基础知识，大家可能都了解Activity的生命周期，但是Fragment的生命周期和Activity生命周期之间的关系到底是怎么样的呢？相互调用机制又如何呢？ 一、我们首先观察一下Activity的生命周期： Fragment生命周期： Activity和Fragment生命周期的对比图：【参考资料】：1、Android Fragment源代码2、API Doc for fragments (Fragments | Android Developers)3、Fragment生命周期","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】长按连续触发事件的实现方法","slug":"【Android】长按连续触发事件的实现方法","date":"2015-11-19T06:35:55.000Z","updated":"2016-10-18T04:56:01.785Z","comments":true,"path":"2015/11/19/【Android】长按连续触发事件的实现方法/","link":"","permalink":"http://github.com/2015/11/19/【Android】长按连续触发事件的实现方法/","excerpt":"项目中需要实现一个类似购物车数量的小组件，需要单击时增加数量，长按时可以连续增大，之前的代码实现效果不理想，google后得到一个解决方法,测试可以完美实现。 实现效果大致如图： 【原理说明】 大致原理是,如果手指按在view上，则使用ScheduledExecutorService对象执行scheduleWithFixedDelay()方法，每隔一个间隔不停地向Handler发送Message，此处Message里的信息是View id，然后由Handler在handlemessage的时候处理需要触发的事件。","text":"项目中需要实现一个类似购物车数量的小组件，需要单击时增加数量，长按时可以连续增大，之前的代码实现效果不理想，google后得到一个解决方法,测试可以完美实现。 实现效果大致如图： 【原理说明】 大致原理是,如果手指按在view上，则使用ScheduledExecutorService对象执行scheduleWithFixedDelay()方法，每隔一个间隔不停地向Handler发送Message，此处Message里的信息是View id，然后由Handler在handlemessage的时候处理需要触发的事件。 【实现】 1、首先,让对应的View设置一个OnTouchListener，在手指按下时触发不停的发送消息,手指抬起时停止发送。 subtractButton.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_DOWN)&#123; updateAddOrSubtract(v.getId()); //手指按下时触发不停的发送消息 &#125;else if(event.getAction() == MotionEvent.ACTION_UP)&#123; stopAddOrSubtract(); //手指抬起时停止发送 &#125; return true; &#125; &#125;); 2、发送消息与终止方法：先定义一个ScheduledExecutorService对象，然后调用scheduleWithFixedDelay()方法 private ScheduledExecutorService scheduledExecutor;private void updateAddOrSubtract(int viewId) &#123; final int vid = viewId; scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); scheduledExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); msg.what = vid; handler.sendMessage(msg); &#125; &#125;, 0, 100, TimeUnit.MILLISECONDS); //每间隔100ms发送Message &#125; private void stopAddOrSubtract() &#123; if (scheduledExecutor != null) &#123; scheduledExecutor.shutdownNow(); scheduledExecutor = null; &#125; &#125; 3、用来处理Touch事件的Handler定义如下：private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; int viewId = msg.what; switch (viewId)&#123; case R.id.custom_number_picker_subtract_button: setValue(value - rangeability); //减小操作 break; case R.id.custom_number_picker_add_button: setValue(value + rangeability); //增大操作 break; &#125; &#125; &#125;;","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】HashMap 和 HashTable 的区别到底是什么？","slug":"【Java】HashMap 和 HashTable 的区别到底是什么？","date":"2015-11-10T03:55:00.000Z","updated":"2016-10-18T04:56:18.669Z","comments":true,"path":"2015/11/10/【Java】HashMap 和 HashTable 的区别到底是什么？/","link":"","permalink":"http://github.com/2015/11/10/【Java】HashMap 和 HashTable 的区别到底是什么？/","excerpt":"第一、继承不同第一个不同主要是历史原因。Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable, Serializable &#123;...&#125;public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;...&#125; 而HashMap继承的抽象类AbstractMap实现了Map接口： public abstract class AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;...&#125;","text":"第一、继承不同第一个不同主要是历史原因。Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable, Serializable &#123;...&#125;public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;...&#125; 而HashMap继承的抽象类AbstractMap实现了Map接口： public abstract class AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;...&#125; 第二、线程安全不一样Hashtable 中的方法是同步的，而HashMap中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 //这是Hashtable的put()方法:/** * Associate the specified value with the specified key in this * &#123;@code Hashtable&#125;. If the key already exists, the old value is replaced. * The key and value cannot be null. * * @param key * the key to add. * @param value * the value to add. * @return the old value associated with the specified key, or &#123;@code null&#125; * if the key did not exist. * @see #elements * @see #get * @see #keys * @see java.lang.Object#equals */ public synchronized V put(K key, V value) &#123; if (key == null) &#123; throw new NullPointerException(\"key == null\"); &#125; else if (value == null) &#123; throw new NullPointerException(\"value == null\"); &#125; int hash = Collections.secondaryHash(key); HashtableEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); HashtableEntry&lt;K, V&gt; first = tab[index]; for (HashtableEntry&lt;K, V&gt; e = first; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; //这是HashMap的put()方法:/** * Maps the specified key to the specified value. * * @param key * the key. * @param value * the value. * @return the value of any previous mapping with the specified key or * &#123;@code null&#125; if there was no such mapping. */ @Override public V put(K key, V value) &#123; if (key == null) &#123; return putValueForNullKey(value); &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; preModify(e); V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; 从上面的源代码可以看到Hashtable的put()方法是synchronized的，而HashMap的put()方法却不是。 第三、允不允许null值从上面的put()方法源码可以看到，Hashtable中，key和value都不允许出现null值，否则会抛出NullPointerException异常。而在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 第四、遍历方式的内部实现上不同Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 第五、哈希值的使用不同HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 第六、内部实现方式的数组的初始大小和扩容的方式不一样HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 【总结】： HashMap 线程不安全 允许有null的键和值 效率高一点、 方法不是Synchronize的要提供外同步 有containsvalue和containsKey方法 HashMap 是Java1.2 引进的Map interface 的一个实现 HashMap是Hashtable的轻量级实现 Hashtable 线程安全 不允许有null的键和值 效率稍低、 方法是是Synchronize的 有contains方法方法 Hashtable 继承于Dictionary 类 Hashtable 比HashMap 要旧 【建议】： 一些资料建议，当需要同步时，用Hashtable，反之用HashMap。但是，因为在需要时，HashMap可以被同步，HashMap的功能比Hashtable的功能更多，而且它不是基于一个陈旧的类的，所以有人认为，在各种情况下，HashMap都优先于Hashtable。 【参考资料】： 1、Hashtable、HashMap源代码 2、Java的HashMap和HashTable 3、HashMap与HashTable的区别","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"各种排序算法时间复杂度和空间复杂度表","slug":"各种排序算法时间复杂度和空间复杂度表","date":"2015-11-03T03:55:00.000Z","updated":"2017-07-17T06:44:07.870Z","comments":true,"path":"2015/11/03/各种排序算法时间复杂度和空间复杂度表/","link":"","permalink":"http://github.com/2015/11/03/各种排序算法时间复杂度和空间复杂度表/","excerpt":"各种排序算法时间复杂度和空间复杂度表: 比较时间复杂度函数的情况如下图： 对n较大的排序记录。一般的选择都是时间复杂度为O(nlog2n)的排序方法： 接下来博主抽时间要整理一下各经典算法思想和心得，敬请期待","text":"各种排序算法时间复杂度和空间复杂度表: 比较时间复杂度函数的情况如下图： 对n较大的排序记录。一般的选择都是时间复杂度为O(nlog2n)的排序方法： 接下来博主抽时间要整理一下各经典算法思想和心得，敬请期待 一、快速排序（Quicksort）import java.util.Arrays;public class MySort &#123; public static void main(String args[])&#123; int[] array = &#123;5,3,9,1,6,4,10,2,8,7&#125;; System.out.println(\"Before: \" + Arrays.toString(array)); new MySort().quickSort(array, 0, array.length-1); System.out.println(\"After: \" + Arrays.toString(array)); &#125; /** * 快速排序： 递归实现的挖坑填数法 * @param array * @param left * @param right */ private void quickSort(int[] array, int left, int right)&#123; if(left &gt;= right)&#123; return; &#125; int i = left; int j = right; int key = array[left]; while(i&lt;j)&#123; while(array[j] &gt;= key &amp;&amp; i&lt;j)&#123; //从后向前搜索，比key小的值就挖出来填到i处的坑 j--; &#125; array[i] = array[j]; while(array[i] &lt;= key &amp;&amp; i&lt;j)&#123; //从前向后搜索，找出比key大的值填到刚才j处空缺的坑 i++; &#125; array[j] = array[i]; &#125; array[i] = key; //把key回填到数组的空缺处 System.out.println(\"Sort: \" + Arrays.toString(array)); quickSort(array, left, i-1); quickSort(array, i+1, right); &#125;&#125; 快速排序的测试代码输出结果如下：Before: [5, 3, 9, 1, 6, 4, 10, 2, 8, 7]Sort: [2, 3, 4, 1, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 4, 3, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 7, 9, 8, 10]Sort: [1, 2, 3, 4, 5, 6, 7, 9, 8, 10]Sort: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]After: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 【参考资料】： 白话经典算法系列之六 快速排序 快速搞定 必须知道的八大种排序算法【java实现】","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Java】函数中的参数传递是“引用传递”还是“值传递”？","slug":"【Java】函数中的参数传递是“引用传递”还是“值传递”？","date":"2015-11-02T07:33:20.000Z","updated":"2016-10-18T04:56:41.696Z","comments":true,"path":"2015/11/02/【Java】函数中的参数传递是“引用传递”还是“值传递”？/","link":"","permalink":"http://github.com/2015/11/02/【Java】函数中的参数传递是“引用传递”还是“值传递”？/","excerpt":"问题引入：在一个快速排序的函数 private void quickSort(List intList, int left, int right) 中，传进去的参数intList是对象传递还是引用传递呢？ 先抛出结论： 将对象（对象的引用）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的对象。 当将基本类型或基本类型的包装集作为参数传递时，传递的是值。也就是说函数内对参数所做的修改不会影响原来的变量。 数组(数组引用)）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的数组。 String类型(引用)作为参数传递时传递的是引用，只是对String做出任何修改时有一个新的String对象会产生，原来的String对象的值不会做任何修改。(但是可以将新的对象的 引用赋给原来的引用,这样给人的表面现象就是原来的对象变了，其实没有变，只是原来指向它的引用指向了新的对象)。","text":"问题引入：在一个快速排序的函数 private void quickSort(List intList, int left, int right) 中，传进去的参数intList是对象传递还是引用传递呢？ 先抛出结论： 将对象（对象的引用）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的对象。 当将基本类型或基本类型的包装集作为参数传递时，传递的是值。也就是说函数内对参数所做的修改不会影响原来的变量。 数组(数组引用)）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的数组。 String类型(引用)作为参数传递时传递的是引用，只是对String做出任何修改时有一个新的String对象会产生，原来的String对象的值不会做任何修改。(但是可以将新的对象的 引用赋给原来的引用,这样给人的表面现象就是原来的对象变了，其实没有变，只是原来指向它的引用指向了新的对象)。 举例一：public class Mainjava &#123; String str=new String(&quot;good&quot;); char[] ch=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;; Integer i = 0; int x = 0; Test t1 = new Test(); Test t2 = new Test(); public static void main(String args[])&#123; Mainjava ex=new Mainjava(); ex.change(ex.str,ex.ch, ex.x, ex.i, ex.t1, ex.t2); System.out.print(ex.str + &quot; and &quot;); System.out.print(String.valueOf(ex.ch) + &quot; and &quot;); System.out.print(ex.x + &quot;,&quot; + ex.i + &quot;,&quot; + ex.t1.getA() + &quot;,&quot; + ex.t2.getA()); &#125; public void change(String str, char ch[], int x, Integer i, Test t1, Test t2)&#123; str=&quot;test ok&quot;; ch[0]=&apos;g&apos;; x = 2; i = 5; Test newT = new Test(); newT.setA(99); t1 = newT; t2.setA(33); &#125;&#125;//Test类public class Test &#123; private int a = 0; public void setA(int a)&#123; this.a = a; &#125; public int getA()&#123; return a; &#125;&#125; 输出结果是多少呢？ good and gbc and 0,0,0,33 为什么不是”test ok and gbc and 2,5,99,33”呢？ 因为str是引用数据类型String,而字符数组是基本数据类型,二者存放在内存中的机制是不一样的!public void change(String str, char ch[], int x)&#123; str = &quot;test ok&quot;; ch[0] = &apos;g&apos;; x = 2;&#125; change()方法传入str,虽然把”test ok”强行赋给str,但是这里的str存放在新的栈内存中,和原来的str存放的地址不一样,所以你System.out.print(ex.str+”and”);这里的输出还是调用原来内存中的str;字符数组不一样,你声明一个字符数组之后,那个数组的位置就定死了,你调用change()之后,把原来的字符数组的第1个元素改为了g.这就是引用数据类型和基本数据类型的区别。 举例二： import java.util.ArrayList;import java.util.List;public class Mainjava &#123; public static void main(String args[])&#123; List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;(); integerList.add(7); integerList.add(1); integerList.add(3); integerList.add(8); integerList.add(9); integerList.add(2); integerList.add(5); integerList.add(4); integerList.add(10); integerList.add(6); print(integerList); quickSort(integerList, 0, integerList.size()-1); print(integerList); /*对比排序前后的integerList中的值，如果发生改变，说明是引用传递，即传递的是对象地址值*/ &#125; private static void quickSort(List&lt;Integer&gt; intList, int left, int right)&#123; if(left &gt;= right) &#123; return; &#125; int i = left; int j = right; int key = intList.get(i); System.out.println(&quot;key:&quot;+&quot;intList.get(&quot;+i+&quot;)=&quot;+key); while(i &lt; j)&#123; while(i &lt; j &amp;&amp; intList.get(j) &gt;= key)&#123; j--; &#125; intList.set(i, intList.get(j)); while(i &lt; j &amp;&amp; intList.get(i) &lt;= key)&#123; i++; &#125; intList.set(j, intList.get(i)); &#125; intList.set(i, key); quickSort(intList, left, i - 1); quickSort(intList, i + 1, right); &#125; private static void print(List&lt;Integer&gt; intList)&#123; for (int i = 0; i &lt; intList.size(); i++) &#123; System.out.print(intList.get(i)+&quot;, &quot;); &#125; System.out.println(&quot;&quot;); &#125;&#125; 运行输出结果如下： 7, 1, 3, 8, 9, 2, 5, 4, 10, 6,key:intList.get(0)=7key:intList.get(0)=6key:intList.get(0)=2key:intList.get(2)=3key:intList.get(3)=4key:intList.get(7)=91, 2, 3, 4, 5, 6, 7, 8, 9, 10, 结论： 实验证明，Java中函数传递对象时，传递的是该对象的地址值，即引用传递。函数传递基本类型数据时，传递的是值，也就是说函数返回之后不会改变这个值。","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】Activity四种启动模式","slug":"【Android】Activity四种启动模式","date":"2015-10-09T12:03:00.000Z","updated":"2017-10-13T09:45:31.131Z","comments":true,"path":"2015/10/09/【Android】Activity四种启动模式/","link":"","permalink":"http://github.com/2015/10/09/【Android】Activity四种启动模式/","excerpt":"Task栈每个应用都有一个任务栈，是用来存放Activity的，功能类似于函数调用的栈，先后顺序代表了Activity的出现顺序；比如Activity1–&gt;Activity2–&gt;Activity3，则任务栈为： 四种启动模式启动模式简单地说就是Activity启动时的策略，在AndroidManifest.xml中的标签的android:launchMode属性设置； 启动模式有4种，分别为standard、singleTop、singleTask、singleInstance；","text":"Task栈每个应用都有一个任务栈，是用来存放Activity的，功能类似于函数调用的栈，先后顺序代表了Activity的出现顺序；比如Activity1–&gt;Activity2–&gt;Activity3，则任务栈为： 四种启动模式启动模式简单地说就是Activity启动时的策略，在AndroidManifest.xml中的标签的android:launchMode属性设置； 启动模式有4种，分别为standard、singleTop、singleTask、singleInstance； 1、standard每次激活Activity时(startActivity)，都创建Activity实例，并放入任务栈； 2、singleTop（栈顶复用模式）如果某个Activity自己激活自己，即任务栈栈顶就是该Activity，则不需要创建，其余情况都要创建Activity实例； singleTop模式分3种情况： 当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法。 当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例 当前栈中不存在该Activity的实例时，其行为同standard启动模式。 3、singleTask（栈内复用模式）如果要激活的那个Activity在任务栈中存在该实例，则不需要创建，只需要把此Activity放入栈顶，并把该Activity以上的Activity实例都pop singleTask启动模式启动Activity时，首先会根据taskAffinity去寻找当前是否存在一个对应名字的任务栈 如果不存在，则会创建一个新的Task，并创建新的Activity实例入栈到新创建的Task中去 如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例 如果存在实例，则将它上面的Activity实例都出栈，然后回调启动的Activity实例的onNewIntent方法 如果不存在该实例，则新建Activity，并入栈 4、singleInstance（全局唯一模式）如果应用1的任务栈中创建了MainActivity实例，如果应用2也要激活MainActivity，则不需要创建，两应用共享该Activity实例； 该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 根据上面的讲解，并且参考谷歌官方文档，singleInstance的特点可以归结为以下三条： 以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例 以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中（官方文档上的描述为，singleInstance模式的Activity不允许其他Activity和它共存在一个任务中） 被singleInstance模式的Activity开启的其他activity，能够开启一个新任务，但不一定开启新的任务，也可能在已有的一个任务中开启 参考资料 Android入门：Activity四种启动模式 Android–Activity的启动模式 基础总结篇之二：Activity的四种launchMode Android中Activity四种启动模式和taskAffinity属性详解 彻底弄懂Activity四大启动模式 Activity四种启动模式","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】onActivityResult()和onResume()的调用顺序问题","slug":"【Android】onActivityResult()和onResume()的调用顺序问题","date":"2015-09-18T09:16:55.000Z","updated":"2016-10-18T04:55:17.484Z","comments":true,"path":"2015/09/18/【Android】onActivityResult()和onResume()的调用顺序问题/","link":"","permalink":"http://github.com/2015/09/18/【Android】onActivityResult()和onResume()的调用顺序问题/","excerpt":"在Android生命周期中，如果使用到startActivityForResult()，则在新Activity被finish掉之后，onActivityResult()和onResume()到底是哪一个先调用的呢？ 我们来看官方源码： /** * Called when an activity you launched exits, giving you the requestCode * you started it with, the resultCode it returned, and any additional * data from it. The &lt;var&gt;resultCode&lt;/var&gt; will be * {@link #RESULT_CANCELED} if the activity explicitly returned that, * didn't return any result, or crashed during its operation. * * &lt;p&gt;You will receive this call immediately before onResume() when your * activity is re-starting. * * &lt;p&gt;This method is never invoked if your activity sets * {@link android.R.styleable#AndroidManifestActivity_noHistory noHistory} to * &lt;code&gt;true&lt;/code&gt;. * * @param requestCode The integer request code originally supplied to * startActivityForResult(), allowing you to identify who this * result came from. * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \"extras\"). * * @see #startActivityForResult * @see #createPendingResult * @see #setResult(int) */ protected void onActivityResult(int requestCode, int resultCode, Intent data) { }","text":"在Android生命周期中，如果使用到startActivityForResult()，则在新Activity被finish掉之后，onActivityResult()和onResume()到底是哪一个先调用的呢？ 我们来看官方源码： /** * Called when an activity you launched exits, giving you the requestCode * you started it with, the resultCode it returned, and any additional * data from it. The &lt;var&gt;resultCode&lt;/var&gt; will be * {@link #RESULT_CANCELED} if the activity explicitly returned that, * didn't return any result, or crashed during its operation. * * &lt;p&gt;You will receive this call immediately before onResume() when your * activity is re-starting. * * &lt;p&gt;This method is never invoked if your activity sets * {@link android.R.styleable#AndroidManifestActivity_noHistory noHistory} to * &lt;code&gt;true&lt;/code&gt;. * * @param requestCode The integer request code originally supplied to * startActivityForResult(), allowing you to identify who this * result came from. * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \"extras\"). * * @see #startActivityForResult * @see #createPendingResult * @see #setResult(int) */ protected void onActivityResult(int requestCode, int resultCode, Intent data) { } &#160; &#160; &#160; &#160;从上面的源码注释第二段可以看到：You will receive this call immediately before onResume() when your activity is re-starting. 所以很明显，在activity重新恢复启动的时候，onActivityResult()会在onResume()之前调用完毕。 &#160; &#160; &#160; &#160;而且，onActivityResult()还会在onStart()之前调用完毕。经过断点调试，发现它们三者的调用顺序如下： onActivityResult() -&gt; onStart() -&gt; onResume()","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】如何启动调用其他app中的Activity","slug":"【Android】如何启动调用其他app中的Activity","date":"2015-09-15T03:06:00.000Z","updated":"2016-10-18T04:55:55.045Z","comments":true,"path":"2015/09/15/【Android】如何启动调用其他app中的Activity/","link":"","permalink":"http://github.com/2015/09/15/【Android】如何启动调用其他app中的Activity/","excerpt":"最近项目正在将原系统拆分为小型App，所以需要在原Project中启动另一个新的App中的Activity。这样的话启动要用到ComponentName ，它就是用来打开其他应用程序中的Activity或服务的。 用法其实很简单，像下面这样： //第一个参数是Activity所在的package包名，第二个参数是完整的Class类名（包括包路径）ComponentName componetName = new ComponentName(\"com.cybo3d.cybox.miya\", \"com.cybo3d.cybox.miya.MainActivity\");Intent intent = new Intent();intent.setComponent(componetName);startActivity(intent);","text":"最近项目正在将原系统拆分为小型App，所以需要在原Project中启动另一个新的App中的Activity。这样的话启动要用到ComponentName ，它就是用来打开其他应用程序中的Activity或服务的。 用法其实很简单，像下面这样： //第一个参数是Activity所在的package包名，第二个参数是完整的Class类名（包括包路径）ComponentName componetName = new ComponentName(\"com.cybo3d.cybox.miya\", \"com.cybo3d.cybox.miya.MainActivity\");Intent intent = new Intent();intent.setComponent(componetName);startActivity(intent); 我们来看源码中ComponentName的参数信息，pkg和cls均不能为null。此处特别注意第二个参数cls必须为 完整的Class类名。 /** * Create a new component identifier. * * @param pkg The name of the package that the component exists in. Can * not be null. * @param cls The name of the class inside of &lt;var&gt;pkg&lt;/var&gt; that * implements the component. Can not be null. */ public ComponentName(String pkg, String cls) &#123; if (pkg == null) throw new NullPointerException(\"package name is null\"); if (cls == null) throw new NullPointerException(\"class name is null\"); mPackage = pkg; mClass = cls; &#125; 另外，在调用的时候一定要保证在Manifest.xml中设置被启动Activity的exported=true，否则会报错Activity is not found.","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】保存图片到系统图库, 并立即显示在图库中","slug":"【Android】保存图片到系统图库, 并立即显示在图库中","date":"2014-09-12T03:55:00.000Z","updated":"2017-08-29T02:41:16.537Z","comments":true,"path":"2014/09/12/【Android】保存图片到系统图库, 并立即显示在图库中/","link":"","permalink":"http://github.com/2014/09/12/【Android】保存图片到系统图库, 并立即显示在图库中/","excerpt":"搬运原链接：http://stormzhang.github.io/android/2014/07/24/android-save-image-to-gallery 正文最近有些用户反映保存图片之后在系统图库找不到保存的图片，遂决定彻底查看并解决下。 Android中保存图片的方法可能有如下两种： 第一种是自己写方法，如下代码： public static File saveImage(Bitmap bmp) &#123; File appDir = new File(Environment.getExternalStorageDirectory(), \"Boohee\"); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + \".jpg\"; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","text":"搬运原链接：http://stormzhang.github.io/android/2014/07/24/android-save-image-to-gallery 正文最近有些用户反映保存图片之后在系统图库找不到保存的图片，遂决定彻底查看并解决下。 Android中保存图片的方法可能有如下两种： 第一种是自己写方法，如下代码： public static File saveImage(Bitmap bmp) &#123; File appDir = new File(Environment.getExternalStorageDirectory(), \"Boohee\"); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + \".jpg\"; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 以上代码便是将Bitmap保存图片到指定的路径/sdcard/Boohee/下，文件名以当前系统时间命名,但是这种方法保存的图片没有加入到系统图库中 第二种是调用系统提供的插入图库的方法： MediaStore.Images.Media.insertImage(getContentResolver(), bitmap, \"title\", \"description\"); 调用以上系统自带的方法会把bitmap对象保存到系统图库中，但是这种方法无法指定保存的路径和名称，上述方法的title、description参数只是插入数据库中的字段，真实的图片名称系统会自动分配。 看似上述第二种方法就是我们要用到的方法，但是可惜的调用上述第二种插入图库的方法图片并没有立刻显示在图库中，而我们需要立刻更新系统图库以便让用户可以立刻查看到这张图片。 更新系统图库的方法sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse(\"file://\"+ Environment.getExternalStorageDirectory()))); 上面那条广播是扫描整个sd卡的广播，如果你sd卡里面东西很多会扫描很久，在扫描当中我们是不能访问sd卡，所以这样子用户体现很不好，所以下面我们还有如下的方法： sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(new File(\"/sdcard/Boohee/image.jpg\")));); 或者还有如下方法： final MediaScannerConnection msc = new MediaScannerConnection(mContext, new MediaScannerConnectionClient() &#123; public void onMediaScannerConnected() &#123; msc.scanFile(\"/sdcard/Boohee/image.jpg\", \"image/jpeg\"); &#125; public void onScanCompleted(String path, Uri uri) &#123; Log.v(TAG, \"scan completed\"); msc.disconnect(); &#125; &#125;); 上面代码的图片路径不管是通过自己写方法还是系统插入图库的方法都可以很容易的获取到。 终极完美解决方案那么到这里可能有人又会问了，如果我想把图片保存到指定的文件夹，同时又需要图片出现在图库里呢？答案是可以的，sdk还提供了这样一个方法: MediaStore.Images.Media.insertImage(getContentResolver(), \"image path\", \"title\", \"description\"); 上述方法的第二个参数是image path，这样的话就有思路了，首先自己写方法把图片指定到指定的文件夹，然后调用上述方法把刚保存的图片路径传入进去，最后通知图库更新。 所以写了一个方法，完整的代码如下： public static void saveImageToGallery(Context context, Bitmap bmp) &#123; // 首先保存图片 File appDir = new File(Environment.getExternalStorageDirectory(), \"Boohee\"); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + \".jpg\"; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 其次把文件插入到系统图库 try &#123; MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), fileName, null); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; // 最后通知图库更新 context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(\"file://\" + path)));&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"如何删除多行首字母，Sublime Text多行编辑运用","slug":"如何删除多行首字母，Sublime Text多行编辑运用","date":"2014-05-15T03:55:00.000Z","updated":"2016-10-18T04:58:04.697Z","comments":true,"path":"2014/05/15/如何删除多行首字母，Sublime Text多行编辑运用/","link":"","permalink":"http://github.com/2014/05/15/如何删除多行首字母，Sublime Text多行编辑运用/","excerpt":"一、问题描述：问答区有个问题是这样问的：如何在eclipse中删除多行首字母？ 题主的问题是代码中每行都有序号，这些序号一行一行地删太麻烦，如何进行批量删除？我们在进行代码重用的时候时常会出现行号同时被复制的情况，比如下面的这点代码： 155. @Override 156. public boolean onKeyDown(int keyCode, KeyEvent event) 157. &#123; 158. Log.d(\"onKeyDown:\", \" keyCode=\" + keyCode + \" KeyEvent=\" + event); 159. switch (keyCode) 160. &#123; 161. case KeyEvent.KEYCODE_DPAD_UP: 162. 163. break; 164. case KeyEvent.KEYCODE_DPAD_DOWN: 165. 166. break; 167. case KeyEvent.KEYCODE_DPAD_LEFT: 168. //右左按键可以控制第一进度的增减 169. pb.setProgress( pb.getProgress()-5 ); 170. break; 171. case KeyEvent.KEYCODE_DPAD_RIGHT: 172. pb.setProgress( pb.getProgress()+5 ); 173. break; 174. case KeyEvent.KEYCODE_DPAD_CENTER: 175. 176. break; 177. case KeyEvent.KEYCODE_0: 178. break; 179. &#125; 180. return super.onKeyDown(keyCode, event); 181. &#125; 182. &#125;","text":"一、问题描述：问答区有个问题是这样问的：如何在eclipse中删除多行首字母？ 题主的问题是代码中每行都有序号，这些序号一行一行地删太麻烦，如何进行批量删除？我们在进行代码重用的时候时常会出现行号同时被复制的情况，比如下面的这点代码： 155. @Override 156. public boolean onKeyDown(int keyCode, KeyEvent event) 157. &#123; 158. Log.d(\"onKeyDown:\", \" keyCode=\" + keyCode + \" KeyEvent=\" + event); 159. switch (keyCode) 160. &#123; 161. case KeyEvent.KEYCODE_DPAD_UP: 162. 163. break; 164. case KeyEvent.KEYCODE_DPAD_DOWN: 165. 166. break; 167. case KeyEvent.KEYCODE_DPAD_LEFT: 168. //右左按键可以控制第一进度的增减 169. pb.setProgress( pb.getProgress()-5 ); 170. break; 171. case KeyEvent.KEYCODE_DPAD_RIGHT: 172. pb.setProgress( pb.getProgress()+5 ); 173. break; 174. case KeyEvent.KEYCODE_DPAD_CENTER: 175. 176. break; 177. case KeyEvent.KEYCODE_0: 178. break; 179. &#125; 180. return super.onKeyDown(keyCode, event); 181. &#125; 182. &#125; 这是博主从别处摘来的代码粘贴在Eclipse中的，很明显行号也被复制了进来。 对于这样的问题，如果代码行数真的多到可以用来数绵羊了，还用Delete键一行一行地解决可真就轻而易举地抑郁了哭 #其实我有特别的患抑郁症技巧# 二、解决办法：解决办法就是利用Sublime Text的多行编辑功能删除掉行首的序号。在Sublime Text中打开或者粘贴你想清理的代码，然后选中所有行 选中需要清理的所有行 按下Ctrl + Shift + L（Command + Shift + L）——— 可以同时编辑这些行 用左右方向键把光标移动到行首，然后按下 Delete键 或者 Backspace退格键 来删除行号。","categories":[],"tags":[],"keywords":[]},{"title":"Ubuntu上Eclipse识别不了Android手机的解决方法","slug":"Ubuntu上Eclipse识别不了Android手机的解决方法","date":"2013-10-20T08:46:00.000Z","updated":"2016-10-18T04:57:41.236Z","comments":true,"path":"2013/10/20/Ubuntu上Eclipse识别不了Android手机的解决方法/","link":"","permalink":"http://github.com/2013/10/20/Ubuntu上Eclipse识别不了Android手机的解决方法/","excerpt":"转载链接： http://www.cnblogs.com/AndroidManifest/archive/2011/12/09/2281635.html google官方开发向导里对Android手机已经设置了允许安装非market程序，并且处于usb调试模式，但是仍然在usb连接电脑后无法被识别的问题作了解释。官方网址：http://developer.android.com/guide/developing/device.html 操作步骤：如果是windows平台下，需要安装一个为adb准备的usb驱动。如果是Ubuntu Linux需要添加一个rules文件，里面包含了每一个想要调试的设备的usb配置信息。以HTC手机为例实现步骤如下： 1、在终端输入 : sudo gedit /etc/udev/rules.d/51-android.rules","text":"转载链接： http://www.cnblogs.com/AndroidManifest/archive/2011/12/09/2281635.html google官方开发向导里对Android手机已经设置了允许安装非market程序，并且处于usb调试模式，但是仍然在usb连接电脑后无法被识别的问题作了解释。官方网址：http://developer.android.com/guide/developing/device.html 操作步骤：如果是windows平台下，需要安装一个为adb准备的usb驱动。如果是Ubuntu Linux需要添加一个rules文件，里面包含了每一个想要调试的设备的usb配置信息。以HTC手机为例实现步骤如下： 1、在终端输入 : sudo gedit /etc/udev/rules.d/51-android.rules 2、在打开的文件里加入 SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;0bb4&quot;, MODE=&quot;0666&quot; 3、保存退出后在终端执行 : sudo chmod a+r /etc/udev/rules.d/51-android.rules 重新将手机连接到电脑后HTC手机就可以被正常识别了。注意：如果按步骤操作仍不能识别的，检查 ATTR{idVendor} 值里的字母是否是小写。 如果是别的厂家的手机，需要在步骤2更改ATTR{idVendor}的值。如果要添加多个厂家的手机，重复步骤2。其他usb供应商的ID如下： Company USB Vendor ID Acer 0502 ASUS 0B05 Dell 413C Foxconn 0489 Garmin-Asus 091E Google 18D1 HTC 0BB4 Huawei 12D1 K-Touch 24E3 KT Tech 2116 Kyocera 0482 Lenevo 17EF LG 1004 Motorola 22B8 NEC 0409 Nook 2080 Nvidia 0955 OTGV 2257 Pantech 10A9 Pegatron 1D4D Philips 0471 PMC-Sierra 04DA Qualcomm 05C6 SK Telesys 1F53 Samsung 04E8 Sharp 04DD Sony Ericsson 0FCE Toshiba 0930 ZTE 19D2 注意：如果按步骤操作仍不能识别的，检查 ATTR{idVendor} 值里的字母是否是小写。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】操作excel表，包括创建、读取、以及修改","slug":"【Java】操作excel表，包括创建、读取、以及修改","date":"2013-08-01T04:31:20.000Z","updated":"2016-10-18T04:56:35.699Z","comments":true,"path":"2013/08/01/【Java】操作excel表，包括创建、读取、以及修改/","link":"","permalink":"http://github.com/2013/08/01/【Java】操作excel表，包括创建、读取、以及修改/","excerpt":"作者的网站上对它的特征有如下描述： 支持Excel 95-2000的所有版本 生成Excel 2000标准格式 支持字体、数字、日期操作 能够修饰单元格属性 支持图像和图表 应该说以上功能已经能够大致满足我们的需要。最关键的是这套API是纯Java的，并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。 搭建环境下载jxl.jar（可以点击这里进行下载），放入classpath，安装就完成了。","text":"作者的网站上对它的特征有如下描述： 支持Excel 95-2000的所有版本 生成Excel 2000标准格式 支持字体、数字、日期操作 能够修饰单元格属性 支持图像和图表 应该说以上功能已经能够大致满足我们的需要。最关键的是这套API是纯Java的，并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。 搭建环境下载jxl.jar（可以点击这里进行下载），放入classpath，安装就完成了。 基本操作一、创建文件拟生成一个名为“测试数据.xls”的Excel文件，其中第一个工作表被命名为“第一页”。代码（CreateXLS.java）： //生成Excel的类 import java.io. * ;import jxl. * ;import jxl.write. * ;public class CreateXLS &#123; public static void main(String args[]) &#123; try &#123; //打开文件 WritableWorkbook book = Workbook.createWorkbook(new File(“测试.xls”)); //生成名为“第一页”的工作表，参数0表示这是第一页 WritableSheet sheet = book.createSheet(“第一页”, 0); //在Label对象的构造子中指名单元格位置是第一列第一行(0,0) //以及单元格内容为test Label label = new Label(0, 0, ”test”); //将定义好的单元格添加到工作表中 sheet.addCell(label); /*生成一个保存数字的单元格, 必须使用Number的完整包路径，否则有语法歧义 单元格位置是第二列，第一行，值为789.123*/ jxl.write.Number number = new jxl.write.Number(1, 0, 789.123); sheet.addCell(number); //写入数据并关闭文件 book.write(); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 编译执行后，会在当前位置产生一个Excel文件。 二、读取文件以刚才我们创建的Excel文件为例，做一个简单的读取操作，程序代码如下： //读取Excel的类 import java.io. * ;import jxl. * ;public class ReadXLS &#123; public static void main(String args[]) &#123; try &#123; Workbook book = Workbook.getWorkbook(new File(“测试.xls”)); //获得第一个工作表对象 Sheet sheet = book.getSheet(0); //得到第一列第一行的单元格 Cell cell1 = sheet.getCell(0, 0); String result = cell1.getContents(); System.out.println(result); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 三、修改文件利用jExcelAPI可以修改已有的Excel文件，修改Excel文件的时候，除了打开文件的方式不同之外，其他操作和创建Excel是一样的。下面的例子是在我们已经生成的Excel文件中添加一个工作表： //修改Excel的类，添加一个工作表 import java.io.*;import jxl.*;import jxl.write.*;public class UpdateXLS &#123; public static void main(String args[]) &#123; try &#123; //Excel获得文件 Workbook wb = Workbook.getWorkbook(new File(“测试.xls”)); //打开一个文件的副本，并且指定数据写回到原文件 WritableWorkbook book = Workbook.createWorkbook(new File(“测试.xls”), wb); //添加一个工作表 WritableSheet sheet = book.createSheet(“第二页”, 1); sheet.addCell(new Label(0, 0, ”第二页的测试数据”)); book.write(); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 高级操作一、 数据格式化在Excel中不涉及复杂的数据类型，能够比较好的处理字串、数字和日期已经能够满足一般的应用。 1、 字串格式化字符串的格式化涉及到的是字体、粗细、字号等元素，这些功能主要由WritableFont和WritableCellFormat类来负责。假设我们在生成一个含有字串的单元格时，使用如下语句，为方便叙述，我们为每一行命令加了编号： WritableFont font1=new WritableFont(WritableFont.TIMES,16,WritableFont.BOLD); 或//设置字体格式为excel支持的格式 WritableFont font3=new WritableFont(WritableFont.createFont(“楷体 _GB2312”),12,WritableFont.NO_BOLD );① WritableCellFormat format1=new WritableCellFormat(font1); ② Label label=new Label(0,0,”data 4 test”,format1) ③ 其中①指定了字串格式：字体为TIMES，字号16，加粗显示。WritableFont有非常丰富的构造子，供不同情况下使用，jExcelAPI的 java-doc中有详细列表，这里不再列出。 ②处代码使用了WritableCellFormat类，这个类非常重要，通过它可以指定单元格的各种属性，后面的单元格格式化中会有更多描述。 ③处使用了Label类的构造子，指定了字串被赋予那种格式。 在WritableCellFormat类中，还有一个很重要的方法是指定数据的对齐方式，比如针对我们上面的实例，可以指定： //把水平对齐方式指定为居中 format1.setAlignment(jxl.format.Alignment.CENTRE); //把垂直对齐方式指定为居中 format1.setVerticalAlignment(jxl.format.VerticalAlignment.CENTRE);//设置自动换行format1.setWrap(true); 二、单元格操作Excel中很重要的一部分是对单元格的操作，比如行高、列宽、单元格合并等，所幸jExcelAPI提供了这些支持。这些操作相对比较简单，下面只介绍一下相关的API。 1、 合并单元格 WritableSheet.mergeCells(int m,int n,int p,int q);作用是从(m,n)到(p,q)的单元格全部合并，比如： WritableSheet sheet=book.createSheet(“第一页”,0); //合并第一列第一行到第六列第一行的所有单元格 sheet.mergeCells(0,0,5,0); 合并既可以是横向的，也可以是纵向的。合并后的单元格不能再次进行合并，否则会触发异常。 2、 行高和列宽 WritableSheet.setRowView(int i,int height);作用是指定第i+1行的高度，比如： //将第一行的高度设为200 sheet.setRowView(0,200); WritableSheet.setColumnView(int i,int width);作用是指定第i+1列的宽度，比如： //将第一列的宽度设为30 sheet.setColumnView(0,30); 三、操作图片public static void write() throws Exception &#123; WritableWorkbook wwb = Workbook.createWorkbook(new File(\"c:/1.xls\")); WritableSheet ws = wwb.createSheet(\"Test Sheet 1\", 0); File file = new File(\"C:\\\\jbproject\\\\PVS\\\\WebRoot\\\\weekhit\\\\1109496996281.png\"); WritableImage image = new WritableImage(1, 4, 6, 18, file); ws.addImage(image); wwb.write(); wwb.close();&#125; 很简单和插入单元格的方式一样，不过就是参数多了些，WritableImage这个类继承了Draw，上面只是他构造方法的一种，最后一个参数不用了说 了，前面四个参数的类型都是double，依次是 x, y, width, height,注意，这里的宽和高可不是图片的宽和高，而是图片所要占的单位格的个数，因为继承的Draw所以他的类型必须是double，具体里面怎么 实现的我还没细看：）因为着急赶活，先完成功能，其他的以后有时间慢慢研究。以后会继续写出在使用中的心得给大家。 总结1、读 读的时候是这样的一个思路,先用一个输入流(InputStream)得到Excel文件,然后用jxl中的Workbook得到工作薄,用Sheet从工作薄中得到工作表,用Cell得到工作表中得某个单元格.InputStream-&gt;Workbook-&gt;Sheet-&gt;Cell,就得到了excel文件中的单元格 String path = \"c:\\\\excel.xls\"; //Excel文件URLInputStream is = new FileInputStream(path); //写入到FileInputStreamjxl.Workbook wb = Workbook.getWorkbook(is); //得到工作薄 jxl.Sheet st = wb.getSheet(0); //得到工作薄中的第一个工作表Cell cell = st.getCell(0, 0); //得到工作表的第一个单元格,即A1String content = cell.getContents(); //getContents()将Cell中的字符转为字符串wb.close(); //关闭工作薄is.close(); //关闭输入流 我们可以通过Sheet的getCell(x,y)方法得到任意一个单元格,x,y和excel中的坐标对应.例如A1对应(0,0),A2对应(0,1),D3对应(3,2).Excel中坐标从A,1开始,jxl中全部是从0开始.还可以通过Sheet的getRows(),getColumns()方法得到行数列数,并用于循环控制,输出一个sheet中的所有内容. 2、写 往Excel中写入内容主要是用jxl.write包中的类.思路是这样的:OutputStream&lt;-WritableWorkbook&lt;-WritableSheet&lt;-Label这里面Label代表的是写入Sheet的Cell位置及内容. OutputStream os = new FileOutputStream(\"c:\\\\test.xls\"); WritableWorkbook wwb = Workbook.createWorkbook(os); WritableSheet ws = wwb.createSheet(\"sheet1\", 0); //创建可写工作表Label labelCF = new Label(0, 0, \"hello\"); //创建写入位置和内容ws.addCell(labelCF); //将Label写入sheet中//Label的构造函数Label(int x, int y,String aString)xy意同读的时候的xy,aString是写入的内容.WritableFont wf = new WritableFont(WritableFont.TIMES, 12, WritableFont.BOLD, false); //设置写入字体WritableCellFormat wcfF = new WritableCellFormat(wf); //设置CellFormatLabel labelCF = new Label(0, 0, \"hello\"); //创建写入位置,内容和格式//Label的另一构造函数Label(int c, int r, String cont, CellFormat st)可以对写入内容进行格式化,设置字体及其它的属性. wwb.write();wwb.close();os.close; OK,只要把读和写结合起来,就可以在N个Excel中读取数据写入你希望的Excel新表中,还是比较方便的. 下面是程序代码: sql = \"select * from tablename\";rs = stmt.executeQuery(sql);//新建Excel文件String filePath = request.getRealPath(\"aaa.xls\");File myFilePath = new File(filePath);if (!myFilePath.exists()) myFilePath.createNewFile();FileWriter resultFile = new FileWriter(myFilePath);PrintWriter myFile = new PrintWriter(resultFile);resultFile.close();//用JXL向新建的文件中添加内容OutputStream outf = new FileOutputStream(filePath);jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(outf);jxl.write.WritableSheet ws = wwb.createSheet(\"sheettest\", 0);int i = 0;int j = 0;for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123; ws.addCell(new Label(k, 0, rs.getMetaData().getColumnName(k + 1)));&#125;while (rs.next()) &#123; out.println(rs.getMetaData().getColumnCount()); for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123; ws.addCell(new Label(k, j + i + 1, rs.getString(k + 1))); &#125; i++;&#125;wwb.write();wwb.close();&#125; catch(Exception e) &#123; e.printStackTrace();&#125; finally &#123; rs.close(); conn.close();&#125;response.sendRedirect(\"aaa.xls\");","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]}]}