<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iTimeTraveler</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2017-11-26T07:38:36.681Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Mr.Seven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java】HashMap源码分析（JDK1.8）</title>
    <link href="http://github.com/2017/11/25/%E3%80%90Java%E3%80%91HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88JDK1.8%EF%BC%89/"/>
    <id>http://github.com/2017/11/25/【Java】HashMap源码分析（JDK1.8）/</id>
    <published>2017-11-25T14:20:55.000Z</published>
    <updated>2017-11-26T07:38:36.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是<code>HashMap</code>、<code>Hashtable</code>、<code>LinkedHashMap</code>和<code>TreeMap</code>，类继承关系如下图所示：</p>
<p><img src="/gallery/java-common/java.util.map_class.png" alt=""></p>
<p>下面针对各个实现类的特点做一些说明：</p>
<p>(1) <strong>HashMap</strong>：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>(2) <strong>Hashtable</strong>：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如<strong>ConcurrentHashMap</strong>，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) <strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) <strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<a id="more"></a>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>HashMap是Java基本功，JDK1.8又对HashMap进行了优化。</p>
<h4 id="存储结构Node类"><a href="#存储结构Node类" class="headerlink" title="存储结构Node类"></a>存储结构Node类</h4><p>JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。</p>
<p>针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。</p>
<p><img src="/gallery/java-common/hashMap内存结构图.png" alt=""></p>
<p>从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></div><div class="line"></div><div class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.hash = hash;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                Objects.equals(value, e.getValue()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>红黑树TreeNode结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></div><div class="line">    TreeNode&lt;K,V&gt; left;</div><div class="line">    TreeNode&lt;K,V&gt; right;</div><div class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></div><div class="line">    <span class="keyword">boolean</span> red;</div><div class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, val, next);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">//...省略其他代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap就是这样一个Entry（包括Node和TreeNode）数组，Node对象中包含键、值和hash值，next指向下一个Entry，用来处理哈希冲突。TreeNode对象包含指向父节点、子节点和前一个节点（移除对象时使用）的指针，以及表示红黑节点颜色的boolean标识。</p>
<h4 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The default initial capacity - MUST be a power of two.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The maximum capacity, used if a higher value is implicitly specified</div><div class="line"> * by either of the constructors with arguments.</div><div class="line"> * MUST be a power of two &lt;= 1&lt;&lt;30.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The load factor used when none specified in constructor.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The bin count threshold for using a tree rather than list for a</div><div class="line"> * bin.  Bins are converted to trees when adding an element to a</div><div class="line"> * bin with at least this many nodes. The value must be greater</div><div class="line"> * than 2 and should be at least 8 to mesh with assumptions in</div><div class="line"> * tree removal about conversion back to plain bins upon</div><div class="line"> * shrinkage.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The bin count threshold for untreeifying a (split) bin during a</div><div class="line"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</div><div class="line"> * most 6 to mesh with shrinkage detection under removal.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The smallest table capacity for which bins may be treeified.</div><div class="line"> * (Otherwise the table is resized if too many nodes in a bin.)</div><div class="line"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</div><div class="line"> * between resizing and treeification thresholds.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div></pre></td></tr></table></figure>
<ul>
<li><strong>默认容量</strong> - <code>DEFAULT_INITIAL_CAPACITY</code> ：默认初始化的容量为16，必须是2的幂。 </li>
<li><strong>最大容量</strong> - <code>MAXIMUM_CAPACITY</code>：最大容量是2^30 </li>
<li><strong>装载因子</strong> - <code>DEFAULT_LOAD_FACTOR</code>：默认的装载因子是0.75，用于判断是否需要扩容 </li>
<li><strong>链表转换成树的阈值</strong> - <code>TREEIFY_THRESHOLD</code>：一个桶中Entry（或称为Node）的存储方式由链表转换成树的阈值。即当桶中Entry的数量超过此值时使用红黑树来代替链表。默认值是8 </li>
<li><strong>树转还原成链表的阈值</strong> - <code>UNTREEIFY_THRESHOLD</code>：当执行resize操作时，当桶中Entry的数量少于此值时使用链表来代替树。默认值是6 </li>
<li><strong>最小树形化容量</strong> - <code>MIN_TREEIFY_CAPACITY</code>：当哈希表中的容量大于这个值时，表中的桶才能进行树形化。否则桶内元素太多时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于<code>4 * TREEIFY_THRESHOLD</code></li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// 哈希桶数组bucket</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">// entry缓存Set</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// 元素个数</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// 修改次数</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> threshold; <span class="comment">// 阈值，等于装载因子*容量，当实际大小超过阈值则进行扩容</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 装载因子，默认值为0.75</span></div></pre></td></tr></table></figure>
<p>其中loadFactor装载因子用来衡量HashMap满的程度。loadFactor的默认值为0.75f。计算HashMap的实时装载因子的方法为：<code>size/capacity</code>，<strong>也就是HashMap所有Entry的总数量/HashMap中桶的数量</strong>。而不是占用桶的数量去除以capacity。</p>
<ul>
<li>若加载因子越大，填满的元素越多。好处是空间利用率高了。但是冲突的机会加大了。链表长度会越来越长,查找效率降低。</li>
<li>反之，加载因子越小，填满的元素越少。好处是冲突的机会减小了，但空间浪费多了。表中的数据将过于稀疏（很多空间还没用，就开始扩容了）</li>
</ul>
<p><strong>冲突的机会越大，则查找的成本越高。</strong>因此，必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间-空间”矛盾的平衡与折衷。如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据初始化容量和负载因子构建一个空的HashMap.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="comment">//注意此处的tableSizeFor方法</span></div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用初始化容量和默认加载因子(0.75).</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用默认初始化大小(16)和默认加载因子(0.75).</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 用已有的Map构造一个新的HashMap.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过重载方法HashMap传入两个参数：1. 初始化容量；2. 装载因子。那么就介绍下几个名词：</p>
<ol>
<li><p>capacity：表示的是hashmap中桶的数量，初始化容量initCapacity为16，第一次扩容会扩到64，之后每次扩容都是之前容量的2倍，所以容量每次都是2的次幂。</p>
</li>
<li><p>loadFactor：装载因子，衡量hashmap一个满的程度，初始化为0.75</p>
</li>
<li><p>threshold：hashmap扩容的一个阈值标准，每当size大于这个阈值时就会进行扩容操作，threeshold等于<code>capacity*loadfactor</code></p>
</li>
</ol>
<h4 id="tableSizeFor-方法"><a href="#tableSizeFor-方法" class="headerlink" title="tableSizeFor()方法"></a>tableSizeFor()方法</h4><p>这个方法被调用的地方在上面构造函数中，当传入一个初始容量时，会调用<code>this.threshold = tableSizeFor(initialCapacity);</code>计算扩容阈值。那它是究竟干了什么的呢？tableSizeFor的功能（不考虑大于最大容量的情况）是返回<strong>大于输入参数且最近的2的整数次幂的数</strong>。比如10，则返回16。该算法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来分析有关n位操作部分：先来假设n的二进制为01xxx…xxx。接着</p>
<blockquote>
<p>对n右移1位：<code>001xx...xxx</code>，再位或：<code>011xx...xxx</code><br>对n右移2为：<code>00011...xxx</code>，再位或：<code>01111...xxx</code><br>此时前面已经有四个1了，再右移4位且位或可得8个1<br>同理，有8个1，右移8位肯定会让后八位也为1。<br>综上可得，该算法让最高位的1后面的位全变为1。<br>最后再让结果n+1，即得到了2的整数次幂的值了。</p>
</blockquote>
<p>现在回来看看第一条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>让cap-1再赋值给n的目的是另找到的目标值大于或<strong>等于</strong>原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。</p>
<p>举一个例子说明下吧。比如cap=10，则返回16。 </p>
<p><img src="/gallery/java-common/20160408183651111.jpg" alt=""></p>
<p>由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity，由于HashMap的容量capacity都是2的幂，因此这个方法用于找到大于等于initialCapacity的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。 </p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><p>JDK1.8对哈希碰撞后的拉链算法进行了优化， 当链表上Entry数量太多（超过8个）时，将链表重构为红黑树。下面是源码相关的注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Implements Map.put and related methods</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash hash for key</div><div class="line"> * <span class="doctag">@param</span> key the key</div><div class="line"> * <span class="doctag">@param</span> value the value to put</div><div class="line"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</div><div class="line"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</div><div class="line"> * <span class="doctag">@return</span> previous value, or null if none</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">    Node&lt;K,V&gt; p; </div><div class="line">    <span class="keyword">int</span> n, i;</div><div class="line"></div><div class="line">    <span class="comment">//步骤①：如果Table为空，初始化一个Table</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line"></div><div class="line">    <span class="comment">//步骤②：如果该bucket位置没值，则直接存储到该bucket位置</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; </div><div class="line">        K k;</div><div class="line"></div><div class="line">        <span class="comment">//步骤③：如果节点key存在，直接覆盖value</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">//步骤④：如果该bucket位置数据是TreeNode类型，则将新数据添加到红黑树中。</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;	<span class="comment">//步骤⑤：如果该链为链表</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="comment">//添加到链表尾部</span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);	<span class="comment">//如果链表个数达到8个时，将链表修改为红黑树结构</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// key已经存在直接覆盖value</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//更新键值，并返回旧值</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">//步骤⑥：存储的数目超过最大容量阈值，就扩容</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap的put方法执行过程可以通过下图来理解。</p>
<p><img src="/gallery/java-common/hashMap put方法执行流程图.png" alt=""></p>
<p>图中的步骤总结如下：</p>
<ul>
<li><p>①. 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
</li>
<li><p>②. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
</li>
<li><p>③. 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
</li>
<li><p>④. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
</li>
<li><p>⑤. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
</li>
<li><p>⑥. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
</li>
</ul>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Implements Map.get and related methods</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash hash for key</div><div class="line"> * <span class="doctag">@param</span> key the key</div><div class="line"> * <span class="doctag">@return</span> the node, or null if none</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; 	<span class="comment">//Table桶</span></div><div class="line">    Node&lt;K,V&gt; first, e;</div><div class="line">    <span class="keyword">int</span> n; </div><div class="line">    K k;</div><div class="line"></div><div class="line">    <span class="comment">//table数组不为空且length大于0，并且key的hash对应的桶第一个元素不为空时，才去get</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//首先判断是不是key的hash对应的桶中的第一个元素</span></div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果该桶的存储结构是红黑树，从树中查找并返回</span></div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line"></div><div class="line">            <span class="comment">//否则，遍历链表并返回</span></div><div class="line">            do &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法就相对简单了，通过hash定位桶，然后根据该桶的存储结构决定是遍历红黑树还是遍历链表。</p>
<h4 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash()方法"></a>hash()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//java 8中的散列值优化函数 </span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//java 7中的散列函数</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line"></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码叫“<strong>扰动函数</strong>”。大家都知道上面代码里的<strong>key.hashCode()</strong>函数调用的是key键值类型自带的哈希函数，返回int型散列值。</p>
<p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从<strong>-2147483648</strong>到<strong>2147483648</strong>。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。JDK1.8源码中模运算是这么完成的：<code>i = (length - 1) &amp; hash</code>，而在JDK1.7中是在<strong>indexFor( )</strong>函数里完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">bucketIndex = indexFor(hash, table.length);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>indexFor()的代码也很简单，就是把散列值和数组长度做一个<strong>“与”</strong>操作，就定位出了Key对应的桶，这个方法非常巧妙，它通过<code>h &amp; (table.length -1)</code>来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，<code>h&amp; (length-1)</code>运算等价于对length取模，也就是<code>h%length</code>，但是位运算&amp;比取模运算%具有更高的效率。</p>
<p>这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个“<strong>低位掩码”。</strong>“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是<strong>00000000 00000000 00001111</strong>。和某散列值做“与”操作如下，结果就是截取了最低的四位值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    10100101 11000100 00100101</div><div class="line">&amp;	00000000 00000000 00001111</div><div class="line">----------------------------------</div><div class="line">	00000000 00000000 00000101    //高位全部归零，只保留末四位</div></pre></td></tr></table></figure>
<p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。</p>
<p>这时候“<strong>扰动函数</strong>”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图，</p>
<p><img src="/gallery/java-common/hashMap哈希算法例图.png" alt=""></p>
<p>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<h4 id="resize-扩容方法"><a href="#resize-扩容方法" class="headerlink" title="resize()扩容方法"></a>resize()扩容方法</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置新的resize上限</span></div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)  <span class="comment">//如果该桶只有一个数据，则散列到当前位置或者（原位置+oldCap）位置</span></div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//红黑树重构</span></div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="comment">// 原索引</span></div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 原索引+oldCap</span></div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">// 原索引放到bucket里</span></div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当Entry的实际数量size 大于桶table的实际数量时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="/gallery/java-common/jdk1.7扩容例图.png" alt=""></p>
<p>在JDK1.8中我们可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="/gallery/java-common/hashMap 1.8 哈希算法例图1.png" alt=""></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/gallery/java-common/hashMap 1.8 哈希算法例图2.png" alt=""></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“<strong>原索引+oldCap</strong>”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/gallery/java-common/jdk1.8 hashMap扩容例图.png" alt=""></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。下面是JDK1.7的扩容方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * JDK 1.7中的resize()方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></div><div class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;         </div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></div><div class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></div><div class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></div><div class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></div><div class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></div><div class="line">        Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></div><div class="line">            do &#123;</div><div class="line">                Entry&lt;K,V&gt; next = e.next;</div><div class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></div><div class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></div><div class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></div><div class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></div><div class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<h4 id="树形化方法treeifyBin"><a href="#树形化方法treeifyBin" class="headerlink" title="树形化方法treeifyBin()"></a>树形化方法treeifyBin()</h4><p>在Java 8 中，如果一个桶中的链表元素个数超过 TREEIFY_THRESHOLD（默认是 8 ），就使用红黑树来替换链表，从而提高速度。这个替换的方法叫 treeifyBin() 即树形化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//将桶内所有的 链表节点 替换成 红黑树节点</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n, index; Node e;</div><div class="line">    <span class="comment">//如果当前哈希表为空，或者哈希表中Entry元素总数量小于进行树形化的阈值(默认为 64)，就去新建/扩容</span></div><div class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</div><div class="line">        resize();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//如果哈希表中的元素个数超过了树形化阈值，进行树形化</span></div><div class="line">        <span class="comment">// e 是哈希表中指定位置桶里的链表节点，从第一个开始</span></div><div class="line">        TreeNode hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>; <span class="comment">//红黑树的头、尾节点</span></div><div class="line">        do &#123;</div><div class="line">            <span class="comment">//新建一个树形节点，内容和当前链表节点 e 一致</span></div><div class="line">            TreeNode p = replacementTreeNode(e, <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">//确定树头节点</span></div><div class="line">                hd = p;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                p.prev = tl;</div><div class="line">                tl.next = p;</div><div class="line">            &#125;</div><div class="line">            tl = p;</div><div class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </div><div class="line">        <span class="comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span></div><div class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</div><div class="line">            hd.treeify(tab);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function">TreeNode <span class="title">replacementTreeNode</span><span class="params">(Node p, Node next)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述操作做了这些事:</p>
<ul>
<li>根据哈希表中元素个数确定是扩容还是树形化</li>
<li>如果是树形化<ul>
<li>遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</li>
<li>然后让桶第一个元素指向新建的树头结点，替换桶的链表内容为树形内容</li>
</ul>
</li>
</ul>
<p>但是我们发现，之前的操作并没有设置红黑树的颜色值，现在得到的只能算是个二叉树。在 最后调用树形root节点 <code>hd.treeify(tab)</code>方法进行塑造红黑树，来看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</div><div class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</div><div class="line">        x.left = x.right = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;  <span class="comment">//第一次进入循环，确定root根结点，为黑色</span></div><div class="line">            x.parent = <span class="keyword">null</span>;</div><div class="line">            x.red = <span class="keyword">false</span>;</div><div class="line">            root = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;   <span class="comment">//非第一次进入循环，x指向树中的某个节点</span></div><div class="line">            K k = x.key;</div><div class="line">            <span class="keyword">int</span> h = x.hash;</div><div class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">//从根节点开始，遍历所有节点跟当前节点 x 比较，调整位置</span></div><div class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</div><div class="line">                <span class="keyword">int</span> dir, ph;</div><div class="line">                K pk = p.key;</div><div class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  <span class="comment">//当比较节点p的哈希值比 x 大时， dir为-1</span></div><div class="line">                    dir = -<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)   <span class="comment">//哈希值比 x 小时，dir为1</span></div><div class="line">                    dir = <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</div><div class="line">                    dir = tieBreakOrder(k, pk);</div><div class="line"></div><div class="line">                <span class="comment">//把当前节点p变成 x 的父亲</span></div><div class="line">                TreeNode&lt;K,V&gt; xp = p;</div><div class="line">                </div><div class="line">                <span class="comment">//如果当前比较节点p的哈希值比 x 大，x 就是左孩子，否则 x 是右孩子 </span></div><div class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line">                    x.parent = xp;</div><div class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line">                        xp.left = x;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        xp.right = x;</div><div class="line">                    <span class="comment">//平衡操作</span></div><div class="line">                    root = balanceInsertion(root, x);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    moveRootToFront(tab, root);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，将二叉树变为红黑树时，需要保证有序。这里有个双重循环，拿树中的所有节点和当前节点的哈希值进行对比(如果哈希值相等，就对比键，这里不用完全有序），然后根据比较结果确定在树中的位置。</p>
<h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">        <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//所有的桶</span></div><div class="line">    Node&lt;K,V&gt; p;   <span class="comment">//对应桶的第一个元素</span></div><div class="line">    <span class="keyword">int</span> n, index;  <span class="comment">//桶数量，对应桶的次序</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; </div><div class="line">        K k; </div><div class="line">        V v;</div><div class="line">      </div><div class="line">        <span class="comment">//要删除的元素如果刚好匹配该桶中的第一个元素</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            node = p;</div><div class="line">        <span class="comment">//如果不是桶中的第一个元素，往下遍历</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                do &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key ||</div><div class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                        node = e;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    p = e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//找到要删除的元素之后，删除</span></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//红黑树中删除</span></div><div class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)     <span class="comment">//是该桶中链表首节点删除</span></div><div class="line">                tab[index] = node.next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                p.next = node.next;</div><div class="line">            ++modCount;</div><div class="line">            --size;</div><div class="line">            afterNodeRemoval(node);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>remove()方法也很简单，这里就不展开讲了。<code>clear()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//清空所有元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">        size = <span class="number">0</span>;</div><div class="line">        <span class="comment">//仅清空桶数组的引用</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</div><div class="line">            tab[i] = <span class="keyword">null</span>;   <span class="comment">// 把哈希数组中所有位置都赋为null</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h3><p>一直以来只是知道HashMap是线程不安全的，但是到底HashMap为什么线程不安全，多线程并发的时候在什么情况下可能出现问题？</p>
<p>javadoc中关于hashmap的一段描述如下：</p>
<blockquote>
<p><strong>此实现不是同步的。</strong>如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它<em>必须</em> 保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 <code>Collections.synchronizedMap()</code> 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap(...));</div></pre></td></tr></table></figure>
<ol>
<li><p><strong>多线程put后可能导致get死循环</strong></p>
<p>问题原因就是HashMap是非线程安全的，多个线程put的时候造成了某个key值Entry key List的死循环，问题就这么产生了。参考：<a href="https://my.oschina.net/xianggao/blog/393990#OSC_h2_1" target="_blank" rel="external">HashMap多线程并发问题分析</a></p>
</li>
<li><p><strong>多线程put的时候可能导致元素丢失</strong></p>
<p>如果两个线程都put()时，使用<code>p.next = newNode(hash, key, value, null);</code>同时取得了p，则他们下一个元素都是newNode，然后赋值给table元素的时候有一个成功有一个丢失。</p>
</li>
</ol>
<blockquote>
<p>注意：不合理使用HashMap导致出现的是死循环而不是死锁。</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h4><p>到这里，你能回答出如下问题吗？  </p>
<p>1、哈希基本原理？（答：散列表、hash碰撞、链表、<strong>红黑树</strong>）<br>2、hashmap查询的时间复杂度， 影响因素和原理？ （答：最好O（1），最差O（n）， 如果是<strong>红黑O（logn）</strong>）<br>3、resize如何实现的， 记住已经没有rehash了！！！（答：拉链entry根据高位bit散列到当前位置i和size+i位置）<br>4、为什么获取下标时用按位与&amp;，而不是取模%？ （答：不只是&amp;速度更快哦，  我觉得你能答上来便真正理解hashmap了）</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。<br>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。<br>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。<br>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://juejin.im/entry/5839ad0661ff4b007ec7cc7a" target="_blank" rel="external">面试旧敌之 HashMap : JDK 1.8 后它通过什么提升性能</a></li>
<li><a href="http://blog.csdn.net/fan2012huan/article/details/51087722" target="_blank" rel="external">HashMap中capacity、loadFactor、threshold、size等概念的解释</a></li>
<li><a href="http://blog.csdn.net/u014026363/article/details/56342142" target="_blank" rel="external">Java源码分析之HashMap(JDK1.8)</a></li>
<li><a href="http://blog.csdn.net/brycegao321/article/details/52527236" target="_blank" rel="external">HashMap源码分析（JDK1.8）- 你该知道的都在这里了</a></li>
<li><a href="http://www.cnblogs.com/ITtangtang/p/3948406.html" target="_blank" rel="external">Java集合：HashMap源码剖析</a></li>
<li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a> - 美团点评技术团队</li>
<li><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="external">JDK源码中HashMap的hash方法原理是什么？</a> - 知乎</li>
<li><a href="http://blog.csdn.net/anxpp/article/details/51234835" target="_blank" rel="external">HashMap源码之hash()函数分析（JDK 1.8）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是&lt;code&gt;HashMap&lt;/code&gt;、&lt;code&gt;Hashtable&lt;/code&gt;、&lt;code&gt;LinkedHashMap&lt;/code&gt;和&lt;code&gt;TreeMap&lt;/code&gt;，类继承关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/java-common/java.util.map_class.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面针对各个实现类的特点做一些说明：&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;HashMap&lt;/strong&gt;：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;Hashtable&lt;/strong&gt;：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。&lt;/p&gt;
&lt;p&gt;(3) &lt;strong&gt;LinkedHashMap&lt;/strong&gt;：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。&lt;/p&gt;
&lt;p&gt;(4) &lt;strong&gt;TreeMap&lt;/strong&gt;：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。&lt;/p&gt;
&lt;p&gt;对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。&lt;/p&gt;
&lt;p&gt;通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Android】View事件分发机制</title>
    <link href="http://github.com/2017/11/18/%E3%80%90Android%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://github.com/2017/11/18/【Android】源码分析 - View事件分发机制/</id>
    <published>2017-11-18T14:20:55.000Z</published>
    <updated>2017-11-19T09:01:40.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事件分发对象"><a href="#事件分发对象" class="headerlink" title="事件分发对象"></a>事件分发对象</h3><p>（1）所有 Touch 事件都被封装成了 MotionEvent 对象，包括 Touch 的位置、时间、历史记录以及第几个手指(多指触摸)等。</p>
<p>（2）事件类型分为 <code>ACTION_DOWN</code>， <code>ACTION_UP</code>，<code>ACTION_MOVE</code>，<code>ACTION_POINTER_DOWN</code>，<code>ACTION_POINTER_UP</code>， <code>ACTION_CANCEL</code>，每个事件都是以 <code>ACTION_DOWN</code> 开始 <code>ACTION_UP</code> 结束。</p>
<p>主要发生的Touch事件有如下四种：</p>
<ul>
<li>MotionEvent.ACTION_DOWN：按下View（所有事件的开始）</li>
<li>MotionEvent.ACTION_MOVE：滑动View</li>
<li>MotionEvent.ACTION_CANCEL：非人为原因结束本次事件</li>
<li>MotionEvent.ACTION_UP：抬起View（与DOWN对应）</li>
</ul>
<p>事件列：从手指接触屏幕至手指离开屏幕，这个过程产生的一系列事件<br>任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图： </p>
<p><img src="/gallery/android-view/944365-79b1e86793514e99.png" alt=""></p>
<p>即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。这个事件传递的过程就是分发过程。</p>
<p>（3）对事件的处理包括三类，分别：</p>
<ul>
<li><p>传递——dispatchTouchEvent()函数；</p>
</li>
<li><p>拦截——onInterceptTouchEvent()函数</p>
</li>
<li><p>消费——onTouchEvent()函数和 OnTouchListener</p>
</li>
</ul>
<a id="more"></a>
<h3 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h3><p>触摸事件发生后，在Activity内最先接收到事件的是Activity自身的dispatchTouchEven接着Window传递给最顶端的View，也就是DecorView。接下来才是我们熟悉的触摸事件流程：首先是最顶端的ViewGroup(这边便是DecorView)的dispatchTouchEvent接收到事件。并通过onInterceptTouchEvent判断是否需要拦截。如果拦截则分配到ViewGroup自身的onTouchEvent，如果不拦截则查找位于点击区域的子View(当事件是ACTION_DOWN的时候，会做一次查找并根据查找到的子View设定一个TouchTarget，有了TouchTarget以后，后续的对应id的事件如果不被拦截都会分发给这一个TouchTarget)。查找到子View以后则调用dispatchTransformedTouchEvent把MotionEvent的坐标转换到子View的坐标空间，这不仅仅是x，y的偏移，还包括根据子View自身矩阵的逆矩阵对坐标进行变换(这就是使用setTranslationX,setScaleX等方法调用后，子View的点击区域还能保持和自身绘制内容一致的原因。使用Animation做变换点击区域不同步是因为Animation使用的是Canvas的矩阵而不是View自身的矩阵来做变换)。</p>
<h4 id="事件分发的源头"><a href="#事件分发的源头" class="headerlink" title="事件分发的源头"></a>事件分发的源头</h4><p>触摸事件发生后，在Activity内最先接收到事件的是Activity自身的<code>dispatchTouchEvent()</code>，然后Activity传递给Activity的Window：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        onUserInteraction();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的这个<code>getWindow()</code>得到的就是Activity的<code>mWindow</code>对象，它是在<code>attach()</code>方法中初始化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></div><div class="line">            Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</div><div class="line">            Application application, Intent intent, ActivityInfo info,</div><div class="line">            CharSequence title, Activity parent, String id,</div><div class="line">            NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">            Configuration config, IVoiceInteractor voiceInteractor) &#123;</div><div class="line"></div><div class="line">    <span class="comment">//创建一个Window对象        </span></div><div class="line">    mWindow = PolicyManager.makeNewWindow(<span class="keyword">this</span>);</div><div class="line">    mWindow.setCallback(<span class="keyword">this</span>);</div><div class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</div><div class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</div><div class="line">    </div><div class="line"></div><div class="line">    mWindow.setWindowManager(</div><div class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</div><div class="line">            mToken, mComponent.flattenToString(),</div><div class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</div><div class="line">    mWindowManager = mWindow.getWindowManager();</div><div class="line"></div><div class="line">    <span class="comment">//...省略其他代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用了PolicyManager的<code>makeNewWindow()</code>方法创建的Window对象。我们跟进去<code>PolicyManager</code>这个类（这个类在Android 6.0之后源码中删除了，下面是我找的5.1的源码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POLICY_IMPL_CLASS_NAME =</div><div class="line">        <span class="string">"com.android.internal.policy.impl.Policy"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IPolicy sPolicy;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="comment">// Pull in the actual implementation of the policy at run-time</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME);</div><div class="line">            sPolicy = (IPolicy)policyClass.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be loaded"</span>, ex);</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be instantiated"</span>, ex);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be instantiated"</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Cannot instantiate this class</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PolicyManager</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// The static methods to spawn new policy-specific objects</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPolicy.makeNewWindow(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">makeNewLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPolicy.makeNewLayoutInflater(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerPolicy <span class="title">makeNewWindowManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPolicy.makeNewWindowManager();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FallbackEventHandler <span class="title">makeNewFallbackEventHandler</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPolicy.makeNewFallbackEventHandler(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到实际上调用了<code>Policy</code>类的<code>makeNewWindow()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Policy</span> <span class="keyword">implements</span> <span class="title">IPolicy</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"PhonePolicy"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] preload_classes = &#123;</div><div class="line">        <span class="string">"com.android.internal.policy.impl.PhoneLayoutInflater"</span>,</div><div class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow"</span>,</div><div class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$1"</span>,</div><div class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$DialogMenuCallback"</span>,</div><div class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$DecorView"</span>,</div><div class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$PanelFeatureState"</span>,</div><div class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$PanelFeatureState$SavedState"</span>,</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="comment">// For performance reasons, preload some policy specific classes when</span></div><div class="line">        <span class="comment">// the policy gets loaded.</span></div><div class="line">        <span class="keyword">for</span> (String s : preload_classes) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Class.forName(s);</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">                Log.e(TAG, <span class="string">"Could not preload class for phone policy: "</span> + s);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneWindow(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">makeNewLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> WindowManagerPolicy <span class="title">makeNewWindowManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneWindowManager();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> FallbackEventHandler <span class="title">makeNewFallbackEventHandler</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneFallbackEventHandler(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来是一个<code>PhoneWindow</code>对象，我们赶紧看看它的<code>superDispatchTouchEvent</code>方法，原来是继续调用了<code>DecorView</code>的<code>superDispatchTouchEvent()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// This is the top-level view of the window, containing the window decor.</span></div><div class="line"><span class="keyword">private</span> DecorView mDecor;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>DecorView</code>是<code>PhoneWindow</code>的一个内部类，它继承了FrameLayout：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">RootViewSurfaceTaker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">//...省略其他代码... </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而FrameLayout本身没有实现<code>dispatchTouchEvent()</code>这个方法，它继承了ViewGroup：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p>下面我们来看一下ViewGroup的<code>dispatchTouchEvent()</code>方法源码。</p>
<h4 id="ViewGroup开始分发"><a href="#ViewGroup开始分发" class="headerlink" title="ViewGroup开始分发"></a>ViewGroup开始分发</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            <span class="comment">// 触摸事件流开始，重置触摸相关的状态</span></div><div class="line">            cancelAndClearTouchTargets(ev);</div><div class="line">            resetTouchState();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 关键点1： 检测当前是否需要拦截事件</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">          </div><div class="line">            <span class="comment">// 处理调用requestDisallowInterceptTouchEvent()来决定是否允许ViewGroup拦截事件</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">                intercepted = onInterceptTouchEvent(ev);</div><div class="line">                ev.setAction(action); </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                intercepted = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 当前没有TouchTarget也不是事件流的起始的话，则直接默认拦截，不通过onInterceptTouchEvent判断。</span></div><div class="line">            intercepted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</div><div class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class="line"></div><div class="line">        <span class="comment">// 检测是否需要把多点触摸事件分配给不同的子View</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</div><div class="line">      </div><div class="line">        <span class="comment">// 当前事件流对应的TouchTarget对象</span></div><div class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line"></div><div class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">                    ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                        : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">                <span class="comment">// 当前事件是事件流的初始事件(包括多点触摸时第二、第三点灯的DOWN事件)，清除之前相应的TouchTarget的状态</span></div><div class="line">                removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></div><div class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">                    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">                  </div><div class="line">                    <span class="comment">//通过for循环，遍历了当前ViewGroup下的所有子View</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</div><div class="line">                                childrenCount, i, customOrder);</div><div class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</div><div class="line">                                preorderedList, children, childIndex);</div><div class="line"></div><div class="line">                        <span class="comment">// 关键点2： 判断当前遍历到的子View能否接受事件，如果不能则直接continue进入下一次循环</span></div><div class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">// 当前子View能接收事件，为子View创建TouchTarget</span></div><div class="line">                        newTouchTarget = getTouchTarget(child);</div><div class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        resetCancelNextUpFlag(child);</div><div class="line">                        <span class="comment">// 调用dispatchTransformedTouchEvent把事件分配给子View</span></div><div class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                            mLastTouchDownTime = ev.getDownTime();</div><div class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                        mLastTouchDownIndex = j;</div><div class="line">                                        <span class="keyword">break</span>;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                mLastTouchDownIndex = childIndex;</div><div class="line">                            &#125;</div><div class="line">                            mLastTouchDownX = ev.getX();</div><div class="line">                            mLastTouchDownY = ev.getY();</div><div class="line">                            </div><div class="line">                            <span class="comment">// 把TouchTarget添加到TouchTarget列表的第一位</span></div><div class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                    newTouchTarget = mFirstTouchTarget;</div><div class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</div><div class="line">                        newTouchTarget = newTouchTarget.next;</div><div class="line">                    &#125;</div><div class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 目前没有任何TouchTarget，所以直接传null给dispatchTransformedTouchEvent</span></div><div class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">                    TouchTarget.ALL_POINTER_IDS);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 把事件根据pointer id分发给TouchTarget列表内的所有TouchTarget，用来处理多点触摸的情况</span></div><div class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</div><div class="line">            TouchTarget target = mFirstTouchTarget;</div><div class="line">            <span class="comment">// 遍历TouchTarget列表</span></div><div class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</div><div class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">                    handled = <span class="keyword">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                            || intercepted;</div><div class="line">                  </div><div class="line">                    <span class="comment">// 根据TouchTarget的pointerIdBits来执行dispatchTransformedTouchEvent</span></div><div class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                            target.child, target.pointerIdBits)) &#123;</div><div class="line">                        handled = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</div><div class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</div><div class="line">                            mFirstTouchTarget = next;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            predecessor.next = next;</div><div class="line">                        &#125;</div><div class="line">                        target.recycle();</div><div class="line">                        target = next;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                predecessor = target;</div><div class="line">                target = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 处理CANCEL和UP事件的情况</span></div><div class="line">        <span class="keyword">if</span> (canceled</div><div class="line">                || actionMasked == MotionEvent.ACTION_UP</div><div class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">            resetTouchState();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</div><div class="line">            removePointersFromTouchTargets(idBitsToRemove);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码比较长，先不用细看。下面一张图来简化对照着理解一下：</p>
<p><img src="/gallery/android-view/viewgroup_touchevent.png" alt=""></p>
<ul>
<li><p><strong>关键点1</strong>：只有<code>ACTION_DOWN</code>事件或者<code>mFirstTouchTarget</code>为空时，并且没有调用过<code>requestDisallowInterceptTouchEvent()</code>去阻止该ViewGroup拦截事件的话，才可能执行拦截方法<code>onInterceptTouchEvent()</code></p>
</li>
<li><p><strong>关键点2</strong>：判断当前遍历到的子View能否接受事件主要由两点来衡量：子元素是否在播动画（<code>canViewReceivePointerEvents（）</code>方法）；点击事件坐标是否落在子元素区域内（``）。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//子元素是否在播动画</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canViewReceivePointerEvents</span><span class="params">(View child)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</div><div class="line">            || child.getAnimation() != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//点击事件坐标是否落在子元素区域内</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isTransformedTouchPointInView</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, View child,</span></span></div><div class="line">            PointF outLocalPoint) &#123;</div><div class="line">    <span class="keyword">float</span> localX = x + mScrollX - child.mLeft;</div><div class="line">    <span class="keyword">float</span> localY = y + mScrollY - child.mTop;</div><div class="line">    <span class="keyword">if</span> (! child.hasIdentityMatrix() &amp;&amp; mAttachInfo != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span>[] localXY = mAttachInfo.mTmpTransformLocation;</div><div class="line">        localXY[<span class="number">0</span>] = localX;</div><div class="line">        localXY[<span class="number">1</span>] = localY;</div><div class="line">        child.getInverseMatrix().mapPoints(localXY);</div><div class="line">        localX = localXY[<span class="number">0</span>];</div><div class="line">        localY = localXY[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//检测坐标是否在child区域内</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isInView = child.pointInView(localX, localY);</div><div class="line">    <span class="keyword">if</span> (isInView &amp;&amp; outLocalPoint != <span class="keyword">null</span>) &#123;</div><div class="line">        outLocalPoint.set(localX, localY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> isInView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当子View满足这两个条件之后，ViewGroup就会调用<code>dispatchTransformedMotionEvent()</code>方法去交给子元素处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line">            View child, <span class="keyword">int</span> desiredPointerIdBits) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</div><div class="line">    <span class="comment">// 处理CANCEL的情况，直接把MotionEvent的原始数据分发给子View或者自身的onTouchEvent</span></div><div class="line">		<span class="comment">// (这边调用View.dispatchTouchEvent，而View.dispatchTouchEvent会再调用onTouchEvent方法，把MotionEvent传入)</span></div><div class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            handled = child.dispatchTouchEvent(event);</div><div class="line">        &#125;</div><div class="line">        event.setAction(oldAction);</div><div class="line">        <span class="keyword">return</span> handled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 对MotionEvent自身的pointer id和当前我们需要处理的pointer id做按位与，得到共有的pointer id</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</div><div class="line"></div><div class="line">    <span class="comment">// 没有pointer id需要处理，直接返回</span></div><div class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</div><div class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</div><div class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 关键点1： 子View为空，直接交还给自身的onTouchEvent处理</span></div><div class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</div><div class="line">                event.offsetLocation(offsetX, offsetY);</div><div class="line"></div><div class="line">                <span class="comment">// 关键点2：交给子view的dispatchTouchEvent()方法去处理</span></div><div class="line">                handled = child.dispatchTouchEvent(event);</div><div class="line">                event.offsetLocation(-offsetX, -offsetY);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> handled;</div><div class="line">        &#125;</div><div class="line">        transformedEvent = MotionEvent.obtain(event);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// MotionEvent自身的pointer id和当前需要处理的pointer id不同，把不需要处理的pointer id相关的信息剔除掉。</span></div><div class="line">        transformedEvent = event.split(newPointerIdBits);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 子View为空，直接交还给自身的onTouchEvent处理</span></div><div class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 根据当前的scrollX、scrollY和子View的left、top对MotionEvent的触摸坐标x、y进行偏移</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</div><div class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</div><div class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</div><div class="line">            <span class="comment">// 获取子View自身矩阵的逆矩阵，并对MotionEvent的坐标相关信息进行矩阵变换</span></div><div class="line">            transformedEvent.transform(child.getInverseMatrix());</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">        <span class="comment">// 把经过偏移以及矩阵变换的事件传递给子View处理</span></div><div class="line">        handled = child.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    transformedEvent.recycle();</div><div class="line">    <span class="keyword">return</span> handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="子View消费事件"><a href="#子View消费事件" class="headerlink" title="子View消费事件"></a>子View消费事件</h4><p>然后我们看看View的<code>dispatchTouchEvent()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        <span class="comment">// Defensive cleanup for new gesture</span></div><div class="line">        stopNestedScroll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">        <span class="comment">// 如果存在mOnTouchListener，直接交给它消费Touch事件</span></div><div class="line">        ListenerInfo li = mListenerInfo;</div><div class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">            result = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 交给onTouchEvent()方法消费Touch事件</span></div><div class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">            result = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></div><div class="line">    <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></div><div class="line">    <span class="comment">// of the gesture.</span></div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</div><div class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</div><div class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</div><div class="line">        stopNestedScroll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里View的<code>mOnTouchListener.onTouch(this, event)</code>和<code>onTouchEvent(event)</code>都是放在if判断条件里的，也就是说他们的返回值会影响事件是否继续往下传递。如果<code>mOnTouchListener.onTouch(this, event)</code>返回true的话，就不会再执行此子View的<code>onTouchEvent(event)</code>方法了。</p>
<p>最后我们再看下View的<code>onTouchEvent()</code>方法是如何消费事件的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">            setPressed(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">        <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</div><div class="line">                    <span class="comment">// take focus if we don't have it already and we should in</span></div><div class="line">                    <span class="comment">// touch mode.</span></div><div class="line">                    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                        focusTaken = requestFocus();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                        <span class="comment">// The button is being released before we actually</span></div><div class="line">                        <span class="comment">// showed it as pressed.  Make it show the pressed</span></div><div class="line">                        <span class="comment">// state now (before scheduling the click) to ensure</span></div><div class="line">                        <span class="comment">// the user sees it.</span></div><div class="line">                        setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</div><div class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></div><div class="line">                        removeLongPressCallback();</div><div class="line"></div><div class="line">                        <span class="comment">// Only perform take click actions if we were in the pressed state</span></div><div class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                            <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                            <span class="comment">// of the view update before click actions start.</span></div><div class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                            	<span class="comment">//关键点</span></div><div class="line">                                performClick();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                        postDelayed(mUnsetPressedState,</div><div class="line">                                ViewConfiguration.getPressedStateDuration());</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                        <span class="comment">// If the post failed, unpress right now</span></div><div class="line">                        mUnsetPressedState.run();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    removeTapCallback();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></div><div class="line">                <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line"></div><div class="line">                <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></div><div class="line">                <span class="comment">// a short period in case this is a scroll.</span></div><div class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                    mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                    <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                        mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                    &#125;</div><div class="line">                    mPendingCheckForTap.x = event.getX();</div><div class="line">                    mPendingCheckForTap.y = event.getY();</div><div class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></div><div class="line">                    setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                    checkForLongClick(<span class="number">0</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                setPressed(<span class="keyword">false</span>);</div><div class="line">                removeTapCallback();</div><div class="line">                removeLongPressCallback();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                drawableHotspotChanged(x, y);</div><div class="line"></div><div class="line">                <span class="comment">// Be lenient about moving outside of buttons</span></div><div class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                    <span class="comment">// Outside button</span></div><div class="line">                    removeTapCallback();</div><div class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// Remove any future long press/tap checks</span></div><div class="line">                        removeLongPressCallback();</div><div class="line"></div><div class="line">                        setPressed(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们这里只注意一下在这个View接收到<code>ACTION_UP</code>事件之后，会调用到<code>performClick()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">        playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">        <span class="comment">//通知回调mOnClickListener的onClick方法</span></div><div class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">        result = <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        result = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里能说明View的<code>OnClickListener</code>的<code>onClick()</code>事件的执行时机是在整个TouchEvent事件列的最后才会执行。</p>
<h3 id="Touch案例分析"><a href="#Touch案例分析" class="headerlink" title="Touch案例分析"></a>Touch案例分析</h3><p><img src="/gallery/android-view/journey-of-an-event-the-android-touch-marco-cova-facebook-9-638.jpg" alt=""></p>
<blockquote>
<p><strong>问题</strong>：当ViewGroup的<code>onInterceptTouchEvent()</code>函数分别返回true和false时，这个ViewGroup和View1分别能接收到DOWN、MOVE、UP中的什么事件？</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">ViewGroup的<code>onInterceptTouchEvent()</code>方法</th>
<th style="text-align:center">ViewGroup</th>
<th style="text-align:center">View1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">return true</td>
<td style="text-align:center">仅能接收到DOWN事件</td>
<td style="text-align:center">什么都接收不到</td>
</tr>
<tr>
<td style="text-align:center">return false</td>
<td style="text-align:center">三种都能接收到</td>
<td style="text-align:center">三种都能接收到</td>
</tr>
</tbody>
</table>
<p>另一个案例可以参考这篇文章：<a href="https://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="external">Android 编程下 Touch 事件的分发和消费机制</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/gallery/android-view/1520093523-0.png" alt=""></p>
<ul>
<li>Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。</li>
</ul>
<ul>
<li>（1）事件从 Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的 ViewGroup开始一直往下(子View)传递。子View可以通过 <code>onTouchEvent()</code>对事件进行处理。</li>
<li>（2）事件由ViewGroup传递给子 View，ViewGroup 可以通过 <code>onInterceptTouchEvent()</code>对事件做拦截，停止其往下传递。</li>
<li>（3）如果事件从上往下传递过程中一直没有被停止，且最底层子 View 没有消费事件，事件会反向往上传递，这时父 View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到 Activity 的 onTouchEvent()函数。</li>
<li>（4） 如果 View 没有对 ACTION_DOWN 进行消费，之后的其他事件不会传递过来。</li>
<li>（5）OnTouchListener 优先于 onTouchEvent()对事件进行消费。</li>
<li>当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到第一个真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。</li>
<li>当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。</li>
<li>当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。</li>
<li>ViewGroup默认不拦截任何事件。源码中的ViewGroup的<code>onInterceptTouchEvent()</code>方法默认返回false。</li>
<li>View没有<code>onInterceptTouchEvent()</code>方法。一旦点击事件传递给它，就会调用它的<code>onTouchEvent</code>方法</li>
<li>我们可以发现ViewGroup没有onTouchEvent事件，说明他的处理逻辑和View是一样的。 </li>
<li>子view如果消耗了事件，那么ViewGroup就不会在接受到事件了。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.cnblogs.com/linjzong/p/4191891.html" target="_blank" rel="external">Android:30分钟弄明白Touch事件分发机制</a></li>
<li><a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92" target="_blank" rel="external">公共技术点之 View 事件传递</a></li>
<li><a href="http://blog.csdn.net/aigestudio/article/details/44260301" target="_blank" rel="external">Android事件分发完全解析之为什么是她</a></li>
<li><a href="http://blog.csdn.net/wallezhe/article/details/51737034" target="_blank" rel="external">Android ViewGroup/View 事件分发机制详解</a></li>
<li><a href="http://blog.csdn.net/carson_ho/article/details/54136311" target="_blank" rel="external">Android事件分发机制详解：史上最全面、最易懂</a></li>
<li><a href="https://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="external">Android 编程下 Touch 事件的分发和消费机制</a></li>
<li><a href="https://github.com/LittleFriendsGroup/AndroidSdkSourceAnalysis/blob/master/article/ViewGroup%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">ViewGroup 源码解析</a></li>
<li><a href="http://blog.csdn.net/sw950729/article/details/77744545" target="_blank" rel="external">ViewGroup源码解读</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事件分发对象&quot;&gt;&lt;a href=&quot;#事件分发对象&quot; class=&quot;headerlink&quot; title=&quot;事件分发对象&quot;&gt;&lt;/a&gt;事件分发对象&lt;/h3&gt;&lt;p&gt;（1）所有 Touch 事件都被封装成了 MotionEvent 对象，包括 Touch 的位置、时间、历史记录以及第几个手指(多指触摸)等。&lt;/p&gt;
&lt;p&gt;（2）事件类型分为 &lt;code&gt;ACTION_DOWN&lt;/code&gt;， &lt;code&gt;ACTION_UP&lt;/code&gt;，&lt;code&gt;ACTION_MOVE&lt;/code&gt;，&lt;code&gt;ACTION_POINTER_DOWN&lt;/code&gt;，&lt;code&gt;ACTION_POINTER_UP&lt;/code&gt;， &lt;code&gt;ACTION_CANCEL&lt;/code&gt;，每个事件都是以 &lt;code&gt;ACTION_DOWN&lt;/code&gt; 开始 &lt;code&gt;ACTION_UP&lt;/code&gt; 结束。&lt;/p&gt;
&lt;p&gt;主要发生的Touch事件有如下四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MotionEvent.ACTION_DOWN：按下View（所有事件的开始）&lt;/li&gt;
&lt;li&gt;MotionEvent.ACTION_MOVE：滑动View&lt;/li&gt;
&lt;li&gt;MotionEvent.ACTION_CANCEL：非人为原因结束本次事件&lt;/li&gt;
&lt;li&gt;MotionEvent.ACTION_UP：抬起View（与DOWN对应）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件列：从手指接触屏幕至手指离开屏幕，这个过程产生的一系列事件&lt;br&gt;任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/android-view/944365-79b1e86793514e99.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。这个事件传递的过程就是分发过程。&lt;/p&gt;
&lt;p&gt;（3）对事件的处理包括三类，分别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;传递——dispatchTouchEvent()函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;拦截——onInterceptTouchEvent()函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消费——onTouchEvent()函数和 OnTouchListener&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Java】生产者消费者模式的实现</title>
    <link href="http://github.com/2017/11/10/%E3%80%90Java%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://github.com/2017/11/10/【Java】生产者消费者模式的实现/</id>
    <published>2017-11-10T14:20:55.000Z</published>
    <updated>2017-11-16T11:16:15.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。</p>
<p>阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。</p>
<a id="more"></a>
<h3 id="wait-notify方法"><a href="#wait-notify方法" class="headerlink" title="wait/notify方法"></a>wait/notify方法</h3><p>首先，我们搞清楚Thread.sleep()方法和Object.wait()、Object.notify()方法的区别。根据这篇文章<a href="https://www.zhihu.com/question/23328075" target="_blank" rel="external">java sleep和wait的区别的疑惑?</a></p>
<ol>
<li><p><code>sleep()</code>是Thread类的方法；而<code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>是Object类中定义的方法；尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的。</p>
</li>
<li><p><code>Thread.sleep()</code>不会导致锁行为的改变，如果当前线程是拥有锁的，那么<code>Thread.sleep()</code>不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用<code>Thread.sleep()</code>是不会影响锁的相关行为。</p>
</li>
<li><p><code>Thread.sleep</code>和<code>Object.wait</code>都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。</p>
</li>
</ol>
<p><strong>线程状态图：</strong></p>
<p><img src="/gallery/android_common/1886630-1301e97750ae36a3.jpg" alt=""></p>
<ul>
<li><code>Thread.sleep()</code>让线程从 【running】 -&gt; 【阻塞态】 时间结束/interrupt -&gt; 【runnable】</li>
<li><code>Object.wait()</code>让线程从 【running】 -&gt; 【等待队列】notify  -&gt; 【锁池】 -&gt; 【runnable】</li>
</ul>
<h3 id="实现生产者消费者模型"><a href="#实现生产者消费者模型" class="headerlink" title="实现生产者消费者模型"></a>实现生产者消费者模型</h3><p>生产者消费者问题是研究多线程程序时绕不开的经典问题之一，它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。</p>
<p>（1）<strong>Object</strong>的wait() / notify()方法<br>（2）<strong>Lock</strong>和<strong>Condition</strong>的await() / signal()方法<br>（3）<strong>BlockingQueue</strong>阻塞队列方法<br>（4）<strong>PipedInputStream</strong> / <strong>PipedOutputStream</strong></p>
<p>本文只介绍最常用的前三种，第四种暂不做讨论。源代码在这里：<a href="https://github.com/iTimeTraveler/DataStructureAndAlgorithms/tree/master/src/main/java/multithread">Java实现生产者消费者模型</a></p>
<h4 id="1-使用Object的wait-notify-方法"><a href="#1-使用Object的wait-notify-方法" class="headerlink" title="1. 使用Object的wait() / notify()方法"></a>1. 使用Object的wait() / notify()方法</h4><p><code>wait()</code>/ <code>nofity()</code>方法是基类Object的两个方法，也就意味着所有Java类都会拥有这两个方法，这样，我们就可以为任何对象实现同步机制。</p>
<ul>
<li><code>wait()</code>：当缓冲区已满/空时，生产者/消费者线程停止自己的执行，放弃锁，使自己处于等待状态，让其他线程执行。</li>
<li><code>notify()</code>：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 生产者消费者模式：使用Object.wait() / notify()方法实现</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">5</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">		</div><div class="line">		Thread producer1 = <span class="keyword">new</span> Producer(<span class="string">"P-1"</span>, queue, CAPACITY);</div><div class="line">		Thread producer2 = <span class="keyword">new</span> Producer(<span class="string">"P-2"</span>, queue, CAPACITY);</div><div class="line">		Thread consumer1 = <span class="keyword">new</span> Consumer(<span class="string">"C1"</span>, queue, CAPACITY);</div><div class="line">		Thread consumer2 = <span class="keyword">new</span> Consumer(<span class="string">"C2"</span>, queue, CAPACITY);</div><div class="line">		Thread consumer3 = <span class="keyword">new</span> Consumer(<span class="string">"C3"</span>, queue, CAPACITY);</div><div class="line"></div><div class="line">		producer1.start();</div><div class="line">		producer2.start();</div><div class="line">		consumer1.start();</div><div class="line">		consumer2.start();</div><div class="line">		consumer3.start();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 生产者</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		<span class="keyword">private</span> Queue&lt;Integer&gt; queue;</div><div class="line">		String name;</div><div class="line">		<span class="keyword">int</span> maxSize;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String name, Queue&lt;Integer&gt; queue, <span class="keyword">int</span> maxSize)</span></span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="keyword">this</span>.name = name;</div><div class="line">			<span class="keyword">this</span>.queue = queue;</div><div class="line">			<span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">				<span class="keyword">synchronized</span>(queue)&#123;</div><div class="line">					<span class="keyword">while</span>(queue.size() == maxSize)&#123;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">							System.out .println(<span class="string">"Queue is full, Producer["</span> + name + <span class="string">"] thread waiting for "</span> + <span class="string">"consumer to take something from queue."</span>);</div><div class="line">							queue.wait();</div><div class="line">						&#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">							ex.printStackTrace();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					System.out.println(<span class="string">"["</span> + name + <span class="string">"] Producing value : +"</span> + i);</div><div class="line">					queue.offer(i++);</div><div class="line">					queue.notifyAll();</div><div class="line"></div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 消费者</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		<span class="keyword">private</span> Queue&lt;Integer&gt; queue;</div><div class="line">		String name;</div><div class="line">		<span class="keyword">int</span> maxSize;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name, Queue&lt;Integer&gt; queue, <span class="keyword">int</span> maxSize)</span></span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="keyword">this</span>.name = name;</div><div class="line">			<span class="keyword">this</span>.queue = queue;</div><div class="line">			<span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">				<span class="keyword">synchronized</span>(queue)&#123;</div><div class="line">					<span class="keyword">while</span>(queue.isEmpty())&#123;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">							System.out.println(<span class="string">"Queue is empty, Consumer["</span> + name + <span class="string">"] thread is waiting for Producer"</span>);</div><div class="line">							queue.wait();</div><div class="line">						&#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">							ex.printStackTrace();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">int</span> x = queue.poll();</div><div class="line">					System.out.println(<span class="string">"["</span> + name + <span class="string">"] Consuming value : "</span> + x);</div><div class="line">					queue.notifyAll();</div><div class="line"></div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h5><p>判断Queue大小为0或者大于等于queueSize时须使用 <code>while (condition) {}</code>，不能使用 <code>if(condition) {}</code>。其中 <code>while(condition)</code>循环，它又被叫做<strong>“自旋锁”</strong>。自旋锁以及<code>wait()</code>和<code>notify()</code>方法在<a href="http://ifeve.com/thread-signaling/" target="_blank" rel="external">线程通信</a>这篇文章中有更加详细的介绍。为防止该线程没有收到<code>notify()</code>调用也从<code>wait()</code>中返回（也称作<strong>虚假唤醒</strong>），这个线程会重新去检查condition条件以决定当前是否可以安全地继续执行还是需要重新保持等待，而不是认为线程被唤醒了就可以安全地继续执行了。</p>
<p>输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">0</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">1</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">2</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">3</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">4</span></div><div class="line">Queue is full, Producer[P-<span class="number">1</span>] thread waiting <span class="keyword">for</span> consumer to take something from queue.</div><div class="line">[C3] Consuming value : <span class="number">0</span></div><div class="line">[C3] Consuming value : <span class="number">1</span></div><div class="line">[C3] Consuming value : <span class="number">2</span></div><div class="line">[C3] Consuming value : <span class="number">3</span></div><div class="line">[C3] Consuming value : <span class="number">4</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">0</span></div><div class="line">[C1] Consuming value : <span class="number">0</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">5</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">6</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">7</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">8</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">9</span></div><div class="line">Queue is full, Producer[P-<span class="number">1</span>] thread waiting <span class="keyword">for</span> consumer to take something from queue.</div><div class="line">[C3] Consuming value : <span class="number">5</span></div><div class="line">[C3] Consuming value : <span class="number">6</span></div><div class="line">[C3] Consuming value : <span class="number">7</span></div><div class="line">[C3] Consuming value : <span class="number">8</span></div><div class="line">[C3] Consuming value : <span class="number">9</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">1</span></div><div class="line">[C1] Consuming value : <span class="number">1</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">10</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">11</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">12</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">13</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">14</span></div><div class="line">Queue is full, Producer[P-<span class="number">1</span>] thread waiting <span class="keyword">for</span> consumer to take something from queue.</div><div class="line">[C3] Consuming value : <span class="number">10</span></div><div class="line">[C3] Consuming value : <span class="number">11</span></div><div class="line">[C3] Consuming value : <span class="number">12</span></div><div class="line">[C3] Consuming value : <span class="number">13</span></div><div class="line">[C3] Consuming value : <span class="number">14</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">2</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">3</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">4</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">5</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">6</span></div><div class="line">Queue is full, Producer[P-<span class="number">2</span>] thread waiting <span class="keyword">for</span> consumer to take something from queue.</div><div class="line">[C1] Consuming value : <span class="number">2</span></div><div class="line">[C1] Consuming value : <span class="number">3</span></div><div class="line">[C1] Consuming value : <span class="number">4</span></div><div class="line">[C1] Consuming value : <span class="number">5</span></div><div class="line">[C1] Consuming value : <span class="number">6</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">15</span></div><div class="line">[C3] Consuming value : <span class="number">15</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">7</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">8</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">9</span></div></pre></td></tr></table></figure>
<h4 id="2-使用Lock和Condition的await-signal-方法"><a href="#2-使用Lock和Condition的await-signal-方法" class="headerlink" title="2. 使用Lock和Condition的await() / signal()方法"></a>2. 使用Lock和Condition的await() / signal()方法</h4><p>在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步、锁定、线程池等，它们可以实现更细粒度的线程控制。Condition接口的<code>await()</code>和<code>signal()</code>就是其中用来做同步的两种方法，它们的功能基本上和Object的<code>wait()</code>/ <code>nofity()</code>相同，完全可以取代它们，但是它们和新引入的锁定机制<code>Lock</code>直接挂钩，具有更大的灵活性。通过在<code>Lock</code>对象上调用<code>newCondition()</code>方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。下面来看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 生产者消费者模式：使用Lock和Condition实现</div><div class="line"> * &#123;<span class="doctag">@link</span> java.util.concurrent.locks.Lock&#125;</div><div class="line"> * &#123;<span class="doctag">@link</span> java.util.concurrent.locks.Condition&#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerByLock</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">5</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition fullCondition = lock.newCondition();		<span class="comment">//队列满的条件</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition emptyCondition = lock.newCondition();		<span class="comment">//队列空的条件</span></div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line"></div><div class="line">		Thread producer1 = <span class="keyword">new</span> Producer(<span class="string">"P-1"</span>, queue, CAPACITY);</div><div class="line">		Thread producer2 = <span class="keyword">new</span> Producer(<span class="string">"P-2"</span>, queue, CAPACITY);</div><div class="line">		Thread consumer1 = <span class="keyword">new</span> Consumer(<span class="string">"C1"</span>, queue, CAPACITY);</div><div class="line">		Thread consumer2 = <span class="keyword">new</span> Consumer(<span class="string">"C2"</span>, queue, CAPACITY);</div><div class="line">		Thread consumer3 = <span class="keyword">new</span> Consumer(<span class="string">"C3"</span>, queue, CAPACITY);</div><div class="line"></div><div class="line">		producer1.start();</div><div class="line">		producer2.start();</div><div class="line">		consumer1.start();</div><div class="line">		consumer2.start();</div><div class="line">		consumer3.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 生产者</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		<span class="keyword">private</span> Queue&lt;Integer&gt; queue;</div><div class="line">		String name;</div><div class="line">		<span class="keyword">int</span> maxSize;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String name, Queue&lt;Integer&gt; queue, <span class="keyword">int</span> maxSize)</span></span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="keyword">this</span>.name = name;</div><div class="line">			<span class="keyword">this</span>.queue = queue;</div><div class="line">			<span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"></div><div class="line">				<span class="comment">//获得锁</span></div><div class="line">				lock.lock();</div><div class="line">				<span class="keyword">while</span>(queue.size() == maxSize)&#123;</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						System.out .println(<span class="string">"Queue is full, Producer["</span> + name + <span class="string">"] thread waiting for "</span> + <span class="string">"consumer to take something from queue."</span>);</div><div class="line">						<span class="comment">//条件不满足，生产阻塞</span></div><div class="line">						fullCondition.await();</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">						ex.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				System.out.println(<span class="string">"["</span> + name + <span class="string">"] Producing value : +"</span> + i);</div><div class="line">				queue.offer(i++);</div><div class="line"></div><div class="line">				<span class="comment">//唤醒其他所有生产者、消费者</span></div><div class="line">				fullCondition.signalAll();</div><div class="line">				emptyCondition.signalAll();</div><div class="line"></div><div class="line">				<span class="comment">//释放锁</span></div><div class="line">				lock.unlock();</div><div class="line"></div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 消费者</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		<span class="keyword">private</span> Queue&lt;Integer&gt; queue;</div><div class="line">		String name;</div><div class="line">		<span class="keyword">int</span> maxSize;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name, Queue&lt;Integer&gt; queue, <span class="keyword">int</span> maxSize)</span></span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="keyword">this</span>.name = name;</div><div class="line">			<span class="keyword">this</span>.queue = queue;</div><div class="line">			<span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">				<span class="comment">//获得锁</span></div><div class="line">				lock.lock();</div><div class="line"></div><div class="line">				<span class="keyword">while</span>(queue.isEmpty())&#123;</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						System.out.println(<span class="string">"Queue is empty, Consumer["</span> + name + <span class="string">"] thread is waiting for Producer"</span>);</div><div class="line">						<span class="comment">//条件不满足，消费阻塞</span></div><div class="line">						emptyCondition.await();</div><div class="line">					&#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">						ex.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">int</span> x = queue.poll();</div><div class="line">				System.out.println(<span class="string">"["</span> + name + <span class="string">"] Consuming value : "</span> + x);</div><div class="line"></div><div class="line">				<span class="comment">//唤醒其他所有生产者、消费者</span></div><div class="line">				fullCondition.signalAll();</div><div class="line">				emptyCondition.signalAll();</div><div class="line"></div><div class="line">				<span class="comment">//释放锁</span></div><div class="line">				lock.unlock();</div><div class="line"></div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输入日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">0</span></div><div class="line">[C1] Consuming value : <span class="number">0</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">0</span></div><div class="line">[C3] Consuming value : <span class="number">0</span></div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">1</span></div><div class="line">[C2] Consuming value : <span class="number">1</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">1</span></div><div class="line">[C1] Consuming value : <span class="number">1</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">2</span></div><div class="line">[C3] Consuming value : <span class="number">2</span></div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">2</span></div><div class="line">[C2] Consuming value : <span class="number">2</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">3</span></div><div class="line">[C1] Consuming value : <span class="number">3</span></div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">3</span></div><div class="line">[C2] Consuming value : <span class="number">3</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">4</span></div><div class="line">[C1] Consuming value : <span class="number">4</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">4</span></div><div class="line">[C3] Consuming value : <span class="number">4</span></div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">5</span></div><div class="line">[C2] Consuming value : <span class="number">5</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">5</span></div><div class="line">[C1] Consuming value : <span class="number">5</span></div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">6</span></div><div class="line">[C2] Consuming value : <span class="number">6</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">6</span></div><div class="line">[C3] Consuming value : <span class="number">6</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">7</span></div><div class="line">[C3] Consuming value : <span class="number">7</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">7</span></div><div class="line">[C1] Consuming value : <span class="number">7</span></div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">8</span></div><div class="line">[C2] Consuming value : <span class="number">8</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">8</span></div><div class="line">[C1] Consuming value : <span class="number">8</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">9</span></div><div class="line">[C3] Consuming value : <span class="number">9</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">10</span></div><div class="line">[C2] Consuming value : <span class="number">10</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">9</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">10</span></div><div class="line">[C1] Consuming value : <span class="number">9</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">11</span></div><div class="line">[C3] Consuming value : <span class="number">10</span></div><div class="line">[C2] Consuming value : <span class="number">11</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">12</span></div><div class="line">[C1] Consuming value : <span class="number">12</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">11</span></div><div class="line">[C3] Consuming value : <span class="number">11</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">13</span></div><div class="line">[C2] Consuming value : <span class="number">13</span></div><div class="line">Queue is empty, Consumer[C2] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">12</span></div><div class="line">[C2] Consuming value : <span class="number">12</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">13</span></div><div class="line">[C3] Consuming value : <span class="number">13</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">14</span></div><div class="line">[C1] Consuming value : <span class="number">14</span></div><div class="line">Queue is empty, Consumer[C3] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">14</span></div><div class="line">[C3] Consuming value : <span class="number">14</span></div><div class="line">Queue is empty, Consumer[C1] thread is waiting <span class="keyword">for</span> Producer</div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">15</span></div><div class="line">[C1] Consuming value : <span class="number">15</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">15</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">16</span></div><div class="line">[C3] Consuming value : <span class="number">15</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">16</span></div></pre></td></tr></table></figure>
<h4 id="3-使用BlockingQueue阻塞队列方法"><a href="#3-使用BlockingQueue阻塞队列方法" class="headerlink" title="3. 使用BlockingQueue阻塞队列方法"></a>3. 使用BlockingQueue阻塞队列方法</h4><p>JDK 1.5 以后新增的 <code>java.util.concurrent</code>包新增了 <code>BlockingQueue</code> 接口。并提供了如下几种阻塞队列实现：</p>
<ul>
<li>java.util.concurrent.<strong>ArrayBlockingQueue</strong></li>
<li>java.util.concurrent.<strong>LinkedBlockingQueue</strong></li>
<li>java.util.concurrent.<strong>SynchronousQueue</strong></li>
<li>java.util.concurrent.<strong>PriorityBlockingQueue</strong></li>
</ul>
<p>实现生产者-消费者模型使用 <code>ArrayBlockingQueue</code>或者 <code>LinkedBlockingQueue</code>即可。</p>
<p>我们这里使用<code>LinkedBlockingQueue</code>，它是一个已经在内部实现了同步的队列，实现方式采用的是我们第2种<code>await()</code>/ <code>signal()</code>方法。它可以在生成对象时指定容量大小。它用于阻塞操作的是put()和take()方法。</p>
<ul>
<li><code>put()</code>方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。</li>
<li><code>take()</code>方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。</li>
</ul>
<p>我们可以跟进源码看一下<code>LinkedBlockingQueue</code>类的<code>put()</code>方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** Main lock guarding all access */</span></div><div class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="comment">/** Condition for waiting takes */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</div><div class="line"></div><div class="line"><span class="comment">/** Condition for waiting puts */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    putLast(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (!linkLast(node))</div><div class="line">            notFull.await();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这里证实了它的实现方式采用的是我们第2种<code>await()</code>/ <code>signal()</code>方法。下面我们就使用它实现吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 生产者消费者模式：使用&#123;<span class="doctag">@link</span> java.util.concurrent.BlockingQueue&#125;实现</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerByBQ</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">5</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		LinkedBlockingDeque&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;Integer&gt;(CAPACITY);</div><div class="line"></div><div class="line">		Thread producer1 = <span class="keyword">new</span> Producer(<span class="string">"P-1"</span>, blockingQueue, CAPACITY);</div><div class="line">		Thread producer2 = <span class="keyword">new</span> Producer(<span class="string">"P-2"</span>, blockingQueue, CAPACITY);</div><div class="line">		Thread consumer1 = <span class="keyword">new</span> Consumer(<span class="string">"C1"</span>, blockingQueue, CAPACITY);</div><div class="line">		Thread consumer2 = <span class="keyword">new</span> Consumer(<span class="string">"C2"</span>, blockingQueue, CAPACITY);</div><div class="line">		Thread consumer3 = <span class="keyword">new</span> Consumer(<span class="string">"C3"</span>, blockingQueue, CAPACITY);</div><div class="line"></div><div class="line">		producer1.start();</div><div class="line">		producer2.start();</div><div class="line">		consumer1.start();</div><div class="line">		consumer2.start();</div><div class="line">		consumer3.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 生产者</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		<span class="keyword">private</span> LinkedBlockingDeque&lt;Integer&gt; blockingQueue;</div><div class="line">		String name;</div><div class="line">		<span class="keyword">int</span> maxSize;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String name, LinkedBlockingDeque&lt;Integer&gt; queue, <span class="keyword">int</span> maxSize)</span></span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="keyword">this</span>.name = name;</div><div class="line">			<span class="keyword">this</span>.blockingQueue = queue;</div><div class="line">			<span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					blockingQueue.put(i);</div><div class="line">					System.out.println(<span class="string">"["</span> + name + <span class="string">"] Producing value : +"</span> + i);</div><div class="line">					i++;</div><div class="line"></div><div class="line">					<span class="comment">//暂停最多1秒</span></div><div class="line">					Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 消费者</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		<span class="keyword">private</span> LinkedBlockingDeque&lt;Integer&gt; blockingQueue;</div><div class="line">		String name;</div><div class="line">		<span class="keyword">int</span> maxSize;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name, LinkedBlockingDeque&lt;Integer&gt; queue, <span class="keyword">int</span> maxSize)</span></span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="keyword">this</span>.name = name;</div><div class="line">			<span class="keyword">this</span>.blockingQueue = queue;</div><div class="line">			<span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="keyword">int</span> x = blockingQueue.take();</div><div class="line">					System.out.println(<span class="string">"["</span> + name + <span class="string">"] Consuming : "</span> + x);</div><div class="line"></div><div class="line">					<span class="comment">//暂停最多1秒</span></div><div class="line">					Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">0</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">0</span></div><div class="line">[C1] Consuming : <span class="number">0</span></div><div class="line">[C3] Consuming : <span class="number">0</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">1</span></div><div class="line">[C2] Consuming : <span class="number">1</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">2</span></div><div class="line">[C1] Consuming : <span class="number">2</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">1</span></div><div class="line">[C2] Consuming : <span class="number">1</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">2</span></div><div class="line">[C3] Consuming : <span class="number">2</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">3</span></div><div class="line">[C2] Consuming : <span class="number">3</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">3</span></div><div class="line">[C1] Consuming : <span class="number">3</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">4</span></div><div class="line">[C2] Consuming : <span class="number">4</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">4</span></div><div class="line">[C3] Consuming : <span class="number">4</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">5</span></div><div class="line">[C1] Consuming : <span class="number">5</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">5</span></div><div class="line">[C2] Consuming : <span class="number">5</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">6</span></div><div class="line">[C1] Consuming : <span class="number">6</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">6</span></div><div class="line">[C2] Consuming : <span class="number">6</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">7</span></div><div class="line">[C2] Consuming : <span class="number">7</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">7</span></div><div class="line">[C1] Consuming : <span class="number">7</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">8</span></div><div class="line">[C3] Consuming : <span class="number">8</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">9</span></div><div class="line">[C2] Consuming : <span class="number">9</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">8</span></div><div class="line">[C2] Consuming : <span class="number">8</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">10</span></div><div class="line">[C1] Consuming : <span class="number">10</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">9</span></div><div class="line">[C3] Consuming : <span class="number">9</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">10</span></div><div class="line">[C2] Consuming : <span class="number">10</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">11</span></div><div class="line">[C1] Consuming : <span class="number">11</span></div><div class="line">[C3] Consuming : <span class="number">12</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">12</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">13</span></div><div class="line">[C2] Consuming : <span class="number">13</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">11</span></div><div class="line">[C3] Consuming : <span class="number">11</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">12</span></div><div class="line">[C3] Consuming : <span class="number">12</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">14</span></div><div class="line">[C1] Consuming : <span class="number">14</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">13</span></div><div class="line">[C2] Consuming : <span class="number">13</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">15</span></div><div class="line">[C3] Consuming : <span class="number">15</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">16</span></div><div class="line">[C1] Consuming : <span class="number">16</span></div><div class="line">[P-<span class="number">1</span>] Producing value : +<span class="number">14</span></div><div class="line">[C3] Consuming : <span class="number">14</span></div><div class="line">[P-<span class="number">2</span>] Producing value : +<span class="number">17</span></div><div class="line">[C2] Consuming : <span class="number">17</span></div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.geeksforgeeks.org/producer-consumer-solution-using-threads-java/" target="_blank" rel="external">Producer-Consumer solution using threads in Java</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="external">生产者消费者问题 - 维基百科</a></li>
<li><a href="http://blog.csdn.net/monkey_d_meng/article/details/6251879/" target="_blank" rel="external">生产者/消费者问题的多种Java实现方式</a></li>
<li><a href="http://www.importnew.com/16453.html" target="_blank" rel="external">如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例</a></li>
<li><a href="http://www.cnblogs.com/hapjin/p/5492645.html" target="_blank" rel="external">JAVA多线程之wait/notify</a></li>
<li><a href="https://www.zhihu.com/question/23328075" target="_blank" rel="external">java sleep和wait的区别的疑惑?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。&lt;/p&gt;
&lt;p&gt;阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Android】Dialog异常CalledFromWrongThreadException深入分析</title>
    <link href="http://github.com/2017/10/26/%E3%80%90Android%E3%80%91Dialog%E5%BC%82%E5%B8%B8CalledFromWrongThreadException%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>http://github.com/2017/10/26/【Android】Dialog异常CalledFromWrongThreadException深入分析/</id>
    <published>2017-10-26T14:20:55.000Z</published>
    <updated>2017-10-27T01:53:34.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在使用Dialog时，因为线程问题，在调用dismiss方法时出现了CalledFromWrongThreadException的Crash，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</div></pre></td></tr></table></figure>
<p>抛出异常为<code>CalledFromWrongThreadException</code>，很明显第一反应就是出现了非ui线程进行了ui操作造成了此异常。通过分析工程代码，发现本质上是因为在非ui线程中创建了Dialog，而在主线程（即ui线程）中调用了<code>show()</code>以及<code>dismiss()</code>方法，我把问题模型写成测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity test"</span>;</div><div class="line">    <span class="keyword">private</span> ProgressDialog dialog;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                Looper.prepare();</div><div class="line"></div><div class="line">                <span class="comment">//子线程中创建Dialog</span></div><div class="line">                dialog = <span class="keyword">new</span> ProgressDialog(MainActivity.<span class="keyword">this</span>);</div><div class="line">                dialog.setCanceledOnTouchOutside(<span class="keyword">true</span>);</div><div class="line">                dialog.setOnCancelListener(<span class="keyword">new</span> DialogInterface.OnCancelListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(DialogInterface dialog)</span> </span>&#123;</div><div class="line">                        Log.d(TAG, <span class="string">"Dialog onCancel thread: "</span> + getThreadInfo());</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">                dialog.setOnDismissListener(<span class="keyword">new</span> DialogInterface.OnDismissListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDismiss</span><span class="params">(DialogInterface dialog)</span> </span>&#123;</div><div class="line">                        Log.d(TAG, <span class="string">"Dialog onDismiss thread: "</span> + getThreadInfo());</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">                dialog.setMessage(<span class="string">"正在加载..."</span>);</div><div class="line">                Log.d(TAG, <span class="string">"Dialog create thread: "</span> + getThreadInfo());</div><div class="line"></div><div class="line">                Looper.loop();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line"></div><div class="line">        Button btn = (Button) findViewById(R.id.btn_helloworld);</div><div class="line">        btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="comment">//UI主线程中show，然后点击空白区域dismiss</span></div><div class="line">                dialog.show();</div><div class="line">                Log.d(TAG, <span class="string">"Dialog show thread: "</span> + getThreadInfo());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 输出线程信息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getThreadInfo</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"["</span> + Thread.currentThread().getId() + <span class="string">"]"</span> +</div><div class="line">                ((Looper.myLooper() == Looper.getMainLooper())? <span class="string">" is UI-Thread"</span> : <span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是Activity打开的时候，使用work子线程创建了一个Dialog，然后手动点击按钮的时候，显示Dialog。再点击空白处，dialog本应该dismiss的，但是直接crash了。抛出了<code>CalledFromWrongThreadException</code>的异常。</p>
<p>在上面的代码中，我顺便输出了Dialog每个操作的线程ID，同时会判定是不是ui主线程。我们来看看log：</p>
<blockquote>
<p>10-26 16:11:07.836 7405-7652/com.cuc.myandroidtest D/MainActivity test: Dialog create thread: [3953]<br>10-26 16:11:27.763 7405-7405/com.cuc.myandroidtest D/MainActivity test: Dialog show thread: [1] is UI-Thread<br>10-26 16:11:35.642 7405-7652/com.cuc.myandroidtest D/MainActivity test: Dialog onCancel thread: [3953]</p>
<p>——– beginning of crash</p>
</blockquote>
<p>可以看到，以上出现的问题中执行Dialog操作的线程信息如下：</p>
<ul>
<li>创建Dialog：work子线程</li>
<li>show()：ui主线程</li>
<li>cancel()：work子线程</li>
<li>dismiss()：因为crash没有执行到，未知</li>
</ul>
<p>如果说<strong>只有创建这个控件的线程才能去更新该控件的内容</strong>。那么在调用show方法的时候为什么不会crash，然后dismiss的时候才会崩溃？</p>
<p>另外，到底是不是所有的操作都必须放到ui线程中执行才对？带着疑问我们深入Dialog源码一看究竟。</p>
<a id="more"></a>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>我们先看Dialog的dismiss方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Dismiss this dialog, removing it from the screen. This method can be</div><div class="line"> * invoked safely from any thread.  Note that you should not override this</div><div class="line"> * method to do cleanup when the dialog is dismissed, instead implement</div><div class="line"> * that in &#123;<span class="doctag">@link</span> #onStop&#125;.</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dismiss</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Looper.myLooper() == mHandler.getLooper()) &#123;</div><div class="line">        dismissDialog();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mHandler.post(mDismissAction);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mDismissAction = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        dismissDialog();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们先看注释，意思是<strong>dismiss()这个函数可以在任意线程中调用，不用担心线程安全问题</strong>。</p>
<p>很明显，dialog对于ui操作做了特别处理。如果当前执行dismiss操作的线程和mHandler所依附的线程不一致的话那么就会将dismiss操作丢到对应的mHandler的线程队列中等待执行。那么这个Handler又是哪里来的呢？</p>
<p>我们开始调查，可以看到<code>mHandler</code>对象是Dialog类中私有的，会在new Dialog的时候自动初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Dialog implements DialogInterface, Window.Callback,</div><div class="line">        KeyEvent.Callback, OnCreateContextMenuListener, Window.OnWindowDismissedCallback &#123;</div><div class="line"></div><div class="line">    private final Handler mHandler = new Handler();</div><div class="line">    </div><div class="line">    //...省略其余代码...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以分析得出，该mHandler直接关联的就是new Dialog的线程。也就能得出以下结论：</p>
<blockquote>
<p><strong>结论一</strong>：最终真正执行<code>dismissDialog()</code>方法销毁Dialog的线程就是new Dialog的线程。</p>
</blockquote>
<p>然后我们跟进去<code>dismissDialog()</code>看看到底如何销毁Dialog的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dismissDialog</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span> || !mShowing) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mWindow.isDestroyed()) &#123;</div><div class="line">        Log.e(TAG, <span class="string">"Tried to dismissDialog() but the Dialog's window was already destroyed!"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mWindowManager.removeViewImmediate(mDecor);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mActionMode != <span class="keyword">null</span>) &#123;</div><div class="line">            mActionMode.finish();</div><div class="line">        &#125;</div><div class="line">        mDecor = <span class="keyword">null</span>;</div><div class="line">        mWindow.closeAllPanels();</div><div class="line">        onStop();</div><div class="line">        mShowing = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        sendDismissMessage();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出最终调用了<code>mWindowManager.removeViewImmediate(mDecor);</code>来销毁Dialog，继续跟进<code>removeViewImmediate()</code>这个方法。发现<code>mWindowManager</code>的类WindowManager是个abstract的类，我们来找找本尊。</p>
<h4 id="Dialog中mWindowManager对象的来历"><a href="#Dialog中mWindowManager对象的来历" class="headerlink" title="Dialog中mWindowManager对象的来历"></a>Dialog中mWindowManager对象的来历</h4><p>发现<code>mWindowManager</code>这个对象的初始化是在Dialog的构造函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Dialog(Context context, <span class="keyword">int</span> theme, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</div><div class="line">    <span class="keyword">if</span> (createContextThemeWrapper) &#123;</div><div class="line">        <span class="keyword">if</span> (theme == <span class="number">0</span>) &#123;</div><div class="line">            TypedValue outValue = <span class="keyword">new</span> TypedValue();</div><div class="line">            context.getTheme().resolveAttribute(com.android.internal.R.attr.dialogTheme,</div><div class="line">                    outValue, <span class="keyword">true</span>);</div><div class="line">            theme = outValue.resourceId;</div><div class="line">        &#125;</div><div class="line">        mContext = <span class="keyword">new</span> ContextThemeWrapper(context, theme);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mWindowManager = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">    Window w = PolicyManager.makeNewWindow(mContext);</div><div class="line">    mWindow = w;</div><div class="line">    w.setCallback(<span class="keyword">this</span>);</div><div class="line">    w.setOnWindowDismissedCallback(<span class="keyword">this</span>);</div><div class="line">    w.setWindowManager(mWindowManager, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    w.setGravity(Gravity.CENTER);</div><div class="line">    mListenersHandler = <span class="keyword">new</span> ListenersHandler(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它是通过<code>context.getSystemService(Context.WINDOW_SERVICE);</code>得到的，这里的context肯定就是Activity了，我们去Activity中找<code>getSystemService()</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(@ServiceName @NonNull String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (getBaseContext() == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                <span class="string">"System services not available to Activities before onCreate()"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (WINDOW_SERVICE.equals(name)) &#123;</div><div class="line">        <span class="keyword">return</span> mWindowManager;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SEARCH_SERVICE.equals(name)) &#123;</div><div class="line">        ensureSearchManager();</div><div class="line">        <span class="keyword">return</span> mSearchManager;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSystemService(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></div><div class="line">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</div><div class="line">        Application application, Intent intent, ActivityInfo info,</div><div class="line">        CharSequence title, Activity parent, String id,</div><div class="line">        NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">        Configuration config, IVoiceInteractor voiceInteractor) &#123;</div><div class="line"></div><div class="line">    mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</div><div class="line">            mToken, mComponent.flattenToString(),</div><div class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</div><div class="line"></div><div class="line">    mWindowManager = mWindow.getWindowManager();</div><div class="line">    </div><div class="line">    <span class="comment">//...省略其他代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到<code>mWindowManager</code>这个对象是在Activity被创建之后调用attach函数的时候通过<code>mWindow.setWindowManager()</code>初始化的，而这个函数里干了什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName,</span></span></div><div class="line">        <span class="keyword">boolean</span> hardwareAccelerated) &#123;</div><div class="line">    mAppToken = appToken;</div><div class="line">    mAppName = appName;</div><div class="line">    mHardwareAccelerated = hardwareAccelerated</div><div class="line">            || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, <span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (wm == <span class="keyword">null</span>) &#123;</div><div class="line">        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">    &#125;</div><div class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>mWindowManager</code>这个对象最终来源于<code>WindowManagerImpl</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Display mDisplay;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Window mParentWindow;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> WindowManagerImpl <span class="title">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(mDisplay, parentWindow);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</div><div class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">        mGlobal.removeView(view, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeViewImmediate</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">        mGlobal.removeView(view, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//...省略其余代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在其中我们终于看到了<code>removeViewImmediate()</code>函数的身影，也就是说，在执行Dialog销毁的函数<code>dismissDialog()</code>中，最终调用了<code>mWindowManager.removeViewImmediate(mDecor);</code>来销毁Dialog。实际上调用的就是<code>WindowManagerImpl</code>实例中的<code>removeViewImmediate()</code>方法。</p>
<p>而它又调用的是<code>WindowManagerGlobal</code>的<code>removeView()</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</div><div class="line">        View curView = mRoots.get(index).getView();</div><div class="line">        removeViewLocked(index, immediate);</div><div class="line">        <span class="keyword">if</span> (curView == view) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Calling with view "</span> + view</div><div class="line">                + <span class="string">" but the ViewAncestor is attached to "</span> + curView);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</div><div class="line">    ViewRootImpl root = mRoots.get(index);</div><div class="line">    View view = root.getView();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">        InputMethodManager imm = InputMethodManager.getInstance();</div><div class="line">        <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</div><div class="line">            imm.windowDismissed(mViews.get(index).getWindowToken());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate);</div><div class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">        view.assignParent(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (deferred) &#123;</div><div class="line">            mDyingViews.add(view);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这句<code>boolean deferred = root.die(immediate);</code>，其中root对象是个<code>ViewRootImpl</code>的实例，我们看看它的<code>die()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></div><div class="line">    <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></div><div class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</div><div class="line">        doDie();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="comment">//...省略其余代码...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</div><div class="line">    checkThread();</div><div class="line">    </div><div class="line">    <span class="comment">//...省略其余代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，执行到了<code>ViewRootImpl</code>类的<code>doDie()</code>方法，这个方法的第一句就是<code>checkThread()</code>，根据<a href="https://my.oschina.net/qixiaobo025/blog/195396" target="_blank" rel="external">Android4.4DialogUI线程CalledFromWrongThreadExcection</a>这篇文章，我们知道最终抛出异常的位置就是是在<code>ViewRootImpl</code>代码中的<code>checkThread</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</div><div class="line">                <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，当调用Dialog的<code>dismiss()</code>方法时，Dialog会自动抛到new Dialog的线程中执行，而这个线程就是当前的<code>Thread.currentThread()</code>。换句话说ViewRootImpl本身的mThread和这个new Dialog的线程不是同一个线程。然后我们看看这个ViewRootImpl本身的mThread的来源在何处。</p>
<h4 id="ViewRootImpl中mThread的来历"><a href="#ViewRootImpl中mThread的来历" class="headerlink" title="ViewRootImpl中mThread的来历"></a>ViewRootImpl中mThread的来历</h4><p>在ViewRootImpl的构造函数中发现了mThread赋值的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">    </div><div class="line">    <span class="comment">//...省略其余代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那这个ViewRootImpl什么时候调用这个构造函数创建实例的呢？我们刚才在<code>WindowManagerGlobal</code>的<code>removeView()</code>函数中，看到了<code>root</code>对象是从<code>mRoots</code>对象中取出来的，而<code>mRoots</code>是一个<code>ArrayList&lt;ViewRootImpl&gt;</code>。</p>
<p>所以我们来<code>WindowManagerGlobal</code>中找找<code>mRoots.add()</code>的地方，发现是在它的<code>addView()</code>函数中创建了一个<code>ViewRootImpl</code>对象并添加到了<code>mRoots</code>这个list中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></div><div class="line">        Display display, Window parentWindow) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//...省略其余代码.....</span></div><div class="line"></div><div class="line">    ViewRootImpl root;</div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">       </div><div class="line">       <span class="comment">//...省略其余代码.....</span></div><div class="line"></div><div class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</div><div class="line">        mRoots.add(root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// do this last because it fires off messages to start doing things</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        root.setView(view, wparams, panelParentView);</div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">        <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">                removeViewLocked(index, <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而这个<code>addView</code>方法什么时候会调用呢？就是<code>WindowManagerImpl</code>。</p>
<p>就是刚才分析Dialog中<code>mWindowManager</code>对象的来历时，知道了它其实是<code>WindowManagerImpl</code>类的一个实例，WindowManagerImpl会通过<code>WindowManagerGlobal</code>的<code>removeView()</code>方法去实现removeView。同理，此处<code>WindowManagerGlobal</code>的<code>addView()</code>方法也是被WindowManagerImpl调用的。</p>
<p>我们在Dialog的源码中找一下<code>mWindowManager</code>对象调用<code>addView()</code>方法的地方，很让人惊喜，它竟然在Dialog的<code>show()</code>方法中出现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//...省略其余代码.....</span></div><div class="line">    onStart();</div><div class="line">    mDecor = mWindow.getDecorView();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mWindowManager.addView(mDecor, l);</div><div class="line">        mShowing = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        sendShowMessage();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，Dialog的<code>show()</code>方法，会通过<code>mWindowManager.addView(mDecor, l);</code>创建一个<code>ViewRootImpl</code>的对象，这个对象会在创建的时候保存一个当前线程的Thread对象。也就是调用Dialog的<code>show()</code>方法的线程。</p>
<p>而在调用Dialog的<code>dismiss()</code>方法时，会首先把它抛到new Dialog的线程中执行，最后通过调用<code>mWindowManager.removeViewImmediate()</code>来销毁View，此时也就自然调用到了<code>ViewRootImpl</code>对象的<code>doDie()</code>方法，这个方法中会<code>checkThread();</code>，此时会检查当前线程（也就是调用new Dialog的线程）是不是创建<code>ViewRootImpl</code>的对象的线程（也就是Dialog的<code>show()</code>方法的线程）。</p>
<p>到这里，本文的bug根源也就找到了说通了。我们再来熟悉一下这个异常的场景。</p>
<ul>
<li>创建Dialog：work子线程</li>
<li>show()：ui主线程</li>
<li>cancel()：work子线程</li>
<li>dismiss()：因为crash没有执行到，未知（其实是抛到了work子线程）</li>
</ul>
<p>现在就明确了，执行<code>show()</code>方法的时候<code>ViewRootImpl</code>没有<code>checkThread()</code>，所以不会出现crash。而在执行<code>dismiss()</code>的时候，它首先被抛到创建Dialog的线程中执行，而后真正销毁View时<code>ViewRootImpl</code>会<code>checkThread()</code>，保证addView的线程才能removeView。而在文章开头出错的例子中，Dialog的<code>show()</code>是在主线程执行，<code>new Dialog()</code>是在work子线程中执行的，所以抛出了<code>CalledFromWrongThreadException</code>的异常。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li><p>Dialog的<code>dismiss()</code>会首先被抛到new Dialog的线程中执行。</p>
</li>
<li><p>只要保证创建Dialog和<code>show()</code>方法在同一个线程中执行，无论是在放到ui线程还是work子线程都可以。</p>
</li>
</ol>
<p>比如，把文章开头的例子中的<code>show()</code>方法同样放到work线程中，可以正常执行，输出log如下：</p>
<blockquote>
<p>10-26 19:23:02.603 27689-27760/com.cuc.myandroidtest D/MainActivity test: Dialog create thread: [4213]<br>10-26 19:23:02.686 27689-27760/com.cuc.myandroidtest D/MainActivity test: Dialog show thread: [4213]<br>10-26 19:23:07.243 27689-27760/com.cuc.myandroidtest D/MainActivity test: Dialog onCancel thread: [4213]<br>10-26 19:23:07.243 27689-27760/com.cuc.myandroidtest D/MainActivity test: Dialog onDismiss thread: [4213]</p>
</blockquote>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><p>注意，本文的这个<code>CalledFromWrongThreadException</code>异常，是在4.4版本及以上才会出现的。具体区别可以参考这篇文章：<a href="https://my.oschina.net/qixiaobo025/blog/195396" target="_blank" rel="external">Android4.4DialogUI线程CalledFromWrongThreadExcection</a></p>
<p>4.2中Dialog的dismissDialog和4.4中Dialog的dismissDialog区别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//4.2中Dialog的dismissDialog</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    mWindowManager.removeView(mDecor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//4.4中Dialog的dismissDialog</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    mWindowManager.removeViewImmediate(mDecor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://my.oschina.net/qixiaobo025/blog/195396" target="_blank" rel="external">Android4.4DialogUI线程CalledFromWrongThreadExcection</a></li>
<li><a href="http://blog.csdn.net/qq_32059827/article/details/51689309" target="_blank" rel="external">Android异常：android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original</a></li>
<li><a href="http://blog.csdn.net/kc58236582/article/details/52088224" target="_blank" rel="external">Activity WMS ViewRootImpl三者关系（Activity创建窗口 按键分发等）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;在使用Dialog时，因为线程问题，在调用dismiss方法时出现了CalledFromWrongThreadException的Crash，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;抛出异常为&lt;code&gt;CalledFromWrongThreadException&lt;/code&gt;，很明显第一反应就是出现了非ui线程进行了ui操作造成了此异常。通过分析工程代码，发现本质上是因为在非ui线程中创建了Dialog，而在主线程（即ui线程）中调用了&lt;code&gt;show()&lt;/code&gt;以及&lt;code&gt;dismiss()&lt;/code&gt;方法，我把问题模型写成测试代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseActivity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String TAG = &lt;span class=&quot;string&quot;&gt;&quot;MainActivity test&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; ProgressDialog dialog;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        setContentView(R.layout.activity_main);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        EventBus.getDefault().register(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Looper.prepare();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//子线程中创建Dialog&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                dialog = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProgressDialog(MainActivity.&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                dialog.setCanceledOnTouchOutside(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                dialog.setOnCancelListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DialogInterface.OnCancelListener() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCancel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(DialogInterface dialog)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        Log.d(TAG, &lt;span class=&quot;string&quot;&gt;&quot;Dialog onCancel thread: &quot;&lt;/span&gt; + getThreadInfo());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                dialog.setOnDismissListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DialogInterface.OnDismissListener() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDismiss&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(DialogInterface dialog)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        Log.d(TAG, &lt;span class=&quot;string&quot;&gt;&quot;Dialog onDismiss thread: &quot;&lt;/span&gt; + getThreadInfo());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                dialog.setMessage(&lt;span class=&quot;string&quot;&gt;&quot;正在加载...&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Log.d(TAG, &lt;span class=&quot;string&quot;&gt;&quot;Dialog create thread: &quot;&lt;/span&gt; + getThreadInfo());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Looper.loop();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;).start();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Button btn = (Button) findViewById(R.id.btn_helloworld);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        btn.setOnClickListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; View.OnClickListener() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(View v)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//UI主线程中show，然后点击空白区域dismiss&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                dialog.show();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Log.d(TAG, &lt;span class=&quot;string&quot;&gt;&quot;Dialog show thread: &quot;&lt;/span&gt; + getThreadInfo());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * 输出线程信息&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getThreadInfo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;[&quot;&lt;/span&gt; + Thread.currentThread().getId() + &lt;span class=&quot;string&quot;&gt;&quot;]&quot;&lt;/span&gt; +&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                ((Looper.myLooper() == Looper.getMainLooper())? &lt;span class=&quot;string&quot;&gt;&quot; is UI-Thread&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就是Activity打开的时候，使用work子线程创建了一个Dialog，然后手动点击按钮的时候，显示Dialog。再点击空白处，dialog本应该dismiss的，但是直接crash了。抛出了&lt;code&gt;CalledFromWrongThreadException&lt;/code&gt;的异常。&lt;/p&gt;
&lt;p&gt;在上面的代码中，我顺便输出了Dialog每个操作的线程ID，同时会判定是不是ui主线程。我们来看看log：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;10-26 16:11:07.836 7405-7652/com.cuc.myandroidtest D/MainActivity test: Dialog create thread: [3953]&lt;br&gt;10-26 16:11:27.763 7405-7405/com.cuc.myandroidtest D/MainActivity test: Dialog show thread: [1] is UI-Thread&lt;br&gt;10-26 16:11:35.642 7405-7652/com.cuc.myandroidtest D/MainActivity test: Dialog onCancel thread: [3953]&lt;/p&gt;
&lt;p&gt;——– beginning of crash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，以上出现的问题中执行Dialog操作的线程信息如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建Dialog：work子线程&lt;/li&gt;
&lt;li&gt;show()：ui主线程&lt;/li&gt;
&lt;li&gt;cancel()：work子线程&lt;/li&gt;
&lt;li&gt;dismiss()：因为crash没有执行到，未知&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果说&lt;strong&gt;只有创建这个控件的线程才能去更新该控件的内容&lt;/strong&gt;。那么在调用show方法的时候为什么不会crash，然后dismiss的时候才会崩溃？&lt;/p&gt;
&lt;p&gt;另外，到底是不是所有的操作都必须放到ui线程中执行才对？带着疑问我们深入Dialog源码一看究竟。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【算法】字符串是否包含问题</title>
    <link href="http://github.com/2017/10/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/10/18/【算法】字符串是否包含问题/</id>
    <published>2017-10-18T14:20:55.000Z</published>
    <updated>2017-10-23T04:02:27.132Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看到这篇文章：<a href="http://www.vaikan.com/google-interviewing-story/" target="_blank" rel="external">一次谷歌面试趣事</a>。觉得其中的算法题以及作者的解决思路很有趣，就拿来分享一下吧。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>假设这有一个各种字母组成的字符串，假设这还有另外一个字符串，而且这个字符串里的字母数相对少一些。从算法是讲，什么方法能最快的查出所有小字符串里的字母在大字符串里都有？</p>
<p>比如，如果是下面两个字符串：</p>
<blockquote>
<p>String 1: ABCDEFGHLMNOPQRS<br>String 2: DCGSRQPO</p>
</blockquote>
<p>答案是true，所有在String2里的字母String1也都有。如果是下面两个字符串：</p>
<blockquote>
<p>String 1: ABCDEFGHLMNOPQRS<br>String 2: DCGSRQPZ</p>
</blockquote>
<p>答案是false，因为第二个字符串里的Z字母不在第一个字符串里。</p>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-轮询"><a href="#1-轮询" class="headerlink" title="1. 轮询"></a>1. 轮询</h4><p>对于这种操作最简单最幼稚的做法是轮询第二个字符串里的每个字母，看它是否同在第一个字符串里。从算法上讲，这需要<code>O(n*m)</code>次操作，其中n是string1的长度，m是string2的长度。就拿上面的例子来说，最坏的情况下将会有16*8 = 128次操作。</p>
<h4 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h4><p>一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要<code>O(m log m) + O(n log n)</code>次操作（常规情况下），之后的线性扫描需要<code>O(m+n)</code>次操作。同样拿上面的字串做例子，将会需要16<em>4 + 8</em>3 = 88加上对两个字串线性扫描的16 + 8 = 24的操作。（随着字串长度的增长，你会发现这个算法的效果会越来越好）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 排序方案：快速排序</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubsetByQuickSort</span><span class="params">(String a, String b)</span></span>&#123;</div><div class="line">	<span class="keyword">char</span>[] ca = a.toCharArray();</div><div class="line">	<span class="keyword">char</span>[] cb = b.toCharArray();</div><div class="line"></div><div class="line">	quickSort(ca, <span class="number">0</span>, ca.length - <span class="number">1</span>);</div><div class="line">	quickSort(cb, <span class="number">0</span>, cb.length - <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="comment">//字符串String1的比较指针</span></div><div class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : cb)&#123;</div><div class="line">		<span class="keyword">while</span>(pos &lt; ca.length-<span class="number">1</span> &amp;&amp; ca[pos] &lt; c)&#123;</div><div class="line">			pos++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(c != ca[pos])&#123;</div><div class="line">			System.out.println(<span class="string">"No exist char: "</span> + c);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">	<span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> l = low;</div><div class="line">	<span class="keyword">int</span> r = high;</div><div class="line">	<span class="keyword">char</span> pivot = arr[l];</div><div class="line">	<span class="keyword">while</span>(l &lt; r)&#123;</div><div class="line">		<span class="keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;</div><div class="line">			r--;</div><div class="line">		&#125;</div><div class="line">		arr[l] = arr[r];</div><div class="line">		<span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;</div><div class="line">			l++;</div><div class="line">		&#125;</div><div class="line">		arr[r] = arr[l];</div><div class="line">	&#125;</div><div class="line">	arr[l] = pivot;</div><div class="line">	quickSort(arr, low, l - <span class="number">1</span>);</div><div class="line">	quickSort(arr, l + <span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，常规排序比如快排可以达到<code>O(n log n)</code>的时间复杂度，这里也可以选用用空间换时间的的基数排序、桶排序等线性时间复杂度的排序算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 字母编码[A - z]:[65 - 122]</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LETTER_REGION = <span class="number">122</span> - <span class="number">65</span> + <span class="number">1</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 排序方案：计数排序</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubsetByCounterSort</span><span class="params">(String a, String b)</span></span>&#123;</div><div class="line">	<span class="keyword">char</span>[] ca = a.toCharArray();</div><div class="line">	<span class="keyword">char</span>[] cb = b.toCharArray();</div><div class="line"></div><div class="line">	ca = counterSort(ca);</div><div class="line">	cb = counterSort(cb);</div><div class="line"></div><div class="line">	<span class="comment">//字符串String1的比较指针</span></div><div class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : cb)&#123;</div><div class="line">		<span class="keyword">while</span>(pos &lt; ca.length-<span class="number">1</span> &amp;&amp; ca[pos] &lt; c)&#123;</div><div class="line">			pos++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(c != ca[pos])&#123;</div><div class="line">			System.out.println(<span class="string">"No exist char: "</span> + c);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] counterSort(<span class="keyword">char</span>[] arr)&#123;</div><div class="line">	<span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[LETTER_REGION];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : arr)&#123;</div><div class="line">		<span class="keyword">int</span> index = c - <span class="string">'A'</span>;</div><div class="line">		bucket[index]++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LETTER_REGION; i++)&#123;</div><div class="line">		bucket[i] += bucket[i - <span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[arr.length];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : arr)&#123;</div><div class="line">		<span class="keyword">int</span> index = c - <span class="string">'A'</span>;</div><div class="line">		res[bucket[index] - <span class="number">1</span>] = c;</div><div class="line">		bucket[index]--;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3. 哈希表"></a>3. 哈希表</h4><p>哈希表Hashtable是一个只需要<code>O(n+m)</code>次操作的算法。方法就是，对第一个字串进行轮询，把其中的每个字母都放入一个Hashtable里（时间成本是<code>O(n)</code>，这里是16次操作）。然后轮询第二个字串，在Hashtable里查询每个字母，看能否找到。如果找不到，说明没有匹配成功。这将消耗掉8次操作 —— 这样两项操作加起来一共只有24次。不错吧，比前面两种方案都要好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 哈希表Hashset</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubsetByHashset</span><span class="params">(String a, String b)</span></span>&#123;</div><div class="line">	<span class="keyword">char</span>[] ca = a.toCharArray();</div><div class="line">	<span class="keyword">char</span>[] cb = b.toCharArray();</div><div class="line">	HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : ca)&#123;</div><div class="line">		set.add(c);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : cb)&#123;</div><div class="line">		<span class="keyword">if</span>(!set.contains(c))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4、Bitmap位图法"><a href="#4、Bitmap位图法" class="headerlink" title="4、Bitmap位图法"></a>4、Bitmap位图法</h4><p>这个解决方案思想和Hashtable一致，只不过使用的是位图法来为每一个字符保留一位。同样只需要<code>O(n+m)</code>次操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 字母编码区间[A - z]:[65 - 122]</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LETTER_REGION = <span class="number">122</span> - <span class="number">65</span> + <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 比特位方案</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubsetByBitmap</span><span class="params">(String a, String b)</span></span>&#123;</div><div class="line">	<span class="keyword">char</span>[] ca = a.toCharArray();</div><div class="line">	<span class="keyword">char</span>[] cb = b.toCharArray();</div><div class="line">	<span class="keyword">byte</span>[] bitmap = <span class="keyword">new</span> <span class="keyword">byte</span>[LETTER_REGION / Byte.SIZE];</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : ca)&#123;</div><div class="line">		setBit(bitmap, c - <span class="string">'A'</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : cb)&#123;</div><div class="line">		<span class="keyword">if</span>(getBit(bitmap, c - <span class="string">'A'</span>) == <span class="number">0</span>)&#123;</div><div class="line">			System.out.println(<span class="string">"No exist char in Bitmap: "</span> + c);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 写入指定位的比特</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBit</span><span class="params">(<span class="keyword">byte</span> bitmap[], <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">	bitmap[k / Byte.SIZE] |= (<span class="number">1</span> &lt;&lt; (k % Byte.SIZE));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 读取指定位的比特</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBit</span><span class="params">(<span class="keyword">byte</span> bitmap[], <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> (bitmap[k / Byte.SIZE] &amp; (<span class="number">1</span> &lt;&lt; (k % Byte.SIZE)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此为止，<code>O(n+m)</code>几乎是你能得到的最好的结果了，因为至少要对每个字母至少访问一次才能完成这项操作，而上述这两个方案是刚好是对每个字母只访问一次。下面看看文章中最后的这个素数方案。</p>
<h4 id="5-素数"><a href="#5-素数" class="headerlink" title="5. 素数"></a>5. 素数</h4><p>假设我们有一个一定个数的字母组成字串。我给每个字母分配一个素数，从2开始，往后类推。这样A将会是2，B将会是3，C将会是5，等等。现在我遍历第一个字串，把每个字母代表的素数相乘。最终会得到一个很大的整数，对吧？然后 —— 轮询第二个字符串，用每个字母除它。如果除的结果有余数，这说明有不匹配的字母。如果整个过程中没有余数，你应该知道它是第一个字串恰好的子集了。这样不行吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> primes[] =  &#123;</div><div class="line">			<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,</div><div class="line">			<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,<span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,</div><div class="line">			<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,<span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>,<span class="number">257</span>,<span class="number">263</span>,<span class="number">269</span>,<span class="number">271</span>,<span class="number">277</span>,<span class="number">281</span>,<span class="number">283</span>,<span class="number">293</span>,<span class="number">307</span>,<span class="number">311</span>,<span class="number">313</span>,<span class="number">317</span>,<span class="number">331</span>,</div><div class="line">			<span class="number">337</span>,<span class="number">347</span>,<span class="number">349</span>,<span class="number">353</span>,<span class="number">359</span>,<span class="number">367</span>,<span class="number">373</span>,<span class="number">379</span>,<span class="number">383</span>,<span class="number">389</span>,<span class="number">397</span>,<span class="number">401</span>,<span class="number">409</span>,<span class="number">419</span>,<span class="number">421</span>,<span class="number">431</span>,<span class="number">433</span>,<span class="number">439</span>,<span class="number">443</span>,<span class="number">449</span>,</div><div class="line">			<span class="number">457</span>,<span class="number">461</span>,<span class="number">463</span>,<span class="number">467</span>,<span class="number">479</span>,<span class="number">487</span>,<span class="number">491</span>,<span class="number">499</span>,<span class="number">503</span>,<span class="number">509</span>,<span class="number">521</span>,<span class="number">523</span>,<span class="number">541</span>,<span class="number">547</span>,<span class="number">557</span>,<span class="number">563</span>,<span class="number">569</span>,<span class="number">571</span>,<span class="number">577</span>,<span class="number">587</span>,</div><div class="line">			<span class="number">593</span>,<span class="number">599</span>,<span class="number">601</span>,<span class="number">607</span>,<span class="number">613</span>,<span class="number">617</span>,<span class="number">619</span>,<span class="number">631</span>,<span class="number">641</span>,<span class="number">643</span>,<span class="number">647</span>,<span class="number">653</span>,<span class="number">659</span>,<span class="number">661</span>,<span class="number">673</span>,<span class="number">677</span>,<span class="number">683</span>,<span class="number">691</span>,<span class="number">701</span>,<span class="number">709</span>,</div><div class="line">			<span class="number">719</span>,<span class="number">727</span>,<span class="number">733</span>,<span class="number">739</span>,<span class="number">743</span>,<span class="number">751</span>,<span class="number">757</span>,<span class="number">761</span>,<span class="number">769</span>,<span class="number">773</span>,<span class="number">787</span>,<span class="number">797</span>,<span class="number">809</span>,<span class="number">811</span>,<span class="number">821</span>,<span class="number">823</span>,<span class="number">827</span>,<span class="number">829</span>,<span class="number">839</span>,<span class="number">853</span>,</div><div class="line">			<span class="number">857</span>,<span class="number">859</span>,<span class="number">863</span>,<span class="number">877</span>,<span class="number">881</span>,<span class="number">883</span>,<span class="number">887</span>,<span class="number">907</span>,<span class="number">911</span>,<span class="number">919</span>,<span class="number">929</span>,<span class="number">937</span>,<span class="number">941</span>,<span class="number">947</span>,<span class="number">953</span>,<span class="number">967</span>,<span class="number">971</span>,<span class="number">977</span>,<span class="number">983</span>,<span class="number">991</span>&#125;;</div><div class="line"><span class="comment">// 字母编码区间[A - z]:[65 - 122]</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LETTER_REGION = <span class="number">122</span> - <span class="number">65</span> + <span class="number">1</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 素数方案</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubsetByPrimeNumber</span><span class="params">(String a, String b)</span></span>&#123;</div><div class="line">	<span class="keyword">char</span>[] ca = a.toCharArray();</div><div class="line">	<span class="keyword">char</span>[] cb = b.toCharArray();</div><div class="line"></div><div class="line">	<span class="comment">// 防止乘积int溢出，使用BigInteger存储乘积结果</span></div><div class="line">	BigInteger p = BigInteger.ONE;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : ca)&#123;</div><div class="line">		p = p.multiply(BigInteger.valueOf(primes[c - <span class="string">'A'</span>]));</div><div class="line">	&#125;</div><div class="line">	System.out.println(<span class="string">"乘积结果p = "</span> + p.toString());</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : cb)&#123;</div><div class="line">		<span class="keyword">if</span>(!p.remainder(BigInteger.valueOf(primes[c - <span class="string">'A'</span>])).equals(BigInteger.ZERO))&#123;</div><div class="line">			System.out.println(<span class="string">"No exist char: "</span> + c);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterSubset</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 假设你有一个一定长度的由字母组成的字符串。你还有另外一个，短些。你如何才能知道所有的在较短的字符串里的字母在长字符串里也有？</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		String a1 = <span class="string">"ABCDEFGHLMNOPQRS"</span>;</div><div class="line">		String b1 = <span class="string">"DCGSRQPOM"</span>;</div><div class="line"></div><div class="line">		String a2 = <span class="string">"ABCDEFGHLMNOPQRS"</span>;</div><div class="line">		String b2 = <span class="string">"DCGSRQPOZ"</span>;</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"\na1 and b1: "</span> + isSubsetByQuickSort(a1, b1));</div><div class="line">		System.out.println(<span class="string">"\na2 and b2: "</span> + isSubsetByQuickSort(a2, b2));</div><div class="line">		System.out.println(<span class="string">"\na1 and b1: "</span> + isSubsetByCounterSort(a1, b1));</div><div class="line">		System.out.println(<span class="string">"\na2 and b2: "</span> + isSubsetByCounterSort(a2, b2));</div><div class="line">		System.out.println(<span class="string">"\na1 and b1: "</span> + isSubsetByHashset(a1, b1));</div><div class="line">		System.out.println(<span class="string">"\na2 and b2: "</span> + isSubsetByHashset(a2, b2));</div><div class="line">		System.out.println(<span class="string">"\na1 and b1: "</span> + isSubsetByPrimeNumber(a1, b1));</div><div class="line">		System.out.println(<span class="string">"\na2 and b2: "</span> + isSubsetByPrimeNumber(a2, b2));</div><div class="line">		System.out.println(<span class="string">"\na1 and b1: "</span> + isSubsetByBitmap(a1, b1));</div><div class="line">		System.out.println(<span class="string">"\na2 and b2: "</span> + isSubsetByBitmap(a2, b2));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>就如文章中所说，素数方案在算法上并不能说就比哈希表好。而且在实际操作中，你很可能仍会使用哈希表的方案，因为它更通用，无需跟麻烦的大型数字打交道。但从”巧妙水平“上讲，Guy提供的素数方案是一种更、更、更有趣的方案。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.vaikan.com/google-interviewing-story/" target="_blank" rel="external">一次谷歌面试趣事</a></li>
<li><a href="http://blog.csdn.net/v_JULY_v/article/details/6347454" target="_blank" rel="external">程序员编程艺术：第二章、字符串是否包含问题</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看到这篇文章：&lt;a href=&quot;http://www.vaikan.com/google-interviewing-story/&quot;&gt;一次谷歌面试趣事&lt;/a&gt;。觉得其中的算法题以及作者的解决思路很有趣，就拿来分享一下吧。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;假设这有一个各种字母组成的字符串，假设这还有另外一个字符串，而且这个字符串里的字母数相对少一些。从算法是讲，什么方法能最快的查出所有小字符串里的字母在大字符串里都有？&lt;/p&gt;
&lt;p&gt;比如，如果是下面两个字符串：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String 1: ABCDEFGHLMNOPQRS&lt;br&gt;String 2: DCGSRQPO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案是true，所有在String2里的字母String1也都有。如果是下面两个字符串：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String 1: ABCDEFGHLMNOPQRS&lt;br&gt;String 2: DCGSRQPZ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案是false，因为第二个字符串里的Z字母不在第一个字符串里。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【Android】源码分析 - AsyncTask异步任务机制</title>
    <link href="http://github.com/2017/10/09/%E3%80%90Android%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20AsyncTask%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
    <id>http://github.com/2017/10/09/【Android】源码分析 - AsyncTask异步任务机制/</id>
    <published>2017-10-09T12:03:00.000Z</published>
    <updated>2017-10-10T08:06:15.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>提到Android的多线程机制，常用的有如下几种方式：</p>
<ul>
<li><strong>AsyncTask:</strong> 封装了线程池和Handler，为 UI 线程与工作线程之间进行快速切换提供一种便捷机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li><strong>HandlerThread:</strong> 一个已经拥有了Looper的线程类，内部可以直接使用Handler。为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li><strong>ThreadPool:</strong> 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li><strong>IntentService:</strong> 适合于执行由 UI 触发的后台 Service 任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。</li>
</ul>
<p>尽管Android已经设计了基本的Handler异步消息机制提供给我们进行线程间通信，不过对于频繁得UI更新操作Handler用起来确实有点细碎，为了更加方便我们在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它我们可以非常灵活方便地从子线程切换到UI线程。</p>
<p><img src="http://itimetraveler.github.io/gallery/android-asynctask/worker_thread.png" alt=""></p>
<p>我们就从AsyncTask的基本用法开始，一起分析下AsyncTask源码，看看它是如何实现的。</p>
<h3 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h3><p>由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下：</p>
<ol>
<li><strong>Params</strong>：在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</li>
<li><strong>Progress</strong>：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</li>
<li><strong>Result</strong>：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li>
</ol>
<p>一个最简单的自定义AsyncTask就可以写成如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个：</p>
<ul>
<li><p><strong>onPreExecute()</strong>：一般会在<code>UI Thread</code>中执行。用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。</p>
</li>
<li><p><strong>doInBackground(Params…)</strong>：这个方法中的所有代码都会在子线程<code>Worker Thread</code>中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用<code>publishProgress(Progress...)</code>方法来完成。</p>
</li>
<li><p><strong>onProgressUpdate(Progress…)</strong>：在<code>UI Thread</code>中执行。当在后台任务中调用了<code>publishProgress(Progress...)</code>方法后，这个方法随后就会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p>
</li>
<li><p><strong>onPostExecute(Result)</strong>：在<code>UI Thread</code>中执行。当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如弹出Toast提醒任务执行的结果，以及关闭掉进度条对话框等。</p>
</li>
</ul>
<blockquote>
<p>特别说明！<code>onPreExecute</code>并不保证一定在UI线程中执行！我们稍后源码分析时说明</p>
</blockquote>
<p>一个比较完整的自定义AsyncTask就可以写成如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFilesTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">URL</span>, <span class="title">Integer</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;  </div><div class="line">        progressDialog.show();  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">doInBackground</span><span class="params">(URL... urls)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = urls.length;</div><div class="line">        <span class="keyword">long</span> totalSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            totalSize += Downloader.downloadFile(urls[i]);</div><div class="line">            <span class="comment">//更新进度</span></div><div class="line">            publishProgress((<span class="keyword">int</span>) ((i / (<span class="keyword">float</span>) count) * <span class="number">100</span>));</div><div class="line">            <span class="comment">// Escape early if cancel() is called</span></div><div class="line">            <span class="keyword">if</span> (isCancelled()) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> totalSize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progress)</span> </span>&#123;</div><div class="line">        progressDialog.setMessage(<span class="string">"当前下载进度："</span> + progress[<span class="number">0</span>] + <span class="string">"%"</span>);  </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Long result)</span> </span>&#123;</div><div class="line">        showDialog(<span class="string">"下载已完成！Downloaded "</span> + result + <span class="string">" bytes"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，调用<code>execute()</code>执行任务就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> DownloadFilesTask().execute(url1, url2, url3);</div></pre></td></tr></table></figure>
<p>以上就是AsyncTask的基本用法，我们并不需要去考虑什么异步消息处理机制，也不需要专门使用一个Handler来发送和接收消息，只需要调用一下<code>publishProgress()</code>方法就可以轻松地从子线程切换到UI线程了。</p>
<h3 id="AsyncTask源码"><a href="#AsyncTask源码" class="headerlink" title="AsyncTask源码"></a>AsyncTask源码</h3><p>首先提醒一下大家，该版本分析的代码是Android API 21（对应的Android 5.0）的源码，由于AsyncTask在之前几个版本改动比较大，不过不影响我们分析原理，所以最后我尽量介绍一下区别。</p>
<p>AsyncTask的源码链接：<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/os/AsyncTask.java">https://github.com/android/platform_frameworks_base/blob/master/core/java/android/os/AsyncTask.java</a></p>
<p>可以看到AsyncTask开头定义了一些字段，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG_TAG = <span class="string">"AsyncTask"</span>;</div><div class="line"></div><div class="line"><span class="comment">//CPU_COUNT为手机中的CPU核数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line"><span class="comment">//线程池的核心线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</div><div class="line"><span class="comment">//线程池的最大线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line"><span class="comment">//同一时刻只允许1个线程执行</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">//sThreadFactory用于在后面创建线程池</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">//重写newThread方法: 为了将新增线程的名字以"AsyncTask #"标识</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//实例化阻塞式队列BlockingQueue，队列中存放Runnable，容量为128</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</div><div class="line"></div><div class="line"><span class="comment">//根据上面定义的参数实例化线程池</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<p>通过以上代码和注释我们可以知道，AsyncTask初始化了一些参数，并用这些参数实例化了一个线程池<code>THREAD_POOL_EXECUTOR</code>，需要注意的是该线程池被定义为<code>public static final</code>，由此我们可以看出AsyncTask内部维护了一个静态的线程池，默认情况下，AsyncTask的实际工作就是通过该<code>THREAD_POOL_EXECUTOR</code>完成的。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><p>我们来看一看AsyncTask的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;    </div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//实例化mWorker，实现了Callable接口的call方法</span></div><div class="line">        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                <span class="comment">//在线程池的工作线程中执行doInBackground方法，执行完的结果传递给postResult方法</span></div><div class="line">                <span class="keyword">return</span> postResult(doInBackground(mParams));</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">      </div><div class="line">        <span class="comment">//用mWorker实例化mFuture</span></div><div class="line">        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    postResultIfNotInvoked(get());</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    android.util.Log.w(LOG_TAG, e);</div><div class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,</div><div class="line">                            e.getCause());</div><div class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    ...省略其他代码...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们看到AsyncTask是一个<strong>抽象类</strong>，所以我们不能直接使用。在构造函数上有一句注释说：<strong>AsyncTask的构造函数需要在UI线程上调用</strong>，言外之意也就是说我们必须在主线程中new创建AsyncTask对象。</p>
<p>然后构造函数中实际上并没有任何具体的逻辑会得到执行，只是初始化了两个变量，<code>mWorker</code>和<code>mFuture</code>，并在初始化<code>mFuture</code>的时候将<code>mWorker</code>作为参数传入。<code>mWorker</code>是一个Callable对象，<code>mFuture</code>是一个FutureTask对象，这两个变量会暂时保存在内存中，稍后才会用到它们。</p>
<p>mWorker是WorkerRunnable类型的对象，WorkerRunnable是AsyncTask中的一个内部类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</div><div class="line">    Params[] mParams;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>mWorker</strong> ：上面代码我们可以看到，mWorker其实是一个Callable类型的对象。实例化mWorker，实现了Callable接口的call方法。call方法是在线程池的某个线程中执行的，而不是运行在主线程中。在线程池的工作线程中执行doInBackground方法，执行实际的任务，并返回结果。当doInBackground执行完毕后，将执行完的结果传递给postResult方法。postResult方法我们后面会再讲解。</li>
<li><strong>mFuture</strong> ：mFuture是一个FutureTask类型的对象，用mWorker作为参数实例化了mFuture。在这里，其实现了FutureTask的done方法，我们之前提到，当FutureTask的任务执行完成或任务取消的时候会执行FutureTask的done方法。done方法里面的逻辑我们稍后再讲。</li>
</ul>
<p>这里先详细说一下FutureTask：由于AsyncTask能够取消任务，所以AsyncTask使用了FutureTask以及与其相关的Callable，此处对二者简单进行一下介绍。FutureTask、Callable在Java的并发编程中是比较常见的，可以用来获取任务执行完之后的返回值，也可以取消线程池中的某个任务。Callable是一个接口，其内部定义了call方法，在call方法内需要编写代码执行具体的任务，在这一点上Callable接口与Runnable接口很类似，不过不同的是<strong>Runnable的run方法没有返回值，Callable的call方法可以指定返回值</strong>。FutureTask类同时实现了Callable接口和Runnable接口，FutureTask的构造函数中需要传入一个Callable对象以对其进行实例化。Executor的execute方法接收一个Runnable对象，由于FutureTask实现了Runnable接口，所以可以把一个FutureTask对象传递给Executor的execute方法去执行。当任务执行完毕的时候会执行FutureTask的done方法，我们可以在这个方法中写一些逻辑处理。在任务执行的过程中，我们也可以随时调用FutureTask的cancel方法取消执行任务，任务取消后也会执行FutureTask的done方法。我们也可以通过FutureTask的get方法阻塞式地等待任务的返回值（即Callable的call方法的返回值），如果任务执行完了就立即返回执行的结果，否则就阻塞式等待call方法的完成。</p>
<p>构造函数我们先分析到这里，关于<strong>mWorker</strong>这个对象里调用<strong><code>doInBackground()</code>函数</strong>的流程我们稍后讲到然后把它们串起来。</p>
<h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a><strong>execute()方法</strong></h4><p>如果我们想要启动某一个任务，就需要调用该任务的<code>execute()</code>方法，因此现在我们来看一看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="comment">//如果当前AsyncTask已经处于运行状态，那么就抛出异常，不再执行新的任务</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="comment">//如果当前AsyncTask已经把之前的任务运行完成，那么也抛出异常，不再执行新的任务</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    <span class="comment">//Executor的execute方法接收Runnable参数，由于mFuture是FutureTask的实例，</span></div><div class="line">    <span class="comment">//且FutureTask同时实现了Callable和Runnable接口，所以此处可以让exec执行mFuture</span></div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div></pre></td></tr></table></figure>
<p>可以看到<code>execute()</code>方法调用了<code>executeOnExecutor()</code>方法。</p>
<p>在<code>executeOnExecutor()</code>方法中，我们终于看到它调用了<code>onPreExecute()</code>方法，因此证明了onPreExecute()方法会第一个得到执行。</p>
<p>下面对以上代码进行一下说明：</p>
<ul>
<li>一个AsyncTask实例执行执行一次任务，当第二次执行任务时就会抛出异常。executeOnExecutor方法一开始就检查AsyncTask的状态是不是PENDING，只有PENDING状态才往下执行，如果是其他状态表明现在正在执行另一个已有的任务或者已经执行完成了一个任务，这种情况下都会抛出异常。</li>
<li>如果开始是PENDING状态，那么就说明该AsyncTask还没执行过任何任务，代码可以继续执行，然后将状态设置为RUNNING，表示开始执行任务。</li>
<li>在真正执行任务前，先调用onPreExecute方法。由于executeOnExecutor方法应该运行在主线程上，所以此处的onPreExecute方法也会运行在主线程上，可以在该方法中做一些UI上的处理操作。</li>
<li>Executor的execute方法接收Runnable参数，由于mFuture是FutureTask的实例，且FutureTask同时实现了Callable和Runnable接口，所以此处可以让exec通过execute方法在执行mFuture。在执行了exec.execute(mFuture)之后，后面会在exec的工作线程中执行mWorker的call方法，我们之前在介绍mWorker的实例化的时候也介绍了call方法内部的执行过程，会首先在工作线程中执行doInBackground方法，并返回结果，然后将结果传递给postResult方法。</li>
</ul>
<p>最后调用<code>exec.execute(mFuture);</code>去执行真正的任务，此处exec对象就是<code>sDefaultExecutor</code>，可以看到其实是个<code>SerialExecutor</code>对象，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="comment">//mTasks是一个维护Runnable的双端队列，ArrayDeque没有容量限制，其容量可自增长</span></div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        <span class="comment">//execute方法会传入一个Runnable类型的变量r</span></div><div class="line">        <span class="comment">//然后我们会实例化一个Runnable类型的匿名内部类以对r进行封装，</span></div><div class="line">        <span class="comment">//通过队列的offer方法将封装后的Runnable添加到队尾</span></div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//此处r的run方法是在线程池中执行的</span></div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="comment">//当前任务执行完毕后，通过调用scheduleNext方法执行下一个Runnable任务</span></div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//只有当前没有执行任何任务时，才会立即执行scheduleNext方法</span></div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//通过mTasks的poll方法进行出队操作，删除并返回队头的Runnable，</span></div><div class="line">        <span class="comment">//将返回的Runnable赋值给mActive，并将其作为参数传递给THREAD_POOL_EXECUTOR的execute方法进行执行</span></div><div class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SerialExecutor实现了Executor接口中的execute方法，该类用于串行执行任务，即一个接一个地执行任务，而不是并行执行任务。</p>
<p>通过以上代码和注释我们可以知道：</p>
<ul>
<li><p>SerialExecutor实现了Executor接口中的execute方法，该类用于串行执行任务，即一个接一个地执行任务，而不是并行执行任务。</p>
</li>
<li><p>SerialExecutor内部维护了一个存放Runnable的双端队列mTasks。当执行SerialExecutor的execute方法时，会传入一个Runnable变量r，但是mTasks并不直接存储r，而是又新new了一个匿名Runnable对象，其内部会调用r，这样就对r进行了封装，将该封装后的Runnable对象通过队列的offer方法入队，添加到mTasks的队尾。</p>
</li>
<li><p>SerialExecutor内部通过mActive存储着当前正在执行的任务Runnable。当执行SerialExecutor的execute方法时，首先会向mTasks的队尾添加进一个Runnable。然后判断如果mActive为null，即当前没有任务Runnable正在运行，那么就会执行scheduleNext()方法。当执行scheduleNext方法的时候，会首先从mTasks中通过poll方法出队，删除并返回队头的Runnable，将返回的Runnable赋值给mActive，如果不为空，那么就让将其作为参数传递给THREAD_POOL_EXECUTOR的execute方法进行执行。由此，我们可以看出SerialExecutor实际上是通过之前定义的线程池<code>THREAD_POOL_EXECUTOR</code>进行实际的处理的。</p>
</li>
<li><p>当将mTasks中的Runnable作为参数传递给THREAD_POOL_EXECUTOR执行execute方法时，会在线程池的工作线程中执行匿名内部类Runnable中的try-finally代码段，即先在工作线程中执行r.run()方法去执行任务，无论任务r正常完成还是抛出异常，都会在finally中执行scheduleNext方法，用于执行mTasks中的下一个任务。从而在此处我们可以看出SerialExecutor是一个接一个执行任务，是串行执行任务，而不是并行执行。</p>
</li>
</ul>
<p><img src="http://itimetraveler.github.io/gallery/android-asynctask/serial.png" alt="SerialExecutor串行执行任务"></p>
<p>我们看SerialExecutor最终执行的是<code>r.run()</code>，那这里的r是什么呢？就是execute方法中的<strong><code>exec.execute(mFuture)</code></strong>中的参数mFuture。也就是最终执行了mFuture这个FutureTask对象的run()方法，我们进入看看<strong>FutureTask</strong>类中的run()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//FutureTask的构造函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">//此处的callable就是接收的mWorker对象</span></div><div class="line">    <span class="keyword">this</span>.callable = callable;</div><div class="line">    <span class="keyword">this</span>.state = NEW;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (state != NEW ||</div><div class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</div><div class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            <span class="keyword">boolean</span> ran;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//核心是调用了callable（也就是mWorker）的call方法</span></div><div class="line">                result = c.call();</div><div class="line">                ran = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                result = <span class="keyword">null</span>;</div><div class="line">                ran = <span class="keyword">false</span>;</div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (ran)</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// runner must be non-null until state is settled to</span></div><div class="line">        <span class="comment">// prevent concurrent calls to run()</span></div><div class="line">        runner = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></div><div class="line">        <span class="comment">// leaked interrupts</span></div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到核心代码是调用了callable对象（也就是mWorker）的call方法。所以我们回头看看构造函数中的mWorker对象。</p>
<h4 id="执行任务-调用doInBackground"><a href="#执行任务-调用doInBackground" class="headerlink" title="执行任务 - 调用doInBackground()"></a><strong>执行任务 - 调用doInBackground()</strong></h4><p>我们前面知道，Executor的execute方法接收Runnable参数，由于mFuture是FutureTask的实例，且FutureTask同时实现了Callable和Runnable接口，所以此处可以让exec通过execute方法在执行mFuture。在执行了<code>exec.execute(mFuture)</code>之后，后面会在exec的工作线程中执行mWorker的call方法，我们之前在构造函数中介绍mWorker的实例化的时候也介绍了call方法内部的执行过程，会首先在工作线程中执行doInBackground方法，并返回结果，然后将结果传递给postResult方法。</p>
<p>我们回过头看看构造函数中mWorker这个任务对象，在构造函数中的mWorker定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        <span class="comment">//noinspection unchecked</span></div><div class="line">        <span class="keyword">return</span> postResult(doInBackground(mParams));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们看最后这句<code>postResult(doInBackground(mParams));</code>，它会调用我们的doInBackground()函数执行任务，并把结果发送给<code>postResult()</code>方法，我们跟进去看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalHandler sHandler = <span class="keyword">new</span> InternalHandler();</div></pre></td></tr></table></figure>
<p>它使用<code>sHandler</code>对象发出了一条消息，InternalHandler创建一个Message Code为MESSAGE_POST_RESULT的Message，此处还将<code>doInBackground</code>返回的result通过<code>new AsyncTaskResult&lt;Result&gt;(this, result)</code>封装成了AsyncTaskResult，将其作为message的obj属性。</p>
<p>AsyncTaskResult是AsyncTask的一个内部类，其代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//mTask表示当前AsyncTaskResult是哪个AsyncTask的结果</span></div><div class="line">    <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">    <span class="comment">//mData表示其存储的数据</span></div><div class="line">    <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">        mTask = task;</div><div class="line">        mData = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在构建了message对象后，通过<code>message.sendToTarget()</code>将该message发送给<code>sHandler</code>，之后<code>sHandler</code>的handleMessage方法会接收并处理该message，这个<code>sHandler</code>对象是InternalHandler类的一个实例，InternalHandler的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult result = (AsyncTaskResult) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>msg.obj是AsyncTaskResult类型，result.mTask表示当前AsyncTaskResult所绑定的AsyncTask。result.mData[0]表示的是doInBackground所返回的处理结果。将该结果传递给AsyncTask的finish方法，finish代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        <span class="comment">//如果任务被取消了，那么执行onCancelled方法</span></div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//将结果发传递给onPostExecute方法</span></div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//最后将AsyncTask的状态设置为完成状态</span></div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>finish方法内部会首先判断AsyncTask是否被取消了，如果被取消了执行onCancelled(result)，否则执行onPostExecute(result)方法。需要注意的是InternalHandler是指向主线程的，所以其handleMessage方法是在主线程中执行的，从而此处的finish方法也是在主线程中执行的，进而onPostExecute也是在主线程中执行的。</p>
<p>我们知道，在doInBackground方法中是在工作线程中执行比较耗时的操作，这个操作时间可能比较长，而我们的任务有可能分成多个部分，每当我完成其中的一部分任务时，我们可以在doInBackground中多次调用AsyncTask的publishProgress方法，将阶段性数据发布出去。</p>
<p>publishProgress方法代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</div><div class="line">        sHandler.obtainMessage(MESSAGE_POST_PROGRESS,</div><div class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到最后发送了一条<code>MESSAGE_POST_PROGRESS</code>的Message给sHandler，到sHandler的代码中，我们能看到它调用了<code>onProgressUpdate()</code>这个方法，也就是我们使用示例当中的进度条更新函数。</p>
<p>最后，AsyncTask无论任务完成还是取消任务，FutureTask都会执行done方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//任务执行完毕或取消任务都会执行done方法</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//任务正常执行完成</span></div><div class="line">            postResultIfNotInvoked(get());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">//任务出现中断异常</span></div><div class="line">            android.util.Log.w(LOG_TAG, e);</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="comment">//任务执行出现异常</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                    e.getCause());</div><div class="line">        &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">            <span class="comment">//任务取消</span></div><div class="line">            postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>无论任务正常执行完成还是任务取消，都会执行postResultIfNotInvoked方法。postResultIfNotInvoked代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</div><div class="line">    <span class="keyword">if</span> (!wasTaskInvoked) &#123;</div><div class="line">        <span class="comment">//只有mWorker的call没有被调用才会执行postResult方法</span></div><div class="line">        postResult(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果AsyncTask正常执行完成的时候，call方法都执行完了，mTaskInvoked设置为true，并且在call方法中最后执行了postResult方法，然后进入mFuture的done方法，然后进入postResultIfNotInvoked方法，由于mTaskInvoked已经执行，所以不会执行再执行postResult方法。</p>
<p>如果在调用了AsyncTask的execute方法后立马就执行了AsyncTask的cancel方法（实际执行mFuture的cancel方法），那么会执行done方法，且捕获到CancellationException异常，从而执行语句<code>postResultIfNotInvoked(null)</code>，由于此时还没有来得及执行mWorker的call方法，所以mTaskInvoked还未false，这样就可以把null传递给postResult方法。</p>
<p>到这里，AsyncTask中的细节基本上就分析完了。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在<a href="https://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">Google官方文档</a>里有这么一段：</p>
<blockquote>
<h4 id="Threading-rules"><a href="#Threading-rules" class="headerlink" title="Threading rules"></a>Threading rules</h4><hr>
<p>There are a few threading rules that must be followed for this class to work properly:</p>
<ul>
<li>The AsyncTask class must be loaded on the UI thread. This is done automatically as of <code>JELLY_BEAN</code>.</li>
<li>The task instance must be created on the UI thread.</li>
<li><code>execute(Params...)</code> must be invoked on the UI thread.</li>
<li>Do not call <code>onPreExecute()</code>, <code>onPostExecute(Result)</code>, <code>doInBackground(Params...)</code>, <code>onProgressUpdate(Progress...)</code> manually.</li>
<li>The task can be executed only once (an exception will be thrown if a second execution is attempted.</li>
</ul>
</blockquote>
<p>翻译过来就是：</p>
<ul>
<li>AsyncTask必须在UI主线程中创建（new）；</li>
<li><code>execute(Params...)</code>函数必须在UI线程中调用；</li>
<li>不要手动调用 <code>onPreExecute()</code>, <code>onPostExecute(Result)</code>, <code>doInBackground(Params...)</code>, <code>onProgressUpdate(Progress...)</code> 这些方法。</li>
<li>每个AsyncTask任务只能被执行一次；</li>
</ul>
<p>大家注意到了吗，AsyncTask必须在UI主线程中创建（new），<strong><code>execute(Params...)</code>函数必须在UI线程中调用</strong>。也就是说这个要求Google并没有在framework层实现强制约束，而是给了口头上的一种编码约定（结合源码我们也能看到源码中也没有这样的机制保证）。这也就可能会引发我们开头那个问题：</p>
<blockquote>
<p><code>onPreExecute</code>并不保证一定在UI线程中执行！而是由<strong><code>execute(Params...)</code>函数在哪个线程中调用</strong>决定的！</p>
</blockquote>
<p>比如stackoverflow上的这个问题：<a href="https://stackoverflow.com/questions/16416305/android-asynctask-onpreexecute-method-is-not-executed-in-ui-thread" target="_blank" rel="external">Android: AsyncTask onPreExecute() method is NOT executed in UI thread - stackoverflow</a>。就是在子线程中调用了<code>execute(Params...)</code>函数。所以为了避免这样的问题，我们一定要遵守上面那几条官方约定。</p>
<h3 id="一些版本变化"><a href="#一些版本变化" class="headerlink" title="一些版本变化"></a>一些版本变化</h3><p>在Android 3.0之前是并没有SerialExecutor这个类的，那个时候是直接在AsyncTask中构建了一个sExecutor常量，并对线程池总大小，同一时刻能够运行的线程数做了规定，比如<a href="http://androidxref.com/2.2.3/xref/frameworks/base/core/java/android/os/AsyncTask.java" target="_blank" rel="external">Android Froyo 2.2.3版本的源码</a>如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG_TAG = <span class="string">"AsyncTask"</span>;</div><div class="line"></div><div class="line">    <span class="comment">//线程池大小</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">128</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sWorkQueue =</div><div class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor sExecutor = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,</div><div class="line">            MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_RESULT = <span class="number">0x1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_PROGRESS = <span class="number">0x2</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_CANCEL = <span class="number">0x3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalHandler sHandler = <span class="keyword">new</span> InternalHandler();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Status mStatus = Status.PENDING;</div><div class="line"></div><div class="line"></div><div class="line">    ...省略其他代码...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这里规定同一时刻能够运行的线程数为5个，线程池总大小为128。也就是说当我们启动了10个任务时，只有5个任务能够立刻执行，另外的5个任务则需要等待，当有一个任务执行完毕后，第6个任务才会启动，以此类推。而线程池中最大能存放的线程数是128个，当我们尝试去添加第129个任务时，程序就会崩溃。</p>
<p>而到了<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/java/android/os/AsyncTask.java" target="_blank" rel="external">Android Gingerbread 2.3.6版本</a>，把同一时刻的5个并发线程改成了同一时刻只有一个线程的串行执行，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG_TAG = <span class="string">"AsyncTask"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">128</span>; </div><div class="line">    <span class="comment">//注意这里</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sWorkQueue =</div><div class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor sExecutor = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,</div><div class="line">            MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_RESULT = <span class="number">0x1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_PROGRESS = <span class="number">0x2</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_CANCEL = <span class="number">0x3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalHandler sHandler = <span class="keyword">new</span> InternalHandler();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Status mStatus = Status.PENDING;</div><div class="line">    </div><div class="line">    ...省略其他代码...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>AsyncTask的底层其实是对Thread、Handler、Message的封装，智能的应用了Handler。</p>
</li>
<li><p>因为AsyncTask里面的内部handler和Executor都是静态变量，所以他们控制着所有的子类。</p>
</li>
<li><p>如果不想使用默认的线程池，可以使用<code>executeOnExecutor()</code>函数自由地进行配置而不是<code>execute()</code>。因为用系统默认的线程池因为串行执行可能需要等待（SerialExecutor）。自己使用自定义线程池方式如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Executor exec = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">15</span>, <span class="number">200</span>, <span class="number">10</span>,  </div><div class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </div><div class="line"><span class="keyword">new</span> DownloadTask().executeOnExecutor(exec);</div></pre></td></tr></table></figure>
<ul>
<li><p>AsyncTask适合处理短时间的操作。长时间的操作，比如下载一个很大的视频，这就需要你使用自己的线程来下载，不管是断点下载还是其它的。从google官方文档你也可以看到，AsyncTasks should ideally be used for short operations (a few seconds at the most.)</p>
</li>
<li><p>不要随意使用AsyncTask,除非你必须要与UI线程交互。默认情况下使用Thread即可，要注意需要将线程优先级调低。</p>
</li>
</ul>
<p>Android3.0之前，异步任务是并发执行的，即几个任务同时切换执行，3.0之后，异步任务改成了顺序执行，即任务队列中的任务要一个个执行（并非按顺序），一个执行不完，不能执行另一个，即顺序执行，他是默认的执行方式<code>execue()</code>方法，其默认执行的方法是：<code>executeOnExecutor(AsyncTask.SERIAL_EXECUTOR)</code>，如果要并发执行，需要执行<code>AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</code>，且为了防止系统的任务繁重，只在线程池中维护了5个线程，也就是，每次最多跑5个任务（类似于迅雷下载）。如果需要并发更多的任务，需要自定义线程池了。所以异步任务只适合处理一些轻量级的并随时修改UI的异步线程，如果遇到繁重的任务，最好自己新建一个Thread并用handler和looper机制处理。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/11711405" target="_blank" rel="external">Android AsyncTask完全解析，带你从源码的角度彻底理解</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/50670388" target="_blank" rel="external">源码解析Android中AsyncTask的工作原理 - 孙群</a></li>
<li><a href="https://dev.qq.com/topic/59157b344ba93ae12c5f8f3e" target="_blank" rel="external">Android性能优化典范之多线程篇 - 腾讯Bugly</a></li>
<li><a href="https://stackoverflow.com/questions/16416305/android-asynctask-onpreexecute-method-is-not-executed-in-ui-thread" target="_blank" rel="external">Android: AsyncTask onPreExecute() method is NOT executed in UI thread - stackoverflow</a></li>
<li><a href="https://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask - Google Android Developers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;提到Android的多线程机制，常用的有如下几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AsyncTask:&lt;/strong&gt; 封装了线程池和Handler，为 UI 线程与工作线程之间进行快速切换提供一种便捷机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HandlerThread:&lt;/strong&gt; 一个已经拥有了Looper的线程类，内部可以直接使用Handler。为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ThreadPool:&lt;/strong&gt; 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IntentService:&lt;/strong&gt; 适合于执行由 UI 触发的后台 Service 任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管Android已经设计了基本的Handler异步消息机制提供给我们进行线程间通信，不过对于频繁得UI更新操作Handler用起来确实有点细碎，为了更加方便我们在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它我们可以非常灵活方便地从子线程切换到UI线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://itimetraveler.github.io/gallery/android-asynctask/worker_thread.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们就从AsyncTask的基本用法开始，一起分析下AsyncTask源码，看看它是如何实现的。&lt;/p&gt;
&lt;h3 id=&quot;使用AsyncTask&quot;&gt;&lt;a href=&quot;#使用AsyncTask&quot; class=&quot;headerlink&quot; title=&quot;使用AsyncTask&quot;&gt;&lt;/a&gt;使用AsyncTask&lt;/h3&gt;&lt;p&gt;由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Params&lt;/strong&gt;：在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Progress&lt;/strong&gt;：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Result&lt;/strong&gt;：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个最简单的自定义AsyncTask就可以写成如下方式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyTask&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AsyncTask&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Void&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Void&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Void&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123; ... &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://github.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Android】源码分析 - IntentService机制</title>
    <link href="http://github.com/2017/10/05/%E3%80%90Android%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20IntentService%E6%9C%BA%E5%88%B6/"/>
    <id>http://github.com/2017/10/05/【Android】源码分析 - IntentService机制/</id>
    <published>2017-10-05T08:03:00.000Z</published>
    <updated>2017-10-26T06:36:13.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>提到Android的多线程机制，除了我们常用的Thread来实现异步任务之外，还有</p>
<ol>
<li><strong>AsyncTask</strong>：封装了线程池和Handler，主要为了子线程更新UI；</li>
<li><strong>HandlerThread</strong>：一个已经拥有了Looper的线程类，内部可以直接使用Handler；</li>
<li><strong>IntentService</strong>：一个内部采用HandlerThread来执行任务的Service服务，任务执行完毕后会自动退出；</li>
</ol>
<p>今天我们来根据平时的使用方式来分析一下第三个IntentSevice到底是什么怎么实现的？</p>
<h3 id="IntentService的使用"><a href="#IntentService的使用" class="headerlink" title="IntentService的使用"></a>IntentService的使用</h3><p>IntentService继承了Service并且它本身是一个<strong>抽象类</strong>，因此使用它必须创建它的子类才能使用。所以这里我们自定义一个MyIntentService，来处理异步任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyIntentService"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="comment">//查看线程id</span></div><div class="line">	        Log.i(TAG, intent.getStringExtra(<span class="string">"params"</span>) + <span class="string">", 线程id:"</span> + Thread.currentThread().getId());</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line"></div><div class="line">            <span class="comment">//从0-100渐增</span></div><div class="line">            isRunning = <span class="keyword">true</span>;</div><div class="line">            count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (isRunning) &#123;</div><div class="line">                count++;</div><div class="line">                Log.i(TAG, <span class="string">"MyIntentService 线程运行中..."</span> + count);</div><div class="line">                <span class="keyword">if</span> (count &gt;= <span class="number">100</span>) &#123;</div><div class="line">                    isRunning = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                Thread.sleep(<span class="number">50</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后启动服务之前别忘了在manifest文件中注册这个Service：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 在 Manifest 中注册服务</span></div><div class="line">&lt;service android:name=<span class="string">".service.MyIntentService"</span>/&gt;</div></pre></td></tr></table></figure>
<p>最后是启动服务，就和普通Service一样启动：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 像启动 Service 那样启动 IntentService</span></div><div class="line">Intent intent= <span class="keyword">new</span> Intent(getActivity(), MyIntentService.class);</div><div class="line">intent.putExtra(<span class="string">"params"</span>, <span class="string">"testString..."</span>);</div><div class="line">getActivity().startService(intent);</div></pre></td></tr></table></figure></p>
<p>到此，通过IntentService执行的异步任务已经开始执行了，当执行完毕之后它会自动停止而不用我们手动操作。</p>
<p>当这个MyIntentService启动之后，我们看到它接收到了消息并打印出了传递过去的intent参数，同时显示<strong>onHandlerIntent方法执行的线程ID并非主线程</strong>，也就是说它果真开了一个额外的线程，什么时候开启的呢？我们进入IntentService源码看看。</p>
<h3 id="IntentService源码"><a href="#IntentService源码" class="headerlink" title="IntentService源码"></a>IntentService源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//IntentService继承了Service并且它本身是一个抽象类，因此使用它必须创建它的子类才能使用。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</div><div class="line">    <span class="keyword">private</span> String mName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(looper);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">	        <span class="comment">// onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。</span></div><div class="line">            onHandleIntent((Intent)msg.obj);</div><div class="line">            stopSelf(msg.arg1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">        mRedelivery = enabled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">        <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">        <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">        thread.start();</div><div class="line"></div><div class="line">        mServiceLooper = thread.getLooper();</div><div class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        Message msg = mServiceHandler.obtainMessage();</div><div class="line">        msg.arg1 = startId;</div><div class="line">        msg.obj = intent;</div><div class="line">        mServiceHandler.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        onStart(intent, startId);</div><div class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        mServiceLooper.quit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@WorkerThread</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码还是相当的简洁的，首先通过定义我们可以知道IntentService是一个Service，并且是一个抽象类，所以我们在继承IntentService的时候需要实现其抽象方法：onHandlerIntent。</p>
<h4 id="1-启动-IntentService-为什么不需要新建线程？"><a href="#1-启动-IntentService-为什么不需要新建线程？" class="headerlink" title="1. 启动 IntentService 为什么不需要新建线程？"></a><strong>1. 启动 IntentService 为什么不需要新建线程？</strong></h4><p>我们来看看它的onCreate()函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    <span class="comment">// HandlerThread 继承自 Thread，内部封装了 Looper，在这里新建线程并启动，所以启动 IntentService 不需要新建线程。</span></div><div class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    <span class="comment">// 获得工作线程的 Looper，并维护自己的消息队列MessageQueue</span></div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    <span class="comment">// mServiceHandler 是属于这个工作线程的</span></div><div class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以发现其内部定义一个HandlerThread（本质上是一个含有消息队列的线程）。然后用成员变量维护其Looper和Handler，由于其Handler（也就是mServiceHandler对象）关联着这个HandlerThread的Looper对象，<strong>所以这个<code>ServiceHandler</code>的handleMessage方法在HandlerThread线程中执行</strong>。</p>
<p>然后我们发现其onStartCommand方法就是调用的其onStart方法，具体看一下其onStart方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">    Message msg = mServiceHandler.obtainMessage();</div><div class="line">    msg.arg1 = startId;</div><div class="line">    msg.obj = intent;</div><div class="line">    mServiceHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单就是将startId和启动时接受到的intent对象传递到ServiceHandler的消息队列中处理，那么我们具体看一下ServiceHandler的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">		<span class="comment">// onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。</span></div><div class="line">        onHandleIntent((Intent)msg.obj);</div><div class="line">        stopSelf(msg.arg1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到起handleMessage方法内部执行了两个逻辑：</p>
<ul>
<li><p>一个是调用了其<code>onHandlerIntent()</code>抽象方法，在子线程中执行。</p>
</li>
<li><p>二是调用了<code>stopSelf()</code>方法，这里需要注意的是stopSelf方法传递了<code>msg.arg1</code>参数，从刚刚的onStart方法我们可以知道我们传递了<code>startId</code>，这是<strong>由于service可以启动多次，可以传递N次消息</strong>，当IntentService的消息队列中含有消息时调用stopSelf(startId)并不会立即stop自己，<strong>只有当消息队列中最后一个消息被执行完成时才会真正的stop自身</strong>。</p>
</li>
</ul>
<h4 id="2-为什么不建议通过-bindService-启动-IntentService？"><a href="#2-为什么不建议通过-bindService-启动-IntentService？" class="headerlink" title="2. 为什么不建议通过 bindService() 启动 IntentService？"></a><strong>2. 为什么不建议通过 bindService() 启动 IntentService？</strong></h4><p>我们看IntentService的<code>onBind()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IntentService 源码中的 <code>onBind()</code> 默认返回 null，不适合 <code>bindService()</code> 启动服务，如果你执意要 <code>bindService()</code> 来启动 IntentService，可能因为你想通过 Binder 或 Messenger 使得 IntentService 和 Activity 可以通信，<strong>这样 onHandleIntent() 就不会被回调</strong>，相当于在你使用 Service 而不是 IntentService。</p>
<!-- ### HandlerThread

HandlerThread，其本质上是一个Thread，只不过内部定义了其自身的Looper和MessageQueue。为了让多个线程之间能够方便的通信，我们会使用Handler实现线程间的通信。这个时候我们手动实现的多线程+Handler的简化版就是我们HandlerThrea所要做的事了。 -->
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>IntentService 是继承自 Service 并处理异步请求的一个<strong>抽象类</strong>，在 IntentService 内有一个工作线程来处理耗时操作，当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，依次去执行，执行完自动结束。</p>
<p>IntentService有以下特点：</p>
<p>1）.  它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents。<br>2）.  创建了一个工作队列，来逐个发送intent给onHandleIntent()。<br>3）.  不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。<br>4）.  默认实现的onBind()返回null<br>5）.  默认实现的onStartCommand()的目的是将intent插入到工作队列中</p>
<p> 继承IntentService的类至少要实现两个函数：<strong>构造函数</strong>和<strong>onHandleIntent()</strong>函数。要覆盖IntentService的其它函数时，注意要通过super调用父类的对应的函数。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/qq_23547831/article/details/50958757" target="_blank" rel="external">Android源码解析之（五）–&gt;IntentService</a></li>
<li><a href="http://www.jianshu.com/p/332b6daf91f0" target="_blank" rel="external">IntentService 示例与详解</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;提到Android的多线程机制，除了我们常用的Thread来实现异步任务之外，还有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;AsyncTask&lt;/strong&gt;：封装了线程池和Handler，主要为了子线程更新UI；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HandlerThread&lt;/strong&gt;：一个已经拥有了Looper的线程类，内部可以直接使用Handler；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IntentService&lt;/strong&gt;：一个内部采用HandlerThread来执行任务的Service服务，任务执行完毕后会自动退出；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天我们来根据平时的使用方式来分析一下第三个IntentSevice到底是什么怎么实现的？&lt;/p&gt;
&lt;h3 id=&quot;IntentService的使用&quot;&gt;&lt;a href=&quot;#IntentService的使用&quot; class=&quot;headerlink&quot; title=&quot;IntentService的使用&quot;&gt;&lt;/a&gt;IntentService的使用&lt;/h3&gt;&lt;p&gt;IntentService继承了Service并且它本身是一个&lt;strong&gt;抽象类&lt;/strong&gt;，因此使用它必须创建它的子类才能使用。所以这里我们自定义一个MyIntentService，来处理异步任务：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyIntentService&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IntentService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String TAG = &lt;span class=&quot;string&quot;&gt;&quot;MyIntentService&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isRunning = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyIntentService&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;MyIntentService&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onHandleIntent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Intent intent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	        &lt;span class=&quot;comment&quot;&gt;//查看线程id&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	        Log.i(TAG, intent.getStringExtra(&lt;span class=&quot;string&quot;&gt;&quot;params&quot;&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&quot;, 线程id:&quot;&lt;/span&gt; + Thread.currentThread().getId());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//从0-100渐增&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            isRunning = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (isRunning) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                count++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Log.i(TAG, &lt;span class=&quot;string&quot;&gt;&quot;MyIntentService 线程运行中...&quot;&lt;/span&gt; + count);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count &amp;gt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    isRunning = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Thread.sleep(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onDestroy();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://github.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Android】EventBus 3.0 源码分析</title>
    <link href="http://github.com/2017/09/30/%E3%80%90Android%E3%80%91EventBus%203.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://github.com/2017/09/30/【Android】EventBus 3.0源码分析/</id>
    <published>2017-09-30T14:03:00.000Z</published>
    <updated>2017-10-10T03:13:52.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong><a href="https://github.com/greenrobot/EventBus">EventBus</a></strong>是Android中一个基于<strong>观察者模式</strong>的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，主要功能是替代Intent，Handler，BroadCast 在 Fragment，Activity，Service，线程Thread之间传递消息。优点是开销小，使用方便，可以很大程度上降低它们之间的耦合。 类似的库还有<a href="https://github.com/square/otto">Otto</a> ，今天就带大家一起研读 EventBus 的源码。</p>
<p>这是EventBus源码中的介绍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;<span class="doctag">@link</span> #post(Object)&#125;) to the</div><div class="line"> * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,</div><div class="line"> * subscribers must register themselves to the bus using &#123;<span class="doctag">@link</span> #register(Object)&#125;. Once registered, subscribers</div><div class="line"> * receive events until &#123;<span class="doctag">@link</span> #unregister(Object)&#125; is called. Event handling methods must be annotated by</div><div class="line"> * &#123;<span class="doctag">@link</span> Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter</div><div class="line"> * (the event).</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Markus Junginger, greenrobot</div><div class="line"> */</div></pre></td></tr></table></figure>
<blockquote>
<p>EventBus 是Android上的以<strong>发布\订阅事件</strong>为核心的库。事件 (<code>event</code>) 通过 <code>post()</code> 发送到总线，然后再分发到匹配事件类型的订阅者 (<code>subscribers</code>) 。订阅者只有在总线中注册 (<code>register</code>) 了才能收到事件，注销 (<code>unrigister</code>) 之后就收不到任何事件了。事件方法必须带有 <code>Subscribe</code> 的注解，必须是 <code>public</code> ，没有返回类型 <code>void</code> 并且只能有一个参数。</p>
</blockquote>
<p>EventBus3 与之前的相比，其主要差别在于订阅方法可以不再以<code>onEvent</code> 开头了，改为用<strong>注解</strong>。</p>
<a id="more"></a>
<h3 id="一、使用EventBus"><a href="#一、使用EventBus" class="headerlink" title="一、使用EventBus"></a>一、使用EventBus</h3><p><img src="/gallery/EventBus/how_to_use.png" alt=""></p>
<p>在Gradle中添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">compile <span class="string">'org.greenrobot:eventbus:3.0.0'</span></div></pre></td></tr></table></figure>
<h4 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h4><p>EventBus默认有一个单例，可以通过<code>getDefault()</code>获取，也可以通过<code>EventBus.builder()</code>构造自定义的EventBus，比如要应用我们生成好的索引时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBus mEventBus = EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).build();</div></pre></td></tr></table></figure>
<p>如果想把自定义的设置应用到EventBus默认的单例中，则可以用<code>installDefaultEventBus()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).installDefaultEventBus();</div></pre></td></tr></table></figure>
<h4 id="1-2-定义事件"><a href="#1-2-定义事件" class="headerlink" title="1.2 定义事件"></a>1.2 定义事件</h4><p>所有能被实例化为Object的实例都可以作为事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String message;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageEvent</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在最新版的eventbus 3中如果用到了索引加速，事件类的修饰符必须为<strong>public</strong>，不然编译时会报错：<code>Subscriber method must be public</code>。</p>
<h4 id="1-3-监听事件"><a href="#1-3-监听事件" class="headerlink" title="1.3 监听事件"></a>1.3 监听事件</h4><p>订阅者需要在总线上注册和注销自己。只有当订阅者注册了才能接收到事件。在Android中，通常与 Activity 和 Fragment 的生命周期绑定在一起。</p>
<p>之前2.x版本中有四种注册方法，区分了普通注册和粘性事件注册，并且在注册时可以选择接收事件的优先级，这里我们就不对2.x版本做过多的研究了。由于3.0版本将粘性事件以及订阅事件的优先级换成了<strong>注解</strong>的实现方式，所以3.0版本中的注册就变得简单，只有一个register()方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//3.0版本的注册</span></div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line">	   </div><div class="line"><span class="comment">//2.x版本的四种注册方法</span></div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>, <span class="number">100</span>);</div><div class="line">EventBus.getDefault().registerSticky(<span class="keyword">this</span>);</div><div class="line">EventBus.getDefault().registerSticky(<span class="keyword">this</span>, <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>当我们不在需要接收事件的时候需要解除注册unregister，2.x和3.0的解除注册也是相同的。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//取消注册</span></div><div class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>接收到消息之后的处理方式，在2.x版本中，注册这些消息的监听需要区分是否监听黏性（sticky）事件，监听EventBus事件的模块需要实现以onEvent开头的方法。如今3.0改为在方法上添加注解的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//3.0版本</span></div><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING, priority = <span class="number">0</span>, sticky = <span class="keyword">true</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(DriverEvent event)</span> </span>&#123;</div><div class="line">    Log.d(TAG, event.info);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//2.x版本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在2.x版本中只有通过onEvent开头的方法会被注册，而且响应事件方法触发的线程通过<code>onEventMainThread</code>或<code>onEventBackgroundThread</code>这些方法名区分，而在3.0版本中，通过<code>@Subscribe</code>注解，来确定运行的线程threadMode，是否接受粘性事件sticky以及事件优先级priority，而且方法名不在需要<code>onEvent</code>开头，所以又简洁灵活了不少。</p>
<p>我们可以看到注解<code>@Subscribe</code>有三个参数，threadMode为回调所在的线程，priority为优先级，sticky为是否接收黏性事件。调度单位从类细化到了方法，对方法的命名也没有了要求，方便混淆代码。但注册了监听的模块必须有一个标注了Subscribe注解方法，不然在register时会抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Subscriber class XXX and its super classes have no public methods with the @Subscribe annotation</div></pre></td></tr></table></figure>
<h4 id="1-4-发送事件"><a href="#1-4-发送事件" class="headerlink" title="1.4 发送事件"></a>1.4 发送事件</h4><p>可以从代码的任何地方调用post或者postSticky发送事件，此时注册了的且匹配事件的订阅者能够接收到事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(<span class="string">"Hello everyone!"</span>));</div></pre></td></tr></table></figure>
<p>在实际项目的使用中，register和unregister通常与Activity和Fragment的生命周期相关，ThreadMode.MainThread可以很好地解决Android的界面刷新必须在UI线程的问题，不需要再回调后用Handler中转（<strong>EventBus中已经自动用Handler做了处理</strong>），黏性事件可以很好地解决post与register同时执行时的异步问题（这个在原理中会说到），事件的传递也没有序列化与反序列化的性能消耗，足以满足我们大部分情况下的模块间通信需求。</p>
<h3 id="二、EventBus源码跟踪"><a href="#二、EventBus源码跟踪" class="headerlink" title="二、EventBus源码跟踪"></a>二、EventBus源码跟踪</h3><p>我们通过<code>EventBus</code>的使用流程来跟踪分析它的调用流程，通过我们熟悉的使用方法来深入到<code>EventBus</code>的实现内部并理解它的实现原理。</p>
<h4 id="2-1-创建EventBus对象"><a href="#2-1-创建EventBus对象" class="headerlink" title="2.1 创建EventBus对象"></a><strong>2.1 创建EventBus对象</strong></h4><p>先看看 <code>getDefault()</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</div><div class="line"></div><div class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> defaultInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是设计模式里我们常用的<strong>单例模式</strong>，用到了double check。保证了<code>getDefault()</code>得到的都是同一个实例。如果不存在实例，就调用了<code>EventBus</code>的构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造函数可以创建多个不同的EventBus，不同的实例之间可以相互隔离，如果只想使用同一个总线，就直接使用getDefault()方法获取单例</div><div class="line"> * </div><div class="line"> * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</div><div class="line"> * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(DEFAULT_BUILDER);</div><div class="line">&#125;</div><div class="line"></div><div class="line">EventBus(EventBusBuilder builder) &#123;</div><div class="line">	<span class="comment">//key:订阅的事件,value:订阅这个事件的所有订阅者集合</span></div><div class="line">	<span class="comment">//private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span></div><div class="line">	subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//key:订阅者对象,value:这个订阅者订阅的事件集合</span></div><div class="line">	<span class="comment">//private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span></div><div class="line">	typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//粘性事件 key:粘性事件的class对象, value:事件对象</span></div><div class="line">	<span class="comment">//private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span></div><div class="line">	stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//事件主线程处理</span></div><div class="line">	mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</div><div class="line">	<span class="comment">//事件 Background 处理</span></div><div class="line">	backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</div><div class="line">	<span class="comment">//事件异步线程处理</span></div><div class="line">	asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</div><div class="line">	indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</div><div class="line">	<span class="comment">//订阅者响应函数信息存储和查找类</span></div><div class="line">	subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</div><div class="line">	       builder.strictMethodVerification, builder.ignoreGeneratedIndex);</div><div class="line">	logSubscriberExceptions = builder.logSubscriberExceptions;</div><div class="line">	logNoSubscriberMessages = builder.logNoSubscriberMessages;</div><div class="line">	sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</div><div class="line">	sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</div><div class="line">	throwSubscriberException = builder.throwSubscriberException;</div><div class="line">	<span class="comment">//是否支持事件继承</span></div><div class="line">	eventInheritance = builder.eventInheritance;</div><div class="line">	executorService = builder.executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么，既然是单例模式构造函数还是 <code>public</code> ？没错，这样的设计是因为不仅仅可以只有一条总线，还可以有其他的线 (bus) ，订阅者可以注册到不同的线上的 <code>EventBus</code>，通过不同的 <code>EventBus</code> 实例来发送数据，不同的 <code>EventBus</code> 是相互隔离开的，订阅者都只会收到注册到该线上事件。</p>
<p>然后我们说一下构造函数里这三个 <code>HasMap</code>。</p>
<ul>
<li><strong><code>subscriptionsByEventType</code></strong> 是以 <code>event</code> 为 <em>key</em>，<code>subscriber列表</code> 为 <em>value</em>，当发送 <code>event</code> 的时候，都是去这里找对应的订阅者。</li>
<li><strong><code>typesBySubscriber</code></strong> 是以 <code>subscriber</code> 为 <em>key</em>，<code>event列表</code>为 <em>value</em>，当 <code>register()</code> 和 <code>unregister()</code> 的时候都是操作这个map，同时对 <code>subscriptionsByEventType</code> 进行对用操作。</li>
<li><strong><code>stickyEvents</code></strong> 维护的是粘性事件，粘性事件也就是当 <code>event</code> 发送出去之后再注册粘性事件的话，该粘性事件也能收到之前发送出去的 <code>event</code>。</li>
</ul>
<p>同时构造函数中还创建了 3 个 poster ：<strong>HandlerPoster ，BackgroundPoster和AsyncPoster，这 3 个 poster 负责线程间调度</strong>，稍后的事件分发模块我们会详细讲到。我们接着看这个构造函数中，最终运用到了builder设计模式，那么来看看这个 <code>EventBusBuilder</code> 中有哪些参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusBuilder</span> </span>&#123;</div><div class="line">	<span class="comment">//线程池</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</div><div class="line">	<span class="comment">//当调用事件处理函数异常时是否打印异常信息</span></div><div class="line">	<span class="keyword">boolean</span> logSubscriberExceptions = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//当没有订阅者订阅该事件时是否打印日志</span></div><div class="line">	<span class="keyword">boolean</span> logNoSubscriberMessages = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//当调用事件处理函数异常时是否发送 SubscriberExceptionEvent 事件</span></div><div class="line">	<span class="keyword">boolean</span> sendSubscriberExceptionEvent = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//当没有事件处理函数对事件处理时是否发送 NoSubscriberEvent 事件</span></div><div class="line">	<span class="keyword">boolean</span> sendNoSubscriberEvent = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//是否要抛出异常，建议debug开启</span></div><div class="line">	<span class="keyword">boolean</span> throwSubscriberException;</div><div class="line">	<span class="comment">//与event有继承关系的类是否需要发送</span></div><div class="line">	<span class="keyword">boolean</span> eventInheritance = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//是否忽略生成的索引(SubscriberInfoIndex)</span></div><div class="line">	<span class="keyword">boolean</span> ignoreGeneratedIndex;</div><div class="line">	<span class="comment">//是否严格的方法名校验</span></div><div class="line">	<span class="keyword">boolean</span> strictMethodVerification;</div><div class="line">	<span class="comment">//线程池，async 和 background 的事件会用到</span></div><div class="line">	ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;</div><div class="line">	<span class="comment">//当注册的时候会进行方法名的校验(EventBus3之前方法名必须以onEvent开头)，而这个列表是不参加校验的类的列表(EventBus3之后就没用这个参数了)</span></div><div class="line">	List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;</div><div class="line">	<span class="comment">//维护着由EventBus生成的索引(SubscriberInfoIndex)</span></div><div class="line">	List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;</div><div class="line"></div><div class="line">	EventBusBuilder() &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//赋值buidler(可用户自定义的)给单例的EventBus，如果单例的EventBus不为null了，则抛出异常</span></div><div class="line">	<span class="function"><span class="keyword">public</span> EventBus <span class="title">installDefaultEventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">	        <span class="keyword">if</span> (EventBus.defaultInstance != <span class="keyword">null</span>) &#123;</div><div class="line">	            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Default instance already exists."</span> +</div><div class="line">	                    <span class="string">" It may be only set once before it's used the first time to ensure consistent behavior."</span>);</div><div class="line">	        &#125;</div><div class="line">	        EventBus.defaultInstance = build();</div><div class="line">	        <span class="keyword">return</span> EventBus.defaultInstance;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> EventBus <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> EventBus(<span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//...省略其他代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出是通过初始化了一个<code>EventBusBuilder()</code>对象来分别初始化<code>EventBus</code>的一些配置，注释里我标注了大部分比较重要的对象，这里没必要记住，看下面的文章时如果对某个对象不了解，可以再回来看看。</p>
<h4 id="2-2-注册与订阅Register"><a href="#2-2-注册与订阅Register" class="headerlink" title="2.2 注册与订阅Register"></a><strong>2.2 注册与订阅Register</strong></h4><p>EventBus 3.0的注册入口只提供一个<code>register()</code>方法了，所以我们先来看看register()方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    <span class="comment">//首先获得订阅者的class对象</span></div><div class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</div><div class="line">    </div><div class="line">    <span class="comment">//通过subscriberMethodFinder来找到订阅者订阅了哪些事件.返回一个SubscriberMethod对象的List</span></div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">            <span class="comment">//订阅</span></div><div class="line">            subscribe(subscriber, subscriberMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>register()</code>方法很简洁，代码里的注释也很清楚了，我们可以看出通过<code>subscriberMethodFinder.findSubscriberMethods(subscriberClass)</code>方法就能返回一个<code>SubscriberMethod</code>的对象，而<code>SubscriberMethod</code>里包含了所有我们需要的接下来执行<code>subscribe()</code>的信息。</p>
<p>那 <strong><code>SubscriberMethod</code></strong>里包含了什么呢？下面是它的变量和构造函数。可以看到里面包括订阅类里的具体执行方法<code>Method</code>对象，需要在哪个线程执行<code>ThreadMode</code>，事件类型<code>eventType</code>，优先级<code>priority</code>，以及是否接收粘性<code>sticky</code>事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Method method;        <span class="comment">//具体的执行方法</span></div><div class="line">    <span class="keyword">final</span> ThreadMode threadMode; <span class="comment">//执行线程</span></div><div class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;   <span class="comment">//事件类型，也就是执行方法接受的参数类型</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;         <span class="comment">//优先级</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;       <span class="comment">//是否粘性，之后会讲到</span></div><div class="line">    <span class="comment">/** Used for efficient comparison */</span></div><div class="line">    String methodString;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubscriberMethod</span><span class="params">(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, <span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.method = method;</div><div class="line">        <span class="keyword">this</span>.threadMode = threadMode;</div><div class="line">        <span class="keyword">this</span>.eventType = eventType;</div><div class="line">        <span class="keyword">this</span>.priority = priority;</div><div class="line">        <span class="keyword">this</span>.sticky = sticky;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//...省略其他代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们去看看SubscriberMethodFinder类的<code>findSubscriberMethods()</code>是怎么找到订阅方法的，最后我们再去关注<code>subscribe()</code>。</p>
<p><strong>SubscriberMethodFinder的实现</strong></p>
<p>从字面理解，这个类就是订阅者方法发现者。一句话来描述<code>SubscriberMethodFinder</code>类就是用来<strong>查找和缓存订阅者响应函数的信息</strong>的类。所以我们首先要知道怎么能获得订阅者响应函数的相关信息。在3.0版本中，EventBus提供了一个<strong><code>EventBusAnnotationProcessor</code>注解处理器</strong>来在编译期通过读取<code>@Subscribe()</code>注解并解析，处理其中所包含的信息，然后生成java类来保存所有订阅者关于订阅的信息，这样就比在运行时使用反射来获得这些订阅者的信息速度要快。我们可以参考EventBus项目里的<a href="https://github.com/greenrobot/EventBus/tree/master/EventBusPerformance">EventBusPerformance</a>这个例子，编译后我们可以在build文件夹里找到这个类，<a href="https://github.com/greenrobot/EventBus/blob/master/EventBusPerformance/build.gradle#L27">MyEventBusIndex 类</a>，当然类名是可以自定义的。我们大致看一下生成的<code>MyEventBusIndex</code>类是什么样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This class is generated by EventBus, do not edit.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</div><div class="line"></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class,</div><div class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[]&#123;</div><div class="line">                <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventAsync"</span>, TestEvent.class, ThreadMode.ASYNC),</div><div class="line">        &#125;));</div><div class="line"></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(TestRunnerActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[]&#123;</div><div class="line">                <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestFinishedEvent.class, ThreadMode.MAIN),</div><div class="line">        &#125;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</div><div class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</div><div class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出是使用一个静态HashMap即：<code>SUBSCRIBER_INDEX</code>来保存订阅类的信息，其中包括了订阅类的class对象，是否需要检查父类，以及订阅方法的信息<code>SubscriberMethodInfo</code>的数组，<code>SubscriberMethodInfo</code>中又保存了，订阅方法的方法名，订阅的事件类型，触发线程，是否接收sticky事件以及优先级priority。这其中就保存了register()的所有需要的信息，如果再配置EventBus的时候通过<code>EventBusBuilder</code>配置：<code>eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();</code>来将编译生成的<code>MyEventBusIndex</code>配置进去，这样就能在<code>SubscriberMethodFinder</code>类中直接查找出订阅类的信息，就不需要再利用注解判断了，当然这种方法是作为EventBus的可选配置，<code>SubscriberMethodFinder</code>同样提供了通过注解来获得订阅类信息的方法，下面我们就来看<code>findSubscriberMethods()</code>到底是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    <span class="comment">//先从METHOD_CACHE取看是否有缓存, key:保存订阅类的类名,value:保存类中订阅的方法数据,</span></div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</div><div class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//是否忽略注解器生成的MyEventBusIndex类</span></div><div class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</div><div class="line">        <span class="comment">//利用反射来读取订阅类中的订阅方法信息</span></div><div class="line">        subscriberMethods = findUsingReflection(subscriberClass);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息</span></div><div class="line">        subscriberMethods = findUsingInfo(subscriberClass);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</div><div class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//保存进METHOD_CACHE缓存</span></div><div class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看看利用反射来读取订阅类中的订阅方法信息的函数：<code>findUsingReflection()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    <span class="comment">//FindState 用来做订阅方法的校验和保存</span></div><div class="line">    FindState findState = prepareFindState();</div><div class="line">    findState.initForSubscriber(subscriberClass);</div><div class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//通过反射来获得订阅方法信息</span></div><div class="line">        findUsingReflectionInSingleClass(findState);</div><div class="line">        <span class="comment">//查找父类的订阅方法</span></div><div class="line">        findState.moveToSuperclass();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//获取findState中的SubscriberMethod(也就是订阅方法List)并返回</span></div><div class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以及从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息： <code>findUsingInfo()</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    FindState findState = prepareFindState();</div><div class="line">    findState.initForSubscriber(subscriberClass);</div><div class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//得到订阅者信息</span></div><div class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</div><div class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//遍历订阅者方法</span></div><div class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</div><div class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</div><div class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</div><div class="line">                    findState.subscriberMethods.add(subscriberMethod);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果没有订阅者信息就使用反射查找订阅方法</span></div><div class="line">            findUsingReflectionInSingleClass(findState);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//跳转到父类中继续查找</span></div><div class="line">        findState.moveToSuperclass();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进入到<code>getSubscriberInfo()</code> 方法中我们看到了从自定义索引Index获取订阅方法信息的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">    <span class="comment">//判断FindState对象中是否有缓存的订阅方法</span></div><div class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</div><div class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</div><div class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</div><div class="line">            <span class="keyword">return</span> superclassInfo;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息</span></div><div class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</div><div class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</div><div class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> info;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我们可以看到作者使用了<code>FindState</code>类来做<strong>订阅方法的校验和保存</strong>，并通过<code>FIND_STATE_POOL</code>静态数组来保存<code>FindState</code>对象，可以使<code>FindState</code>复用，避免重复创建过多的对象。最终是通过<code>findUsingReflectionInSingleClass()</code>来具体获得相关订阅方法的信息的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在较新的类文件，编译器可能会添加方法。那些被称为BRIDGE或SYNTHETIC方法。EventBus必须忽略两者。有修饰符没有公开，但在Java类文件中有格式定义</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BRIDGE = <span class="number">0x40</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0x1000</span>;</div><div class="line"><span class="comment">//需要忽略的修饰符</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">    Method[] methods;</div><div class="line">    <span class="comment">//通过反射得到方法数组</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></div><div class="line">        methods = findState.clazz.getDeclaredMethods();</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></div><div class="line">        methods = findState.clazz.getMethods();</div><div class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历Method</span></div><div class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</div><div class="line">        <span class="comment">//必须是public的方法</span></div><div class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</div><div class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">            <span class="comment">//保证必须只有一个事件参数</span></div><div class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</div><div class="line">                <span class="comment">//得到注解</span></div><div class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</div><div class="line">                    <span class="comment">//校验是否添加该方法</span></div><div class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</div><div class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">                        <span class="comment">//实例化SubscriberMethod对象并添加</span></div><div class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</div><div class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</div><div class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</div><div class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 <code>BRIDGE</code> 和 <code>SYNTHETIC</code> ，注释写道：</p>
<blockquote>
<p>In newer class files, compilers may add methods. Those are called bridge or synthetic methods. EventBus must ignore both. There modifiers are not public but defined in the Java class file format: <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1" target="_blank" rel="external">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1</a></p>
</blockquote>
<p>在较新的类文件，编译器可能会添加方法。那些被称为 BRIDGE 或 SYNTHETIC 方法，EventBus 必须忽略两者。有修饰符没有公开，但在 Java 类文件中有格式定义。</p>
<p>该<code>findUsingReflectionInSingleClass</code>方法流程是：</p>
<ol>
<li>拿到当前 class 的所有方法；</li>
<li>过滤掉不是 public 和是 abstract、static、bridge、synthetic 的方法；</li>
<li>过滤出方法参数只有一个的方法；</li>
<li>过滤出被Subscribe注解修饰的方法；</li>
<li>将 method 方法和 event 事件添加到 <code>findState</code> 中；</li>
<li>将 EventBus 关心的 method 方法、event 事件、threadMode、priority、sticky 封装成 <code>SubscriberMethod</code> 对象添加到 <code>findState.subscriberMethods</code> 列表中；</li>
</ol>
<p>这里走完，我们订阅类的所有<code>SubscriberMethod</code>都已经被保存了，最后再通过<code>getMethodsAndRelease()</code>返回<code>List&lt;SubscriberMethod&gt;</code>。至此，所有关于如何获得订阅类的订阅方法信息即：<code>SubscriberMethod</code>对象就已经完全分析完了，下面我们来看<code>subscribe()</code>是如何实现的。</p>
<p><strong>subscribe()方法的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//必须在同步代码块里调用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</div><div class="line">    <span class="comment">//获取订阅的事件类型</span></div><div class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">    <span class="comment">//创建Subscription对象</span></div><div class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">    <span class="comment">//从subscriptionsByEventType里检查是否已经添加过该Subscription,如果添加过就抛出异常,也就是每个类只能有一个函数响应同一种事件类型</span></div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</div><div class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">        subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">                    + eventType);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//根据优先级priority来添加Subscription对象</span></div><div class="line">    <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">            subscriptions.add(i, newSubscription);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将订阅者对象以及订阅的事件保存到typesBySubscriber里.</span></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">    &#125;</div><div class="line">    subscribedEvents.add(eventType);</div><div class="line">    <span class="comment">//如果接收sticky事件,立即分发sticky事件</span></div><div class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">        <span class="comment">//eventInheritance 表示是否分发订阅了响应事件类父类事件的方法</span></div><div class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></div><div class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></div><div class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></div><div class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></div><div class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                    Object stickyEvent = entry.getValue();</div><div class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是所有注册过程，现在再来看这张图就会特别清晰<code>EventBus</code>的<code>register()</code>过程了:</p>
<p><img src="/gallery/EventBus/register-flow-chart.png" alt=""></p>
<p>到这里，订阅流程就走完了。接下来我们在看事件分发的流程。</p>
<h4 id="2-3-发送事件Post"><a href="#2-3-发送事件Post" class="headerlink" title="2.3 发送事件Post"></a><strong>2.3 发送事件Post</strong></h4><p>我们知道发送事件是通过<code>post()</code> 方法进行广播的，比如第一节我们例子中提到的<code>EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;));</code> 接下来我们进入这个<code>post()</code>方法一窥究竟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    <span class="comment">//得到当前线程的Posting状态.</span></div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    <span class="comment">//获取当前线程的事件队列</span></div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    eventQueue.add(event);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">        <span class="comment">// 记录当前发送线程是否为主线程</span></div><div class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">        postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//处理队列，一直发送完所有事件</span></div><div class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">                <span class="comment">//发送单个事件</span></div><div class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">            postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是通过<code>currentPostingThreadState.get()</code>方法来得到当前线程<code>PostingThreadState</code>的对象，为什么是说当前线程？我们来看看<code>currentPostingThreadState</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实现是返回一个 <code>PostingThreadState</code> 对象，而 <code>PostingThreadState</code> 类的结构如下，封装的是当前线程的 post 信息，包括事件队列、是否正在分发中、是否在主线程、订阅者信息、事件实例、是否取消。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** For ThreadLocal, much faster to set (and get multiple values). */</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div><div class="line">    <span class="keyword">boolean</span> isPosting;</div><div class="line">    <span class="keyword">boolean</span> isMainThread;</div><div class="line">    Subscription subscription;</div><div class="line">    Object event;</div><div class="line">    <span class="keyword">boolean</span> canceled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综上，<code>currentPostingThreadState</code>的实现是一个包含了<code>PostingThreadState</code>的<code>ThreadLocal</code>对象，关于<code>ThreadLocal</code><a href="http://kymjs.com/code/2015/12/16/01" target="_blank" rel="external">张涛的这篇文章</a>解释的很好：<strong>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。</strong> 其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，通过这样就可以做到每个线程通过<code>get()</code> 方法获取的时候，取到的只能是自己线程所对应的数据。 所以这里取到的就是每个线程的<code>PostingThreadState</code>状态.接下来我们来看<code>postSingleEvent()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</div><div class="line">    Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//是否触发订阅了该事件(eventClass)的父类,以及接口的类的响应方法</span></div><div class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">        <span class="comment">//查找eventClass类所有的父类以及接口</span></div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">        <span class="comment">//循环postSingleEventForEventType</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</div><div class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">            <span class="comment">//只要右边有一个为true,subscriptionFound就为true</span></div><div class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//post单个</span></div><div class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没发现</span></div><div class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</div><div class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</div><div class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</div><div class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">            <span class="comment">//发送一个NoSubscriberEvent事件,如果我们需要处理这种状态,接收这个事件就可以了</span></div><div class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lookupAllEventTypes()</code> 就是查找该事件的所有父类，返回所有的该事件的父类的 class 。它通过循环和递归一起用，将一个类的父类（接口）全部添加到全局静态变量 <code>eventTypes</code> 集合中。跟着上面的代码的注释，我们可以很清楚的发现是在<code>postSingleEventForEventType()</code>方法里去进行事件的分发，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">    <span class="comment">//获取订阅了这个事件的Subscription列表.</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">            postingState.event = event;</div><div class="line">            postingState.subscription = subscription;</div><div class="line">            <span class="comment">//是否被中断</span></div><div class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//分发给订阅者</span></div><div class="line">                postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                aborted = postingState.canceled;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postingState.event = <span class="keyword">null</span>;</div><div class="line">                postingState.subscription = <span class="keyword">null</span>;</div><div class="line">                postingState.canceled = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (aborted) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</div><div class="line">    <span class="comment">//根据接收该事件的订阅方法约定的ThreadMode决定分配到哪个线程执行</span></div><div class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">        <span class="keyword">case</span> POSTING:</div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MAIN:</div><div class="line">            <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mainThreadPoster.enqueue(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BACKGROUND:</div><div class="line">            <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                backgroundPoster.enqueue(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ASYNC:</div><div class="line">            asyncPoster.enqueue(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结上面的代码就是,首先从<code>subscriptionsByEventType</code>里获得所有订阅了这个事件的<code>Subscription</code>列表，然后在通过<code>postToSubscription()</code>方法来分发事件，在<code>postToSubscription()</code>通过不同的<code>threadMode</code>在不同的线程里<code>invoke()</code>订阅者的方法,<code>ThreadMode</code>共有四类：</p>
<ol>
<li><code>PostThread</code>：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：<strong>对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作</strong>；</li>
<li><code>MainThread</code>：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，<code>MainThread</code>类的方法也不能有耗时操作，以避免卡主线程。适用场景：<strong>必须在主线程执行的操作</strong>；</li>
<li><code>BackgroundThread</code>：在后台线程中执行响应方法。如果发布线程<strong>不是</strong>主线程，则直接调用订阅者的事件响应函数，否则启动<strong>唯一的</strong>后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有<code>PostThread</code>类和<code>MainThread</code>类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：<em>操作轻微耗时且不会过于频繁</em>，即一般的耗时操作都可以放在这里；</li>
<li><code>Async</code>：不论发布线程是否为主线程，都使用一个空闲线程来处理。和<code>BackgroundThread</code>不同的是，<code>Async</code>类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：<em>长耗时操作，例如网络访问</em>。</li>
</ol>
<p>这里我们先看看<code>invokeSubscriber(subscription, event);</code>是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">        handleSubscriberException(subscription, event, e.getCause());</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上就是通过反射调用了订阅者的订阅函数并把<code>event</code>对象作为参数传入。然后我们就又遇到了在EventBus构造函数中初始化的3个Poster：<strong>HandlerPoster</strong>（也就是代码中的mainThreadPoster对象） ，<strong>BackgroundPoster</strong>和<strong>AsyncPoster</strong>，这 3 个 poster 负责线程间调度。我们分别来看看：</p>
<p><strong>#  HandlerPoster</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	<span class="comment">//队列，即将执行的Post</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">  	<span class="comment">//一个Post最大的在HandleMessage中的时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line">  	<span class="comment">//handler是否运行起来了</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</div><div class="line"></div><div class="line">    <span class="comment">//EventBus的构造函数中初始化了mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);</span></div><div class="line">    <span class="comment">//注意此处的Looper.getMainLooper()便指定了主线程的Looper</span></div><div class="line">    HandlerPoster(EventBus eventBus, Looper looper, <span class="keyword">int</span> maxMillisInsideHandleMessage) &#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">        <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">        <span class="keyword">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</div><div class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">      	<span class="comment">//PendingPost维护了一个可以复用PendingPost对象的复用池</span></div><div class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">          	<span class="comment">//加入到队列中</span></div><div class="line">            queue.enqueue(pendingPost);</div><div class="line">          	<span class="comment">//如果handleMessage没有运行起来</span></div><div class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</div><div class="line">                handlerActive = <span class="keyword">true</span>;</div><div class="line">              	<span class="comment">//发送一个空消息，让handleMessage运行起来</span></div><div class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> started = SystemClock.uptimeMillis();</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">              	<span class="comment">//从队列中取出PendingPost</span></div><div class="line">                PendingPost pendingPost = queue.poll();</div><div class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                        <span class="comment">// Check again, this time in synchronized</span></div><div class="line">                        pendingPost = queue.poll();</div><div class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                            handlerActive = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">              	<span class="comment">//调用eventBus的方法，分发消息</span></div><div class="line">                eventBus.invokeSubscriber(pendingPost);</div><div class="line">                <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</div><div class="line">              	<span class="comment">//如果再一定时间内都还没有将队列排空，则退出</span></div><div class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</div><div class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</div><div class="line">                    &#125;</div><div class="line">                    rescheduled = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            handlerActive = rescheduled;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们有必要回看EventBus的构造函数中初始化了<code>mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);</code>的代码。注意这行代码中传入的第二个参数<strong>Looper.getMainLooper()</strong>便指定了主线程的Looper，保证了这个HandlerPoster的运行在主线程。</p>
<p>然后<code>PendingPost</code> 的数据结构是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</div><div class="line">    Object event;<span class="comment">//事件</span></div><div class="line">    Subscription subscription;<span class="comment">//订阅</span></div><div class="line">    PendingPost next;<span class="comment">//与队列的数据结构有关，指向下一个节点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>PendingPost</code> 维护着一个可以复用PendingPost对象的复用池，通过 <code>obtainPendingPost(Subscription, Object)</code> 方法复用，通过 <code>releasePendingPost(PendingPost )</code> 方法回收。</p>
<p><code>handleMessage()</code> 中有一个死循环，这个死循环不停的从队列中拿数据，然后通过 <code>EventBus.invokeSubscriber()</code> 分发出去。每分发完一次比对一下时间，如果超过了 <code>maxMillisInsideHandleMessage</code> ，那么发送空 <code>message</code>再次进入到 <code>handlerMessage</code> 中且退出本次循环。</p>
<p><strong># BackgroundPoster</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Posts events in background.</div><div class="line"> * <span class="doctag">@author</span> Markus</div><div class="line"> */</div><div class="line"> <span class="comment">//我们注意到它实现了Runable接口</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</div><div class="line"></div><div class="line">    BackgroundPoster(EventBus eventBus) &#123;</div><div class="line">        <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">//加入到队列中</span></div><div class="line">            queue.enqueue(pendingPost);</div><div class="line">            <span class="keyword">if</span> (!executorRunning) &#123;</div><div class="line">                executorRunning = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//把自己这个Runable抛入线程池开始运行</span></div><div class="line">                eventBus.getExecutorService().execute(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                    <span class="comment">//从队列中取出PendingPost，此处的1000表示如果队列为空就暂停1000毫秒再取</span></div><div class="line">                    PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</div><div class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                            <span class="comment">// Check again, this time in synchronized</span></div><div class="line">                            pendingPost = queue.poll();</div><div class="line">                            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                                executorRunning = <span class="keyword">false</span>;</div><div class="line">                                <span class="keyword">return</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//调用eventBus的方法，分发消息</span></div><div class="line">                    eventBus.invokeSubscriber(pendingPost);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                Log.w(<span class="string">"Event"</span>, Thread.currentThread().getName() + <span class="string">" was interruppted"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            executorRunning = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理 <code>BackgroundPoster</code> ，只不过 <code>HandlerPoster</code> 是在 <code>handlerMessage</code> 中进行分发操作，而 <code>BackgroundPoster</code> 是在 <code>Runnable</code> 的 <code>run</code> 方法中将所有队列中的消息取出进行分发，直到取完为止。</p>
<p><strong># AsyncPoster</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Posts events in background.</div><div class="line"> * <span class="doctag">@author</span> Markus</div><div class="line"> */</div><div class="line"> <span class="comment">//它也实现Runable接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line"></div><div class="line">    AsyncPoster(EventBus eventBus) &#123;</div><div class="line">        <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">        queue.enqueue(pendingPost);</div><div class="line">        eventBus.getExecutorService().execute(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        PendingPost pendingPost = queue.poll();</div><div class="line">        <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</div><div class="line">        &#125;</div><div class="line">        eventBus.invokeSubscriber(pendingPost);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 <code>AsyncPoster</code> 虽然也是在 <code>Runnable</code> 的 <code>run</code> 方法中取出队列中的消息，但是只取一个。不论发布线程是否为主线程，都使用一个空闲线程来处理。和<code>BackgroundThread</code>不同的是，<code>Async</code>类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：<em>长耗时操作，例如网络访问</em>。</p>
<p>可以看到，不同的Poster会在post事件时，调度相应的事件队列PendingPostQueue，让每个订阅者的回调方法收到相应的事件，并在其注册的Thread中运行。而这个事件队列是一个链表，由一个个PendingPost组成，其中包含了事件，事件订阅者，回调方法这三个核心参数，以及需要执行的下一个PendingPost。至此<code>post()</code>流程就结束了，整体流程图如下：</p>
<p><img src="/gallery/EventBus/post-flow-chart.png" alt=""></p>
<h4 id="2-4-解除注册Unregister"><a href="#2-4-解除注册Unregister" class="headerlink" title="2.4 解除注册Unregister"></a>2.4 解除注册Unregister</h4><p>看完了上面的分析，解除注册就相对容易了，解除注册只要调用<code>unregister()</code>方法即可。实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    <span class="comment">//通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型,</span></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//分别解除每个订阅了的事件类型</span></div><div class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">            unsubscribeByEventType(subscriber, eventType);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从typesBySubscriber移除subscriber</span></div><div class="line">        typesBySubscriber.remove(subscriber);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后接着看<code>unsubscribeByEventType()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">    <span class="comment">//subscriptionsByEventType里拿出这个事件类型的订阅者列表.</span></div><div class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">        <span class="comment">//取消订阅</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            Subscription subscription = subscriptions.get(i);</div><div class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</div><div class="line">                subscription.active = <span class="keyword">false</span>;</div><div class="line">                subscriptions.remove(i);</div><div class="line">                i--;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终分别从<code>typesBySubscriber</code>和<code>subscriptions</code>里分别移除订阅者以及相关信息即可。</p>
<h3 id="三、EventBus原理分析"><a href="#三、EventBus原理分析" class="headerlink" title="三、EventBus原理分析"></a>三、EventBus原理分析</h3><p>在平时使用中我们不需要关心EventBus中对事件的分发机制，但要成为能够快速排查问题的老司机，我们还是得熟悉它的工作原理，下面我们就透过UML图来学习一下。</p>
<h4 id="3-1-核心架构"><a href="#3-1-核心架构" class="headerlink" title="3.1 核心架构"></a>3.1 核心架构</h4><p>EventBus的核心工作机制透过作者Blog中的这张图就能很好地理解：</p>
<p><img src="/gallery/EventBus/eventbus_overview.png" alt=""></p>
<p>订阅者模块需要通过EventBus订阅相关的事件，并准备好处理事件的回调方法，而事件发布者则在适当的时机把事件post出去，EventBus就能帮我们搞定一切。在架构方面，EventBus 3.0与之前稍老版本有不同，我们直接看架构图：</p>
<p><img src="/gallery/EventBus/class_overview.png" alt="EventBus 3.0架构图"></p>
<p>为了方便理解或者对比，顺便也放一张2.x老版本的结构图吧：</p>
<p><img src="/gallery/EventBus/class-relation.png" alt="EventBus 2.x老版本结构图"></p>
<p>虽然更新了3.0，但是整体上的设计还是可以用上面的类图来分析，从类图上我们可以看到大部分类都是依赖于EventBus的，上部分主要是订阅者相关信息，中间是 EventBus 类，下面是发布者发布事件后的调用。</p>
<p>根据UML图，我们先看核心类EventBus，其中<code>subscriptionByEventType</code>是以事件的类为key，订阅者的回调方法为value的映射关系表。也就是说EventBus在收到一个事件时，就可以根据这个事件的类型，在<code>subscriptionByEventType</code>中找到所有监听了该事件的订阅者及处理事件的回调方法。而<code>typesBySubscriber</code>则是每个订阅者所监听的事件类型表，在取消注册时可以通过该表中保存的信息，快速删除<code>subscriptionByEventType</code>中订阅者的注册信息，避免遍历查找。注册事件、发送事件和注销都是围绕着这两个核心数据结构来展开。上面的Subscription可以理解为每个订阅者与回调方法的关系，在其他模块发送事件时，就会通过这个关系，让订阅者执行回调方法。</p>
<p>回调方法在这里被封装成了<code>SubscriptionMethod</code>，里面保存了在需要反射invoke方法时的各种参数，包括优先级，是否接收黏性事件和所在线程等信息。而要生成这些封装好的方法，则需要<code>SubscriberMethodFinder</code>，它可以在regster时得到订阅者的所有回调方法，并封装返回给EventBus。而右边的加速器模块，就是为了提高<code>SubscriberMethodFinder</code>的效率，这里就不再啰嗦。</p>
<p>至此EventBus 3.0的架构就分析完了，与之前EventBus老版本最明显的区别在于：分发事件的调度单位从订阅者，细化成了订阅者的回调方法。也就是说每个回调方法都有自己的优先级，执行线程和是否接收黏性事件，提高了事件分发的灵活程度，接下来我们在看核心功能的实现时更能体现这一点。</p>
<h4 id="3-2-register"><a href="#3-2-register" class="headerlink" title="3.2 register"></a>3.2 register</h4><p>简单来说就是：根据订阅者的类来找回调方法，把订阅者和回调方法封装成关系，并保存到相应的数据结构中，为随后的事件分发做好准备，最后处理黏性事件。</p>
<p><img src="/gallery/EventBus/register.png" alt="注册订阅流程"></p>
<ol>
<li>根据订阅者来找到订阅方法和事件，封装成 <code>SubscriberMehod</code></li>
<li>循环每个 <code>SubscriberMethod</code></li>
<li>通过事件得到该事件的所有订阅者列表，再根据优先级插入到 <code>subscriptionsByEventType</code> 的所有订阅者列表中</li>
<li>通过订阅者得到该订阅者的所有事件列表，再将事件添加到 <code>typeBySubscriber</code> 的所以事件列表中</li>
<li>是否是粘性事件</li>
<li>是的话进行分发，post此事件给当前订阅者，不是的话不管</li>
<li>结束本次循环，跳到 2</li>
</ol>
<h4 id="3-3-post"><a href="#3-3-post" class="headerlink" title="3.3 post"></a>3.3 post</h4><p>总的来说就是分析事件，得到所有监听该事件的订阅者的回调方法，并利用反射来invoke方法，实现回调。</p>
<p><img src="/gallery/EventBus/post.png" alt="发送流程"></p>
<ol>
<li>从 <code>currentPostingThreadState</code> 中得到当前线程的 <code>PostThreadState</code> 信息</li>
<li>将此事件添加到 <code>PostPostThreadState</code> 的事件队列中</li>
<li>判断是否再分发</li>
<li>不是的话，循环队列，是的话跳 7</li>
<li>判断是个需要继承关系</li>
<li>是的话，循环得到父类，不是的话跳 7</li>
<li>查找该事件的订阅者，循环订阅者</li>
<li>根据 <code>ThreadMoth</code> 发送事件</li>
<li>结束本次循环订阅者，跳 7</li>
<li>结束本次循环队列，跳 4</li>
</ol>
<p>在源代码中为了保证post执行不会出现死锁，等待和对同一订阅者发送相同的事件，增加了很多线程保护锁和标志位，值得我们每个开发者学习。</p>
<h4 id="3-4-unregister"><a href="#3-4-unregister" class="headerlink" title="3.4 unregister"></a>3.4 unregister</h4><p>注销就比较简单了，把在注册时往两个数据结构中添加的订阅者信息删除即可：</p>
<p><img src="/gallery/EventBus/unregister.png" alt="注销流程"></p>
<p>至此大家对EventBus的运行原理应该有了一定的了解，虽然看起来像是一个复杂耗时的自动机，但大部分时候事件都是一瞬间就能分发到位的，而大家关心的性能问题反而是发生在注册EventBus的时候，因为需要遍历监听者的所有方法去找到回调的方法。作者也提到运行时注解的性能在Android上并不理想，为了解决这个问题，作者才会以索引的方式去生成回调方法表，也就是在EventBus 3.0中引入了<strong>EventBusAnnotationProcessor</strong>（注解分析生成索引）技术，大大提高了EventBus的运行效率。关于索引技术的源码分析，大家可以参考腾讯Bugly的这边文章：<a href="https://segmentfault.com/a/1190000005089229" target="_blank" rel="external">老司机教你 “飙” EventBus 3</a> 。</p>
<h3 id="四、缺点与问题"><a href="#四、缺点与问题" class="headerlink" title="四、缺点与问题"></a>四、缺点与问题</h3><p>一直以来，EventBus被大家吐槽的一大问题就是代码混淆问题。</p>
<h4 id="4-1-混淆问题"><a href="#4-1-混淆问题" class="headerlink" title="4.1 混淆问题"></a>4.1 混淆问题</h4><p>混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。</p>
<p>首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报<code>java.lang.NoSuchFieldError: No static field POSTING</code>。网上给出的解决办法是keep住所有eventbus相关的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">de</span>.<span class="title">greenrobot</span>.** </span>&#123;*;&#125;</div></pre></td></tr></table></figure>
<p>其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-keep <span class="keyword">public</span> <span class="keyword">enum</span> org.greenrobot.eventbus.ThreadMode &#123; <span class="keyword">public</span> <span class="keyword">static</span> *; &#125;</div></pre></td></tr></table></figure>
<p>这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：<code>Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?</code></p>
<p>这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * </span>&#123;</div><div class="line">    <span class="meta">@de</span>.greenrobot.event.Subscribe &lt;methods&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。</p>
<h4 id="4-2-跨进程问题"><a href="#4-2-跨进程问题" class="headerlink" title="4.2 跨进程问题"></a>4.2 跨进程问题</h4><p>目前EventBus只支持跨线程，而<strong>不支持跨进程</strong>。如果一个app的service起到了另一个进程中，那么注册监听的模块则会收不到另一个进程的EventBus发出的事件。这里可以考虑利用IPC做映射表，并在两个进程中各维护一个EventBus，不过这样就要自己去维护register和unregister的关系，比较繁琐，而且这种情况下通常用广播会更加方便，大家可以思考一下有没有更优的解决方案。</p>
<h4 id="4-3-事件环路问题"><a href="#4-3-事件环路问题" class="headerlink" title="4.3 事件环路问题"></a>4.3 事件环路问题</h4><p>在使用EventBus时，通常我们会把两个模块相互监听，来达到一个相互回调通信的目的。但这样一旦出现死循环，而且如果没有相应的日志信息，很难定位问题。所以在使用EventBus的模块，如果在回调上有环路，而且回调方法复杂到了一定程度的话，就要考虑把接收事件专门封装成一个子模块，同时考虑避免出现事件环路。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><code>EventBus</code>不论从使用方式和实现方式上都是非常值得我们学习的开源项目，可以说是目前消息通知里最好用的项目。但是业内对<code>EventBus</code>的主要争论点是在于<code>EventBus</code>使用反射会出现性能问题，实际上在<code>EventBus</code>里我们可以看到不仅可以使用注解处理器预处理获取订阅信息，<code>EventBus</code>也会将订阅者的方法缓存到<code>METHOD_CACHE</code>里避免重复查找，所以只有在最后<code>invoke()</code>方法的时候会比直接调用多出一些性能损耗。</p>
<p>而且相比旧版的2.x，现在新版的EventBus 3.0，订阅者已经没有固定的处理事件的方法了，<code>onEvent</code>、<code>onEventMainThread</code>、<code>onEventBackgroundThread</code>、<code>onEventAsync</code>都没有了，现在支持处理事件的方法名自定义，但必须public，只有一个参数，然后使用注解<code>@Subscribe</code>来标记该方法为处理事件的方法，ThreadMode和priority也通过该注解来定义。在subscriberMethodFinder中，通过反射的方式寻找事件方法。使用注解，用起来才更爽。</p>
<p>当然，EventBus并不是重构代码的唯一之选。作为观察者模式的“同门师兄弟”——RxJava，作为功能更为强大的响应式编程框架，可以轻松实现EventBus的事件总线功能（<a href="http://www.jianshu.com/p/ca090f6e2fe2" target="_blank" rel="external">RxBus</a>）。但毕竟大型项目要接入RxJava的成本高，复杂的操作符需要开发者投入更多的时间去学习。所以想在成熟的项目中快速地重构、解耦模块，EventBus依旧是我们的不二之选。</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://androiddevblog.com/eventbus-3-droidcon/" target="_blank" rel="external">Markus Junginger - EventBus 3 beta announced at droidcon</a></li>
<li><a href="https://segmentfault.com/a/1190000005089229" target="_blank" rel="external">老司机教你 “飙” EventBus 3</a> -  <a href="https://segmentfault.com/u/tencentbugly" target="_blank" rel="external"><strong>腾讯Bugly</strong></a></li>
<li><a href="https://kymjs.com/code/2015/12/12/01/" target="_blank" rel="external">EventBus源码研读(上)</a>，<a href="https://www.kymjs.com/code/2015/12/13/01/" target="_blank" rel="external">(中)</a>，<a href="https://kymjs.com/code/2015/12/16/01/" target="_blank" rel="external">(下)</a> - kymjs张涛</li>
<li><a href="http://yydcdut.com/2016/03/07/eventbus3-code-analyse/" target="_blank" rel="external">EventBus3.0源码解析</a> - yydcdut</li>
<li><a href="http://skykai521.github.io/2016/02/20/EventBus-3-0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">EventBus 3.0 源代码分析</a> - Skykai</li>
<li><a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">EventBus 源码解析</a> - codeKK</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot;&gt;EventBus&lt;/a&gt;&lt;/strong&gt;是Android中一个基于&lt;strong&gt;观察者模式&lt;/strong&gt;的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，主要功能是替代Intent，Handler，BroadCast 在 Fragment，Activity，Service，线程Thread之间传递消息。优点是开销小，使用方便，可以很大程度上降低它们之间的耦合。 类似的库还有&lt;a href=&quot;https://github.com/square/otto&quot;&gt;Otto&lt;/a&gt; ，今天就带大家一起研读 EventBus 的源码。&lt;/p&gt;
&lt;p&gt;这是EventBus源码中的介绍：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * EventBus is a central publish/subscribe event system for Android. Events are posted (&amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; #post(Object)&amp;#125;) to the&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * subscribers must register themselves to the bus using &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; #register(Object)&amp;#125;. Once registered, subscribers&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * receive events until &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; #unregister(Object)&amp;#125; is called. Event handling methods must be annotated by&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; Subscribe&amp;#125;, must be public, return nothing (void), and have exactly one parameter&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * (the event).&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; Markus Junginger, greenrobot&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;EventBus 是Android上的以&lt;strong&gt;发布\订阅事件&lt;/strong&gt;为核心的库。事件 (&lt;code&gt;event&lt;/code&gt;) 通过 &lt;code&gt;post()&lt;/code&gt; 发送到总线，然后再分发到匹配事件类型的订阅者 (&lt;code&gt;subscribers&lt;/code&gt;) 。订阅者只有在总线中注册 (&lt;code&gt;register&lt;/code&gt;) 了才能收到事件，注销 (&lt;code&gt;unrigister&lt;/code&gt;) 之后就收不到任何事件了。事件方法必须带有 &lt;code&gt;Subscribe&lt;/code&gt; 的注解，必须是 &lt;code&gt;public&lt;/code&gt; ，没有返回类型 &lt;code&gt;void&lt;/code&gt; 并且只能有一个参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;EventBus3 与之前的相比，其主要差别在于订阅方法可以不再以&lt;code&gt;onEvent&lt;/code&gt; 开头了，改为用&lt;strong&gt;注解&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://github.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://github.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Java】try-catch-finally语句中return的执行顺序思考</title>
    <link href="http://github.com/2017/09/20/%E3%80%90Java%E3%80%91try-catch-finally%E8%AF%AD%E5%8F%A5%E4%B8%ADreturn%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%9D%E8%80%83/"/>
    <id>http://github.com/2017/09/20/【Java】try-catch-finally语句中return的执行顺序思考/</id>
    <published>2017-09-20T14:30:55.000Z</published>
    <updated>2017-09-21T08:35:01.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h3><p>对于try-catch-finally语句中return的执行顺序，我们都有知道，finally块中的内容会先于try中的return语句执行，如果finall语句块中也有return语句的话，那么直接从finally中返回了，这也是不建议在finally中return的原因。</p>
<p>下面通过实验来看这几种情况的执行顺序到底是什么。</p>
<h4 id="1、try中有return，finally中没有"><a href="#1、try中有return，finally中没有" class="headerlink" title="1、try中有return，finally中没有"></a><strong>1、try中有return，finally中没有</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"test()函数返回："</span> + test());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			System.out.println(<span class="string">"Try block executing: "</span> + ++i);</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">			System.out.println(<span class="string">"Catch Error executing: "</span> + ++i);</div><div class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">		&#125;<span class="keyword">finally</span> &#123;</div><div class="line">			System.out.println(<span class="string">"finally executing: "</span> + ++i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>结果如下：</p>
<blockquote>
<p>Try block executing: 1<br>finally executing: 2<br>test()函数返回：1</p>
</blockquote>
<p><strong>return的是对象时，看看在finally中改变对象属性，会不会影响try中的return结果。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchTest</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> vaule = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"test()函数返回："</span> + test().vaule);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TryCatchTest <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">		TryCatchTest t = <span class="keyword">new</span> TryCatchTest();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			t.vaule = <span class="number">1</span>;</div><div class="line">			System.out.println(<span class="string">"Try block executing: "</span> + t.vaule);</div><div class="line">			<span class="keyword">return</span> t;</div><div class="line">		&#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">			t.vaule = -<span class="number">1</span>;</div><div class="line">			System.out.println(<span class="string">"Catch Error executing: "</span> + t.vaule);</div><div class="line">			<span class="keyword">return</span> t;</div><div class="line">		&#125;<span class="keyword">finally</span> &#123;</div><div class="line">			t.vaule = <span class="number">3</span>;</div><div class="line">			System.out.println(<span class="string">"finally executing: "</span> + t.vaule);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Try block executing: 1<br>finally executing: 3<br>test()函数返回：3</p>
</blockquote>
<h4 id="2、try和finally中均有return"><a href="#2、try和finally中均有return" class="headerlink" title="2、try和finally中均有return"></a><strong>2、try和finally中均有return</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		System.out.println(<span class="string">"Try block executing: "</span> + ++i);</div><div class="line">		<span class="keyword">return</span> i;</div><div class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">		System.out.println(<span class="string">"Catch Error executing: "</span> + ++i);</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	&#125;<span class="keyword">finally</span> &#123;</div><div class="line">		System.out.println(<span class="string">"finally executing: "</span> + ++i);</div><div class="line">		<span class="keyword">return</span> i;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<p>Try block executing: 1<br>finally executing: 2<br>test()函数返回：2</p>
</blockquote>
<h4 id="3、catch和finally中均有return"><a href="#3、catch和finally中均有return" class="headerlink" title="3、catch和finally中均有return"></a><strong>3、catch和finally中均有return</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		System.out.println(<span class="string">"Try block executing: "</span> + ++i);</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">		System.out.println(<span class="string">"Catch Error executing: "</span> + ++i);</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	&#125;<span class="keyword">finally</span> &#123;</div><div class="line">		System.out.println(<span class="string">"finally executing: "</span> + ++i);</div><div class="line">		<span class="keyword">return</span> i;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Try block executing: 1<br>Catch Error executing: 2<br>finally executing: 3<br>test()函数返回：3</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>1、不管有没有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的<strong>表达式运算</strong>之后执行的；</p>
<p>对于含有return语句的情况，这里我们可以简单地总结如下：</p>
<blockquote>
<p>try语句在返回前，将其他所有的操作执行完，保留好要返回的值，而后转入执行finally中的语句，而后分为以下三种情况：</p>
</blockquote>
<ul>
<li><p><strong>情况一</strong>：如果finally中有return语句，则会将try中的return语句“覆盖”掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。</p>
</li>
<li><p><strong>情况二</strong>：如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后，会接着执行try中的return语句，返回之前保留的值。</p>
</li>
<li><p><strong>情况三</strong>：如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：</p>
<ul>
<li>1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。</li>
<li>2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/kavensu/article/details/8067850" target="_blank" rel="external">有return的情况下try catch finally的执行顺序（最有说服力的总结）</a></li>
<li><a href="http://blog.csdn.net/ns_code/article/details/17485221" target="_blank" rel="external"> Java中try catch finally语句中含有return语句的执行情况（总结版）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实验&quot;&gt;&lt;a href=&quot;#实验&quot; class=&quot;headerlink&quot; title=&quot;实验&quot;&gt;&lt;/a&gt;&lt;strong&gt;实验&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;对于try-catch-finally语句中return的执行顺序，我们都有知道，finally块中的内容会先于try中的return语句执行，如果finall语句块中也有return语句的话，那么直接从finally中返回了，这也是不建议在finally中return的原因。&lt;/p&gt;
&lt;p&gt;下面通过实验来看这几种情况的执行顺序到底是什么。&lt;/p&gt;
&lt;h4 id=&quot;1、try中有return，finally中没有&quot;&gt;&lt;a href=&quot;#1、try中有return，finally中没有&quot; class=&quot;headerlink&quot; title=&quot;1、try中有return，finally中没有&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、try中有return，finally中没有&lt;/strong&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TryCatchTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;test()函数返回：&quot;&lt;/span&gt; + test());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Try block executing: &quot;&lt;/span&gt; + ++i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Catch Error executing: &quot;&lt;/span&gt; + ++i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;finally executing: &quot;&lt;/span&gt; + ++i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【算法】从多项式乘法到快速傅里叶变换</title>
    <link href="http://github.com/2017/09/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BB%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95%E5%88%B0%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://github.com/2017/09/08/【算法】从多项式乘法到快速傅里叶变换/</id>
    <published>2017-09-08T04:20:55.000Z</published>
    <updated>2017-10-23T04:01:18.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来自： <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform" target="_blank" rel="external">从多项式乘法到快速傅里叶变换</a> — <a href="http://blog.miskcoo.com/about" target="_blank" rel="external">miskcoo</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算多项式的乘法，或者计算两个大整数的乘法是在计算机中很常见的运算，如果用普通的方法进行，复杂度将会是$ \mathcal O(n^2) ​$的，还有一种分治乘法，可以做到 $\mathcal O(n^{\log_23}) ​$时间计算（可以看<a href="http://blog.miskcoo.com/2014/10/karatsuba-multiplication" target="_blank" rel="external">Karatsuba 乘法</a>）。下面从计算多项式的乘法出发，介绍<strong>快速傅里叶变换（Fast Fourier Transform, FFT）</strong>如何在 $\mathcal O(n\log n) ​$的时间内计算出两个多项式的乘积。</p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><p>这里介绍一些后面可能会用到的知识（主要是关于多项式、卷积以及复数的），如果你已经知道觉得它太水了或者想用到的时候再看就跳过吧。</p>
<h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>简单来说，形如 $ a_0+a_1X+a_2X^2+\cdots+a_nX^n $ 的代数表达式叫做<strong>多项式</strong>，可以记作$P(X)=a_0+a_1X+a_2X^2+\cdots+a_nX^n$，$a_0, a_1, \cdots, a_n $叫做多项式的<strong>系数</strong>，$X $是一个不定元，不表示任何值，不定元在多项式中最大项的次数称作多项式的<strong>次数</strong></p>
<h3 id="多项式的系数表示法"><a href="#多项式的系数表示法" class="headerlink" title="多项式的系数表示法"></a>多项式的系数表示法</h3><p>像刚刚我们提到的那些多项式，都是以系数形式表示的，也就是将 n 次多项式$ A(x) $的系数 $a_0, a_1, \cdots, a_n $看作 $n+1 $维向量$ \vec a=(a_0,a_1,\cdots,a_n)$，其<strong>系数表示（coefficient representation）</strong>就是向量$ \vec a$ 。</p>
<a id="more"></a>
<h3 id="多项式的点值表示法"><a href="#多项式的点值表示法" class="headerlink" title="多项式的点值表示法"></a>多项式的点值表示法</h3><p>如果选取$ n+1 $个不同的数 $x_0, x_1, \cdots, x_n $对多项式进行求值，得到$ A(x_0), A(x_1), \cdots, A(x_n)$，那么就称$ {\left(x_i, A(x_i)\right) : 0 \leq i \leq n, i \in \mathbb Z} $为多项式$ A(x)$ 的<strong>点值表示（point-value representation）</strong></p>
<p>多项式$ A(x) $的点值表示不止一种，你只要选取不同的数就可以得到不同的点值表示，但是任何一种点值表示都能唯一确定一个多项式，为了从点值表示转换成系数表示，可以直接通过<strong>插值</strong>的方法</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>后面提到的$ i$，除非作为$ \sum $求和的变量，其余的都表示虚数单位 $\sqrt{-1}$</p>
<h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><p>$n $次单位根是指能够满足方程$ z^n=1 $的复数，这些复数一共有$ n $个它们都分布在复平面的单位圆上，并且构成一个正 $n $边形，它们把单位圆等分成$ n $个部分</p>
<p>根据复数乘法相当于模长相乘，幅角相加就可以知道，$n $次单位根的模长一定是$ 1$，幅角的$ n $倍是$ 0$<br>这样，$n$ 次单位根也就是</p>
<p>$$ e^{\frac{2\pi ki}{n}}, k = 0, 1, 2, \cdots, n - 1 $$<br>再根据欧拉公式</p>
<p>$$ e^{\theta i}=\cos\theta + i\sin\theta $$<br>就可以知道 n 次单位根的算术表示</p>
<p>如果记$ \omega_n=e^{\frac{2\pi i}{n}}$，那么$ n $次单位根就是 $\omega_n^0, \omega_n^1, \cdots, \omega_n^{n-1}$</p>
<h2 id="多项式的乘法"><a href="#多项式的乘法" class="headerlink" title="多项式的乘法"></a>多项式的乘法</h2><p>给定两个多项式$ A(x), B(x)$<br>
$$
A(x) = \sum_{i=0}^na_ix^i = a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0 \\ B(x) = \sum_{i=0}^nb_ix^i = b_nx^n+b_{n-1}x^{n-1}+\cdots+b_1x+b_0 
$$
<br>将这两个多项式相乘得到$ C(x) = \sum_{i=0}^{2n}c_ix^i$，在这里</p>

$$
c_i=\sum_{j+k=i,0\leq j,k\leq n}a_jb_kx^i 
$$

<p>如果一个个去算$ c_i $的话，要花费$ \mathcal O(n^2) $的时间才可以完成，但是，这是在系数表示下计算的，如果转换成点值表示，知道了$ A(x), B(x) $的点值表示后，由于只有$ n+1$ 个点，就可以直接将其相乘，在 $\mathcal O(n) $的时间内得到$ C(x)$ 的点值表示</p>
<p>如果能够找到一种有效的方法帮助我们在多项式的点值表示和系数表示之间转换，我们就可以快速地计算多项式的乘法了，快速傅里叶变换就可以做到这一点</p>
<h2 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h2><p>快速傅里叶变换你可以认为有两个部分，DFT 和 IDFT，分别可以在$ \mathcal O(n\log n) $的时间内将多项式的系数表示转化成点值表示，并且转回来，就像下面这张图所示：</p>
<p><img src="/gallery/fft/polynomial-multiplication.png" alt=""></p>
<h3 id="Cooley-Tukey算法"><a href="#Cooley-Tukey算法" class="headerlink" title="Cooley-Tukey算法"></a>Cooley-Tukey算法</h3><p>FFT 最常见的算法是 Cooley-Tukey 算法，它的基本思路在 1965 年由 J. W. Cooley 和 J. W. Tukey 提出的，它是一个基于分治策略的算法</p>
<p>假设现在有一个$ n-1 $次多项式$ A(x)=\sum_{i=0}^{n-1}a_ix^i$（为了方便，假设$ n=2^m, m\in \mathbb Z$，如果不足可以在高次项系数补成 0）</p>
<p>将$ n $个$ n $次单位根$ \omega_n^0, \omega_n^1, \cdots, \omega_n^{n-1}$ 带入$ A(x) $将其转换成点值表达</p>

$$
A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega^{ki} , k = 0, 1, \cdots, n - 1 
$$

<p>点值向量 $ \vec y=(A(\omega_n^0), A(\omega_n^1), \cdots, A(\omega_n^{n-1})) $ 称作系数向量$ \vec a=(a_0, a_1, \cdots, a_{n-1}) $的<strong>离散傅里叶变换</strong>（Discrete Fourier Transform, DFT），也记作$ \vec y=DFT_n(\vec a) $</p>
<p>到此为止，直接计算$ DFT_n(\vec a) $还是需要$ \mathcal O(n^2) $的时间，Cooley-Tukey 算法接下来做的事情是将每一项按照指数奇偶分类</p>

$$
\begin{eqnarray*} A(\omega_n^k) &=& \sum_{i=0}^{n-1}a_i\omega_n^{ki} \\ &=& \sum_{i=0}^{\frac{n}{2}-1}a_{2i}\omega_n^{2ki}+\omega_n^k\sum_{i=0}^{\frac{n}{2}-1}a_{2i+1}\omega_n^{2ki} \\ \end{eqnarray*} 
$$

<p>但是，如果直接这样递归下去，你需要带入的值还是有$ n $个，也就是说，现在只是将系数减半，而没有将需要带入的值减半，上面的$ k $还是$ 0, 1, \cdots, n - 1$，这样的话复杂度还是$ \mathcal O(n^2)$</p>
<p>但是你会注意到，根据准备知识中$ \omega_n^2=\left(e^{\frac{2\pi i}{n}}\right)^2=e^{\frac{2\pi i}{n/2}}=\omega_{\frac{n}{2}}$ ，并且$ \frac{n}{2} $次单位根只有$ \frac{n}{2} $个，也就是说，我们要带入的值再平方以后似乎变少了一半？仔细想想就会发现，既然单位根把单位圆等分，那么肯定会对称，也就是有一个正的，就会有一个负的，平方后这两个当然就相同了。严格一点的证明就是</p>

$$
\omega_n^{\frac{n}{2}+k} = \omega_n^{\frac{n}{2}}\cdot \omega_n^k = -\omega_n^k 
$$

<p>这也就是说，对于$ k &lt; \frac{n}{2}$ 的时候</p>

$$
A(\omega_n^k) = \sum_{i=0}^{\frac{n}{2}-1}a_{2i}\omega_{\frac{n}{2}}^{ki}+\omega_n^{k}\sum_{i=0}^{\frac{n}{2}-1}a_{2i+1}\omega_{\frac{n}{2}}^{ki} 
$$

<p>并且</p>

$$
\begin{eqnarray*} A(\omega_n^{k+\frac{n}{2}}) &=& \sum_{i=0}^{\frac{n}{2}-1}a_{2i}\omega_{\frac{n}{2}}^{ki}+\omega_n^{k+\frac{n}{2}}\sum_{i=0}^{\frac{n}{2}-1}a_{2i+1}\omega_{\frac{n}{2}}^{ki} \\ &=&\sum_{i=0}^{\frac{n}{2}-1}a_{2i}\omega_{\frac{n}{2}}^{ki}-\omega_n^k\sum_{i=0}^{\frac{n}{2}-1}a_{2i+1}\omega_{\frac{n}{2}}^{ki} \end{eqnarray*} 
$$

<p>这样我们就将需要带入的值也减少成了 $ 1, \omega_{\frac{n}{2}}, \omega_{\frac{n}{2}}^2, \cdots, \omega_{\frac{n}{2}}^{\frac{n}{2}-1} $，问题变成了两个规模减半的子问题，只要递归下去计算就可以了，至于复杂度</p>

$$
T(n) = 2T(\frac{n}{2})+\mathcal O(n) = \mathcal O(n\log n) 
$$

<h3 id="傅里叶逆变换（IDFT）"><a href="#傅里叶逆变换（IDFT）" class="headerlink" title="傅里叶逆变换（IDFT）"></a>傅里叶逆变换（IDFT）</h3><p>刚刚计算的是$ \vec y = DFT_n(\vec a)$，可以将多项式转化成点值表示，现在为了将点值表示转化成系数表示，需要计算 IDFT（Inverse Discrete Fourier Transform），它是 DFT 的逆</p>
<p>这个问题实际上相当于是一个解线性方程组的问题，也就是给出了$ n $个线性方程</p>

$$
\begin{equation*} \left\{ \begin{array}{ccccccccc} a_0(\omega_n^0)^{0}&+&\cdots&+&a_{n-2}(\omega_n^0)^{n-2}&+&+a_{n-1}(\omega_n^0)^{n-1}&=&A(\omega_n^0) \\ a_0(\omega_n^1)^{0}&+&\cdots&+&a_{n-2}(\omega_n^1)^{n-2}&+&+a_{n-1}(\omega_n^1)^{n-1}&=&A(\omega_n^1) \\ \vdots & & \vdots & &\vdots& & \vdots & & \vdots\\ a_0(\omega_n^{n-1})^{0}&+&\cdots&+&a_{n-2}(\omega_n^{n-1})^{n-2}&+&+a_{n-1}(\omega_n^{n-1})^{n-1}&=&A(\omega_n^{n-1}) \end{array} \right. \end{equation*}
$$

<p>写成矩阵方程的形式就是</p>

$$
\begin{equation} \label{IDFT-equation} \begin{bmatrix} (\omega_n^0)^0 & (\omega_n^0)^1 & \cdots & (\omega_n^0)^{n-1} \\ (\omega_n^1)^0 & (\omega_n^1)^1 & \cdots & (\omega_n^1)^{n-1} \\ \vdots & \vdots & \ddots & \vdots \\ (\omega_n^{n-1})^0 & (\omega_n^{n-1})^1 & \cdots & (\omega_n^{n-1})^{n-1} \end{bmatrix} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}
$$

<p>记上面的系数矩阵为$ \mathbf V$ 现在考虑下面这个矩阵$ d_{ij}=\omega_n^{-ij}$</p>

$$
\begin{equation*} \mathbf D = \begin{bmatrix} (\omega_n^{-0})^0 & (\omega_n^{-0})^1 & \cdots & (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 & (\omega_n^{-1})^1 & \cdots & (\omega_n^{-1})^{n-1} \\ \vdots & \vdots & \ddots & \vdots \\ (\omega_n^{-(n-1)})^0 & (\omega_n^{-(n-1)})^1 & \cdots & (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \end{equation*}
$$

<p>设它们相乘后的结果是$ \mathbf E=\mathbf D \cdot \mathbf V$</p>

$$
\begin{eqnarray*} e_{ij} &=& \sum_{k=0}^{n-1} d_{ik} v_{kj} \\ &=& \sum_{k=0}^{n-1} \omega_n^{-ik}\omega_n^{kj} \\ &=& \sum_{k=0}^{n-1} \omega_n^{k(j-i)} \end{eqnarray*}
$$

<p>当$ i=j $时，$e_{ij}=n$</p>
<p>当$ i\neq j $时，</p>

$$
\begin{eqnarray*} e_{ij} &=& \sum_{k=0}^{n-1} (\omega_n^{j-i})^k \\ &=& \frac{1-(\omega_n^{j-i})^n}{1-\omega_n^{j-i}}\\ &=& 0 \end{eqnarray*}
$$

<p>因此可以知道$ \mathbf I_n=\frac{1}{n}\mathbf E$，所以$ \frac{1}{n}\mathbf D = \mathbf V^{-1}$</p>
<p>将$ \frac{1}{n}\mathbf D $在$ \ref{IDFT-equation} $ 左乘就会得到</p>

$$
\begin{equation*} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \frac{1}{n} \begin{bmatrix} (\omega_n^{-0})^0 & (\omega_n^{-0})^1 & \cdots & (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 & (\omega_n^{-1})^1 & \cdots & (\omega_n^{-1})^{n-1} \\ \vdots & \vdots & \ddots & \vdots \\ (\omega_n^{-(n-1)})^0 & (\omega_n^{-(n-1)})^1 & \cdots & (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation*}
$$

<p>这样，IDFT 就相当于把 DFT 过程中的$ \omega_n^i $换成$ \omega_n^{-i}$，然后做一次 DFT，之后结果除以$ n$ 就可以了。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>根据前面的说明，递归实现的 FFT 应该不是什么大问题，下面就直接给出 C++ 代码了（主意 n要补齐到 $2^m$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;* buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> step, <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;* epsilon)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line">	<span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>;</div><div class="line">	fft(m, buffer, offset, step &lt;&lt; <span class="number">1</span>, epsilon);</div><div class="line">	fft(m, buffer, offset + step, step &lt;&lt; <span class="number">1</span>, epsilon);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != m; ++k)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> pos = <span class="number">2</span> * step * k;</div><div class="line">		temp[k] = buffer[pos + offset] + epsilon[k * step] * buffer[pos + offset + step];</div><div class="line">		temp[k + m] = buffer[pos + offset] - epsilon[k * step] * buffer[pos + offset + step];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</div><div class="line">		buffer[i * step + offset] = temp[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 <code>epsilon</code>是事先打好了的$ \omega_n $的表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_epsilon</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	<span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</div><div class="line">	&#123;</div><div class="line">		epsilon[i] = <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(<span class="number">2.0</span> * pi * i / n), <span class="built_in">sin</span>(<span class="number">2.0</span> * pi * i / n)); </div><div class="line">		arti_epsilon[i] = conj(epsilon[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>假设现在有$ 16 $个数要进行$DFT $来看看递归的过程</p>
<p><img src="/gallery/fft/bit-reverse.png" alt=""></p>
<p>在 Step1 -&gt; Step2 的过程中，按照奇偶分类，二进制位中最后一位相同的被分到同一组</p>
<p>在 Step2 -&gt; Step3 的过程中，仍然按照奇偶，只不过不是按照数字的奇偶性，而是下标的奇偶性，二进制位中最后两位相同的才被分到同一组</p>
<p>在 Step3 -&gt; Step4 的过程中，二进制位中最后三位相同的数字被分在同一组</p>
<p>现在将整个二进制位反转，例如 0010 就变成 0100，这时候每次在同一组的数字，反转后的二进制位前几位都是相同的，这似乎十分类似加法，相邻两组二进制位反转之后数字会是连续的一段区间。例如在 Step3 中，1、5、9、13 这一组，反转二进制后是 1(1000)、5(1010)、9(1001)、13(1011)，分组后是 1(1000)、9(1001) 和 5(1010)、13(1011)</p>
<p>假设<code>reverse(i)</code>是将二进制位反转的操作，DFT 最后一步的数组是 B，原来的数组是 A，那么 A 和 B 之间有这样的关系<code>B[reverse(i)]=A[i]</code>，也就是说， <code>B[i + 1]=A[reverse(reverse(i)+ 1)]</code>，B 中第 i 项的下一项就是将 i 反转后加 1 再反转回来 A 中的那一项，所以现在要模拟的就是从高位开始的二进制加法</p>
<p>考虑正向二进制加法的过程，相当于从最低位开始，找到第一个 0，然后把这个 0 改成 1，之前的 1 全部变成 0。那么反向二进制加法就是从最高位开始，找到第一个 0，然后把这个 0 改成 1，前面的 1 全部改成 0，所以就是这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse_add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span> &lt;&lt; bit_length; (x ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了从原来的 A 数组，得到最后一步所需要的 B 数组，只要维护两个变量，一个是当前下标 i，一个是反向加的下标 j，表示 B[i] 应该放 A[j] 放的东西，如果 i &gt; j，只要将 i 和 j 存的东西交换，这样最后就可以得到所需要的 B 数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* 这时候 n 已经补齐到 2 的幂次 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bit_reverse</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">complex_t</span> *x)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != n; ++i)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(i &gt; j) swap(x[i], x[j]);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l = n &gt;&gt; <span class="number">1</span>; (j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在已经把要变换的元素排在相邻位置了，所以从下往上 $2 $开始到 $2^m $来进行计算，每次枚举一块往上迭代即可！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">complex_t</span> *x, <span class="keyword">complex_t</span> *w)</span> </span>&#123;</div><div class="line">	bit_reverse(n, x);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> m = i &gt;&gt; <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += i)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != m; ++k)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">complex_t</span> z = x[j + m + k] * w[n / i * k];</div><div class="line">				x[j + m + k] = x[j + k] - z;</div><div class="line">				x[j + k] += z;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h2><p>由于 FFT 涉及到复数运算，难免有精度问题，在计算一些只要求整数的卷积或高精度乘法的时候就有可能由于精度出现错误，这便让我们考虑是否有在模意义下的方法，这就是<strong>快速数论变换</strong>（Fast Number-Theoretic Transform，FNT）</p>
<p>首先来看 FFT 中能在$ \mathcal O(n\log n) $时间内变换用到了单位根 $\omega $的什么性质</p>
<ol>
<li><p>$\omega_n^n=1$</p>
</li>
<li><p>$\omega_n^0, \omega_n^1, \cdots, \omega_n^{n-1} $是互不相同的，这样带入计算出来的点值才可以用来还原出系数</p>
</li>
<li><p>$ \omega_n^2=\omega_{\frac{n}{2}}, \omega_n^{\frac{n}{2}+k}=-\omega_n^k $ ，这使得在按照指数奇偶分类之后能够把带入的值也减半使得问题规模能够减半</p>
</li>
<li>$$ \sum_{k=0}^{n-1} (\omega_n^{j-i})^k = \begin{eqnarray*} \left\{ \begin{aligned}0, ~~~&i \neq j\\ n, ~~~&i = j \end{aligned} \right. \end{eqnarray*} $$ 
<p>​</p>
<p>这点保证了能够使用相同的方法进行逆变换得到系数表示</p>
</li>
</ol>
<h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>现在我们要在数论中寻找满足这三个性质的数，首先来介绍原根的概念，根据费马定理我们知道，对于一个素数$ p$，有下面这样的关系</p>

$$
a^{p-1} \equiv 1 \pmod p 
$$

<p>这一点和单位根 $\omega$ 十分相似，$p$ 的<strong>原根</strong> $g $定义为使得 $g^0, g^1, \cdots, g^{p-2} \pmod p $互不相同的数</p>
<p>如果我们取素数$ p = k\cdot 2^n + 1$，并且找到它的原根$ g$，然后我们令$ g_n\equiv g^k\pmod p$，这样就可以使得$ g_n^0, g_n^1, \cdots, g_n^{n-1} \pmod p $互不相同，并且$ g_n^n\equiv 1\pmod p$，这便满足了性质一和性质二</p>
<p>由于$ p $是素数，并且$ g_n^n \equiv 1 \mod p$，这样 $g_n^\frac{n}{2} \bmod p $必然是$ -1 $或 $1$，再根据$ g^k $互不相同这个特点，所以$ g_n^\frac{n}{2} \equiv -1 \pmod p$，满足性质三</p>
<p>对于性质四，和前面一样也可以验证是满足的，因此再 FNT 中，我们可以用原根替代单位根，<a href="http://blog.miskcoo.com/2014/07/fft-prime-table" target="_blank" rel="external">这里</a>已经有了一些数$ p $及其原根，可以满足大部分需求</p>
<h3 id="模数任意的解决方案"><a href="#模数任意的解决方案" class="headerlink" title="模数任意的解决方案"></a>模数任意的解决方案</h3><p>前面说了，要进行快速数论变换需要模数是 $a\cdot 2^k + 1 $形式的素数，但是在实际应用中，要求的模数可能不是这样的形式，甚至是一个合数！</p>
<p>假设现在需要模 $m$，并且进行变换的长度是$ n$</p>
<p>那么这样任何多项式系数的范围是$ [0, m)$，两个相乘，不会超过$ (m - 1)^2$，一共 $n $项相加，不会超过 $n(m-1)^2$</p>
<p>这样的话，选取$ k $个有上面形式的素数$ p_1, p_2, \cdots, p_k$，要求满足</p>

$$
\prod_{i=1}^k p_k > n(m-1)^2 
$$

<p>然后分别在$ \bmod k $的剩余系下做变换，最后使用<a href="http://blog.miskcoo.com/2014/09/chinese-remainder-theorem" target="_blank" rel="external">中国剩余定理</a>合并（当然这时候或许是需要高精度或者<code>__int128</code> 的）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>FNT 的代码实现和 FFT 是一样的，只要把复数运算换成在 $\bmod p$ 剩余系下的运算即可</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="快速卷积"><a href="#快速卷积" class="headerlink" title="快速卷积"></a>快速卷积</h3><p>现有两个定义在$ \mathbb N $上的函数$ f(n), g(n)$，定义$ f $和 $g $的<strong>卷积</strong>（convolution）为 $f \otimes g$</p>

$$
(f \otimes g)(n) = \sum_{i=0}^n f(i)g(n-i) 
$$

<p><img src="/gallery/fft/convolution.png" alt=""></p>
<p>就像上面的图一样，注意到卷积的形式和多项式乘法的形式是相同的，也就是两个多项式$ A(x), B(x)$，令$ C(x) = A(x)B(x)$，那么会有$ c_i=(a \otimes b)(i)$，因此可以用 FFT 来计算卷积</p>
<p>对于要计算某些形如  $h(k) = \sum_{i=0}^n f(i)g(i+k) $ 的问题，可以令$ f’(x) = f(n-x)$，这样问题就变成计算$ \sum_{i=0}^n f’(n-i)g(i+k)$，也就是一个卷积的形式</p>
<h4 id="例1：-ZJOI2014-力"><a href="#例1：-ZJOI2014-力" class="headerlink" title="例1：[ZJOI2014]力"></a>例1：<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3527" target="_blank" rel="external">[ZJOI2014]力</a></h4><p>题目给出$ n $个数$ q_1, q_2, \cdots, q_n$，要求计算</p>

$$
F_i = \sum_{j=1}^{i-1}\frac{q_iq_j}{(j-i)^i}-\sum_{j=i+1}^{n}\frac{q_iq_j}{(j-i)^i} 
$$

<p>观察一下，假设有四个数$ q_1, q_2, q_3, q_4$，那么</p>

$$
\begin{eqnarray*} \frac{F_1}{q_1} &=& -\frac{q_2}{1^2}-\frac{q_3}{2^2}-\frac{q_4}{3^2} \\ 
\frac{F_2}{q_2} &=& +\frac{q_1}{1^2}-\frac{q_3}{1^2}-\frac{q_4}{2^2} \\ 
\frac{F_3}{q_3} &=& +\frac{q_1}{2^2}+\frac{q_2}{1^2}-\frac{q_4}{1^2} \\ 
\frac{F_4}{q_4} &=& +\frac{q_1}{3^2}+\frac{q_2}{2^2}+\frac{q_3}{1^2} \\ 
\end{eqnarray*} 
$$

<p>初看之下似乎没什么规律，但是这之中出现的几个数列出来</p>
<table>
<thead>
<tr>
<th>q_1</th>
<th>q_2</th>
<th>q_3</th>
<th>q_4</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>$-\frac{1}{3^2}$</td>
<td>$-\frac{1}{2^2}$</td>
<td>$-\frac{1}{1^2}$</td>
<td>$0$</td>
<td>$\frac{1}{1^2}$</td>
<td>$\frac{1}{2^2}$</td>
<td>$\frac{1}{3^2}$</td>
</tr>
</tbody>
</table>
<p>列出来之后你看看每个 $\frac{F_i}{q_i} $的计算，就会发现刚好是像上面那张图一样的顺序相乘再相加，是个卷积的形式！因此最后只需要用 FFT 优化计算卷积，就可以解决此问题，不过要注意精度问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxL = <span class="number">18</span>, MaxN = <span class="number">1</span> &lt;&lt; MaxL;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="keyword">complex_t</span>;</div><div class="line"><span class="keyword">complex_t</span> f[MaxN], g[MaxN];</div><div class="line"><span class="keyword">complex_t</span> eps[MaxN], inv_eps[MaxN];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_eps</span><span class="params">(<span class="keyword">int</span> p)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</div><div class="line">	<span class="keyword">double</span> angle = <span class="number">2.0</span> * pi / p;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != p; ++i)</div><div class="line">		eps[i] = <span class="keyword">complex_t</span>(<span class="built_in">cos</span>(<span class="number">2.0</span> * pi * i / p), <span class="built_in">sin</span>(<span class="number">2.0</span> * pi * i / p));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != p; ++i)</div><div class="line">		inv_eps[i] = conj(eps[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">complex_t</span> *x, <span class="keyword">complex_t</span> *w)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != n; ++i)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(i &gt; j) <span class="built_in">std</span>::swap(x[i], x[j]);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l = n &gt;&gt; <span class="number">1</span>; (j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> m = i &gt;&gt; <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += i)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != m; ++k)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">complex_t</span> z = x[j + m + k] * w[n / i * k];</div><div class="line">				x[j + m + k] = x[j + k] - z;</div><div class="line">				x[j + k] += z;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, p = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(p &lt; n) ++l, p &lt;&lt;= <span class="number">1</span>;</div><div class="line">	++l, p &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != p; ++i)</div><div class="line">		f[i] = g[i] = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">double</span> x;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;x);</div><div class="line">		f[i] = x;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; ++i)</div><div class="line">	&#123;</div><div class="line">		g[i] = <span class="number">1.0</span> / ((n - i - <span class="number">1.0</span>) * (n - i - <span class="number">1.0</span>));</div><div class="line">		g[<span class="number">2</span> * n - i - <span class="number">2</span>] = -g[i];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	init_eps(p);</div><div class="line">	<span class="built_in">std</span>::reverse(g, g + p);</div><div class="line"></div><div class="line">	transform(p, f, eps);</div><div class="line">	transform(p, g, eps);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != p; ++i)</div><div class="line">		f[i] *= g[i];</div><div class="line">	transform(p, f, inv_eps);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = p - n; i != p; ++i)</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, f[i].real() / p);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="生成函数运算"><a href="#生成函数运算" class="headerlink" title="生成函数运算"></a>生成函数运算</h3><p>对于一些需要用到生成函数的计数问题，在列出生成函数之后有可能需要将其平方、求对数、求逆元或者开方，这时便可以用 FFT 来加速计算</p>
<h4 id="例2：-BZOJ3771-Triple"><a href="#例2：-BZOJ3771-Triple" class="headerlink" title="例2：[BZOJ3771]Triple"></a>例2：<a href="http://blog.miskcoo.com/2015/04/bzoj-3771" target="_blank" rel="external">[BZOJ3771]Triple</a></h4><p>这个问题就是用 FFT 加速多项式乘法的过程，具体可以看上面这篇题解</p>
<h3 id="多项式求逆、除法、取模"><a href="#多项式求逆、除法、取模" class="headerlink" title="多项式求逆、除法、取模"></a>多项式求逆、除法、取模</h3><p>关于多项式的求逆元，可以看<a href="http://blog.miskcoo.com/2015/05/polynomial-inverse" target="_blank" rel="external">这里</a></p>
<p>关于多项式的除法和求模，可以看<a href="http://blog.miskcoo.com/2015/05/polynomial-division" target="_blank" rel="external">这里</a></p>
<h3 id="多项式多点求值和快速插值"><a href="#多项式多点求值和快速插值" class="headerlink" title="多项式多点求值和快速插值"></a>多项式多点求值和快速插值</h3><p>关于多项式的多点求值和快速插值，可以看<a href="http://blog.miskcoo.com/2015/05/polynomial-multipoint-eval-and-interpolation" target="_blank" rel="external">这里</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts:"></a>Related Posts:</h2><ol>
<li><a href="http://blog.miskcoo.com/2014/07/fft-prime-table" target="_blank" rel="external">FFT用到的各种素数</a></li>
<li><a href="http://blog.miskcoo.com/2015/05/polynomial-inverse" target="_blank" rel="external">多项式求逆元</a></li>
<li><a href="http://blog.miskcoo.com/2015/05/polynomial-multipoint-eval-and-interpolation" target="_blank" rel="external">多项式的多点求值与快速插值</a></li>
<li><a href="http://blog.miskcoo.com/2015/06/polynomial-with-newton-method" target="_blank" rel="external">牛顿迭代法在多项式运算的应用</a></li>
<li><a href="http://blog.miskcoo.com/2015/08/special-polynomial-linear-interpolation" target="_blank" rel="external">特殊多项式在整点上的线性插值方法</a></li>
<li><a href="http://blog.miskcoo.com/2014/10/karatsuba-multiplication" target="_blank" rel="external">Karatsuba 乘法</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自： &lt;a href=&quot;http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform&quot;&gt;从多项式乘法到快速傅里叶变换&lt;/a&gt; — &lt;a href=&quot;http://blog.miskcoo.com/about&quot;&gt;miskcoo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;计算多项式的乘法，或者计算两个大整数的乘法是在计算机中很常见的运算，如果用普通的方法进行，复杂度将会是$ \mathcal O(n^2) ​$的，还有一种分治乘法，可以做到 $\mathcal O(n^{\log_23}) ​$时间计算（可以看&lt;a href=&quot;http://blog.miskcoo.com/2014/10/karatsuba-multiplication&quot;&gt;Karatsuba 乘法&lt;/a&gt;）。下面从计算多项式的乘法出发，介绍&lt;strong&gt;快速傅里叶变换（Fast Fourier Transform, FFT）&lt;/strong&gt;如何在 $\mathcal O(n\log n) ​$的时间内计算出两个多项式的乘积。&lt;/p&gt;
&lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;p&gt;这里介绍一些后面可能会用到的知识（主要是关于多项式、卷积以及复数的），如果你已经知道觉得它太水了或者想用到的时候再看就跳过吧。&lt;/p&gt;
&lt;h2 id=&quot;多项式&quot;&gt;&lt;a href=&quot;#多项式&quot; class=&quot;headerlink&quot; title=&quot;多项式&quot;&gt;&lt;/a&gt;多项式&lt;/h2&gt;&lt;p&gt;简单来说，形如 $ a_0+a_1X+a_2X^2+\cdots+a_nX^n $ 的代数表达式叫做&lt;strong&gt;多项式&lt;/strong&gt;，可以记作$P(X)=a_0+a_1X+a_2X^2+\cdots+a_nX^n$，$a_0, a_1, \cdots, a_n $叫做多项式的&lt;strong&gt;系数&lt;/strong&gt;，$X $是一个不定元，不表示任何值，不定元在多项式中最大项的次数称作多项式的&lt;strong&gt;次数&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;多项式的系数表示法&quot;&gt;&lt;a href=&quot;#多项式的系数表示法&quot; class=&quot;headerlink&quot; title=&quot;多项式的系数表示法&quot;&gt;&lt;/a&gt;多项式的系数表示法&lt;/h3&gt;&lt;p&gt;像刚刚我们提到的那些多项式，都是以系数形式表示的，也就是将 n 次多项式$ A(x) $的系数 $a_0, a_1, \cdots, a_n $看作 $n+1 $维向量$ \vec a=(a_0,a_1,\cdots,a_n)$，其&lt;strong&gt;系数表示（coefficient representation）&lt;/strong&gt;就是向量$ \vec a$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】大数乘法问题及其高效算法</title>
    <link href="http://github.com/2017/08/22/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/"/>
    <id>http://github.com/2017/08/22/【算法】大数相乘问题及其高效算法/</id>
    <published>2017-08-22T14:20:55.000Z</published>
    <updated>2017-10-23T04:01:38.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写两个任意位数的大数相乘的程序，给出计算结果。比如：</p>
<blockquote>
<p>题目描述：    输出两个不超过100位的大整数的乘积。<br>输入：    输入两个大整数，如1234567 和 123<br>输出：    输出乘积，如：151851741</p>
</blockquote>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">求 <span class="number">1234567891011121314151617181920</span> * <span class="number">2019181716151413121110987654321</span> 的乘积结果</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>所谓大数相乘（Multiplication algorithm），就是指数字比较大，相乘的结果超出了基本类型的表示范围，所以这样的数不能够直接做乘法运算。</p>
<p>参考了很多资料，包括维基百科词条<a href="https://en.wikipedia.org/wiki/Multiplication_algorithm" target="_blank" rel="external">Multiplication algorithm</a>，才知道目前大数乘法算法主要有以下几种思路：</p>
<ol>
<li><strong>模拟小学乘法</strong>：最简单的乘法竖式手算的累加型；</li>
<li><strong>分治乘法</strong>：最简单的是Karatsuba乘法，一般化以后有Toom-Cook乘法；</li>
<li><strong>快速傅里叶变换FFT</strong>：（为了避免精度问题，可以改用快速数论变换FNTT），时间复杂度O(N lgN lglgN)。具体可参照<a href="https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm" target="_blank" rel="external">Schönhage–Strassen algorithm</a>；</li>
<li><strong>中国剩余定理</strong>：把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行；</li>
<li><strong>Furer’s algorithm</strong>：在渐进意义上FNTT还快的算法。不过好像不太实用，本文就不作介绍了。大家可以参考维基百科<a href="https://en.wikipedia.org/wiki/F%C3%BCrer%27s_algorithm" target="_blank" rel="external">Fürer’s algorithm</a></li>
</ol>
<a id="more"></a>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>我们分别实现一下以上算法，既然不能直接使用乘法做运算，最简单最容易想到的办法就是模拟乘法运算。</p>
<h3 id="1、模拟乘法手算累加"><a href="#1、模拟乘法手算累加" class="headerlink" title="1、模拟乘法手算累加"></a>1、模拟乘法手算累加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">      7 8 9 6 5 2</div><div class="line">×         3 2 1 1</div><div class="line">-----------------</div><div class="line">      7 8 9 6 5 2   &lt;---- 第1趟 </div><div class="line">    7 8 9 6 5 2     &lt;---- 第2趟 </div><div class="line">   ..........       &lt;---- 第n趟 </div><div class="line">-----------------</div><div class="line">  ? ? ? ? ? ? ? ?   &lt;---- 最后的值用另一个数组表示</div></pre></td></tr></table></figure>
<p>如上所示，乘法运算可以分拆为两步：</p>
<ul>
<li>第一步，是将乘数与被乘数逐位相乘；</li>
<li>第二步，将逐位相乘得到的结果，对应相加起来。</li>
</ul>
<p>这有点类似小学数学中，计算乘法时通常采用的“竖式运算”。用Java简单实现了这个算法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 大数相乘 - 模拟乘法手算累加</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer[] bigNumberMultiply(<span class="keyword">int</span>[] arr1， <span class="keyword">int</span>[] arr2)&#123;</div><div class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//中间求和的结果</span></div><div class="line"></div><div class="line">    <span class="comment">//arr2 逐位与arr1相乘</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</div><div class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</div><div class="line">        ArrayList&lt;Integer&gt; singleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">//arr2 逐位单次乘法的结果</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr1.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</div><div class="line">            <span class="keyword">int</span> r = arr2[i] * arr1[j] + carry;</div><div class="line">            <span class="keyword">int</span> digit = r % <span class="number">10</span>;</div><div class="line">            carry = r / <span class="number">10</span>;</div><div class="line"></div><div class="line">            singleList.add(digit);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</div><div class="line">            singleList.add(carry);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> resultCarry = <span class="number">0</span>, count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> offset = arr2.length - <span class="number">1</span> - i;       <span class="comment">//加法的偏移位</span></div><div class="line">        ArrayList&lt;Integer&gt; middleResult = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">//arr2每位乘法的结果与上一轮的求和结果相加，从右向左做加法并进位</span></div><div class="line">        <span class="keyword">while</span> (k &lt; singleList.size() || l &lt; result.size()) &#123;</div><div class="line">            <span class="keyword">int</span> kv = <span class="number">0</span>, lv = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (k &lt; singleList.size() &amp;&amp; count &gt;= offset) &#123;</div><div class="line">                kv = singleList.get(k++);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (l &lt; result.size()) &#123;</div><div class="line">                lv = result.get(l++);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> sum = resultCarry + kv + lv;</div><div class="line">            middleResult.add(sum % <span class="number">10</span>);     <span class="comment">//相加结果从右向左（高位到低位）暂时存储，最后需要逆向输出</span></div><div class="line">            resultCarry = sum / <span class="number">10</span>;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(resultCarry != <span class="number">0</span>)&#123;</div><div class="line">            middleResult.add(resultCarry);</div><div class="line">        &#125;</div><div class="line">        result.clear();</div><div class="line">        result = middleResult;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Collections.reverse(result);    <span class="comment">//逆向输出结果</span></div><div class="line">    <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Integer[result.size()]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了以上的代码，感觉思路虽然很简单，但是实现起来却很麻烦，那么我们有没有别的方法来实现这个程序呢？答案是有的，接下来我来介绍第二种方法。</p>
<h3 id="2、模拟乘法累加-改进"><a href="#2、模拟乘法累加-改进" class="headerlink" title="2、模拟乘法累加 - 改进"></a>2、模拟乘法累加 - 改进</h3><p>简单来说，方法二就是先不算任何的进位，也就是说，<strong>将每一位相乘，相加的结果保存到同一个位置，到最后才计算进位</strong>。</p>
<p>例如：计算98×21,步骤如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">        9  8</div><div class="line">×       2  1</div><div class="line">-------------</div><div class="line">       (9)(8)  &lt;---- 第1趟: 98×1的每一位结果 </div><div class="line">  (18)(16)     &lt;---- 第2趟: 98×2的每一位结果 </div><div class="line">-------------</div><div class="line">  (18)(25)(8)  &lt;---- 这里就是相对位的和，还没有累加进位</div></pre></td></tr></table></figure>
<p>这里唯一要注意的便是进位问题，我们可以先不考虑进位，当所有位对应相加，产生结果之后，再考虑。从右向左依次累加，如果该位的数字大于10，那么我们用取余运算，在该位上只保留取余后的个位数，而将十位数进位（通过模运算得到）累加到高位便可，循环直到累加完毕。</p>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 大数相乘方法二</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bigNumberMultiply2(<span class="keyword">int</span>[] num1, <span class="keyword">int</span>[] num2)&#123;</div><div class="line">    <span class="comment">// 分配一个空间，用来存储运算的结果，num1长的数 * num2长的数，结果不会超过num1+num2长</span></div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length + num2.length];</div><div class="line"></div><div class="line">    <span class="comment">// 先不考虑进位问题，根据竖式的乘法运算，num1的第i位与num2的第j位相乘，结果应该存放在结果的第i+j位上</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num1.length; i++)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length; j++)&#123;</div><div class="line">            result[i + j + <span class="number">1</span>] += num1[i] * num2[j];	 <span class="comment">// (因为进位的问题，最终放置到第i+j+1位)</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//单独处理进位</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = result.length-<span class="number">1</span>; k &gt; <span class="number">0</span>; k--)&#123;</div><div class="line">        <span class="keyword">if</span>(result[k] &gt; <span class="number">10</span>)&#123;</div><div class="line">            result[k - <span class="number">1</span>] += result[k] / <span class="number">10</span>;</div><div class="line">            result[k] %= <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>！！注意：</strong>这里的进位有个大坑，因为<code>result[]</code>数组是从左到右记录相对位的和（还没有进位），而最后的进位是从右向左累加进位，这样的话，如果最高位，也就是最左侧那一位的累加结果需要进位的话，<code>result[]</code>数组就没有空间存放了。</p>
</blockquote>
<p>而正好<code>result[]</code>数组的最后一位空置，不可能被占用，我们就响应地把<strong>num1的第i位与num2的第j位相乘，结果应该存放在结果的第i+j位上</strong>的这个结果往后顺移一位（<code>放到第i+j+1位</code>），最后从右向左累加时就多了一个空间。</p>
<h3 id="3、分治-Karatsuba算法"><a href="#3、分治-Karatsuba算法" class="headerlink" title="3、分治 - Karatsuba算法"></a>3、分治 - Karatsuba算法</h3><p>以上两种模拟乘法的手算累加型算法，他们都是模拟普通乘法的计算方式，时间复杂度都是O(n^2)，而这个Karatsuba算法，时间复杂度仅有 $O(n^{\log _{2}3})$ 。下面，我就来介绍一下这个算法。</p>
<p>Karatsuba于1960年发明在 $O(n^{\log _{2}3})$ 步骤内将两个n位数相乘的Karatsuba算法。它反证了安德雷·柯尔莫哥洛夫于1956年认为这个乘法需要  $ \Omega (n^{2})$ 步骤的猜想。</p>
<p>首先来看看这个算法是怎么进行计算的，见下图：</p>
<hr>
<p><img src="/gallery/bignumber-multi/20160910133150980.png" alt="Karatsuba Multiplication Algorithm步骤"></p>
<hr>
<p>图中显示了计算<code>5678 * 1234</code>的过程，首先是拆分成abcd四个部分，然后分别计算<code>ac</code>, <code>bd</code>, <code>(a+b)*(c+d)</code>，最后再用第三个算式的结果减去前面两个（其实得到的就是<code>bc+ad</code>，但是减少了乘法步骤），然后，计算式1后面加4个0，计算式2后面不加，计算式3后面加2个0，再把这三者相加，就是正确结果。</p>
<p>接下来，就来证明一下这个算法的正确性。这是一幅来自<a href="https://pythonandr.com/2015/10/13/karatsuba-multiplication-algorithm-python-code/" target="_blank" rel="external">Karatsuba Multiplication Algorithm – Python Code</a>的图，我们来看看：</p>
<hr>
<p><img src="/gallery/bignumber-multi/QQ截图20170823144857.png" alt="Karatsuba算法证明"></p>
<hr>
<p>我们假设要相乘的两个数是x * y。我们可以把x，y写成：<br>
$$
x = a * 10^{n/2} + b
$$
</p>

$$
y = c * 10^{n/2} + d
$$

<p>这里的n是数字的位数。如果是偶数，则a和b都是<code>n/2</code>位的。如果n是奇数，则你可以让a是<code>n/2+1</code>位，b是<code>n/2</code>位。（例如a = 12，b = 34；a = 123，b = 45），那么<code>x*y</code>就可以换算为：</p>

$$
\begin{eqnarray*}
&&x * y\\
&=&(a * 10^{n/2}+b) * (c * 10^{n/2}+d)\\
&=&ac * 10^n + (ad + bc) * 10^{n/2} + bd\\
&=&ac * 10^n + [(a+b)*(c+d)-ac-bd] * 10^{n/2} + bd
\end{eqnarray*}
$$

<p>注意最后一步，这个式子倒数第二步中的<code>(ad + bc)</code>，没必要另外进行两次乘法，可以使用<code>((a+b)*(c+d) - ac - bd)</code>来重复利用前面的两次乘积结果<code>ac</code>和<code>bd</code>。</p>
<p>也就是说，我们发现最终只需要计算三次乘法 <code>a*c</code>， <code>b*d</code>， <code>(a+b)*(c+d)</code>  以及六次加法。因此这样复杂度就变为</p>

$$ T(n) = 3T(\frac{n}{2}) + 6n = O(n^{\log_23}) $$

<p>对比之前的计算过程，结果已经呼之欲出了。这里唯一需要注意的两点就是：</p>
<blockquote>
<ol>
<li><code>(a*d + b*c)</code>的计算为了防止两次乘法，应该使用之前的计算也就是第一幅图第四步的<code>③-②-①</code></li>
<li>这些乘法在算法里应该是递归实现的，数字很大时，先拆分，然后拆分出来的数字还是很大的话，就继续拆分，直到a * b已经是一个非常简单的小问题为之。这也是分治的思想。</li>
</ol>
</blockquote>
<hr>
<p>我们举例来尝试一下这种算法，比如计算<code>12345 * 6789</code>，我们让<code>a = 12</code>，<code>b = 345</code>。同时<code>c = 6</code>，<code>d = 789</code>。也就是：</p>

$$
12345 = 12 · 1000 + 345\\
6789 = 6 · 1000 + 789
$$

<p>那么<code>a*c</code>，<code>b*d</code>的结果如下：<br>
$$
\begin{align*}
 z_2 &= a*c = 12 × 6 = 72\\
 z_0 &= b*d = 345 × 789 = 272205 \\
 z_1 &= ((a+b)*(c+d) - a*c - b*d)\\
     &= (12 + 345) × (6 + 789) − z_2 − z_0 = 283815 − 72 − 272205 = 11538

\end{align*}
$$
</p>
<p>最终结果就是：</p>

$$
\begin{align*}
& result = z_2 · 10^{2*3} + z_1 · 10^3 + z_0 \\
& result = 72 · 10^6 + 11538 · 10^3 + 272205 = 83810205. \\
\end{align*}
$$

<p>以上就是使用分治的方式计算乘法的原理。上面这个算法，由 Anatolii Alexeevitch Karatsuba 于1960年提出并于1962年发表，所以也被称为 Karatsuba 乘法。</p>
<p>根据上面的思路，实现的Karatsuba乘法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Karatsuba乘法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">karatsuba</span><span class="params">(<span class="keyword">long</span> num1, <span class="keyword">long</span> num2)</span></span>&#123;</div><div class="line">    <span class="comment">//递归终止条件</span></div><div class="line">    <span class="keyword">if</span>(num1 &lt; <span class="number">10</span> || num2 &lt; <span class="number">10</span>) <span class="keyword">return</span> num1 * num2;</div><div class="line"></div><div class="line">    <span class="comment">// 计算拆分长度</span></div><div class="line">    <span class="keyword">int</span> size1 = String.valueOf(num1).length();</div><div class="line">    <span class="keyword">int</span> size2 = String.valueOf(num2).length();</div><div class="line">    <span class="keyword">int</span> halfN = Math.max(size1, size2) / <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 拆分为a, b, c, d */</span></div><div class="line">    <span class="keyword">long</span> a = Long.valueOf(String.valueOf(num1).substring(<span class="number">0</span>, size1 - halfN));</div><div class="line">    <span class="keyword">long</span> b = Long.valueOf(String.valueOf(num1).substring(size1 - halfN));</div><div class="line">    <span class="keyword">long</span> c = Long.valueOf(String.valueOf(num2).substring(<span class="number">0</span>, size2 - halfN));</div><div class="line">    <span class="keyword">long</span> d = Long.valueOf(String.valueOf(num2).substring(size2 - halfN));</div><div class="line"></div><div class="line">    <span class="comment">// 计算z2, z0, z1, 此处的乘法使用递归</span></div><div class="line">    <span class="keyword">long</span> z2 = karatsuba(a, c);</div><div class="line">    <span class="keyword">long</span> z0 = karatsuba(b, d);</div><div class="line">    <span class="keyword">long</span> z1 = karatsuba((a + b), (c + d)) - z0 - z2;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>)(z2 * Math.pow(<span class="number">10</span>, (<span class="number">2</span>*halfN)) + z1 * Math.pow(<span class="number">10</span>, halfN) + z0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>Karatsuba 算法是比较简单的递归乘法，把输入拆分成 2 部分，不过对于更大的数，可以把输入拆分成 3 部分甚至 4 部分。拆分为 3 部分时，可以使用下面的<code>Toom-Cook 3-way</code> 乘法，复杂度降低到 O(n^1.465)。拆分为 4 部分时，使用<code>Toom-Cook 4-way</code> 乘法，复杂度进一步下降到 O(n^1.404)。对于更大的数字，可以拆成 100 段，使用<code>快速傅里叶变换FFT</code>，复杂度接近线性，大约是 O(n^1.149)。可以看出，分割越大，时间复杂度就越低，但是所要计算的中间项以及合并最终结果的过程就会越复杂，开销会增加，因此分割点上升，对于公钥加密，暂时用不到太大的整数，所以使用 Karatsuba 就合适了，不用再去弄更复杂的递归乘法。</p>
<!--
### 4、分治 - Toom-Cook算法


### 5、快速傅里叶变换FFT


### 6、快速数论变换FNTT


### 7、中国剩余定理

-->
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetcodeTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//        String a = "1234567891011121314151617181920";</span></div><div class="line"><span class="comment">//        String b = "2019181716151413121110987654321";</span></div><div class="line"></div><div class="line"><span class="comment">//        String a = "999999999999";</span></div><div class="line"><span class="comment">//        String b = "999999999999";</span></div><div class="line"></div><div class="line"><span class="comment">//        String a = "24566";</span></div><div class="line"><span class="comment">//        String b = "452053";</span></div><div class="line"></div><div class="line">        String a = <span class="string">"98"</span>;</div><div class="line">        String b = <span class="string">"21"</span>;</div><div class="line"></div><div class="line">        <span class="keyword">char</span>[] charArr1 = a.trim().toCharArray();</div><div class="line">        <span class="keyword">char</span>[] charArr2 = b.trim().toCharArray();</div><div class="line"></div><div class="line">        <span class="comment">// 字符数组转换为int[]数组</span></div><div class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[charArr1.length];</div><div class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[charArr2.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArr1.length; i++)&#123;</div><div class="line">            arr1[i] = charArr1[i] - <span class="string">'0'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArr2.length; i++)&#123;</div><div class="line">            arr2[i] = charArr2[i] - <span class="string">'0'</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 开始计算</span></div><div class="line">        <span class="keyword">int</span>[] result = LeetcodeTest.bigNumberMultiply2(arr1, arr2);</div><div class="line">        System.out.println(a + <span class="string">" * "</span> + b + <span class="string">" = "</span> + Arrays.toString(result).replace(<span class="string">", "</span>, <span class="string">""</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，是测试用例输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1234567891011121314151617181920</span> * <span class="number">2019181716151413121110987654321</span> = [<span class="number">02492816912877266687794240983772975935013386905490061131076320</span>]</div><div class="line"></div><div class="line"><span class="number">999999999999</span> * <span class="number">999999999999</span> = [<span class="number">999999999998000000000001</span>]</div><div class="line"></div><div class="line"><span class="number">24566</span> * <span class="number">452053</span> = [<span class="number">11105133998</span>]</div><div class="line"></div><div class="line"><span class="number">98</span> * <span class="number">21</span> = [<span class="number">2058</span>]</div></pre></td></tr></table></figure>
<h2 id="Java中BigInteger的乘法实现"><a href="#Java中BigInteger的乘法实现" class="headerlink" title="Java中BigInteger的乘法实现"></a>Java中BigInteger的乘法实现</h2><p>目前最著名的高精度整数运算库是<a href="https://gmplib.org/" target="_blank" rel="external"><strong>GNU的GMP</strong></a>，GMP是The GNU MP Bignum Library，是一个开源的数学运算库，它可以用于任意精度的数学运算，包括有符号整数、有理数和浮点数。它本身并没有精度限制，只取决于机器的硬件情况。许多著名的计算机代数系统如Axiom, Maple, Mathematica, Maxima等的底层高精度整数运算都是基于GMP实现的。</p>
<p>设n 为乘数的位数, 就目前已知的情况而言, 不同乘法算法的时间复杂度可以从平凡的$O(n^2)$(普通乘法), $O(n^{log_2 3})$(Karatsuba 乘法)， $O(n^{log_3 5})$ (Toom-3 乘法)，$O(n {\log^* n})$ (复数域上的FFT)，其中</p>

$$ log^* n = log n(log log n)(log log log n) ··· , $$

<p>和$O(n(log n)(log log n))$(有限域上的FFT), 其中<strong>“有限域上的FFT”</strong>的时间复杂度已经相当接近线性了。 </p>
<p>但是这些乘法算法中复杂度较低的算法往往有较大的常数因子, 因此如果乘数的位数较少,普通乘法反而是最快的, 所以实用中常常将这些不同的乘法算法结合起来使用, 每次做乘法时都根据相乘两数的大小动态地选择具体采用哪一种算法, 而每种算法的最佳适用范围往往依赖于具体实现和硬件环境, 因此一般直接通过实验来确定。</p>
<h3 id="Java中的实现"><a href="#Java中的实现" class="headerlink" title="Java中的实现"></a>Java中的实现</h3><ol>
<li><p>在 Java 7 里面，就是用二重循环直接乘的。源代码：<a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/00cd9dc3c2b5/src/share/classes/java/math/BigInteger.java#l1165" target="_blank" rel="external">[BigInteger  - Java7]</a> （见1165行）</p>
</li>
<li><p>在 Java 8 里面，根据两个因数的大小，有三种乘法。源代码：<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/math/BigInteger.java#l1464" target="_blank" rel="external">[BigInteger  - Java8]</a> （见1464行）：</p>
<ul>
<li>当两个因数均小于 $2^{32\times 80}$ 时，用二重循环直接相乘，复杂度为$O(n^2) $，n为因数位数（下同）；</li>
<li>否则，当两个因数均小于$2^{32\times 240} $时，采用 Karatsuba algorithm，其复杂度为$O(n^{\log_2 3}) \approx O(n^{1.585})$；</li>
<li>否则，采用 Toom-Cook multiplication，其复杂度为$O(n^{\log_3 5}) \approx O(n^{1.465})$。</li>
</ul>
</li>
</ol>
<p>其中，Java8中的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MULTIPLY_SQUARE_THRESHOLD = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KARATSUBA_THRESHOLD = <span class="number">80</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TOOM_COOK_THRESHOLD = <span class="number">240</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (val.signum == <span class="number">0</span> || signum == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> ZERO;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> xlen = mag.length;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (val == <span class="keyword">this</span> &amp;&amp; xlen &gt; MULTIPLY_SQUARE_THRESHOLD) &#123;</div><div class="line">        <span class="keyword">return</span> square();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ylen = val.mag.length;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((xlen &lt; KARATSUBA_THRESHOLD) || (ylen &lt; KARATSUBA_THRESHOLD)) &#123;</div><div class="line">        <span class="keyword">int</span> resultSign = signum == val.signum ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (val.mag.length == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> multiplyByInt(mag,val.mag[<span class="number">0</span>], resultSign);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mag.length == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> multiplyByInt(val.mag,mag[<span class="number">0</span>], resultSign);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] result = multiplyToLen(mag, xlen,</div><div class="line">                                     val.mag, ylen, <span class="keyword">null</span>);</div><div class="line">        result = trustedStripLeadingZeroInts(result);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(result, resultSign);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ((xlen &lt; TOOM_COOK_THRESHOLD) &amp;&amp; (ylen &lt; TOOM_COOK_THRESHOLD)) &#123;</div><div class="line">            <span class="comment">// 采用 Karatsuba algorithm 算法</span></div><div class="line">            <span class="keyword">return</span> multiplyKaratsuba(<span class="keyword">this</span>, val);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 采用 Toom-Cook multiplication 3路乘法</span></div><div class="line">            <span class="keyword">return</span> multiplyToomCook3(<span class="keyword">this</span>, val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，Java8依据两个因数的量级分别使用Karatsuba algorithm 和 Toom-Cook multiplication 算法计算大数乘积。</p>
<h3 id="Karatsuba-algorithm"><a href="#Karatsuba-algorithm" class="headerlink" title="Karatsuba algorithm"></a>Karatsuba algorithm</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Java8中的 Karatsuba algorithm 算法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigInteger <span class="title">multiplyKaratsuba</span><span class="params">(BigInteger x, BigInteger y)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> xlen = x.mag.length;</div><div class="line">    <span class="keyword">int</span> ylen = y.mag.length;</div><div class="line"></div><div class="line">    <span class="comment">// The number of ints in each half of the number.</span></div><div class="line">    <span class="keyword">int</span> half = (Math.max(xlen, ylen)+<span class="number">1</span>) / <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// xl and yl are the lower halves of x and y respectively,</span></div><div class="line">    <span class="comment">// xh and yh are the upper halves.</span></div><div class="line">    BigInteger xl = x.getLower(half);</div><div class="line">    BigInteger xh = x.getUpper(half);</div><div class="line">    BigInteger yl = y.getLower(half);</div><div class="line">    BigInteger yh = y.getUpper(half);</div><div class="line"></div><div class="line">    BigInteger p1 = xh.multiply(yh);  <span class="comment">// p1 = xh*yh</span></div><div class="line">    BigInteger p2 = xl.multiply(yl);  <span class="comment">// p2 = xl*yl</span></div><div class="line"></div><div class="line">    <span class="comment">// p3=(xh+xl)*(yh+yl)</span></div><div class="line">    BigInteger p3 = xh.add(xl).multiply(yh.add(yl));</div><div class="line"></div><div class="line">    <span class="comment">// result = p1 * 2^(32*2*half) + (p3 - p1 - p2) * 2^(32*half) + p2</span></div><div class="line">    BigInteger result = p1.shiftLeft(<span class="number">32</span>*half).add(p3.subtract(p1).subtract(p2)).shiftLeft(<span class="number">32</span>*half).add(p2);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (x.signum != y.signum) &#123;</div><div class="line">        <span class="keyword">return</span> result.negate();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Toom-Cook-multiplication"><a href="#Toom-Cook-multiplication" class="headerlink" title="Toom-Cook multiplication"></a>Toom-Cook multiplication</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Java8中的 Toom-Cook multiplication 3路乘法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigInteger <span class="title">multiplyToomCook3</span><span class="params">(BigInteger a, BigInteger b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> alen = a.mag.length;</div><div class="line">    <span class="keyword">int</span> blen = b.mag.length;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> largest = Math.max(alen, blen);</div><div class="line"></div><div class="line">    <span class="comment">// k is the size (in ints) of the lower-order slices.</span></div><div class="line">    <span class="keyword">int</span> k = (largest+<span class="number">2</span>)/<span class="number">3</span>;   <span class="comment">// Equal to ceil(largest/3)</span></div><div class="line"></div><div class="line">    <span class="comment">// r is the size (in ints) of the highest-order slice.</span></div><div class="line">    <span class="keyword">int</span> r = largest - <span class="number">2</span>*k;</div><div class="line"></div><div class="line">    <span class="comment">// Obtain slices of the numbers. a2 and b2 are the most significant</span></div><div class="line">    <span class="comment">// bits of the numbers a and b, and a0 and b0 the least significant.</span></div><div class="line">    BigInteger a0, a1, a2, b0, b1, b2;</div><div class="line">    a2 = a.getToomSlice(k, r, <span class="number">0</span>, largest);</div><div class="line">    a1 = a.getToomSlice(k, r, <span class="number">1</span>, largest);</div><div class="line">    a0 = a.getToomSlice(k, r, <span class="number">2</span>, largest);</div><div class="line">    b2 = b.getToomSlice(k, r, <span class="number">0</span>, largest);</div><div class="line">    b1 = b.getToomSlice(k, r, <span class="number">1</span>, largest);</div><div class="line">    b0 = b.getToomSlice(k, r, <span class="number">2</span>, largest);</div><div class="line"></div><div class="line">    BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1, db1;</div><div class="line"></div><div class="line">    v0 = a0.multiply(b0);</div><div class="line">    da1 = a2.add(a0);</div><div class="line">    db1 = b2.add(b0);</div><div class="line">    vm1 = da1.subtract(a1).multiply(db1.subtract(b1));</div><div class="line">    da1 = da1.add(a1);</div><div class="line">    db1 = db1.add(b1);</div><div class="line">    v1 = da1.multiply(db1);</div><div class="line">    v2 = da1.add(a2).shiftLeft(<span class="number">1</span>).subtract(a0).multiply(</div><div class="line">         db1.add(b2).shiftLeft(<span class="number">1</span>).subtract(b0));</div><div class="line">    vinf = a2.multiply(b2);</div><div class="line"></div><div class="line">    <span class="comment">// The algorithm requires two divisions by 2 and one by 3.</span></div><div class="line">    <span class="comment">// All divisions are known to be exact, that is, they do not produce</span></div><div class="line">    <span class="comment">// remainders, and all results are positive.  The divisions by 2 are</span></div><div class="line">    <span class="comment">// implemented as right shifts which are relatively efficient, leaving</span></div><div class="line">    <span class="comment">// only an exact division by 3, which is done by a specialized</span></div><div class="line">    <span class="comment">// linear-time algorithm.</span></div><div class="line">    t2 = v2.subtract(vm1).exactDivideBy3();</div><div class="line">    tm1 = v1.subtract(vm1).shiftRight(<span class="number">1</span>);</div><div class="line">    t1 = v1.subtract(v0);</div><div class="line">    t2 = t2.subtract(t1).shiftRight(<span class="number">1</span>);</div><div class="line">    t1 = t1.subtract(tm1).subtract(vinf);</div><div class="line">    t2 = t2.subtract(vinf.shiftLeft(<span class="number">1</span>));</div><div class="line">    tm1 = tm1.subtract(t2);</div><div class="line"></div><div class="line">    <span class="comment">// Number of bits to shift left.</span></div><div class="line">    <span class="keyword">int</span> ss = k*<span class="number">32</span>;</div><div class="line"></div><div class="line">    BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (a.signum != b.signum) &#123;</div><div class="line">        <span class="keyword">return</span> result.negate();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/king-ding/p/bigIntegerMul.html" target="_blank" rel="external">华为OJ机试题目：两个大整数相乘(纯C语言实现两个大整数相乘，两种方法实现大数相乘)</a></li>
<li><a href="https://www.zhihu.com/question/36725424" target="_blank" rel="external">java的BigInteger的乘法运算是用什么算法实现的？</a></li>
<li><a href="https://www.zhihu.com/question/19678341" target="_blank" rel="external">大数乘法，在算法上，主要有几种思路？</a></li>
<li><a href="http://blog.csdn.net/jinyongqing/article/details/13508577" target="_blank" rel="external">算法理解 — 大数相乘问题</a></li>
<li><a href="http://blog.csdn.net/qj30212/article/details/52494556" target="_blank" rel="external">KaraTsuba乘法 — 高效的大数乘法</a></li>
<li><a href="http://taptree.lofter.com/post/6cb74_f626a" target="_blank" rel="external">大数相乘(from滴答滴答百度空间)</a></li>
<li><a href="https://github.com/bhuztez/oj-solutions/blob/master/topics/bignum/bigint.rst">大整数运算</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multiplication_algorithm" target="_blank" rel="external">维基百科：Multiplication algorithm</a></li>
<li><a href="https://pythonandr.com/2015/10/13/karatsuba-multiplication-algorithm-python-code/" target="_blank" rel="external">Karatsuba Multiplication Algorithm – Python Code</a></li>
<li><a href="https://gmplib.org/manual/Toom-3_002dWay-Multiplication.html" target="_blank" rel="external">Toom-Cook 3-Way Multiplication - GMP Documentations</a></li>
<li><a href="http://blog.miskcoo.com/2014/09/chinese-remainder-theorem" target="_blank" rel="external">扩展欧几里得算法与中国剩余定理</a></li>
</ul>
<p><img src="/gallery/bignumber-multi/1320989430_PEhXSo.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写两个任意位数的大数相乘的程序，给出计算结果。比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述：    输出两个不超过100位的大整数的乘积。&lt;br&gt;输入：    输入两个大整数，如1234567 和 123&lt;br&gt;输出：    输出乘积，如：151851741&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;求 &lt;span class=&quot;number&quot;&gt;1234567891011121314151617181920&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;2019181716151413121110987654321&lt;/span&gt; 的乘积结果&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;所谓大数相乘（Multiplication algorithm），就是指数字比较大，相乘的结果超出了基本类型的表示范围，所以这样的数不能够直接做乘法运算。&lt;/p&gt;
&lt;p&gt;参考了很多资料，包括维基百科词条&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiplication_algorithm&quot;&gt;Multiplication algorithm&lt;/a&gt;，才知道目前大数乘法算法主要有以下几种思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;模拟小学乘法&lt;/strong&gt;：最简单的乘法竖式手算的累加型；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分治乘法&lt;/strong&gt;：最简单的是Karatsuba乘法，一般化以后有Toom-Cook乘法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速傅里叶变换FFT&lt;/strong&gt;：（为了避免精度问题，可以改用快速数论变换FNTT），时间复杂度O(N lgN lglgN)。具体可参照&lt;a href=&quot;https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm&quot;&gt;Schönhage–Strassen algorithm&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中国剩余定理&lt;/strong&gt;：把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Furer’s algorithm&lt;/strong&gt;：在渐进意义上FNTT还快的算法。不过好像不太实用，本文就不作介绍了。大家可以参考维基百科&lt;a href=&quot;https://en.wikipedia.org/wiki/F%C3%BCrer%27s_algorithm&quot;&gt;Fürer’s algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】反转字符串</title>
    <link href="http://github.com/2017/08/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://github.com/2017/08/05/【算法】反转字符串/</id>
    <published>2017-08-05T14:20:55.000Z</published>
    <updated>2017-10-23T04:01:29.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>研究算法能提高我们的编程功底，更好地编写出高效稳健的代码。今天，我们研究的是 —— 反转字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//输入一个字符串，输出它的倒序字符串</span></div><div class="line">input:  Hello</div><div class="line">output: olleH</div></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>反转字符串，确实没什么难度，但是我无意间搜索了一下，才发现这么一个看似简单的反转算法实现起来真可谓花样繁多。这里我们尽可能分别总结介绍一下。</p>
<h3 id="1、使用字符数组倒序输出"><a href="#1、使用字符数组倒序输出" class="headerlink" title="1、使用字符数组倒序输出"></a>1、使用字符数组倒序输出</h3><p>最常规的解法，也是最容易想到的一种方法就是使用字符数组倒序输出。</p>
<p>具体思路是：倒序遍历字符串字符循环给char数组赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) <span class="keyword">return</span> string;</div><div class="line">    </div><div class="line">    <span class="keyword">char</span>[] array = <span class="keyword">new</span> <span class="keyword">char</span>[string.length()];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++)&#123;</div><div class="line">        array[i] = string.charAt(string.length() - i - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>优化：</p>
<p>分析上面这种解法，循环遍历时，我们其实不需要循环这么多次。每次循环的时候，我们应该直接给前、后位置（第一个和最后一个，第二个和倒数第二个）交换。也就是说我们不必对这个字符数组进行完全遍历，通常情况下我们会只遍历一半同时交换中轴前后两个元素就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) <span class="keyword">return</span> string;</div><div class="line"></div><div class="line">    <span class="keyword">char</span>[] array = string.toCharArray();</div><div class="line">    <span class="comment">//注意这里中间的位置计算</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.ceil(string.length() / <span class="number">2.0f</span>); i++)&#123;</div><div class="line">        <span class="keyword">int</span> j = string.length() - i - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(i != j)&#123;		<span class="comment">//交换元素</span></div><div class="line">            <span class="keyword">char</span> temp = array[i];</div><div class="line">            array[i] = array[j];</div><div class="line">            array[j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、使用StringBuilder"><a href="#2、使用StringBuilder" class="headerlink" title="2、使用StringBuilder"></a>2、使用StringBuilder</h3><p><code>StringBuilder</code>可以帮助我们创建字符串，所以也可以使用<code>StringBuilder</code>替代字符数组存储，具体思路是:</p>
<p>逆序遍历字符串中的字符，并将它依次添加到StringBuilder中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithStringBuilder</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) <span class="keyword">return</span> string;</div><div class="line"></div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = string.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</div><div class="line">        sb.append(string.charAt(i));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上这几种方法按算法角度来说，其实可以归结为一类。然而下面的几种算法就完全不是同一类型的了。<br>比如使用栈、使用异或运算。</p>
<h3 id="3、使用StringBuilder-reverse-方法"><a href="#3、使用StringBuilder-reverse-方法" class="headerlink" title="3、使用StringBuilder.reverse()方法"></a>3、使用StringBuilder.reverse()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> StringBuilder(hi).reverse().toString()</div></pre></td></tr></table></figure>
<p>StringBuilder中提供了<code>reverse()</code>方法来实现字符串反转，我们可以直接调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithRecursive</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) <span class="keyword">return</span> string;</div><div class="line">   </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(string).reverse().toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Or, for versions earlier than JDK 1.5, use <code>java.util.StringBuffer</code> instead of <code>StringBuilder</code> — they have the same API. Thanks commentators for pointing out that StringBuilder is preferred nowadays.</p>
</blockquote>
<p>对于JDK 1.5之前的版本可以使用<code>StringBuffer</code>替代<code>StringBuilder</code>，这两个的API都一样。</p>
<h3 id="4、使用栈"><a href="#4、使用栈" class="headerlink" title="4、使用栈"></a>4、使用栈</h3><p>我们都知道，栈有“后进先出(LIFO)”的特点。这一特点刚好用于反转字符串。具体思路是:</p>
<ul>
<li>将字符串转换为char数组</li>
<li>将char数组中的字符依次压入栈中</li>
<li>将栈中的字符依次弹出赋值给char数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithStack</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) <span class="keyword">return</span> string;</div><div class="line"></div><div class="line">    <span class="keyword">char</span>[] array = string.toCharArray();        </div><div class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</div><div class="line">    <span class="keyword">for</span>(Character c : array)&#123;</div><div class="line">        stack.push(c);		<span class="comment">//压栈</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++)&#123;</div><div class="line">        array[i] = stack.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);	<span class="comment">//出栈</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两次循环和栈的开销无疑使这种方法成为目前为止开销最大的方法。但使用栈这个数据结构的想法还是非常有价值的。</p>
<h3 id="5、使用异或运算"><a href="#5、使用异或运算" class="headerlink" title="5、使用异或运算"></a>5、使用异或运算</h3><p>计算机的数据流本质上都是0，1二进制数据。字符串也是一样。而二进制数据的处理往往是通过位运算来实现的。位操作有：<strong>与，或，非，异或</strong>。</p>
<p>对位运算有过了解的应该知道，使用<strong>异或操作</strong>能实现交换两个变量的值而不引入第三个变量。</p>
<p><strong>实现原理:</strong></p>
<ul>
<li>首先介绍异或操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">异或操作: 当两两数值相同为否，而数值不同为真。写作A^B</div><div class="line"></div><div class="line">A  B  A^B</div><div class="line"><span class="number">0</span>  <span class="number">0</span>   <span class="number">0</span></div><div class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">1</span></div><div class="line"><span class="number">1</span>  <span class="number">0</span>   <span class="number">1</span></div><div class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">0</span></div></pre></td></tr></table></figure>
<ul>
<li>使用异或操作交换数值</li>
</ul>
<figure class="highlight parser3"><table><tr><td class="code"><pre><div class="line"><span class="xml">两个数异或的结果再与其中一个数异或的结果是另外一个数</span></div><div class="line"></div><div class="line">这涉及到了离散数学中的异或的性质:</div><div class="line"><span class="number">1.</span><span class="xml">交换律:A</span><span class="keyword">^B</span><span class="xml">=B</span><span class="keyword">^A</span><span class="xml"></span></div><div class="line"><span class="number">2.</span><span class="xml">结合律: A^(B</span><span class="keyword">^C</span><span class="xml">)=(A</span><span class="keyword">^B</span><span class="xml">)</span><span class="keyword">^C</span><span class="xml"></span></div><div class="line"><span class="number">3.</span><span class="xml">恒等律:X</span><span class="keyword">^0</span><span class="xml">=</span><span class="number">0</span><span class="xml"></span></div><div class="line"><span class="number">4.</span><span class="xml">归零律:X</span><span class="keyword">^X</span><span class="xml">=</span><span class="number">0</span><span class="xml"></span></div><div class="line"><span class="number">5.</span><span class="xml">自反：A</span><span class="keyword">^B</span><span class="xml"></span><span class="keyword">^B</span><span class="xml"> = A</span><span class="keyword">^0</span><span class="xml">=A</span></div><div class="line"></div><div class="line">根据以上性质:</div><div class="line"></div><div class="line">A=A<span class="keyword">^B</span><span class="xml"></span></div><div class="line">B=A<span class="keyword">^B</span><span class="xml"></span></div><div class="line">A=A<span class="keyword">^B</span><span class="xml"></span></div><div class="line"></div><div class="line">通过以上三步，能实现在程序中交换两个变量的数值的目标。</div></pre></td></tr></table></figure>
<ul>
<li>使用异或操作交换字符值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">before:<span class="string">"Hello"</span></div><div class="line">after: <span class="string">"olleH"</span></div><div class="line"></div><div class="line">index: <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></div><div class="line"><span class="keyword">char</span> : H   e   l   l   o</div><div class="line">ASCII: <span class="number">72</span>  <span class="number">101</span> <span class="number">108</span> <span class="number">108</span> <span class="number">111</span></div><div class="line"></div><div class="line">以第<span class="number">0</span>个字符和第<span class="number">4</span>个字符交换为例:</div><div class="line"></div><div class="line">交换前:</div><div class="line">array[<span class="number">0</span>]=<span class="number">1001000</span></div><div class="line">array[<span class="number">4</span>]=<span class="number">1101111</span></div><div class="line"></div><div class="line">交换:</div><div class="line">array[<span class="number">0</span>]=array[<span class="number">0</span>]^array[<span class="number">4</span>]=<span class="number">0100111</span></div><div class="line">array[<span class="number">4</span>]=array[<span class="number">4</span>]^array[<span class="number">0</span>]=<span class="number">1001000</span></div><div class="line">array[<span class="number">0</span>]=array[<span class="number">0</span>]^array[<span class="number">4</span>]=<span class="number">1101111</span></div><div class="line"></div><div class="line">交换后:</div><div class="line">array[<span class="number">0</span>]=<span class="number">1101111</span>---&gt;<span class="number">111</span>--&gt;o</div><div class="line">array[<span class="number">4</span>]=<span class="number">1001000</span>---&gt;<span class="number">72</span>---&gt;H</div></pre></td></tr></table></figure>
<p>使用这种交换方法，每次循环的时候，我们直接给中轴前、后位置元素（第一个和最后一个，第二个和倒数第二个）交换。这样我们也只遍历一半就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) <span class="keyword">return</span> string;</div><div class="line"></div><div class="line">    <span class="keyword">char</span>[] array = string.toCharArray();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = string.length() - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</div><div class="line">    	<span class="comment">//异或运算交换元素</span></div><div class="line">        array[i] ^= array[j];</div><div class="line">        array[j] ^= array[i];</div><div class="line">        array[i] ^= array[j];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6、使用递归"><a href="#6、使用递归" class="headerlink" title="6、使用递归"></a>6、使用递归</h3><p>当我们反转字符串的时候，脑海里想的就是从首尾两端依次交换直到到达中间位置。当我们在反转某个字符时，剩下的字符串也是一个反转字符串的过程。这样，我们就能用递归的方法来实现反转字符串的目的。</p>
<p>具体思路是:</p>
<ul>
<li>找出递归结束的临界条件</li>
<li>对针对于临界条件的不同的值做出不同的处理</li>
</ul>
<p>编码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithRecursive</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) <span class="keyword">return</span> string;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(string.length() == <span class="number">1</span>)&#123;</div><div class="line">    	<span class="keyword">return</span> string;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//当前str的反转 = 将第一个元素之后的subString反转 + 第一个元素</span></div><div class="line">    	<span class="keyword">return</span> strReverseWithRecursive(string.substring(<span class="number">1</span>)) + string.charAt(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h2><p>反转一个字符串有这么多方法，那么如何把一个字符串反转，而单词不翻转呢？</p>
<p>题目：写一个函数，将字符串反转，反转方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//输入一个字符串，输出它的倒序字符串，单词不翻转</span></div><div class="line">input:  <span class="string">"I am a student"</span></div><div class="line">output: <span class="string">"student a am I"</span></div></pre></td></tr></table></figure>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>我们可以仿照上面的字符串完全反转方法。</p>
<p>比如使用栈，可以把单词入栈，而不是字符，然后出栈，就是想要的效果了。或者也使用StringBuilder倒序存储，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String word)</span></span>&#123;</div><div class="line">	String[] arr = word.split(<span class="string">"\\W+"</span>);</div><div class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">	<span class="keyword">int</span> len = arr.length;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</div><div class="line">		sb.append(arr[i]).append(<span class="string">" "</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种思路是：<strong>先把整个字符串完全反转，再将字符串分割为单词，每个单词再单独反转回来</strong>。这种办法也没什么问题，大家可以参考一下。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://johntsai.work/2016/06/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/" target="_blank" rel="external">深入浅出经典面试题之——反转字符串</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6997f0150100tpse.html" target="_blank" rel="external">字符串反转的9种方法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;研究算法能提高我们的编程功底，更好地编写出高效稳健的代码。今天，我们研究的是 —— 反转字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输入一个字符串，输出它的倒序字符串&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;input:  Hello&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;output: olleH&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h2&gt;&lt;p&gt;反转字符串，确实没什么难度，但是我无意间搜索了一下，才发现这么一个看似简单的反转算法实现起来真可谓花样繁多。这里我们尽可能分别总结介绍一下。&lt;/p&gt;
&lt;h3 id=&quot;1、使用字符数组倒序输出&quot;&gt;&lt;a href=&quot;#1、使用字符数组倒序输出&quot; class=&quot;headerlink&quot; title=&quot;1、使用字符数组倒序输出&quot;&gt;&lt;/a&gt;1、使用字符数组倒序输出&lt;/h3&gt;&lt;p&gt;最常规的解法，也是最容易想到的一种方法就是使用字符数组倒序输出。&lt;/p&gt;
&lt;p&gt;具体思路是：倒序遍历字符串字符循环给char数组赋值&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;strReverseWithArray&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String string)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (string == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || string.length() == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; string;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[] array = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[string.length()];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; string.length(); i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        array[i] = string.charAt(string.length() - i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(array);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【Android】源码分析 - Handler消息机制再梳理</title>
    <link href="http://github.com/2017/08/03/%E3%80%90Android%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%86%8D%E6%A2%B3%E7%90%86/"/>
    <id>http://github.com/2017/08/03/【Android】源码分析 - Handler消息机制再梳理/</id>
    <published>2017-08-03T08:03:00.000Z</published>
    <updated>2017-10-23T03:35:02.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多线程的消息传递处理，从初学Android时的Handler，懵懵懂懂地照猫画虎，到后来一头雾水的疑惑它为什么这么复杂，再到熟悉之后的叹为观止，一步步地都是自己踩过的足迹，都是成长啊哈哈哈。虽然离出神入化的境界还远十万八千里呢，但Android中的Handler多线程消息传递机制，的确是研发技术学习中不可多得的一个宝藏。本来我以为自己之前的学习以及比较了解 Handler，在印象中 Android 消息机制无非就是：</p>
<ol>
<li>Handler 给 MessageQueue 添加消息</li>
<li>然后 Looper 无限循环读取消息</li>
<li>再调用 Handler 处理消息</li>
</ol>
<p>但是只知道整体流程，细节还不是特别透彻。最近不甚忙碌，回头看到这块又有些许收获，我们来记录一下吧。</p>
<p>在整个Android的源码世界里，有两大利剑，其一是<strong>Binder IPC机制</strong>，另一个便是<strong>消息机制</strong>。Android有大量的消息驱动方式来进行交互，比如Android的四剑客<code>Activity</code>, <code>Service</code>, <code>Broadcast</code>, <code>ContentProvider</code>的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。而Android 消息机制主要涉及 4 个类：</p>
<ul>
<li>Handler</li>
<li>Message</li>
<li>MessageQueue</li>
<li>Looper</li>
</ul>
<p>我们依次结合源码分析一下。</p>
<a id="more"></a>
<h2 id="初学Handler"><a href="#初学Handler" class="headerlink" title="初学Handler"></a>初学Handler</h2><p>每个初学Android开发的都绕不开Handler这个“坎”，为什么说是个坎呢，首先这是Android架构的精髓之一，其次大部分人都是知其然却不知其所以然。所以决定再去翻翻源代码梳理一下Handler的实现机制。</p>
<h3 id="异步更新UI"><a href="#异步更新UI" class="headerlink" title="异步更新UI"></a>异步更新UI</h3><p>我们都知道Android中主线程就是UI线程。<strong>在主线程不能做耗时操作，而子线程不能更新UI</strong>。主线程如果耗时操作太久（超过5秒）会引起ANR。子线程更新UI，会导致线程不安全，界面的刷新不能同步，可能不起作用甚至是崩溃。详细的分析可以看这篇文章<a href="http://www.cnblogs.com/lao-liang/p/5108745.html" target="_blank" rel="external">Android子线程真的不能更新UI么？</a></p>
<p>上面这个规定应该是初学必知的，那要怎么来解决这个问题呢，这时候<code>Handler</code>就出现在我们面前了，我们也可以利用<code>AsyncTask</code>或者<code>IntentService</code>进行异步的操作。这两者又是怎么做到的呢？其实，在AsyncTask和IntentService的内部亦使用了<code>Handler</code>实现其主要功能。抛开这两者不谈，当我们打开Android源码的时候也随处可见Handler的身影。所以，Handler是Android异步操作的核心和精髓，它在众多领域发挥着极其重要甚至是不可替代的作用。我们先来一段经典常用代码（这里忽略内存泄露问题，我们后面再说）：</p>
<p>首先在Activity中新建一个handler:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">		<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">				mTestTV.setText(<span class="string">"This is handleMessage"</span>);	<span class="comment">//更新UI</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在子线程里发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);	<span class="comment">//在子线程有一段耗时操作,比如请求网络</span></div><div class="line">            mHandler.sendEmptyMessage(<span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>我们可以看到，子线程拿着主线程的<code>mHandler</code>对象调用了它的<code>sendEmptyMessage(0)</code>方法发送了一个空Message。然后主线程就更新了<code>mTestTV</code>这个TextView的内容。下面，我们就根据这段代码逐步跟踪分析一下Handler源码，梳理一下Android的这个消息机制。</p>
<h2 id="Handler源码跟踪"><a href="#Handler源码跟踪" class="headerlink" title="Handler源码跟踪"></a>Handler源码跟踪</h2><p>根据上面的Handler使用例子，我们从Handler的<code>sendEmptyMessage()</code>方法这里开始，翻看Handler的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">    Message msg = Message.obtain();</div><div class="line">    msg.what = what;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">        delayMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，最后调用了<code>sendMessageAtTime()</code>方法，我们接着看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;	<span class="comment">//拿到MessageQueue队列对象</span></div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">//把msg对象入队</span></div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，目前我们看到的Handler的<code>sendEmptyMessage()</code>方法调用逻辑如下图：</p>
<p><img src="/gallery/android-handler/java_sendmessage.png" alt="Handler的sendEmptyMessage()方法调用逻辑"></p>
<p>最后这个<code>sendMessageAtTime()</code>方法我们看到两个亮点：</p>
<ul>
<li>第一步，<strong>首先拿到消息队列<code>MessageQueue</code>类型的<code>mQueue</code>对象</strong>。</li>
<li>第二步，<strong>把消息<code>Message</code>类型的实例<code>msg</code>对象入队</strong>。</li>
</ul>
<p>接下来，我们就沿着这两个问题分别往下跟踪。</p>
<h2 id="MessageQueue对象从哪里来"><a href="#MessageQueue对象从哪里来" class="headerlink" title="MessageQueue对象从哪里来"></a>MessageQueue对象从哪里来</h2><p>我们先来看<code>mQueue</code>这个MessageQueue对象哪来的呢？我们找到了赋值的地方，原来在Handler的构造函数里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();	<span class="comment">//使用Looper.myLooper()取到了mLooper对象</span></div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;	<span class="comment">//原来消息队列来自mLooper对象里的mQueue</span></div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来<code>mQueue</code>这个对象是从<code>Looper</code>这个对象中获取的，同时我们看到是通过<code>Looper.myLooper()</code>获取到Looper对象的。也就是说每个Looper拥有一个消息队列<code>MessageQueue</code>对象。我们在Looper的构造函数里看到是它new了一个MessageQueue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> MessageQueue mQueue;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);	<span class="comment">//初始化MessageQueue对象</span></div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们紧接着再进入Looper类中的<code>myLooper()</code>方法看看如何得到Looper实例对象的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Return the Looper object associated with the current thread.  Returns</div><div class="line"> * null if the calling thread is not associated with a Looper.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div></pre></td></tr></table></figure>
<p>原来这个looper对象是从一个<code>ThreadLocal</code>线程本地存储TLS对象中取到的，而且这个实例声明上面我们可以看到一行注释：<strong>如果不提前调用<code>prepare()</code>方法的话<code>sThreadLocal.get()</code>可能返回null</strong>。</p>
<p>我们来看看这个<code>prepare()</code>方法到底干了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">	 <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span></div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建Looper对象，并保存到当前线程的TLS区域</span></div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来是给<code>ThreadLocal</code>线程本地存储TLS对象set了一个新的Looper对象。换句话说，就是new了一个Looper对象然后保存在了线程本地存储区里了。而这个<code>ThreadLocal</code>线程本地存储对象就是每个线程专有的变量，可以理解成线程的自有变量保存区。我们这里不作深入介绍，只用理解每个线程可以通过<code>Looper.prepare()</code>方法new一个Looper对象保存起来，然后就可以拥有一个Looper了。这也就是我们在非UI线程中使用Handler之前必须首先调用<code>Looper.prepare()</code>方法的根本原因。</p>
<blockquote>
<p><strong>插播</strong>：<code>ThreadLocal</code>类实现一个线程本地的存储，也就是说，每个线程都有自己的局部变量。所有线程都共享一个ThreadLocal对象，但是每个线程在访问这些变量的时候能得到不同的值，每个线程可以更改这些变量并且不会影响其他的线程，并且支持null值。详细介绍可以看看这里：<a href="http://www.cnblogs.com/whoislcj/p/5811989.html" target="_blank" rel="external">Android线程管理之ThreadLocal理解及应用场景</a></p>
</blockquote>
<p>比如我们在Activity的onCreate()方法中写一段这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">    Handler h1 = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Handler h2 = <span class="keyword">new</span> Handler();		<span class="comment">//直接在子线程中new一个Handler</span></div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之后h1正常创建，但是创建h2的时候crash了：</p>
<blockquote>
<p>——— beginning of crash<br>E/AndroidRuntime: FATAL EXCEPTION: Thread-263<br>Process: com.example.stone.sfsandroidclient, PID: 32286<br>java.lang.RuntimeException: <strong>Can’t create handler inside thread that has not called Looper.prepare()</strong><br>   at android.os.Handler.<init>(Handler.java:200)<br>   at android.os.Handler.<init>(Handler.java:114)<br>   at com.example.stone.sfsandroidclient.MainActivity$1.run(MainActivity.java:71)<br>   at java.lang.Thread.run(Thread.java:818)</init></init></p>
</blockquote>
<p>很明显，出错日志提示<strong>不能在一个没有调用过<code>Looper.prepare()</code>的Thread里边<code>new Handler()</code></strong>。</p>
<p>看到了这里有一个疑惑，那就是我们在文章开头的示例代码中新建<code>mHandler</code>的时候并没有调用<code>Looper.prepare()</code>方法，那Looper的创建以及方法调用在哪里呢？其实这些东西Android本身已经帮我们做了，在程序入口<strong>ActivityThread</strong>的main方法里面我们可以找到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    Looper.prepareMainLooper();		<span class="comment">//这里等同于Looper.prepare()</span></div><div class="line">    ...</div><div class="line">    Looper.loop();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Message对象如何入队"><a href="#Message对象如何入队" class="headerlink" title="Message对象如何入队"></a>Message对象如何入队</h2><p>我们明白了MessageQueue消息队列对象是来自于ThreadLocal线程本地存储区存储的那个唯一的Looper对象。我们接着看<strong>Handler</strong>在发送消息的最后调用的<code>enqueueMessage()</code>方法，看名字应该是把消息加入队列的意思，点进去看下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;		<span class="comment">//注意此处Handler把自己this赋值给了Message的target变量</span></div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到msg的target的赋值是Handler自己，也就是说这个<code>msg</code>实例对象现在持有了主线程中<code>mHandler</code>这个对象。注意这里，我们稍后会讲到<code>msg</code>持有这个<code>mHandler</code>对象的用途。最后调用了<code>MessageQueue</code>类的<code>enqueueMessage()</code>方法加入到了消息队列。</p>
<p>看来真正的入队方法交给了<strong>MessageQueue</strong>，这个<code>enqueueMessage()</code>方法较长，我们现在继续进入看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;    <span class="comment">//这里要求消息必须跟 Handler 关联</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;    </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;    <span class="comment">//如果消息队列已经退出，还入队就报错</span></div><div class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.markInUse();    <span class="comment">//消息入队后就标记为 在被使用</span></div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="comment">//添加消息到链表中</span></div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;    </div><div class="line">            <span class="comment">//之前是空链表的时候读取消息会阻塞，新添加消息后唤醒</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//插入消息到队列时，只有在队列头部有个屏障并且当前消息是异步的时才需要唤醒队列</span></div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到一个无限循环将消息加入到消息队列中（链表的形式），但是有放就有拿，这个消息怎样把它取出来呢？</p>
<p>翻看<code>MessageQueue</code>的方法，我们找到了<code>next()</code>方法，也就是出队方法。这个方法代码太长，可以不用细看我们知道它是用来把消息取出来的就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//如果消息的 looper 退出，就退出这个方法</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">    <span class="comment">//也是一个循环，有合适的消息就返回，没有就阻塞</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;    <span class="comment">//如果有需要过段时间再处理的消息，先调用 Binder 的这个方法</span></div><div class="line">            Binder.flushPendingCommands();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">//获取下一个消息</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">            Message prevMsg = <span class="keyword">null</span>;</div><div class="line">            Message msg = mMessages;    <span class="comment">//当前链表的头结点</span></div><div class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果消息没有 target，那它就是一个屏障，需要一直往后遍历找到第一个异步的消息</span></div><div class="line">                                do &#123;</div><div class="line">                    prevMsg = msg;</div><div class="line">                    msg = msg.next;</div><div class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;    <span class="comment">//如果这个消息还没到处理时间，就设置个时间过段时间再处理</span></div><div class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 消息是正常的、可以立即处理的</span></div><div class="line">                    mBlocked = <span class="keyword">false</span>;</div><div class="line">                    <span class="comment">//取出当前消息，链表头结点后移一位</span></div><div class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                        prevMsg.next = msg.next;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        mMessages = msg.next;</div><div class="line">                    &#125;</div><div class="line">                    msg.next = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                    msg.markInUse();    <span class="comment">//标记这个消息在被使用</span></div><div class="line">                    <span class="keyword">return</span> msg;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 消息链表里没有消息了</span></div><div class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//如果收到退出的消息，并且所有等待处理的消息都处理完时，调用 Native 方法销毁队列</span></div><div class="line">                        <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                dispose();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//有消息等待过段时间执行时，pendingIdleHandlerCount 增加</span></div><div class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                mBlocked = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">            &#125;</div><div class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                keep = idler.queueIdle();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!keep) &#123;</div><div class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                    mIdleHandlers.remove(idler);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>MessageQueue.next()</code> 方法里有一个循环，在这个循环中遍历消息链表，找到下一个可以处理的、<code>target</code> 不为空的消息并且执行时间不在未来的消息，就返回，否则就继续往后找。</p>
<p>如果有阻塞（没有消息了或者只有 Delay 的消息），会把 <code>mBlocked</code>这个变量标记为 <code>true</code>，在下一个 Message 进队时会判断这个<code>message</code> 的位置，如果在队首就会调用<code>nativeWake()</code> 方法唤醒线程！</p>
<p>不过<code>MessageQueue.next()</code> 这个方法是在什么地方调用的呢，不是在<code>Handler</code>中，我们找到了<strong><code>Looper</code></strong>这个关键人物，专门负责从消息队列中拿消息。</p>
<h2 id="Looper如何处理Message"><a href="#Looper如何处理Message" class="headerlink" title="Looper如何处理Message"></a>Looper如何处理Message</h2><p>我们又来到了<code>Looper</code>的阵地，他在调用MessageQueue的<code>next()</code>方法，来从消息队列中拿Message对象，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;    <span class="comment">//当前线程必须创建 Looper 才可以执行</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">//底层对 IPC 标识的处理，不用关心 </span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环模式</span></div><div class="line">        Message msg = queue.next(); <span class="comment">//从消息队列中读取消息，可能会阻塞</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;    <span class="comment">//当消息队列中没有消息时就会返回，不过这只发生在 queue 退出的时候</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            msg.target.dispatchMessage(msg);    <span class="comment">//调用消息关联的 Handler 处理消息</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        msg.recycleUnchecked();    <span class="comment">//标记这个消息被回收</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>Looper.loop()</code> 也很简单，就是调用消息队列 <code>MessageQueue.next()</code> 方法取消息，如果没有消息的话会阻塞，直到有新的消息进入或者消息队列退出。也就是不断重复下面的操作，直到没有消息时退出循环</p>
<ul>
<li>读取MessageQueue的下一条<strong>Message</strong>；</li>
<li>把Message分发给相应的<strong>target</strong>；</li>
<li>再把分发后的Message回收到消息池，以便重复利用。</li>
</ul>
<p>拿到消息后调用<code>msg.target</code>的<code>dispatchMessage(msg)</code>方法，而这个<code>msg.target</code>是什么呢？就是前面<code>Handler</code>发送消息<code>sendMessageAtTime()</code>时把自己赋值给<code>msg.target</code>的主线程的<code>mHandler</code>对象。也就是说，最后还是 Handler 负责处理消息。可以看到，<strong>Looper 并没有执行消息，真正执行消息的还是添加消息到队列中的那个 Handler</strong>。</p>
<p><img src="/gallery/android-handler/looper.png" alt="Looper处理Message的大致流程"></p>
<p>所以我们来看Handler中的<code>dispatchMessage(msg)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">    message.callback.run();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，Handler 在处理消息时，会有三种情况：</p>
<ol>
<li><strong>msg.callback 不为空</strong> <ul>
<li>这在使用 <code>Handler.postXXX(Runnable)</code> 发送消息的时候会发生</li>
<li>这就直接调用 Runnable 的 run() 方法</li>
</ul>
</li>
<li><strong>mCallback 不为空</strong> <ul>
<li>这在我们使用前面介绍的 Handler.Callback 为参数构造 Handler 时会发生</li>
<li>那就调用构造函数里传入的 <code>handleMessage()</code> 方法</li>
<li>如果返回 true，那就不往下走了</li>
</ul>
</li>
<li><strong>最后就调用<code>Handler.handleMessage()</code> 方法</strong><ul>
<li>这是一个空实现，需要我们在 Handler 子类里重写</li>
</ul>
</li>
</ol>
<p>而我们开头的例子，使用的就是第3种方法，大家可以回顾一下。</p>
<p><img src="/gallery/android-handler/0_1327991304aZK7.jpg" alt="子线程向主线程中发送UI更新消息的整体流程"></p>
<p>到这里，我们的疑问基本上就解决了，虽然没有再深入到jni层看native底层实现，但是java层的机制我们大概明白了。最后我们对上面的源码跟踪分析做一个宏观上的总结。</p>
<h2 id="整体运行机制"><a href="#整体运行机制" class="headerlink" title="整体运行机制"></a>整体运行机制</h2><h3 id="四大主角"><a href="#四大主角" class="headerlink" title="四大主角"></a>四大主角</h3><p>与Windows系统一样，Android也是消息驱动型的系统。引用一下消息驱动机制的四要素：</p>
<ul>
<li>接收消息的“消息队列”</li>
<li>阻塞式地从消息队列中接收消息并进行处理的“线程”</li>
<li>可发送的“消息的格式”</li>
<li>“消息发送函数”</li>
</ul>
<p>与之对应，Android中的实现对应了</p>
<ul>
<li>接收消息的“消息队列” ——【MessageQueue】</li>
<li>阻塞式地从消息队列中接收消息并进行处理的“线程” ——【Thread+Looper】</li>
<li>可发送的“消息的格式” ——【Message】</li>
<li>“消息发送函数”——【Handler的post和sendMessage】</li>
</ul>
<p>也就是说，消息机制主要包含以下四个主角：</p>
<ul>
<li><strong>Message</strong>：消息分为硬件产生的消息（如按钮、触摸）和软件生成的消息；</li>
<li><strong>MessageQueue</strong>：消息队列的主要功能向消息池投递消息（<code>MessageQueue.enqueueMessage()</code>）和取走消息池的消息（<code>MessageQueue.next()</code>）；</li>
<li><strong>Handler</strong>：消息辅助类，主要功能向消息池发送各种消息事件（<code>Handler.sendMessage()</code>）和处理相应消息事件（<code>Handler.handleMessage()</code>）；</li>
<li><strong>Looper</strong>：不断循环执行（<code>Looper.loop()</code>），按分发机制将消息分发给目标处理者。</li>
</ul>
<p>他们之间的关系如下：</p>
<ul>
<li><strong>Thread</strong>：一个线程有唯一一个对应的Looper；</li>
<li><strong>Looper</strong>：有一个MessageQueue消息队列；</li>
<li><strong>MessageQueue</strong>：有一组待处理的Message；</li>
<li><strong>Message</strong>中有一个用于处理消息的Handler；</li>
<li><strong>Handler</strong>中有Looper和MessageQueue。</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/gallery/android-handler/1836169-c13aab3f58697aaa.png" alt=""></p>
<p>一个<code>Looper</code>类似一个消息泵。它本身是一个死循环，不断地从<code>MessageQueue</code>中提取<code>Message</code>或者Runnable。而<code>Handler</code>可以看做是一个<code>Looper</code>的暴露接口，向外部暴露一些事件，并暴露<code>sendMessage()</code>和<code>post()</code>函数。</p>
<p>在安卓中，除了<code>UI线程</code>/<code>主线程</code>以外，普通的线程(先不提<code>HandlerThread</code>)是不自带<code>Looper</code>的。想要通过UI线程与子线程通信需要在子线程内自己实现一个<code>Looper</code>。开启Looper分<strong>三步走</strong>：</p>
<ol>
<li>判定是否已有<code>Looper</code>并<code>Looper.prepare()</code></li>
<li>做一些准备工作(如暴露handler等)</li>
<li>调用<code>Looper.loop()</code>，线程进入阻塞态</li>
</ol>
<p>由于每一个线程内最多只可以有一个<code>Looper</code>，所以一定要在<code>Looper.prepare()</code>之前做好判定，否则会抛出<code>java.lang.RuntimeException: Only one Looper may be created per thread</code>。为了获取Looper的信息可以使用两个方法：</p>
<ul>
<li>Looper.myLooper()</li>
<li>Looper.getMainLooper()</li>
</ul>
<p><code>Looper.myLooper()</code>获取当前线程绑定的Looper，如果没有返回<code>null</code>。<code>Looper.getMainLooper()</code>返回主线程的<code>Looper</code>,这样就可以方便的与主线程通信。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>Looper</code>调用<code>prepare()</code>进行初始化，创建了一个与当前线程对应的<code>Looper</code>对象（通过<code>ThreadLocal</code>实现），并且初始化了一个与当前<code>Looper</code>对应的<code>MessageQueue</code>对象。</li>
<li><code>Looper</code>调用静态方法<code>loop()</code>开始消息循环，通过<code>MessageQueue.next()</code>方法获取<code>Message</code>对象。</li>
<li>当获取到一个<code>Message</code>对象时，让<code>Message</code>的发送者（<code>target</code>）去处理它。</li>
<li><code>Message</code>对象包括数据，发送者（<code>Handler</code>），可执行代码段（<code>Runnable</code>）三个部分组成。</li>
<li><code>Handler</code>可以在一个已经<code>Looper.prepare()</code>的线程中初始化，如果线程没有初始化<code>Looper</code>，创建<code>Handler</code>对象会失败</li>
<li>一个线程的执行流中可以构造多个<code>Handler</code>对象，它们都往同一个MQ中发消息，消息也只会分发给对应的<code>Handler</code>处理。</li>
<li><code>Handler</code>将消息发送到MQ中，<code>Message</code>的<code>target</code>域会引用自己的发送者，<code>Looper</code>从MQ中取出来后，再交给发送这个<code>Message</code>的<code>Handler</code>去处理。</li>
<li><code>Message</code>可以直接添加一个<code>Runnable</code>对象，当这条消息被处理的时候，直接执行<code>Runnable.run()</code>方法。</li>
</ul>
<h2 id="Handler的内存泄露问题"><a href="#Handler的内存泄露问题" class="headerlink" title="Handler的内存泄露问题"></a>Handler的内存泄露问题</h2><p>再来看看我们的新建Handler的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有Activity的引用。</strong></p>
<p>而Handler通常会伴随着一个耗时的后台线程一起出现，这个后台线程在任务执行完毕后发送消息去更新UI。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束。</p>
<p>另外，如果执行了Handler的postDelayed()方法，那么在设定的delay到达之前，会有一条<strong>MessageQueue -&gt; Message -&gt; Handler -&gt; Activity</strong>的链，导致你的Activity被持有引用而无法被回收。</p>
<p>解决方法之一，使用弱引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    WeakReference&lt;Activity &gt; mActivityReference;</div><div class="line">    MyHandler(Activity activity) &#123;</div><div class="line">        mActivityReference= <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Activity activity = mActivityReference.get();</div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">            mImageView.setImageBitmap(mBitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从JDK1.2开始，Java把对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<ol>
<li><p><strong>强引用</strong>：我们一般使用的就是强引用，垃圾回收器一般都不会对其进行回收操作。当内存空间不足时Java虚拟机宁愿抛出OutOfMemoryError错误使程序异常终止，也不会回收具有强引用的对象。</p>
</li>
<li><p><strong>软引用(SoftReference)</strong>：如果一个对象具有软引用(SoftReference)，在内存空间足够的时候GC不会回收它，如果内存空间不足了GC就会回收这些对象的内存空间。</p>
</li>
<li><p><strong>弱引用(WeakReference)</strong> ：如果一个对象具有弱引用(WeakReference)，那么当GC线程扫描的过程中一旦发现某个对象只具有弱引用而不存在强引用时不管当前内存空间足够与否GC都会回收它的内存。由于垃圾回收器是一个优先级较低的线程，所以不一定会很快发现那些只具有弱引用的对象。为了防止内存溢出，在处理一些占用内存大而且生命周期较长的对象时候，可以尽量使用软引用和弱引用。</p>
</li>
<li><p><strong>虚引用(PhantomReference)</strong> ：虚引用(PhantomReference)与其他三种引用都不同，它并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。所以，虚引用主要用来跟踪对象被垃圾回收器回收的活动，在一般的开发中并不会使用它。</p>
</li>
</ol>
<h2 id="进程、线程间通信方式"><a href="#进程、线程间通信方式" class="headerlink" title="进程、线程间通信方式"></a>进程、线程间通信方式</h2><p>文章最后，我们来整理一下进程、线程间通信方式，参考<a href="http://www.cnblogs.com/xh0102/p/5710074.html" target="_blank" rel="external">线程通信与进程通信的区别</a>。看看Handler消息传递机制属于哪种？</p>
<h3 id="一、进程间的通信方式"><a href="#一、进程间的通信方式" class="headerlink" title="一、进程间的通信方式"></a>一、进程间的通信方式</h3><ul>
<li><strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li><strong>有名管道 (namedpipe)</strong> ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li><strong>信号量(semophore )</strong> ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>消息队列( messagequeue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li><strong>信号 (sinal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li><strong>共享内存(shared memory )</strong> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li><strong>套接字(socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>IPC</strong></th>
<th><strong>数据拷贝次数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>共享内存</td>
<td>0</td>
</tr>
<tr>
<td>Android Binder</td>
<td>1</td>
</tr>
<tr>
<td>Socket/管道/消息队列</td>
<td>2</td>
</tr>
</tbody>
</table>
<h3 id="二、线程间的通信方式"><a href="#二、线程间的通信方式" class="headerlink" title="二、线程间的通信方式"></a>二、线程间的通信方式</h3><ul>
<li><strong>锁机制</strong>：包括互斥锁、条件变量、读写锁<ol>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ol>
</li>
<li><strong>信号量机制(Semaphore)</strong>：包括无名线程信号量和命名线程信号量</li>
<li><strong>信号机制(Signal)</strong>：类似进程间的信号处理</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<blockquote>
<p>很明显，Android的Handler消息机制使用消息队列( MessageQueue )实现的线程间通信方式。而Binder是Android建立额一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求。<strong>Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送方添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。</strong>此处就不对Binder作更多介绍了。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="external">Android消息机制1-Handler(Java层)</a></li>
<li><a href="http://blog.csdn.net/ly502541243/article/details/52062179/" target="_blank" rel="external">从Handler.post(Runnable r)再一次梳理Android的消息机制</a></li>
<li><a href="http://blog.csdn.net/u011240877/article/details/72892321" target="_blank" rel="external"><a href="http://blog.csdn.net/u011240877/article/details/72892321" target="_blank" rel="external">Android 进阶14：源码解读 Android 消息机制（ Message MessageQueue Handler Looper）</a></a></li>
<li><a href="http://www.jianshu.com/p/10dd4d605d40" target="_blank" rel="external">Android源码：Handler, Looper和MessageQueue实现解析</a></li>
<li><a href="http://www.androidchina.net/6053.html" target="_blank" rel="external">深入探讨Android异步精髓Handler</a></li>
<li><a href="https://hzj163.gitbooks.io/android-thread/content/androidxiao_xi_ji_zhi.html" target="_blank" rel="external">Android消息机制</a></li>
<li><a href="https://hit-alibaba.github.io/interview/Android/basic/Android-handler-thread-looper.html" target="_blank" rel="external">哈工大面试指导：Android中的Thread, Looper和Handler机制</a></li>
<li><a href="http://blog.csdn.net/fenggit/article/details/50766820" target="_blank" rel="external">Android 线程本地变量&lt;一&gt; ThreadLocal源码解析</a></li>
<li><a href="http://www.cnblogs.com/whoislcj/p/5811989.html" target="_blank" rel="external">Android线程管理之ThreadLocal理解及应用场景</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;多线程的消息传递处理，从初学Android时的Handler，懵懵懂懂地照猫画虎，到后来一头雾水的疑惑它为什么这么复杂，再到熟悉之后的叹为观止，一步步地都是自己踩过的足迹，都是成长啊哈哈哈。虽然离出神入化的境界还远十万八千里呢，但Android中的Handler多线程消息传递机制，的确是研发技术学习中不可多得的一个宝藏。本来我以为自己之前的学习以及比较了解 Handler，在印象中 Android 消息机制无非就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Handler 给 MessageQueue 添加消息&lt;/li&gt;
&lt;li&gt;然后 Looper 无限循环读取消息&lt;/li&gt;
&lt;li&gt;再调用 Handler 处理消息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是只知道整体流程，细节还不是特别透彻。最近不甚忙碌，回头看到这块又有些许收获，我们来记录一下吧。&lt;/p&gt;
&lt;p&gt;在整个Android的源码世界里，有两大利剑，其一是&lt;strong&gt;Binder IPC机制&lt;/strong&gt;，另一个便是&lt;strong&gt;消息机制&lt;/strong&gt;。Android有大量的消息驱动方式来进行交互，比如Android的四剑客&lt;code&gt;Activity&lt;/code&gt;, &lt;code&gt;Service&lt;/code&gt;, &lt;code&gt;Broadcast&lt;/code&gt;, &lt;code&gt;ContentProvider&lt;/code&gt;的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。而Android 消息机制主要涉及 4 个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handler&lt;/li&gt;
&lt;li&gt;Message&lt;/li&gt;
&lt;li&gt;MessageQueue&lt;/li&gt;
&lt;li&gt;Looper&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们依次结合源码分析一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://github.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Android】Binder - 如何使用AIDL</title>
    <link href="http://github.com/2017/08/02/%E3%80%90Android%E3%80%91Binder%20-%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8AIDL/"/>
    <id>http://github.com/2017/08/02/【Android】Binder - 如何使用AIDL/</id>
    <published>2017-08-02T14:20:55.000Z</published>
    <updated>2017-11-02T10:20:16.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、跨进程通信"><a href="#一、跨进程通信" class="headerlink" title="一、跨进程通信"></a>一、跨进程通信</h3><p>为了演示方便，将Service与Activity处于不同的进程，可以在AndroidManifest.xml中，把service配置成<code>android:process=&quot;:remote&quot;</code> ，也可以命名成其他的。</p>
<h4 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h4><p>（1） IRemoteService.aidl：定义Server端提供的服务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// IRemoteService.aidl</span></div><div class="line"><span class="keyword">package</span> com.cuc.myandroidtest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.cuc.myandroidtest.MyData;</div><div class="line"><span class="keyword">import</span> com.cuc.myandroidtest.IServiceCallback;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>;			<span class="comment">//获取服务端进程ID</span></div><div class="line">    <span class="function">MyData <span class="title">getMyData</span><span class="params">()</span></span>;		<span class="comment">//从服务端获取数据</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerCallback</span><span class="params">(IServiceCallback callback)</span></span>;		<span class="comment">//注册服务端回调</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterCallback</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（2） IServiceCallBack.aidl：定义服务端回调接口，把Service的下载进度通知给客户端ClientActivity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// IServiceCallBack.aidl</span></div><div class="line"><span class="keyword">package</span> com.cuc.myandroidtest;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IServiceCallback</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDownloadProgress</span><span class="params">(<span class="keyword">double</span> progress)</span></span>;   <span class="comment">//服务端下载进度通知</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDownloadCompleted</span><span class="params">()</span></span>;                 <span class="comment">//下载完成通知</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（3） MyData.aidl：定义传输的Parcel数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MyData.aidl</span></div><div class="line"><span class="keyword">package</span> com.cuc.myandroidtest;</div><div class="line"></div><div class="line">parcelable MyData;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="Parcel数据"><a href="#Parcel数据" class="headerlink" title="Parcel数据"></a>Parcel数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> data1;</div><div class="line">	<span class="keyword">int</span> data2;</div><div class="line">	String key;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyData</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">MyData</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">		data1 = in.readInt();</div><div class="line">		data2 = in.readInt();</div><div class="line">		key = in.readString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;MyData&gt; CREATOR = <span class="keyword">new</span> Creator&lt;MyData&gt;() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> MyData <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MyData(in);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="keyword">public</span> MyData[] newArray(<span class="keyword">int</span> size) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MyData[size];</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">      <span class="comment">/** 将数据写入到Parcel **/</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">		dest.writeInt(data1);</div><div class="line">		dest.writeInt(data2);</div><div class="line">		dest.writeString(key);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData1</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> data1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData1</span><span class="params">(<span class="keyword">int</span> data1)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.data1 = data1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData2</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> data2;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData2</span><span class="params">(<span class="keyword">int</span> data2)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.data2 = data2;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> key;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.key = key;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderSimple"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> mDownloadCount = <span class="number">0</span>;</div><div class="line">	MyData mMyData;</div><div class="line">	IServiceCallback mCallback;    <span class="comment">//用来通知客户端的回调</span></div><div class="line">	ScheduledExecutorService mThreadPool;    <span class="comment">//下载线程</span></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">		Log.i(TAG, <span class="string">"[RemoteService] onCreate"</span>);</div><div class="line"></div><div class="line">		mMyData = <span class="keyword">new</span> MyData();</div><div class="line">		mMyData.setData1(<span class="number">10</span>);</div><div class="line">		mMyData.setData2(<span class="number">20</span>);</div><div class="line">		mMyData.setKey(<span class="string">"在那遥远的地方"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		Log.i(TAG,<span class="string">"[RemoteService] onBind"</span>);</div><div class="line"></div><div class="line">		<span class="comment">//开始下载</span></div><div class="line">		startDownloadThread();</div><div class="line">		<span class="keyword">return</span> mBinder;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"[RemoteService] onUnbind"</span>);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			mBinder.unregisterCallback();</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onUnbind(intent);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"[RemoteService] onDestroy"</span>);</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 实现接口IRemoteService.aidl中定义的方法</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			Log.i(TAG,<span class="string">"[RemoteService] getPid() = "</span> + android.os.Process.myPid());</div><div class="line">			<span class="keyword">return</span> android.os.Process.myPid();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> MyData <span class="title">getMyData</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			Log.i(TAG,<span class="string">"[RemoteService] getMyData()  "</span> + mMyData.toString());</div><div class="line">			<span class="keyword">return</span> mMyData;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCallback</span><span class="params">(IServiceCallback callback)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			Log.i(TAG,<span class="string">"[RemoteService] registerCallback()  "</span>);</div><div class="line">			mCallback = callback;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterCallback</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			Log.i(TAG,<span class="string">"[RemoteService] unregisterCallback()  "</span>);</div><div class="line">			mCallback = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/**此处可用于权限拦截**/</span></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 模拟下载线程</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startDownloadThread</span><span class="params">()</span></span>&#123;</div><div class="line">		Log.i(TAG,<span class="string">"[RemoteService] startDownloadThread()"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//2秒后开始下载</span></div><div class="line">		mThreadPool = Executors.newScheduledThreadPool(<span class="number">1</span>);</div><div class="line">		mThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					mDownloadCount++;</div><div class="line">					<span class="keyword">if</span>(mCallback != <span class="keyword">null</span>)&#123;</div><div class="line">						mCallback.onDownloadProgress((<span class="keyword">double</span>) mDownloadCount / <span class="number">100.0</span>);</div><div class="line">						<span class="keyword">if</span> (mDownloadCount == <span class="number">100</span>) &#123;</div><div class="line">							mCallback.onDownloadCompleted();</div><div class="line">							mThreadPool.shutdown();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;, <span class="number">2000</span>, <span class="number">50</span>, TimeUnit.MILLISECONDS);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderSimple"</span>;</div><div class="line">	<span class="keyword">private</span> IRemoteService mRemoteService;</div><div class="line">	<span class="keyword">private</span> TextView textView;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> mIsBound;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_client);</div><div class="line"></div><div class="line">		textView = (TextView) findViewById(R.id.tv);</div><div class="line">		Button btn0 = (Button) findViewById(R.id.btn_bind);</div><div class="line">		Button btn1 = (Button) findViewById(R.id.btn_unbind);</div><div class="line">		Button btn2 = (Button) findViewById(R.id.btn_kill);</div><div class="line">		btn0.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				bindMyService();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		btn1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				unBindMyService();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		btn2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				killMyService();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ServiceConnection mRemoteConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">			<span class="comment">//注意这里，把Server返回的Binder对象转换成了IRemoteService接口对象</span></div><div class="line">			mRemoteService = IRemoteService.Stub.asInterface(service);</div><div class="line"></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				mRemoteService.registerCallback(mServiceCallbackBinder);</div><div class="line"></div><div class="line">				MyData myData = mRemoteService.getMyData();</div><div class="line">				String pidInfo = <span class="string">" servicePid = "</span>+ mRemoteService.getPid() +</div><div class="line">						<span class="string">"\n myPid = "</span> + android.os.Process.myPid() +</div><div class="line">						<span class="string">"\n data1 = "</span>+ myData.getData1() +</div><div class="line">						<span class="string">"\n data2 = "</span>+ myData.getData2() +</div><div class="line">						<span class="string">"\n key = "</span>+ myData.getKey();</div><div class="line"></div><div class="line">				Log.i(TAG, <span class="string">"[ClientActivity] onServiceConnected\n"</span> + pidInfo);</div><div class="line">				textView.setText(pidInfo);</div><div class="line">				Toast.makeText(ClientActivity.<span class="keyword">this</span>, <span class="string">"remoteService 连接成功"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">			&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">			Log.i(TAG, <span class="string">"[ClientActivity] onServiceDisconnected"</span>);</div><div class="line">			mRemoteService = <span class="keyword">null</span>;</div><div class="line">			Toast.makeText(ClientActivity.<span class="keyword">this</span>, <span class="string">"remoteService 断开连接"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">//服务回调</span></div><div class="line">	<span class="keyword">private</span> IServiceCallback.Stub mServiceCallbackBinder = <span class="keyword">new</span> IServiceCallback.Stub()&#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDownloadProgress</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> progress)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">			handler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					textView.setText(<span class="string">"下载进度:"</span> + progress);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDownloadCompleted</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			Log.i(TAG, <span class="string">"[ClientActivity] mServiceCallbackBinder -&gt; onDownloadCompleted"</span>);</div><div class="line">			Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">			handler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					textView.setText(<span class="string">"下载完成"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 绑定远程服务</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMyService</span><span class="params">()</span></span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"[ClientActivity] bindMyService"</span>);</div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(ClientActivity.<span class="keyword">this</span>, RemoteService.class);</div><div class="line">		intent.setAction(IRemoteService.class.getName());</div><div class="line">		bindService(intent, mRemoteConnection, Context.BIND_AUTO_CREATE);</div><div class="line"></div><div class="line">		mIsBound = <span class="keyword">true</span>;</div><div class="line">		textView.setText(<span class="string">"bind success"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 解除绑定远程服务</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unBindMyService</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(!mIsBound)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		Log.i(TAG, <span class="string">"[ClientActivity] unBindMyService"</span>);</div><div class="line">		unbindService(mRemoteConnection);</div><div class="line"></div><div class="line">		mIsBound = <span class="keyword">false</span>;</div><div class="line">		textView.setText(<span class="string">"unbind"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 杀死远程服务</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">killMyService</span><span class="params">()</span></span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"[ClientActivity] killMyService"</span>);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			android.os.Process.killProcess(mRemoteService.getPid());</div><div class="line">			textView.setText(<span class="string">"kill success"</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			Toast.makeText(ClientActivity.<span class="keyword">this</span>, <span class="string">"kill failed"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>该工程会生成一个apk，安装到手机，打开apk，界面如下：</p>
<p><img src="/gallery/android-binder/demoapk.gif" alt=""></p>
<p>界面上有三个按钮，分别是功能分别是：</p>
<ul>
<li>bindService（绑定Service）</li>
<li>unbindService（解除绑定Service）</li>
<li>killProcess（杀死Service进程）</li>
</ul>
<p>从左往右，依次点击界面，可得：</p>
<p><img src="/gallery/android-binder/bind-service-log.png" alt=""></p>
<p><img src="/gallery/android-binder/unbind-service-log.png" alt=""></p>
<p><img src="/gallery/android-binder/kill-process_log.png" alt=""></p>
<h3 id="二、同一进程"><a href="#二、同一进程" class="headerlink" title="二、同一进程"></a>二、同一进程</h3><p>如果Activity和Service位于同一进程内，也可以使用上面的方式。不过还有一种方法是下面这种。</p>
<p>AIDL文件、Parcel数据与上面均一致，下面仅列出不同的Server端和Client端的实现。</p>
<h4 id="Server端-1"><a href="#Server端-1" class="headerlink" title="Server端"></a>Server端</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderSimple"</span>;</div><div class="line"></div><div class="line">  	<span class="comment">//封装的服务端功能对象，供Client端bindService之后调用</span></div><div class="line">	<span class="keyword">private</span> LocalServerFunc mBinder = <span class="keyword">new</span> LocalServerFunc();</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">		Log.i(TAG, <span class="string">"[LocalService] onCreate"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		Log.i(TAG,<span class="string">"[LocalService] onBind"</span>);</div><div class="line"></div><div class="line">		<span class="comment">//开启下载线程</span></div><div class="line">		mBinder.startDownloadThread();</div><div class="line">		<span class="keyword">return</span> mBinder;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"[LocalService] onUnbind"</span>);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			mBinder.unregisterCallback();</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onUnbind(intent);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"[LocalService] onDestroy"</span>);</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为，Service被bind了之后，需要返回一个IBinder对象。所以需要继承自Binder封装一个IBinder对象供客户端调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalServerFunc</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IRemoteService</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderSimple"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> mDownloadCount = <span class="number">0</span>;</div><div class="line">	MyData mMyData;</div><div class="line">	IServiceCallback mCallback;</div><div class="line">	ScheduledExecutorService mThreadPool;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LocalServerFunc</span><span class="params">()</span></span>&#123;</div><div class="line">		mMyData = <span class="keyword">new</span> MyData();</div><div class="line">		mMyData.setData1(<span class="number">66</span>);</div><div class="line">		mMyData.setData2(<span class="number">88</span>);</div><div class="line">		mMyData.setKey(<span class="string">"就在眼前"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownloadThread</span><span class="params">()</span></span>&#123;</div><div class="line">		Log.i(TAG,<span class="string">"[LocalServerFunc] startDownloadThread()"</span>);</div><div class="line">		mThreadPool = Executors.newScheduledThreadPool(<span class="number">1</span>);</div><div class="line">		mThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					mDownloadCount++;</div><div class="line">					<span class="keyword">if</span>(mCallback != <span class="keyword">null</span>)&#123;</div><div class="line">						mCallback.onDownloadProgress((<span class="keyword">double</span>) mDownloadCount / <span class="number">100.0</span>);</div><div class="line">						<span class="keyword">if</span> (mDownloadCount == <span class="number">100</span>) &#123;</div><div class="line">							mCallback.onDownloadCompleted();</div><div class="line">							mThreadPool.shutdown();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;, <span class="number">2000</span>, <span class="number">50</span>, TimeUnit.MILLISECONDS);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		Log.i(TAG,<span class="string">"[LocalServerFunc] getPid()"</span>);</div><div class="line">		<span class="keyword">return</span> android.os.Process.myPid();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> MyData <span class="title">getMyData</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		Log.i(TAG,<span class="string">"[LocalServerFunc] getMyData()"</span>);</div><div class="line">		<span class="keyword">return</span> mMyData;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCallback</span><span class="params">(IServiceCallback callback)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		Log.i(TAG,<span class="string">"[LocalServerFunc] registerCallback()"</span>);</div><div class="line">		mCallback = callback;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterCallback</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		Log.i(TAG,<span class="string">"[LocalServerFunc] unregisterCallback()"</span>);</div><div class="line">		<span class="keyword">if</span>(mThreadPool != <span class="keyword">null</span>)&#123;</div><div class="line">			mThreadPool.shutdown();</div><div class="line">		&#125;</div><div class="line">		mCallback = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Client端-1"><a href="#Client端-1" class="headerlink" title="Client端"></a>Client端</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderSimple"</span>;</div><div class="line">	<span class="keyword">private</span> IRemoteService mLocalService;</div><div class="line">	<span class="keyword">private</span> TextView textView;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> mIsBound;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_client);</div><div class="line"></div><div class="line">		textView = (TextView) findViewById(R.id.tv);</div><div class="line">		Button btn0 = (Button) findViewById(R.id.btn_bind);</div><div class="line">		Button btn1 = (Button) findViewById(R.id.btn_unbind);</div><div class="line">		Button btn2 = (Button) findViewById(R.id.btn_kill);</div><div class="line">		btn0.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				bindMyService();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		btn1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				unBindMyService();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		btn2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				killMyService();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">			<span class="comment">//注意这个Binder对象转换成IRemoteService接口方式的不同 </span></div><div class="line">			mLocalService = (IRemoteService) service;</div><div class="line"></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				mLocalService.registerCallback(mLocalServiceCallback);</div><div class="line"></div><div class="line">				MyData myData = mLocalService.getMyData();</div><div class="line">				String pidInfo = <span class="string">" servicePid = "</span>+ mLocalService.getPid() +</div><div class="line">						<span class="string">"\n myPid = "</span> + android.os.Process.myPid() +</div><div class="line">						<span class="string">"\n data1 = "</span>+ myData.getData1() +</div><div class="line">						<span class="string">"\n data2 = "</span>+ myData.getData2() +</div><div class="line">						<span class="string">"\n key = "</span>+ myData.getKey();</div><div class="line"></div><div class="line">				Log.i(TAG, <span class="string">"[ClientActivity] onServiceConnected\n"</span> + pidInfo);</div><div class="line">				textView.setText(pidInfo);</div><div class="line">				Toast.makeText(ClientActivity.<span class="keyword">this</span>, <span class="string">"localService 连接成功"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">			&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">			Log.i(TAG, <span class="string">"[ClientActivity] onServiceDisconnected"</span>);</div><div class="line">			mLocalService = <span class="keyword">null</span>;</div><div class="line">			Toast.makeText(ClientActivity.<span class="keyword">this</span>, <span class="string">"localService 断开连接"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">//服务回调，注意这个对象的不同</span></div><div class="line">	<span class="keyword">private</span> IServiceCallback mLocalServiceCallback = <span class="keyword">new</span> IServiceCallback() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDownloadProgress</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> progress)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">			handler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					textView.setText(<span class="string">"下载进度:"</span> + progress);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDownloadCompleted</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			Log.i(TAG, <span class="string">"[ClientActivity] mServiceCallback -&gt; onDownloadCompleted"</span>);</div><div class="line"></div><div class="line">			Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">			handler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					textView.setText(<span class="string">"下载完成"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 绑定服务</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMyService</span><span class="params">()</span></span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"[ClientActivity] bindMyService"</span>);</div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(ClientActivity.<span class="keyword">this</span>, LocalService.class);</div><div class="line">		intent.setAction(IRemoteService.class.getName());</div><div class="line">		bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</div><div class="line"></div><div class="line">		mIsBound = <span class="keyword">true</span>;</div><div class="line">		textView.setText(<span class="string">"bind success"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 解除绑定服务</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unBindMyService</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(!mIsBound)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		Log.i(TAG, <span class="string">"[ClientActivity] unBindMyService"</span>);</div><div class="line">		unbindService(mServiceConnection);</div><div class="line"></div><div class="line">		mIsBound = <span class="keyword">false</span>;</div><div class="line">		textView.setText(<span class="string">"unbind"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 杀死服务</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">killMyService</span><span class="params">()</span></span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"[ClientActivity] killMyService"</span>);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			android.os.Process.killProcess(mLocalService.getPid());</div><div class="line">			textView.setText(<span class="string">"kill success"</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			Toast.makeText(ClientActivity.<span class="keyword">this</span>, <span class="string">"kill failed"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><p>因为这个Acitivy和Sevice位于同一进程，所以当点击KILL按钮杀死Service进程时，Activity也会同时被杀掉，所以可以看到动画最后就退出了App。</p>
<p><img src="/gallery/android-binder/ezgif-5-bba2b7e591.gif" alt=""></p>
<p>从左往右，依次点击三个按钮，可得：</p>
<p><img src="/gallery/android-binder/bind-localservice.png" alt=""></p>
<p><img src="/gallery/android-binder/unbind-localservice.png" alt=""></p>
<p><img src="/gallery/android-binder/kill-localservice.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="external">Android 接口定义语言 (AIDL)</a> - Google Developer文档</li>
<li><a href="http://gityuan.com/2015/11/23/binder-aidl/" target="_blank" rel="external">Binder系列9—如何使用AIDL</a></li>
<li><a href="http://blog.csdn.net/saberviii/article/details/51470347" target="_blank" rel="external">Android跨进程bindService与callback</a></li>
<li><a href="http://blog.csdn.net/liuyi1207164339/article/details/51683544" target="_blank" rel="external">在Activity和Service之间使用本地Binder和回调接口进行通信</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、跨进程通信&quot;&gt;&lt;a href=&quot;#一、跨进程通信&quot; class=&quot;headerlink&quot; title=&quot;一、跨进程通信&quot;&gt;&lt;/a&gt;一、跨进程通信&lt;/h3&gt;&lt;p&gt;为了演示方便，将Service与Activity处于不同的进程，可以在AndroidManifest.xml中，把service配置成&lt;code&gt;android:process=&amp;quot;:remote&amp;quot;&lt;/code&gt; ，也可以命名成其他的。&lt;/p&gt;
&lt;h4 id=&quot;AIDL&quot;&gt;&lt;a href=&quot;#AIDL&quot; class=&quot;headerlink&quot; title=&quot;AIDL&quot;&gt;&lt;/a&gt;AIDL&lt;/h4&gt;&lt;p&gt;（1） IRemoteService.aidl：定义Server端提供的服务接口&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// IRemoteService.aidl&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.cuc.myandroidtest;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; com.cuc.myandroidtest.MyData;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; com.cuc.myandroidtest.IServiceCallback;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IRemoteService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getPid&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;			&lt;span class=&quot;comment&quot;&gt;//获取服务端进程ID&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;MyData &lt;span class=&quot;title&quot;&gt;getMyData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;		&lt;span class=&quot;comment&quot;&gt;//从服务端获取数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;registerCallback&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(IServiceCallback callback)&lt;/span&gt;&lt;/span&gt;;		&lt;span class=&quot;comment&quot;&gt;//注册服务端回调&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;unregisterCallback&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2） IServiceCallBack.aidl：定义服务端回调接口，把Service的下载进度通知给客户端ClientActivity&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// IServiceCallBack.aidl&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.cuc.myandroidtest;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IServiceCallback&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDownloadProgress&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; progress)&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;//服务端下载进度通知&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDownloadCompleted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;                 &lt;span class=&quot;comment&quot;&gt;//下载完成通知&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3） MyData.aidl：定义传输的Parcel数据&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// MyData.aidl&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.cuc.myandroidtest;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;parcelable MyData;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>连通图的最大生成树的权和</title>
    <link href="http://github.com/2017/07/31/Google%20%E7%AC%94%E8%AF%95%E9%A2%98%20-%20%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%9D%83%E5%92%8C/"/>
    <id>http://github.com/2017/07/31/Google 笔试题 - 连通图的最大生成树的权和/</id>
    <published>2017-07-31T09:20:55.000Z</published>
    <updated>2017-08-01T02:27:59.366Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道Google 笔试题</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个有n个结点的连通图的生成树是原图的最小连通子图, 且包含原图中所有n个结点，并且有保持图联通的最少的边。最大生成树就是权和最大生成树，现在给出一个无向带权图的邻接矩阵，权为0表示没有边。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;&#123;0, 4, 5, 0, 3&#125;, </div><div class="line"> &#123;4, 0, 4, 2, 3&#125;, </div><div class="line"> &#123;5, 4, 0, 2, 0&#125;, </div><div class="line"> &#123;0, 2, 2, 0, 1&#125;, </div><div class="line"> &#123;3, 3, 0, 1, 0&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>求这个图的最大生成树的权和。</p>
<p>A、11</p>
<p>B、12</p>
<p>C、13</p>
<p>D、14</p>
<p>E、15</p>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题意是在考察最大生成树，我们需要根据给出的邻接矩阵代表的无向带权图求出最大生成树，然后计算权和就很简单水到渠成了。</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>说到最大生成树，我们得先回顾一下最小生成树：</p>
<p>最小生成树其实是最小权重生成树的简称。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。也就是说最小生成树就是<strong>边权重之和最小</strong>的生成树。总结起来就是以下：</p>
<ul>
<li>1）必须使用且仅使用该网络中的n-1条边来连接网络中的n个顶点。</li>
<li>2）不能使用产生回路的边。</li>
<li>3）各边上的权值的总和达到最小。</li>
</ul>
<p>简单点说有几个城市你要设计一个路线，这个路线能走完所有的这几个城市，而且路程最短，这个路线就是最小生成树的含义。相反地，最大生成树就是边权重之和最大的生成树。</p>
<p>那么，如何生成最小生成树呢？常用的算法有<strong><a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="external">Prim算法</a></strong>（普里姆算法）和<strong><a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="external">Kruskal算法</a></strong>（克鲁斯克尔算法）。</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>Prim算法是用来从带权图中搜索最小生成树的一种算法。 从单一顶点开始，Prim普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p>
<ol>
<li><p>输入：一个加权连通图，其中顶点集合为$V$ ，边集合为$E$；</p>
</li>
<li><p>初始化：$V_{new} = {x}$ ，其中x为集合V中的任一节点（起始点）， $E_{new} = \{\}$ ；</p>
</li>
<li><p>重复下列操作，直到$V_{new} = V$ ：</p>
<p><strong>a.</strong> 在集合E中选取权值最小的边（u, v），其中u为集合$V_{new}​$中的元素，而v则是V中没有加入$V_{new}​$的顶点（如<strong>b.</strong> 果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；将v加入集合$V_{new}​$中，将（u, v）加入集合$E_{new}​$中；</p>
</li>
<li><p>输出：使用集合$V_{new}$和$E_{new}$来描述所得到的最小生成树。</p>
</li>
</ol>
<p>算法伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Prim(G, T) &#123;</div><div class="line">    T = NULL;</div><div class="line">    U = &#123;w&#125;;    <span class="comment">//添加任一顶点w</span></div><div class="line">    <span class="keyword">while</span>((V - U)!=NULL) &#123;</div><div class="line">        设(u, v)是u ∈ U 与 v ∈ （V - U),且权值最小的边</div><div class="line">        T = T ∪ (u, v);</div><div class="line">        U = U ∪ v ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说白了，就是将起点u（任一节点）放入空集合S，则S = {u}；再找到距离集合S最近的一点u，加入S集合。直到所有节点都加入进来。</p>
<blockquote>
<p>Prim算法时间复杂度为O(V^2)，比较适合于求稠密图的最小生成树。</p>
</blockquote>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a><strong>Kruskal算法</strong></h3><p>Kruskal算法是一种按权值的递增次序选择合适的边来构成最小生成树的方法。算法描述如下：</p>
<ol>
<li>新建图G，G中拥有原图中相同的节点，但没有边</li>
<li>将原图中所有的边按权值从小到大排序</li>
<li>从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中</li>
<li>重复3，直至图G中所有的节点都在同一个连通分量中</li>
</ol>
<p>算法伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">KRUSKAL-FUNCTION(G, w)</div><div class="line">    F := 空集合</div><div class="line">    <span class="keyword">for</span> each 图 G 中的顶点 v</div><div class="line">        do 將 v 加入森林 F</div><div class="line">    所有的边(u, v) ∈ E依权重 w 递增排序</div><div class="line">   <span class="keyword">for</span> each 边(u, v) ∈ E</div><div class="line">        do <span class="keyword">if</span> u 和 v 不在同一棵子树</div><div class="line">            then F := F ∪ &#123;(u, v)&#125;</div><div class="line">                將 u 和 v 所在的子树合并</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Prim算法：是针对顶点展开的，适合于边数较多的情况。</p>
<p>Kruskal算法：是针对边展开的，适合于边的数量较少的情况。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用Krustal算法或者Prime算法构造“”最大生成树”：</p>
<ul>
<li><p><strong>Prime算法</strong>：选择权重最大的边的两个顶点加入等价类</p>
</li>
<li><p><strong>Krustal算法</strong>：即每次选择权重最大的边加入森林；</p>
</li>
</ul>
<p>我们看邻接矩阵</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td>0</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>B</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td><strong>2</strong></td>
<td>3</td>
</tr>
<tr>
<td>C</td>
<td>5</td>
<td>4</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>3</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>利用Krustal算法，选择最大的边加入，但是不能形成回路，图中表黑的就是被选出的，DE边是不能选的，否则就形成闭路。总共5+4+3+2=14</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.chinaunix.net/uid-26345906-id-3951551.html" target="_blank" rel="external">数据结构深入剖析（14）–最小连通图 </a></li>
<li><a href="https://www.zybuluo.com/pastqing/note/318392#prim算法" target="_blank" rel="external">图的常见算法</a></li>
<li><a href="https://www.zybuluo.com/guoxs/note/262429" target="_blank" rel="external">数据结构之图的存储方式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道Google 笔试题&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个有n个结点的连通图的生成树是原图的最小连通子图, 且包含原图中所有n个结点，并且有保持图联通的最少的边。最大生成树就是权和最大生成树，现在给出一个无向带权图的邻接矩阵，权为0表示没有边。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&amp;#123;0, 4, 5, 0, 3&amp;#125;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#123;4, 0, 4, 2, 3&amp;#125;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#123;5, 4, 0, 2, 0&amp;#125;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#123;0, 2, 2, 0, 1&amp;#125;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#123;3, 3, 0, 1, 0&amp;#125;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;求这个图的最大生成树的权和。&lt;/p&gt;
&lt;p&gt;A、11&lt;/p&gt;
&lt;p&gt;B、12&lt;/p&gt;
&lt;p&gt;C、13&lt;/p&gt;
&lt;p&gt;D、14&lt;/p&gt;
&lt;p&gt;E、15&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Google" scheme="http://github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>八大排序算法总结与java实现</title>
    <link href="http://github.com/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://github.com/2017/07/18/八大排序算法总结与java实现/</id>
    <published>2017-07-18T04:30:55.000Z</published>
    <updated>2017-11-21T11:29:55.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：</p>
<p><img src="/gallery/sort-algorithms/big-o.png" alt=""></p>
<ul>
<li>直接插入排序</li>
<li>希尔排序</li>
<li>简单选择排序</li>
<li>堆排序</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<a id="more"></a>
<p>我们讨论的这八大排序算法的实现可以参考<a href="https://github.com/iTimeTraveler/SortAlgorithms">我的Github：<strong>SortAlgorithms</strong></a>，其中也包括了排序测试模块<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Test.java">[Test.java]</a>和排序算法对比模块<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Bench.java">[Bench.java]</a>，大家可以试运行。</p>
<p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p>

$$
\begin{cases}
内部排序 

\begin{cases}
插入排序

\begin{cases}
直接插入排序\\
希尔排序
\end{cases}

\\
选择排序
\begin{cases}
简单选择排序\\
堆排序
\end{cases}
\\

交换排序
\begin{cases}
冒泡排序\\
快速排序 
\end{cases}

\\

归并排序\\
基数排序

\end{cases}

\\
外部排序 
\end{cases}
$$

<h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr>
<p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p>
<p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> 。我们先来看下直接插入排序。</p>
<h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p>
<p><img src="/gallery/sort-algorithms/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p>
<h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p>
<p><img src="/gallery/sort-algorithms/insert-sort.gif" alt="直接插入排序演示"></p>
<p>如果<em>比较操作</em>的代价比<em>交换操作</em>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="external">二分查找法</a>来减少<em>比较操作</em>的数目。该算法可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="external">二分查找插入排序</a>。</p>
<h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 插入排序</div><div class="line"> *</div><div class="line"> * 1. 从第一个元素开始，该元素可以认为已经被排序</div><div class="line"> * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</div><div class="line"> * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</div><div class="line"> * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</div><div class="line"> * 5. 将新元素插入到该位置后</div><div class="line"> * 6. 重复步骤2~5</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++ ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j-- ) &#123;</div><div class="line">            <span class="keyword">if</span>( arr[j-<span class="number">1</span>] &lt;= arr[j] )</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">int</span> temp = arr[j];      <span class="comment">//交换操作</span></div><div class="line">            arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">            arr[j-<span class="number">1</span>] = temp;</div><div class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接插入排序复杂度如下：</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p>
<h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr>
<blockquote class="pullquote right"><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
</blockquote>
<p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p>
<p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><img src="/gallery/sort-algorithms/shell-sort.jpg" alt=""></p>
<p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p>
<p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="external">维基百科</a>。</p>
<h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br>②. 按增量序列个数k，对序列进行k 趟排序；<br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序</div><div class="line"> *</div><div class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</div><div class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</div><div class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;      <span class="comment">//不断缩小gap，直到1为止</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (j+gap) &lt; arr.length; j++)&#123;     <span class="comment">//使用当前gap进行组内插入排序</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; (k+gap)&lt; arr.length; k += gap)&#123;</div><div class="line">                <span class="keyword">if</span>(arr[k] &gt; arr[k+gap]) &#123;</div><div class="line">                    <span class="keyword">int</span> temp = arr[k+gap];      <span class="comment">//交换操作</span></div><div class="line">                    arr[k+gap] = arr[k];</div><div class="line">                    arr[k] = temp;</div><div class="line">                    System.out.println(<span class="string">"    Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>①. 第一层for循环表示一共有多少个增量。增量的序列的个数，就是希尔排序的趟数。上面的增量序列为： <code>arr.length/2, arr.length/2/2, arr.length/2/2/2,     ....   2,  1</code><br>②. 里层的两个for循环，实际上就是以一个gap拆分为一组的<strong>组内插入排序</strong>。</p>
<p>下面是维基百科官方实现，大家注意gap步长取值部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序（Wiki官方版）</div><div class="line"> *</div><div class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</div><div class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</div><div class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>, i, j, len = arr.length;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>)</div><div class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;      <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></div><div class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</div><div class="line">                arr[j + gap] = arr[j];</div><div class="line">            arr[j + gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是希尔排序复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlog2 n)</td>
<td>O(nlog2 n)</td>
<td>O(nlog2 n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr>
<blockquote class="pullquote right"><p><img src="/gallery/sort-algorithms/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></p>
</blockquote>
<p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p>
<h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p>
<p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p>
<h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 选择排序</div><div class="line"> *</div><div class="line"> * 1. 从待排序序列中，找到关键字最小的元素；</div><div class="line"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</div><div class="line"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++)&#123;    <span class="comment">//选出之后待排序中值最小的位置</span></div><div class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</div><div class="line">                min = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(min != i)&#123;</div><div class="line">            <span class="keyword">int</span> temp = arr[min];      <span class="comment">//交换操作</span></div><div class="line">            arr[min] = arr[i];</div><div class="line">            arr[i] = temp;</div><div class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是选择排序复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p>
<h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr>
<blockquote>
<p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p>
</blockquote>
<p>堆的定义如下：$n$个元素的序列
$\left\{{k_1,k_2,···,k_n}\right\}$
当且仅当满足下关系时，称之为堆。</p>

$$
\left\{
\begin{aligned}
k_i & \leqslant  k_{2i} \\
k_i & \leqslant  k_{2i+1} 
\end{aligned}
\right.
\quad  或  \quad
\left\{
\begin{aligned}
k_i & \geqslant  k_{2i} \\
k_i & \geqslant k_{2i+1} 
\end{aligned}
\right.
\quad (i = 1,2,···, \left \lfloor { \frac{n}{2} } \right \rfloor )
$$

<p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p>
<h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p>
<h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 先将初始序列$K[1..n]$建成一个大顶堆, 那么此时第一个元素$K_1$最大, 此堆为初始的无序区.<br>②. 再将关键字最大的记录$K_1$ (即堆顶, 第一个元素)和无序区的最后一个记录 $K_n$ 交换, 由此得到新的无序区$K[1..n-1]$和有序区$K[n]$, 且满足$K[1..n-1].keys \leqslant K[n].key$<br>③. 交换$K_1$ 和 $K_n$ 后, 堆顶可能违反堆性质, 因此需将$K[1..n-1]$调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p>
<p>动图效果如下所示：</p>
<p><img src="/gallery/sort-algorithms/heap_sort_gif.gif" alt="堆排序过程"></p>
<p><img src="/gallery/sort-algorithms/Sorting_heapsort_anim.gif" alt="堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。"></p>
<h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p>
<p>总结起来就是定义了以下几种操作：</p>
<ul>
<li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<p>对于堆节点的访问：</p>
<ul>
<li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li>
<li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li>
<li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 堆排序</div><div class="line"> *</div><div class="line"> * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.</div><div class="line"> * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key</div><div class="line"> * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; i--)&#123;</div><div class="line">        max_heapify(arr, i);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];      <span class="comment">//堆顶元素(第一个元素)与Kn交换</span></div><div class="line">        arr[<span class="number">0</span>] = arr[i-<span class="number">1</span>];</div><div class="line">        arr[i-<span class="number">1</span>] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> limit)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span> || arr.length &lt; limit) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> parentIdx = limit / <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(; parentIdx &gt;= <span class="number">0</span>; parentIdx--)&#123;</div><div class="line">        <span class="keyword">if</span>(parentIdx * <span class="number">2</span> &gt;= limit)&#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = parentIdx * <span class="number">2</span>;       <span class="comment">//左子节点位置</span></div><div class="line">        <span class="keyword">int</span> right = (left + <span class="number">1</span>) &gt;= limit ? left : (left + <span class="number">1</span>);    <span class="comment">//右子节点位置，如果没有右节点，默认为左节点位置</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxChildId = arr[left] &gt;= arr[right] ? left : right;</div><div class="line">        <span class="keyword">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;   <span class="comment">//交换父节点与左右子节点中的最大值</span></div><div class="line">            <span class="keyword">int</span> temp = arr[parentIdx];</div><div class="line">            arr[parentIdx] = arr[maxChildId];</div><div class="line">            arr[maxChildId] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"Max_Heapify: "</span> + Arrays.toString(arr));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注:</strong> x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 == Math.floor(x/2) .</p>
</blockquote>
<p>以上,<br>①. 建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>$O(n \log_{2}n)$</td>
<td>$O(n \log_{2}n)$</td>
<td>$O(n \log_{2}n)$</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>Tips: <strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong> 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p>
<h3 id="五、冒泡排序（Bubble-Sort）"><a href="#五、冒泡排序（Bubble-Sort）" class="headerlink" title="五、冒泡排序（Bubble Sort）"></a>五、冒泡排序（Bubble Sort）</h3><hr>
<p><img src="/gallery/sort-algorithms/bubble-sort02.gif" alt="冒泡排序的思想"></p>
<blockquote>
<p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1、基本思想-4"><a href="#1、基本思想-4" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><img src="/gallery/sort-algorithms/bubble-sort.gif" alt="冒泡排序演示"></p>
<h4 id="2、算法描述-4"><a href="#2、算法描述-4" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>冒泡排序算法的运作如下：</p>
<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>
<h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中, <strong>外层循环</strong>移动游标; <strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 冒泡排序</div><div class="line"> *</div><div class="line"> * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</div><div class="line"> * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</div><div class="line"> * ③. 针对所有的元素重复以上的步骤，除了最后一个。</div><div class="line"> * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; i--) &#123;      <span class="comment">//外层循环移动游标</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i &amp;&amp; (j+<span class="number">1</span>) &lt; i; j++)&#123;    <span class="comment">//内层循环遍历游标及之后(或之前)的元素</span></div><div class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">int</span> temp = arr[j];</div><div class="line">                arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">                arr[j+<span class="number">1</span>] = temp;</div><div class="line">                System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是冒泡排序算法复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p>
<p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p>
<h3 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h3><hr>
<p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p>
<h4 id="1、基本思想-5"><a href="#1、基本思想-5" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p>
<p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><img src="/gallery/sort-algorithms/Sorting_quicksort_anim.gif" alt="使用快速排序法对一列数字进行排序的过程"></p>
<h4 id="2、算法描述-5"><a href="#2、算法描述-5" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p>
<p>①. 从数列中挑出一个元素，称为”基准”（pivot）。<br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><img src="/gallery/sort-algorithms/quick-sort09.gif" alt="快速排序演示"></p>
<h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>用伪代码描述如下：</p>
<p>①. <code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。<br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。<br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。<br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</p>
<p><img src="/gallery/sort-algorithms/200px-Partition_example.svg.png" alt="快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序（递归）</div><div class="line"> *</div><div class="line"> * ①. 从数列中挑出一个元素，称为"基准"（pivot）。</div><div class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</div><div class="line"> * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</div><div class="line"> * <span class="doctag">@param</span> arr   待排序数组</div><div class="line"> * <span class="doctag">@param</span> low   左边界</div><div class="line"> * <span class="doctag">@param</span> high  右边界</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> left = low;</div><div class="line">    <span class="keyword">int</span> right = high;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> temp = arr[left];   <span class="comment">//挖坑1：保存基准的值</span></div><div class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</div><div class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></div><div class="line">            right--;</div><div class="line">        &#125;</div><div class="line">        arr[left] = arr[right];</div><div class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></div><div class="line">            left++;</div><div class="line">        &#125;</div><div class="line">        arr[right] = arr[left];</div><div class="line">    &#125;</div><div class="line">    arr[left] = temp;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></div><div class="line">    System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</div><div class="line">    quickSort(arr, low, left-<span class="number">1</span>);</div><div class="line">    quickSort(arr, left+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p>
<p>因为<strong>递归的本质是栈</strong>，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序（非递归）</div><div class="line"> *</div><div class="line"> * ①. 从数列中挑出一个元素，称为"基准"（pivot）。</div><div class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</div><div class="line"> * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤</div><div class="line"> * <span class="doctag">@param</span> arr   待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortByStack</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//初始状态的左右指针入栈</span></div><div class="line">    stack.push(<span class="number">0</span>);</div><div class="line">    stack.push(arr.length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</div><div class="line">        <span class="keyword">int</span> high = stack.pop();     <span class="comment">//出栈进行划分</span></div><div class="line">        <span class="keyword">int</span> low = stack.pop();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pivotIdx = partition(arr, low, high);</div><div class="line"></div><div class="line">        <span class="comment">//保存中间变量</span></div><div class="line">        <span class="keyword">if</span>(pivotIdx &gt; low) &#123;</div><div class="line">            stack.push(low);</div><div class="line">            stack.push(pivotIdx - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= <span class="number">0</span>)&#123;</div><div class="line">            stack.push(pivotIdx + <span class="number">1</span>);</div><div class="line">            stack.push(high);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> l = low;</div><div class="line">    <span class="keyword">int</span> r = high;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pivot = arr[l];    <span class="comment">//挖坑1：保存基准的值</span></div><div class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</div><div class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></div><div class="line">            r--;</div><div class="line">        &#125;</div><div class="line">        arr[l] = arr[r];</div><div class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></div><div class="line">            l++;</div><div class="line">        &#125;</div><div class="line">        arr[r] = arr[l];</div><div class="line">    &#125;</div><div class="line">    arr[l] = pivot;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></div><div class="line">    <span class="keyword">return</span> l;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<p>以下是快速排序算法复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n²)</td>
<td>O(1)（原地分区递归版）</td>
</tr>
</tbody>
</table>
<p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高. </p>
<p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p>
<h3 id="七、归并排序（Merging-Sort）"><a href="#七、归并排序（Merging-Sort）" class="headerlink" title="七、归并排序（Merging Sort）"></a>七、归并排序（Merging Sort）</h3><hr>
<blockquote class="pullquote right"><p><img src="/gallery/sort-algorithms/merging-sort_sample.jpg" alt=""></p>
</blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<h4 id="1、基本思想-6"><a href="#1、基本思想-6" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p><img src="/gallery/sort-algorithms/2016-07-15_归并排序.gif" alt="这个图很有概括性，来自维基"></p>
<h4 id="2、算法描述-6"><a href="#2、算法描述-6" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p>
<ul>
<li>自上而下的递归</li>
<li>自下而上的迭代</li>
</ul>
<p><strong>一、递归法</strong>（假设序列共有n个元素）：</p>
<p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p>
<p><img src="/gallery/sort-algorithms/merging-sort.gif" alt=""></p>
<p><strong>二、迭代法</strong></p>
<p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p>
<h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>归并排序其实要做两件事：</p>
<ul>
<li>分解：将序列每次折半拆分</li>
<li>合并：将划分后的序列段两两排序合并</li>
</ul>
<p>因此，归并排序实际上就是两个操作，拆分+合并</p>
<p><strong>如何合并？</strong></p>
<p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p>
<p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]<br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]<br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序</p>
<p><strong>如何分解？</strong></p>
<p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>
<p>这里我写了递归算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序（递归）</div><div class="line"> *</div><div class="line"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</div><div class="line"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</div><div class="line"> * ③. 重复步骤②，直到所有元素排序完毕。</div><div class="line"> * <span class="doctag">@param</span> arr	 待排序数组</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergingSort(<span class="keyword">int</span>[] arr)&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> num = arr.length &gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span>[] leftArr = Arrays.copyOfRange(arr, <span class="number">0</span>, num);</div><div class="line">    <span class="keyword">int</span>[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</div><div class="line">    System.out.println(<span class="string">"split two array: "</span> + Arrays.toString(leftArr) + <span class="string">" And "</span> + Arrays.toString(rightArr));</div><div class="line">    <span class="keyword">return</span> mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      <span class="comment">//不断拆分为最小单元，再排序合并</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeTwoArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length + arr2.length];  <span class="comment">//申请额外的空间存储合并之后的数组</span></div><div class="line">    <span class="keyword">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      <span class="comment">//选取两个序列中的较小值放入新数组</span></div><div class="line">        <span class="keyword">if</span>(arr1[i] &lt;= arr2[j])&#123;</div><div class="line">            result[k++] = arr1[i++];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            result[k++] = arr2[j++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; arr1.length)&#123;     <span class="comment">//序列1中多余的元素移入新数组</span></div><div class="line">        result[k++] = arr1[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(j &lt; arr2.length)&#123;     <span class="comment">//序列2中多余的元素移入新数组</span></div><div class="line">        result[k++] = arr2[j++];</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"Merging: "</span> + Arrays.toString(result));</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p>
<p>以下是归并排序算法复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p>
<blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h3 id="八、基数排序（Radix-Sort）"><a href="#八、基数排序（Radix-Sort）" class="headerlink" title="八、基数排序（Radix Sort）"></a>八、基数排序（Radix Sort）</h3><hr>
<p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p>
<p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h4 id="1、基本思想-7"><a href="#1、基本思想-7" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<ul>
<li><p><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</p>
</li>
<li><p><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</p>
</li>
</ul>
<p><img src="/gallery/sort-algorithms/radix-sort_sample.gif" alt="基数排序LSD动图演示"></p>
<h4 id="2、算法描述-7"><a href="#2、算法描述-7" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p>
<p>①. 取得数组中的最大数，并取得位数；<br>②. arr为原始数组，从最低位开始取每个位组成radix数组；<br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<h4 id="3、代码实现-7"><a href="#3、代码实现-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p>
<ul>
<li><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p>
</li>
<li><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基数排序（LSD 从低位开始）</div><div class="line"> *</div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> *</div><div class="line"> * ①. 取得数组中的最大数，并取得位数；</div><div class="line"> * ②. arr为原始数组，从最低位开始取每个位组成radix数组；</div><div class="line"> * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</div><div class="line"> * <span class="doctag">@param</span> arr	 待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">//取得数组中的最大数，并取得位数</span></div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(max &lt; arr[i])&#123;</div><div class="line">            max = arr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxDigit = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(max / <span class="number">10</span> &gt; <span class="number">0</span>)&#123;</div><div class="line">        maxDigit++;</div><div class="line">        max = max / <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"maxDigit: "</span> + maxDigit);</div><div class="line"></div><div class="line">    <span class="comment">//申请一个桶空间</span></div><div class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</div><div class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="comment">//从低位到高位，对每一位遍历，将所有元素分配到桶中</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++)&#123;</div><div class="line">        <span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];        <span class="comment">//存储各个桶中存储元素的数量</span></div><div class="line">        </div><div class="line">        <span class="comment">//分配：将所有元素分配到桶中</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++)&#123;</div><div class="line">            <span class="keyword">int</span> whichBucket = (arr[j] % base) / (base / <span class="number">10</span>);</div><div class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</div><div class="line">            bktLen[whichBucket]++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++)&#123;</div><div class="line">                arr[k++] = buckets[b][p];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</div><div class="line">        base *= <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是基数排序算法复杂度，其中k为最大数的位数：</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(d*(n+r))</td>
<td>O(d*(n+r))</td>
<td>O(d*(n+r))</td>
<td>O(n+r)</td>
</tr>
</tbody>
</table>
<p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p>
<p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p>
<p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>各种排序性能对比如下，有些排序未详细介绍，暂且放到这里。实例测试结果可以看这里：<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/BENCH_RESULT.md"><strong>八大排序算法耗时对比</strong></a> 。</p>
<table>
<thead>
<tr>
<th>排序类型</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3)</td>
<td>O(nlogn)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n²)</td>
<td>O(nlog₂n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n²)</td>
<td>O(n+k)</td>
<td>(不)稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+k))</td>
<td>O(d(n+k))</td>
<td>O(d(n+kd))</td>
<td>O(n+kd)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p>从时间复杂度来说：</p>
<p>(1). 平方阶O(n²)排序：<strong><code>各类简单排序：直接插入、直接选择和冒泡排序</code></strong>；</p>
<p>(2). 线性对数阶O(nlog₂n)排序：<strong><code>快速排序、堆排序和归并排序</code></strong>；</p>
<p>(3). O(n1+§))排序，§是介于0和1之间的常数：<strong><code>希尔排序</code></strong></p>
<p>(4). 线性阶O(n)排序：<strong><code>基数排序，此外还有桶、箱排序</code></strong>。<br>　　<br>到此，很多人会注意到<strong>基数排序</strong>的时间复杂度是最小的，那么为什么却没有快排、堆排序流行呢？我们看看下图算法导论的相关说明：</p>
<p><img src="/gallery/sort-algorithms/radixsort-comparison.jpg" alt=""></p>
<p>基数排序只适用于有基数的情况，而基于比较的排序适用范围就广得多。另一方面是内存上的考虑。作为一种通用的排序方法，最好不要带来意料之外的内存开销，所以各语言的默认实现都没有用基数排序，但是不能否认基数排序在各领域的应用。</p>
<h4 id="时间复杂度极限"><a href="#时间复杂度极限" class="headerlink" title="时间复杂度极限"></a>时间复杂度极限</h4><p><strong>当被排序的数有一些性质的时候</strong>（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如：</p>
<ol>
<li>计数排序 复杂度O( k+n)     要求：被排序的数是0~k范围内的整数</li>
<li>基数排序 复杂度O( d(k+n) )  要求：d位数，每个数位有k个取值</li>
<li>桶排序    复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</li>
</ol>
<p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而<strong>基于比较的排序算法时间复杂度的下限必须是O( nlgn) </strong>。参考<a href="https://www.zhihu.com/question/24516934" target="_blank" rel="external">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li>
<li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li>
<li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li>
</ul>
<p><img src="/gallery/sort-algorithms/2016-07-15_常用排序算法.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>数据结构可视化：<a href="https://visualgo.net/zh" target="_blank" rel="external">visualgo</a>，<a href="https://www.toptal.com/developers/sorting-algorithms/" target="_blank" rel="external">Sorting Algorithms Animations</a>，<a href="https://codepen.io/iTimeTraveler/pen/dRrwZr" target="_blank" rel="external">CodePen</a> &amp; <a href="https://codepen.io/iTimeTraveler/pen/weORyW" target="_blank" rel="external">sort it out</a></li>
<li>排序算法测试：<a href="http://www.cse.chalmers.se/edu/course/DIT960/lab1-sorting.html" target="_blank" rel="external">Lab 1: Sorting - 哥德堡大学课件（University of Gothenburg）</a></li>
<li><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html" target="_blank" rel="external">Sorting - 卡内基梅隆大学课件</a></li>
<li><a href="http://www.jianshu.com/p/7d037c332a9d" target="_blank" rel="external">数据结构常见的八大排序算法（详细整理）</a></li>
<li><a href="http://www.jianshu.com/p/8c915179fd02" target="_blank" rel="external">必须知道的八大种排序算法【java实现】</a></li>
<li><a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></li>
<li><a href="http://blog.jobbole.com/11745/" target="_blank" rel="external">视觉直观感受 7 种常用的排序算法</a></li>
<li><a href="http://louiszhai.github.io/2016/12/23/sort/" target="_blank" rel="external">JS中可能用得到的全部的排序算法</a></li>
<li><a href="http://www.cnblogs.com/minkaihui/p/4077888.html" target="_blank" rel="external">总结5种比较高效常用的排序算法</a></li>
<li><a href="http://www.cnblogs.com/zyb428/p/5673738.html" target="_blank" rel="external">常见排序算法C++总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/sort-algorithms/big-o.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接插入排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;li&gt;简单选择排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】10亿int型数，统计只出现一次的数</title>
    <link href="http://github.com/2017/07/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%9110%E4%BA%BFint%E5%9E%8B%E6%95%B0%EF%BC%8C%E7%BB%9F%E8%AE%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0/"/>
    <id>http://github.com/2017/07/13/【算法】10亿int型数，统计只出现一次的数/</id>
    <published>2017-07-13T10:30:55.000Z</published>
    <updated>2017-07-13T10:37:10.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先分析多大的内存能够表示10亿的数呢？一个int型占4字节，10亿就是40亿字节（很明显就是4GB），也就是如果完全读入内存需要占用4GB，而题目只给1GB内存，显然不可能将所有数据读入内存。</p>
<p>我们先不考虑时间复杂度，仅考虑解决问题。那么接下来的思路一般有两种。</p>
<ol>
<li><strong>位图法</strong>：用一个bit位来标识一个int整数。</li>
<li><strong>分治法</strong>：分批处理这10亿的数。</li>
</ol>
<p>一种是位图法，如果各位老司机有经验的话很快会想到int整型数是4字节（Byte），也就是32位（bit），如果能用一个bit位来标识一个int整数那么存储空间将大大减少。另一种是分治法，内存有限，我想办法分批读取处理。下面大致分析一下两种思路。</p>
<a id="more"></a>
<h3 id="1、位图法（Bitmap）"><a href="#1、位图法（Bitmap）" class="headerlink" title="1、位图法（Bitmap）"></a>1、位图法（Bitmap）</h3><p>位图法是基于int型数的表示范围这个概念的，用一个bit位来标识一个int整数，若该位为1，则说明该数出现；若该位为0，则说明该数没有出现。一个int整型数占4字节（Byte），也就是32位（bit）。那么把所有int整型数字表示出来需要2^32 bit的空间，换算成字节单位也就是2^32/8 = 2^29 Byte，大约等于512MB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 插播一个常识</span></div><div class="line"><span class="number">2</span>^<span class="number">10</span> Byte = <span class="number">1024</span> Byte = <span class="number">1</span>KB</div><div class="line"><span class="number">2</span>^<span class="number">30</span> Byte = (<span class="number">2</span>^<span class="number">10</span>)^<span class="number">3</span> Byte = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> Byte = <span class="number">1</span>GB</div></pre></td></tr></table></figure>
<p>这下就好办了，只需要用512MB的内存就能存储所有的int的范围数。</p>
<h4 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h4><p>那么接下来我们只需要申请一个int数组长度为 int tmp[<strong>N/32+1</strong>]即可存储完这些数据，其中<strong>N代表要进行查找的总数（这里也就是2^32）</strong>，tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表:</p>
<ul>
<li>tmp[0]:可表示0~31</li>
<li>tmp[1]:可表示32~63</li>
<li>tmp[2]可表示64~95</li>
<li>~~</li>
</ul>
<p>假设这10亿int数据为：6,3,8,32,36,……，那么具体的BitMap表示为：</p>
<p><img src="/gallery/bitmap/37237-20160302211041080-958649492.png" alt=""></p>
<p>(1).  如何判断int数字放在哪一个tmp数组中：将数字直接除以32取整数部分(x/32)，例如：整数8除以32取整等于0，那么8就在tmp[0]上；</p>
<p>(2).  如何确定数字放在32个位中的哪个位：将数字mod32取模(x%32)。上例中我们如何确定8在tmp[0]中的32个位中的哪个位，这种情况直接mod上32就ok，又如整数8，在tmp[0]中的第8 mod上32等于8，那么整数8就在tmp[0]中的第八个bit位（从右边数起）。</p>
<p>然后我们怎么统计只出现一次的数呢？每一个数出现的情况我们可以分为三种：0次、1次、大于1次。也就是说我们需要用2个bit位才能表示每个数的出现情况。此时则三种情况分别对应的bit位表示是：00、01、11</p>
<p>我们顺序扫描这10亿的数，在对应的双bit位上标记该数出现的次数。最后取出所有双bit位为01的int型数就可以了。</p>
<h4 id="Bitmap拓展"><a href="#Bitmap拓展" class="headerlink" title="Bitmap拓展"></a>Bitmap拓展</h4><p>位图（Bitmap）算法思想比较简单，但关键是如何确定十进制的数映射到二进制bit位的map图。</p>
<p><strong>优点：</strong></p>
<ol>
<li><p>运算效率高，不许进行比较和移位；</p>
</li>
<li><p>占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M</p>
</li>
</ol>
<p><strong>缺点：</strong>所有的数据不能重复。即不可对重复的数据进行排序和查找。</p>
<p> 建立了Bit-Map之后，就可以方便的使用了。一般来说Bit-Map可作为数据的<strong>查找、去重、排序</strong>等操作。比如以下几个例子：</p>
<blockquote>
<p> 1、在3亿个整数中找出重复的整数个数，限制内存不足以容纳3亿个整数</p>
</blockquote>
<p>对于这种场景可以采用2-BitMap来解决，即为每个整数分配2bit，用不同的0、1组合来标识特殊意思，如00表示此整数没有出现过，01表示出现一次，11表示出现过多次，就可以找出重复的整数了，其需要的内存空间是正常BitMap的2倍，为：3亿*2/8/1024/1024=71.5MB。</p>
<p><strong>具体的过程如下：</strong>扫描着3亿个整数，组BitMap，先查看BitMap中的对应位置，如果00则变成01，是01则变成11，是11则保持不变，当将3亿个整数扫描完之后也就是说整个BitMap已经组装完毕。最后查看BitMap将对应位为11的整数输出即可。</p>
<blockquote>
<p> 2、对没有重复元素的整数进行排序</p>
</blockquote>
<p>对于非重复的整数排序BitMap有着天然的优势，它只需要将给出的无重复整数扫描完毕，组装成为BitMap之后，那么直接遍历一遍Bit区域就可以达到排序效果了。</p>
<p>举个例子：对整数4、3、1、7、6进行排序：</p>
<p><img src="/gallery/bitmap/37237-20160302215109220-1394239868.png" alt=""></p>
<p>直接按Bit位输出就可以得到排序结果了。</p>
<blockquote>
<p> 3、已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数</p>
</blockquote>
<p>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话。</p>
<blockquote>
<p> 4、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数</p>
</blockquote>
<p>将bit-map扩展一下，用2bit表示一个数即可：0表示未出现；1表示出现一次；2表示出现2次及以上，即重复，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。</p>
<p>最后放一个使用Byte[]数组存储、读取bit位的示例代码，来自<a href="http://yacare.iteye.com/blog/1969931" target="_blank" rel="external">利用位映射原理对大数据排重</a>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1000000000</span>;<span class="comment">//数据容量</span></div><div class="line"></div><div class="line">    <span class="comment">// 定义一个byte数组缓存所有的数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] dataBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> &lt;&lt; <span class="number">29</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        BitmapTest ms = <span class="keyword">new</span> BitmapTest();</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CAPACITY; i++) &#123;</div><div class="line">            <span class="keyword">int</span> num = random.nextInt();</div><div class="line">            System.out.println(<span class="string">"读取了第 "</span> + (i + <span class="number">1</span>) + <span class="string">"\t个数: "</span> + num);</div><div class="line">            bytes = ms.splitBigData(num);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">""</span>);</div><div class="line">        ms.output(bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 读取数据，并将对应数数据的 到对应的bit中，并返回byte数组</div><div class="line">     * <span class="doctag">@param</span> num 读取的数据</div><div class="line">     * <span class="doctag">@return</span> byte数组  dataBytes</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] splitBigData(<span class="keyword">int</span> num) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> bitIndex = num + (<span class="number">1l</span> &lt;&lt; <span class="number">31</span>);         <span class="comment">//获取num数据对应bit数组（虚拟）的索引</span></div><div class="line">        <span class="keyword">int</span> index = (<span class="keyword">int</span>) (bitIndex / <span class="number">8</span>);         <span class="comment">//bit数组（虚拟）在byte数组中的索引</span></div><div class="line">        <span class="keyword">int</span> innerIndex = (<span class="keyword">int</span>) (bitIndex % <span class="number">8</span>);    <span class="comment">//bitIndex 在byte[]数组索引index 中的具体位置</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"byte["</span> + index + <span class="string">"] 中的索引："</span> + innerIndex);</div><div class="line"></div><div class="line">        dataBytes[index] = (<span class="keyword">byte</span>) (dataBytes[index] | (<span class="number">1</span> &lt;&lt; innerIndex));</div><div class="line">        <span class="keyword">return</span> dataBytes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 输出数组中的数据</div><div class="line">     * <span class="doctag">@param</span> bytes byte数组</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (!(((bytes[i]) &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>)) &#123;</div><div class="line">                    count++;</div><div class="line">                    <span class="keyword">int</span> number = (<span class="keyword">int</span>) ((((<span class="keyword">long</span>) i * <span class="number">8</span> + j) - (<span class="number">1l</span> &lt;&lt; <span class="number">31</span>)));</div><div class="line">                    System.out.println(<span class="string">"取出的第  "</span> + count + <span class="string">"\t个数: "</span> +  number);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、分治法"><a href="#2、分治法" class="headerlink" title="2、分治法"></a>2、分治法</h3><p>分治法目前看到的解决方案有<strong>哈希分桶（Hash Buckets）</strong>和<strong>归并排序</strong>两种方案。</p>
<p>哈希分桶的思想是先遍历一遍，按照hash分N桶（比如1000桶），映射到不同的文件中。这样平均每个文件就10MB，然后分别处理这1000个文件，找出没有重复的即可。一个相同的数字，绝对不会夸文件，<a href="https://maimai.cn/web/gossip_detail?src=app&amp;webid=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1IjozNDM5ODY0MiwiaWQiOjgzODU0NDR9.zf_21BO_wwAo0t1D8UdKAC9tKXv2TuphOhGnKtCq51E" target="_blank" rel="external">有hash做保证</a>。因为算法具体还不甚了解，这里先不做详细介绍。</p>
<p>归并排序的思想可以参考这篇文章：<a href="http://www.cnblogs.com/cnyao/archive/2009/11/09/interview7.html" target="_blank" rel="external">面试题之10亿正整数问题续–关于多通道排序的问题</a></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6451990" target="_blank" rel="external">程序员编程艺术：第十章、如何给10^7个数据量的磁盘文件排序</a></li>
<li><a href="http://www.cnblogs.com/cnyao/archive/2009/11/09/interview7.html" target="_blank" rel="external">面试题之10亿正整数问题续–关于多通道排序的问题</a></li>
<li><a href="http://yacare.iteye.com/blog/1969931" target="_blank" rel="external">利用位映射原理对大数据排重</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6279498" target="_blank" rel="external">十道海量数据处理面试题与十个方法大总结</a></li>
<li><a href="http://www.cnblogs.com/moonandstar08/p/5236539.html" target="_blank" rel="external">海量数据处理之BitMap</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;首先分析多大的内存能够表示10亿的数呢？一个int型占4字节，10亿就是40亿字节（很明显就是4GB），也就是如果完全读入内存需要占用4GB，而题目只给1GB内存，显然不可能将所有数据读入内存。&lt;/p&gt;
&lt;p&gt;我们先不考虑时间复杂度，仅考虑解决问题。那么接下来的思路一般有两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;位图法&lt;/strong&gt;：用一个bit位来标识一个int整数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分治法&lt;/strong&gt;：分批处理这10亿的数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一种是位图法，如果各位老司机有经验的话很快会想到int整型数是4字节（Byte），也就是32位（bit），如果能用一个bit位来标识一个int整数那么存储空间将大大减少。另一种是分治法，内存有限，我想办法分批读取处理。下面大致分析一下两种思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法的基本概念和Java实现</title>
    <link href="http://github.com/2017/07/11/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8CJava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://github.com/2017/07/11/遗传算法的基本概念和Java实现/</id>
    <published>2017-07-11T10:30:55.000Z</published>
    <updated>2017-07-11T10:57:00.982Z</updated>
    
    <content type="html"><![CDATA[<p>基因遗传算法是一种灵感源于达尔文自然进化理论的启发式搜索算法。该算法反映了自然选择的过程，即最适者被选定繁殖，并产生下一代。本文简要地介绍了遗传算法的基本概念和实现，希望能为读者展示启发式搜索的魅力。</p>
<p><img src="/gallery/genetic-algorithms/1-BYDJpa6M2rzWNSurvspf8Q.png" alt="如上图（左）所示，遗传算法的个体由多条染色体组成，每条染色体由多个基因组成。上图（右）展示了染色体分割和组合的方式。"></p>
<a id="more"></a>
<h3 id="遗传算法的概念"><a href="#遗传算法的概念" class="headerlink" title="遗传算法的概念"></a><strong>遗传算法的概念</strong></h3><p>自然选择的过程从选择群体中最适应环境的个体开始。后代继承了父母的特性，并且这些特性将添加到下一代中。如果父母具有更好的适应性，那么它们的后代将更易于存活。迭代地进行该自然选择的过程，最终，我们将得到由最适应环境的个体组成的一代。</p>
<p>这一概念可以被应用于搜索问题中。我们考虑一个问题的诸多解决方案，并从中搜寻出最佳方案。</p>
<p>遗传算法含以下五步：</p>
<ol>
<li>初始化</li>
<li>个体评价（计算适应度函数）</li>
<li>选择运算</li>
<li>交叉运算</li>
<li>变异运算</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h4><p>该过程从种群的一组个体开始，且每一个体都是待解决问题的一个候选解。</p>
<p>个体以一组参数（变量）为特征，这些特征被称为基因，串联这些基因就可以组成染色体（问题的解）。</p>
<p>在遗传算法中，单个个体的基因组以字符串的方式呈现，通常我们可以使用二进制（1 和 0 的字符串）编码，即一个二进制串代表一条染色体串。因此可以说我们将基因串或候选解的特征编码在染色体中。</p>
<p><img src="/gallery/genetic-algorithms/1-vIrsxg12DSltpdWoO561yA.png" alt="*种群、染色体和基因*"></p>
<h4 id="个体评价（计算适应度函数）"><a href="#个体评价（计算适应度函数）" class="headerlink" title="个体评价（计算适应度函数）"></a><strong>个体评价（计算适应度函数）</strong></h4><p>个体评价利用适应度函数评估了该个体对环境的适应度（与其它个体竞争的能力）。每一个体都有适应度评分，个体被选中进行繁殖的可能性取决于其适应度评分。适应度函数值越大，解的质量就越高。适应度函数是遗传算法进化的驱动力，也是进行自然选择的唯一标准，它的设计应结合求解问题本身的要求而定。</p>
<h4 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a><strong>选择运算</strong></h4><p>选择运算的目的是选出适应性最好的个体，并使它们将基因传到下一代中。基于其适应度评分，我们选择多对较优个体（父母）。适应度高的个体更易被选中繁殖，即将较优父母的基因传递到下一代。</p>
<h4 id="交叉运算"><a href="#交叉运算" class="headerlink" title="交叉运算"></a><strong>交叉运算</strong></h4><p>交叉运算是遗传算法中最重要的阶段。对每一对配对的父母，基因都存在随机选中的交叉点。</p>
<p>举个例子，下图的交叉点为 3：</p>
<p><img src="/gallery/genetic-algorithms/1-Wi6ou9jyMHdxrF2dgczz7g.png" alt="Crossover point"></p>
<p>父母间在交叉点之前交换基因，从而产生了后代。</p>
<p><img src="/gallery/genetic-algorithms/1-eQxFezBtdfdLxHsvSvBNGQ.png" alt="Exchanging genes among parents"></p>
<p>父母间交换基因，然后产生的新后代被添加到种群中。</p>
<p><img src="/gallery/genetic-algorithms/1-_Dl6Hwkay-UU24DJ_oVrLw.png" alt="New offspring"></p>
<h4 id="变异运算"><a href="#变异运算" class="headerlink" title="变异运算"></a><strong>变异运算</strong></h4><p>在某些形成的新后代中，它们的某些基因可能受到低概率变异因子的作用。这意味着二进制位串中的某些位可能会翻转。</p>
<p><img src="/gallery/genetic-algorithms/1-CGt_UhRqCjIDb7dqycmOAg.png" alt="变异运算前后"></p>
<p>变异运算可用于保持种群内的多样性，并防止过早收敛。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a><strong>终止</strong></h4><p>在群体收敛的情况下（群体内不产生与前一代差异较大的后代）该算法终止。也就是说遗传算法提供了一组问题的解。</p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a><strong>案例实现</strong></h3><p>种群的规模恒定。新一代形成时，适应度最差的个体凋亡，为后代留出空间。这些阶段的序列被不断重复，以产生优于先前的新一代。</p>
<p>这一迭代过程的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">START</div><div class="line">Generate the initial population</div><div class="line">Compute fitness</div><div class="line">REPEAT</div><div class="line">    Selection</div><div class="line">    Crossover</div><div class="line">    Mutation</div><div class="line">    Compute fitness</div><div class="line">UNTIL population has converged</div><div class="line">STOP</div></pre></td></tr></table></figure>
<h4 id="Java-中的实例实现"><a href="#Java-中的实例实现" class="headerlink" title="Java 中的实例实现"></a><strong>Java 中的实例实现</strong></h4><p>以下展示的是遗传算法在 Java 中的示例实现，我们可以随意调试和修改这些代码。给定一组五个基因，每一个基因可以保存一个二进制值 0 或 1。这里的适应度是基因组中 1 的数量。如果基因组内共有五个 1，则该个体适应度达到最大值。如果基因组内没有 1，那么个体的适应度达到最小值。该遗传算法希望最大化适应度，并提供适应度达到最大的个体所组成的群体。注意：本例中，在交叉运算与突变运算之后，适应度最低的个体被新的，适应度最高的后代所替代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Vijini</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">//Main class</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDemoGA</span> </span>&#123;</div><div class="line"></div><div class="line">    Population population = <span class="keyword">new</span> Population();</div><div class="line">    Individual fittest;</div><div class="line">    Individual secondFittest;</div><div class="line">    <span class="keyword">int</span> generationCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        SimpleDemoGA demo = <span class="keyword">new</span> SimpleDemoGA();</div><div class="line">        </div><div class="line">        <span class="comment">//Initialize population</span></div><div class="line">        demo.population.initializePopulation(<span class="number">10</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//Calculate fitness of each individual</span></div><div class="line">        demo.population.calculateFitness();</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"Generation: "</span> + demo.generationCount + <span class="string">" Fittest: "</span> + demo.population.fittest);</div><div class="line"></div><div class="line">        <span class="comment">//While population gets an individual with maximum fitness</span></div><div class="line">        <span class="keyword">while</span> (demo.population.fittest &lt; <span class="number">5</span>) &#123;</div><div class="line">            ++demo.generationCount;</div><div class="line">            </div><div class="line">            <span class="comment">//Do selection</span></div><div class="line">            demo.selection();</div><div class="line">            </div><div class="line">            <span class="comment">//Do crossover</span></div><div class="line">            demo.crossover();</div><div class="line">            </div><div class="line">            <span class="comment">//Do mutation under a random probability</span></div><div class="line">            <span class="keyword">if</span> (rn.nextInt()%<span class="number">7</span> &lt; <span class="number">5</span>) &#123;</div><div class="line">                demo.mutation();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//Add fittest offspring to population</span></div><div class="line">            demo.addFittestOffspring();</div><div class="line">            </div><div class="line">            <span class="comment">//Calculate new fitness value </span></div><div class="line">            demo.population.calculateFitness();</div><div class="line">            </div><div class="line">            System.out.println(<span class="string">"Generation: "</span> + demo.generationCount + <span class="string">" Fittest: "</span> + demo.population.fittest);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"\nSolution found in generation "</span> + demo.generationCount);</div><div class="line">        System.out.println(<span class="string">"Fitness: "</span>+demo.population.getFittest().fitness);</div><div class="line">        System.out.print(<span class="string">"Genes: "</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            System.out.print(demo.population.getFittest().genes[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">""</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Selection</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selection</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//Select the most fittest individual</span></div><div class="line">        fittest = population.getFittest();</div><div class="line">        </div><div class="line">        <span class="comment">//Select the second most fittest individual</span></div><div class="line">        secondFittest = population.getSecondFittest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Crossover</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crossover</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        <span class="comment">//Select a random crossover point</span></div><div class="line">        <span class="keyword">int</span> crossOverPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="comment">//Swap values among parents</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; crossOverPoint; i++) &#123;</div><div class="line">            <span class="keyword">int</span> temp = fittest.genes[i];</div><div class="line">            fittest.genes[i] = secondFittest.genes[i];</div><div class="line">            secondFittest.genes[i] = temp;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Mutation</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mutation</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        <span class="comment">//Select a random mutation point</span></div><div class="line">        <span class="keyword">int</span> mutationPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="comment">//Flip values at the mutation point</span></div><div class="line">        <span class="keyword">if</span> (fittest.genes[mutationPoint] == <span class="number">0</span>) &#123;</div><div class="line">            fittest.genes[mutationPoint] = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            fittest.genes[mutationPoint] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mutationPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (secondFittest.genes[mutationPoint] == <span class="number">0</span>) &#123;</div><div class="line">            secondFittest.genes[mutationPoint] = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            secondFittest.genes[mutationPoint] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get fittest offspring</span></div><div class="line">    <span class="function">Individual <span class="title">getFittestOffspring</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (fittest.fitness &gt; secondFittest.fitness) &#123;</div><div class="line">            <span class="keyword">return</span> fittest;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> secondFittest;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//Replace least fittest individual from most fittest offspring</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFittestOffspring</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//Update fitness values of offspring</span></div><div class="line">        fittest.calcFitness();</div><div class="line">        secondFittest.calcFitness();</div><div class="line">        </div><div class="line">        <span class="comment">//Get index of least fit individual</span></div><div class="line">        <span class="keyword">int</span> leastFittestIndex = population.getLeastFittestIndex();</div><div class="line">        </div><div class="line">        <span class="comment">//Replace least fittest individual from most fittest offspring</span></div><div class="line">        population.individuals[leastFittestIndex] = getFittestOffspring();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//Individual class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Individual</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> fitness = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] genes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">    <span class="keyword">int</span> geneLength = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Individual</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">        <span class="comment">//Set genes randomly for each individual</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; genes.length; i++) &#123;</div><div class="line">            genes[i] = rn.nextInt() % <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        fitness = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate fitness</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calcFitness</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        fitness = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (genes[i] == <span class="number">1</span>) &#123;</div><div class="line">                ++fitness;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Population class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Population</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> popSize = <span class="number">10</span>;</div><div class="line">    Individual[] individuals = <span class="keyword">new</span> Individual[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> fittest = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//Initialize population</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializePopulation</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            individuals[i] = <span class="keyword">new</span> Individual();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get the fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Individual <span class="title">getFittest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxFit = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (maxFit &lt;= individuals[i].fitness) &#123;</div><div class="line">                maxFit = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fittest = individuals[maxFit].fitness;</div><div class="line">        <span class="keyword">return</span> individuals[maxFit];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get the second most fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Individual <span class="title">getSecondFittest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxFit1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxFit2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (individuals[i].fitness &gt; individuals[maxFit1].fitness) &#123;</div><div class="line">                maxFit2 = maxFit1;</div><div class="line">                maxFit1 = i;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (individuals[i].fitness &gt; individuals[maxFit2].fitness) &#123;</div><div class="line">                maxFit2 = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> individuals[maxFit2];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get index of least fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeastFittestIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> minFit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (minFit &gt;= individuals[i].fitness) &#123;</div><div class="line">                minFit = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minFit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate fitness of each individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateFitness</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            individuals[i].calcFitness();</div><div class="line">        &#125;</div><div class="line">        getFittest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>原文来自：<a href="https://medium.com/towards-data-science/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3" target="_blank" rel="external">Introduction to Genetic Algorithms — Including Example Code</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基因遗传算法是一种灵感源于达尔文自然进化理论的启发式搜索算法。该算法反映了自然选择的过程，即最适者被选定繁殖，并产生下一代。本文简要地介绍了遗传算法的基本概念和实现，希望能为读者展示启发式搜索的魅力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/genetic-algorithms/1-BYDJpa6M2rzWNSurvspf8Q.png&quot; alt=&quot;如上图（左）所示，遗传算法的个体由多条染色体组成，每条染色体由多个基因组成。上图（右）展示了染色体分割和组合的方式。&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Integer变量相等（==）比较问题</title>
    <link href="http://github.com/2017/07/11/%E3%80%90Java%E3%80%91Integer%E5%8F%98%E9%87%8F%E7%9B%B8%E7%AD%89%EF%BC%88==%EF%BC%89%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/07/11/【Java】Integer变量相等（==）比较问题/</id>
    <published>2017-07-11T04:30:55.000Z</published>
    <updated>2017-07-11T05:12:03.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这是关于一段令人疑惑的Java代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestIntegerCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Integer i3 = <span class="number">100</span>;</div><div class="line">        Integer i4 = <span class="number">100</span>;</div><div class="line">        System.out.println(i3 == i4);</div><div class="line"></div><div class="line">        Integer i5 = <span class="number">1000</span>;</div><div class="line">        Integer i6 = <span class="number">1000</span>;</div><div class="line">        System.out.println(i5 == i6);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么简单，执行结果是什么？</p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<p>一个是true，一个是false！<br>这是为什么呢？为什么和大多数人心里想的不一样！</p>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据Java编译机制，<code>.java</code>文件在编译以后会生成.class文件给JVM加载执行，于是找到.class文件，反编译看了一下，发现编译器在编译我们的代码时，很调皮（聪明的）的在我们声明的变量加上了<code>valueOf</code>方法 ，代码变成了如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestIntegerCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Integer i3 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">        Integer i4 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">        System.out.println(i3 == i4);</div><div class="line"></div><div class="line">        Integer i5 = Integer.valueOf(<span class="number">1000</span>);</div><div class="line">        Integer i6 = Integer.valueOf(<span class="number">1000</span>);</div><div class="line">        System.out.println(i5 == i6);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>valueOf()</code> 方法对它做了什么，我们看看源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</div><div class="line">     * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</div><div class="line">     * required, this method should generally be used in preference to</div><div class="line">     * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</div><div class="line">     * to yield significantly better space and time performance by</div><div class="line">     * caching frequently requested values.</div><div class="line">     *</div><div class="line">     * This method will always cache values in the range -128 to 127,</div><div class="line">     * inclusive, and may cache other values outside of this range.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</div><div class="line">     * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</div><div class="line">     * <span class="doctag">@since</span>  1.5</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)    <span class="comment">//我们看到这里有个缓存，在缓存区间就返回缓存里的</span></div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];   <span class="comment">//缓存数组相应的对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);    <span class="comment">//不在缓存数组区间就new一个对象</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们发现，Integer的作者在写这个类时，为了避免重复创建对象，对Integer值做了缓存，如果这个值在缓存范围内，直接返回缓存好的对象，否则new一个新的对象返回，那究竟这个缓存到底缓存了哪些内容呢？看一下<code>IntegerCache</code>这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Cache to support the object identity semantics of autoboxing for values between</div><div class="line">     * -128 and 127 (inclusive) as required by JLS.</div><div class="line">     *</div><div class="line">     * The cache is initialized on first usage.  The size of the cache</div><div class="line">     * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</div><div class="line">     * During VM initialization, java.lang.Integer.IntegerCache.high property</div><div class="line">     * may be set and saved in the private system properties in the</div><div class="line">     * sun.misc.VM class.</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">	        <span class="comment">//检查虚拟机里是否有缓存区间配置项，如果有就赋成该值，没有就默认[-128, 127]</span></div><div class="line">            <span class="comment">// high value may be configured by property</span></div><div class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">            String integerCacheHighPropValue =</div><div class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">                    i = Math.max(i, <span class="number">127</span>);</div><div class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</div><div class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            high = h;</div><div class="line"></div><div class="line">			<span class="comment">//创建缓存数组，并初始化（缓存值）</span></div><div class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> j = low;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line"></div><div class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></div><div class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这是一个内部静态类，该类只能在Integer这个类的内部访问，这个类在初始化的时候，会去加载JVM的配置，如果有值，就用配置的值初始化缓存数组，否则就缓存<strong><code>-128</code></strong>到<strong><code>127</code></strong>之间的值。<br>再来看看我们之前的代码：</p>
<p><img src="http://img.blog.csdn.net/20170711124934286" alt=""></p>
<p>看完这个，是不是明白了呢</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzQ3NzQ3Nw==&amp;mid=2654250496&amp;idx=1&amp;sn=dad9b1ade6dca4b57020b1bc091df5fb&amp;chksm=8061f50ab7167c1c2672456b1e9f9b4293f6cab49deb08970874f7ae03fd186461acad02e389&amp;mpshare=1&amp;scene=1&amp;srcid=0711yYY7UjcX2zsrDcna3QVp#rd" target="_blank" rel="external">让人疑惑的代码，竟成大多公司面试题热门！</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;这是关于一段令人疑惑的Java代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestIntegerCache&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i3 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i4 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(i3 == i4);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i5 = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i6 = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(i5 == i6);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这么简单，执行结果是什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;true&lt;br&gt;false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个是true，一个是false！&lt;br&gt;这是为什么呢？为什么和大多数人心里想的不一样！&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 8系列之重新认识HashMap</title>
    <link href="http://github.com/2017/06/16/Java%208%E7%B3%BB%E5%88%97%E4%B9%8B%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap/"/>
    <id>http://github.com/2017/06/16/Java 8系列之重新认识HashMap/</id>
    <published>2017-06-16T09:30:55.000Z</published>
    <updated>2017-06-19T10:28:36.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来自美团点评技术团队： <a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是<code>HashMap</code>、<code>Hashtable</code>、<code>LinkedHashMap</code>和<code>TreeMap</code>，类继承关系如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20170616165413193" alt=""></p>
<a id="more"></a>
<p>下面针对各个实现类的特点做一些说明：</p>
<p>(1) <strong>HashMap</strong>：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>(2) <strong>Hashtable</strong>：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) <strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) <strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h2><p>搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。</p>
<h3 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h3><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="http://img.blog.csdn.net/20170616165613975" alt=""></p>
<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么？优点呢？</p>
<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 <code>Node[] table</code>，即哈希桶数组，明显它是一个Node的数组。我们来看<code>Node</code>[JDK1.8]是何物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</div></pre></td></tr></table></figure>
<p>系统将调用”美团”这个key的<code>hashCode()</code>方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></div><div class="line"><span class="keyword">int</span> modCount;  </div><div class="line"><span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a> ，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6105630</a> 。</p>
<h3 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a><strong>功能实现-方法</strong></h3><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p>
<h4 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a><strong>1. 确定哈希桶数组索引位置</strong></h4><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">方法一：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值</strong>、<strong>高位运算</strong>、<strong>取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<p><img src="http://img.blog.csdn.net/20170616170559316" alt=""></p>
<h4 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a><strong>2. 分析HashMap的put方法</strong></h4><p>HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。</p>
<p><img src="http://img.blog.csdn.net/20170616170655449" alt=""></p>
<p>①. 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③. 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<p>JDK1.8HashMap的put方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line"> <span class="number">4</span> &#125;</div><div class="line"> <span class="number">5</span> </div><div class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"> <span class="number">7</span>                <span class="keyword">boolean</span> evict) &#123;</div><div class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></div><div class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line"><span class="number">11</span>         n = (tab = resize()).length;</div><div class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理 </span></div><div class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </div><div class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</div><div class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></div><div class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"><span class="number">20</span>             e = p;</div><div class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></div><div class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></div><div class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></div><div class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></div><div class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</div><div class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</div><div class="line"><span class="number">32</span>                 &#125;</div><div class="line">                    <span class="comment">// key已经存在直接覆盖value</span></div><div class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </div><div class="line"><span class="number">35</span>                            <span class="keyword">break</span>;</div><div class="line"><span class="number">36</span>                 p = e;</div><div class="line"><span class="number">37</span>             &#125;</div><div class="line"><span class="number">38</span>         &#125;</div><div class="line"><span class="number">39</span>         </div><div class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line"><span class="number">41</span>             V oldValue = e.value;</div><div class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line"><span class="number">43</span>                 e.value = value;</div><div class="line"><span class="number">44</span>             afterNodeAccess(e);</div><div class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</div><div class="line"><span class="number">46</span>         &#125;</div><div class="line"><span class="number">47</span>     &#125;</div><div class="line"></div><div class="line"><span class="number">48</span>     ++modCount;</div><div class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></div><div class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line"><span class="number">51</span>         resize();</div><div class="line"><span class="number">52</span>     afterNodeInsertion(evict);</div><div class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">54</span> &#125;</div></pre></td></tr></table></figure>
<h4 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a><strong>3. 扩容机制</strong></h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></div><div class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </div><div class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></div><div class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</div><div class="line"> <span class="number">7</span>     &#125;</div><div class="line"> <span class="number">8</span>  </div><div class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></div><div class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></div><div class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></div><div class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></div><div class="line"><span class="number">13</span> &#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></div><div class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></div><div class="line"> <span class="number">8</span>             do &#123;</div><div class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</div><div class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></div><div class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></div><div class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></div><div class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></div><div class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>         &#125;</div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span> &#125;</div></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="http://img.blog.csdn.net/20170616171207339" alt=""></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="http://img.blog.csdn.net/20170616171255934" alt=""></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="http://img.blog.csdn.net/20170616171330516" alt=""></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="http://img.blog.csdn.net/20170616171352780" alt=""></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line"> <span class="number">2</span>     Node&lt;K,V&gt;[] oldTab = table;</div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">int</span> oldThr = threshold;</div><div class="line"> <span class="number">5</span>     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line"> <span class="number">6</span>     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">7</span>         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></div><div class="line"> <span class="number">8</span>         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line"> <span class="number">9</span>             threshold = Integer.MAX_VALUE;</div><div class="line"><span class="number">10</span>             <span class="keyword">return</span> oldTab;</div><div class="line"><span class="number">11</span>         &#125;</div><div class="line"><span class="number">12</span>         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></div><div class="line"><span class="number">13</span>         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line"><span class="number">14</span>                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line"><span class="number">15</span>             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span>     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line"><span class="number">18</span>         newCap = oldThr;</div><div class="line"><span class="number">19</span>     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line"><span class="number">20</span>         newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line"><span class="number">21</span>         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line"><span class="number">22</span>     &#125;</div><div class="line"><span class="number">23</span>     <span class="comment">// 计算新的resize上限</span></div><div class="line"><span class="number">24</span>     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">25</span> </div><div class="line"><span class="number">26</span>         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line"><span class="number">27</span>         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line"><span class="number">28</span>                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line"><span class="number">29</span>     &#125;</div><div class="line"><span class="number">30</span>     threshold = newThr;</div><div class="line"><span class="number">31</span>     <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</div><div class="line"><span class="number">32</span>         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line"><span class="number">33</span>     table = newTab;</div><div class="line"><span class="number">34</span>     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">35</span>         <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line"><span class="number">36</span>         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line"><span class="number">37</span>             Node&lt;K,V&gt; e;</div><div class="line"><span class="number">38</span>             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">39</span>                 oldTab[j] = <span class="keyword">null</span>;</div><div class="line"><span class="number">40</span>                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line"><span class="number">41</span>                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line"><span class="number">42</span>                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">43</span>                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line"><span class="number">44</span>                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></div><div class="line"><span class="number">45</span>                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">46</span>                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">47</span>                     Node&lt;K,V&gt; next;</div><div class="line"><span class="number">48</span>                     do &#123;</div><div class="line"><span class="number">49</span>                         next = e.next;</div><div class="line"><span class="number">50</span>                         <span class="comment">// 原索引</span></div><div class="line"><span class="number">51</span>                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">52</span>                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">53</span>                                 loHead = e;</div><div class="line"><span class="number">54</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">55</span>                                 loTail.next = e;</div><div class="line"><span class="number">56</span>                             loTail = e;</div><div class="line"><span class="number">57</span>                         &#125;</div><div class="line"><span class="number">58</span>                         <span class="comment">// 原索引+oldCap</span></div><div class="line"><span class="number">59</span>                         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">60</span>                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">61</span>                                 hiHead = e;</div><div class="line"><span class="number">62</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">63</span>                                 hiTail.next = e;</div><div class="line"><span class="number">64</span>                             hiTail = e;</div><div class="line"><span class="number">65</span>                         &#125;</div><div class="line"><span class="number">66</span>                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line"><span class="number">67</span>                     <span class="comment">// 原索引放到bucket里</span></div><div class="line"><span class="number">68</span>                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">69</span>                         loTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">70</span>                         newTab[j] = loHead;</div><div class="line"><span class="number">71</span>                     &#125;</div><div class="line"><span class="number">72</span>                     <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line"><span class="number">73</span>                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">74</span>                         hiTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">75</span>                         newTab[j + oldCap] = hiHead;</div><div class="line"><span class="number">76</span>                     &#125;</div><div class="line"><span class="number">77</span>                 &#125;</div><div class="line"><span class="number">78</span>             &#125;</div><div class="line"><span class="number">79</span>         &#125;</div><div class="line"><span class="number">80</span>     &#125;</div><div class="line"><span class="number">81</span>     <span class="keyword">return</span> newTab;</div><div class="line"><span class="number">82</span> &#125;</div></pre></td></tr></table></figure>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">public class HashMapInfiniteLoop &#123;  </div><div class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2, 0.75f);  </div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        map.put(5, "C");  </div><div class="line"></div><div class="line">        new Thread("Thread1") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(7, "B");  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();  </div><div class="line">        new Thread("Thread2") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(3, "A);  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<p><img src="http://img.blog.csdn.net/20170616171711863" alt=""></p>
<p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<p><img src="http://img.blog.csdn.net/20170616171741879" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170616171859708" alt=""></p>
<p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src="http://img.blog.csdn.net/20170616171810754" alt=""></p>
<p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h2 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a><strong>JDK1.8与JDK1.7的性能对比</strong></h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p>
<h3 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a><strong>Hash较均匀的情况</strong></h3><p>为了便于测试，我们先写一个类Key，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    Key(<span class="keyword">int</span> value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Key key = (Key) o;</div><div class="line">        <span class="keyword">return</span> value == key.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_KEY = <span class="number">10_000_000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS_CACHE = <span class="keyword">new</span> Key[MAX_KEY];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = <span class="keyword">new</span> Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">of</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mapSize)</span> </span>&#123;</div><div class="line"></div><div class="line">     HashMap&lt;Key, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; ++i) &#123;</div><div class="line">         map.put(Keys.of(i), i);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">long</span> beginTime = System.nanoTime(); <span class="comment">//获取纳秒</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; i++) &#123;</div><div class="line">         map.get(Keys.of(i));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">     System.out.println(endTime - beginTime);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;= <span class="number">1000</span> <span class="number">0000</span>;i*= <span class="number">10</span>)&#123;</div><div class="line">         test(i);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：</p>
<p><img src="http://img.blog.csdn.net/20170616172058883" alt=""></p>
<p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p>
<h3 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a><strong>Hash极不均匀的情况</strong></h3><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仍然执行main方法，得出的结果如下表所示：</p>
<p><img src="http://img.blog.csdn.net/20170616172148396" alt=""></p>
<p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p>
<pre><code>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>
<p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ol>
<li>JDK1.7&amp;JDK1.8 源码。</li>
<li>酷壳COOLSHELL，<a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="external">疫苗：JAVA HASHMAP的死循环</a>，2013</li>
<li>CSDN博客频道，<a href="http://blog.csdn.net/xuefeng0707/article/details/40797085" target="_blank" rel="external">HashMap多线程死循环问题</a>，2014。</li>
<li>红黑联盟，<a href="http://www.2cto.com/kf/201505/401433.html" target="_blank" rel="external">Java类集框架之HashMap(JDK1.8)源码剖析</a>，2015。</li>
<li>CSDN博客频道， <a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">教你初步了解红黑树</a>，2010。</li>
<li>Java Code Geeks，<a href="https://www.javacodegeeks.com/2014/04/hashmap-performance-improvements-in-java-8.html" target="_blank" rel="external">HashMap performance improvements in Java 8</a>，2014。</li>
<li>Importnew，<a href="http://www.importnew.com/13384.html" target="_blank" rel="external">危险！在HashMap中将可变对象用作Key</a>，2014。</li>
<li>CSDN博客频道，<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">为什么一般hashtable的桶数会取一个素数</a>，2013。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自美团点评技术团队： &lt;a href=&quot;http://tech.meituan.com/java-hashmap.html&quot;&gt;Java 8系列之重新认识HashMap&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是&lt;code&gt;HashMap&lt;/code&gt;、&lt;code&gt;Hashtable&lt;/code&gt;、&lt;code&gt;LinkedHashMap&lt;/code&gt;和&lt;code&gt;TreeMap&lt;/code&gt;，类继承关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170616165413193&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
</feed>
