<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iTimeTraveler</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2017-07-24T02:53:02.101Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Mr.Seven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>八大排序算法总结与java实现</title>
    <link href="http://github.com/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://github.com/2017/07/18/八大排序算法总结与java实现/</id>
    <published>2017-07-18T04:30:55.000Z</published>
    <updated>2017-07-24T02:53:02.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：</p>
<p><img src="/gallery/sort-algorithms/big-o.png" alt=""></p>
<ul>
<li>直接插入排序</li>
<li>希尔排序</li>
<li>简单选择排序</li>
<li>堆排序</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<a id="more"></a>
<p>其中我们讨论的这八大排序算法都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p>
<p><img src="/gallery/sort-algorithms/1156494-ab4cecff133d87b3.png" alt=""></p>
<h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr>
<h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p>
<p><img src="/gallery/sort-algorithms/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p>
<h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p>
<p><img src="/gallery/sort-algorithms/insert-sort.gif" alt="直接插入排序演示"></p>
<p>如果<em>比较操作</em>的代价比<em>交换操作</em>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="external">二分查找法</a>来减少<em>比较操作</em>的数目。该算法可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="external">二分查找插入排序</a>。</p>
<h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 插入排序</div><div class="line">    *</div><div class="line">    * 1. 从第一个元素开始，该元素可以认为已经被排序</div><div class="line">    * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</div><div class="line">    * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</div><div class="line">    * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</div><div class="line">    * 5. 将新元素插入到该位置后</div><div class="line">    * 6. 重复步骤2~5</div><div class="line">    * <span class="doctag">@param</span> arr  待排序数组</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++ ) &#123;</div><div class="line">           <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j-- ) &#123;</div><div class="line">               <span class="keyword">if</span>( arr[j-<span class="number">1</span>] &lt;= arr[j] )</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="keyword">int</span> temp = arr[j];		<span class="comment">//交换操作</span></div><div class="line">               arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">               arr[j-<span class="number">1</span>] = temp;</div><div class="line">               System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>时间复杂度：O（n^2）</p>
<h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr>
<blockquote class="pullquote right"><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
</blockquote>
<p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p>
<p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><img src="/gallery/sort-algorithms/shell-sort.jpg" alt=""></p>
<p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p>
<p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="external">维基百科</a>。</p>
<h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br>②. 按增量序列个数k，对序列进行k 趟排序；<br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序</div><div class="line"> *</div><div class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</div><div class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</div><div class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;      <span class="comment">//不断缩小gap，直到1为止</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (j+gap) &lt; arr.length; j++)&#123;     <span class="comment">//使用每个gap进行遍历</span></div><div class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+gap])&#123;</div><div class="line">                <span class="keyword">int</span> temp = arr[j+gap];      <span class="comment">//交换操作</span></div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">                System.out.println(<span class="string">"Gap="</span> + gap + <span class="string">", Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(gap == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是维基百科官方实现，大家注意gap步长取值部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序（Wiki官方版）</div><div class="line"> *</div><div class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</div><div class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</div><div class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>, i, j, len = arr.length;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>)</div><div class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;      <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></div><div class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</div><div class="line">                arr[j + gap] = arr[j];</div><div class="line">            arr[j + gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是希尔排序复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlog2 n)</td>
<td>O(nlog2 n)</td>
<td>O(nlog2 n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr>
<blockquote class="pullquote right"><p><img src="/gallery/sort-algorithms/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></p>
</blockquote>
<p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p>
<h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p>
<p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p>
<h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 选择排序</div><div class="line"> *</div><div class="line"> * 1. 从待排序序列中，找到关键字最小的元素；</div><div class="line"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</div><div class="line"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++)&#123;    <span class="comment">//选出之后待排序中值最小的位置</span></div><div class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</div><div class="line">                min = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(min != i)&#123;</div><div class="line">            <span class="keyword">int</span> temp = arr[min];      <span class="comment">//交换操作</span></div><div class="line">            arr[min] = arr[i];</div><div class="line">            arr[i] = temp;</div><div class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是选择排序复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr>
<h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p><img src="/gallery/sort-algorithms/2016-07-15_常用排序算法.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>数据结构可视化：<a href="https://visualgo.net/zh" target="_blank" rel="external">visualgo</a></li>
<li><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html" target="_blank" rel="external">Sorting - 卡内基梅隆大学课件</a></li>
<li><a href="http://www.jianshu.com/p/7d037c332a9d" target="_blank" rel="external">数据结构常见的八大排序算法（详细整理）</a></li>
<li><a href="http://www.jianshu.com/p/8c915179fd02" target="_blank" rel="external">必须知道的八大种排序算法【java实现】</a></li>
<li><a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></li>
<li><a href="http://blog.jobbole.com/11745/" target="_blank" rel="external">视觉直观感受 7 种常用的排序算法</a></li>
<li><a href="http://louiszhai.github.io/2016/12/23/sort/" target="_blank" rel="external">JS中可能用得到的全部的排序算法</a></li>
<li><a href="http://www.cnblogs.com/minkaihui/p/4077888.html" target="_blank" rel="external">总结5种比较高效常用的排序算法</a></li>
<li><a href="http://www.cnblogs.com/zyb428/p/5673738.html" target="_blank" rel="external">常见排序算法C++总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/sort-algorithms/big-o.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接插入排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;li&gt;简单选择排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】10亿int型数，统计只出现一次的数</title>
    <link href="http://github.com/2017/07/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%9110%E4%BA%BFint%E5%9E%8B%E6%95%B0%EF%BC%8C%E7%BB%9F%E8%AE%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0/"/>
    <id>http://github.com/2017/07/13/【算法】10亿int型数，统计只出现一次的数/</id>
    <published>2017-07-13T10:30:55.000Z</published>
    <updated>2017-07-13T10:37:10.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先分析多大的内存能够表示10亿的数呢？一个int型占4字节，10亿就是40亿字节（很明显就是4GB），也就是如果完全读入内存需要占用4GB，而题目只给1GB内存，显然不可能将所有数据读入内存。</p>
<p>我们先不考虑时间复杂度，仅考虑解决问题。那么接下来的思路一般有两种。</p>
<ol>
<li><strong>位图法</strong>：用一个bit位来标识一个int整数。</li>
<li><strong>分治法</strong>：分批处理这10亿的数。</li>
</ol>
<p>一种是位图法，如果各位老司机有经验的话很快会想到int整型数是4字节（Byte），也就是32位（bit），如果能用一个bit位来标识一个int整数那么存储空间将大大减少。另一种是分治法，内存有限，我想办法分批读取处理。下面大致分析一下两种思路。</p>
<a id="more"></a>
<h3 id="1、位图法（Bitmap）"><a href="#1、位图法（Bitmap）" class="headerlink" title="1、位图法（Bitmap）"></a>1、位图法（Bitmap）</h3><p>位图法是基于int型数的表示范围这个概念的，用一个bit位来标识一个int整数，若该位为1，则说明该数出现；若该位为0，则说明该数没有出现。一个int整型数占4字节（Byte），也就是32位（bit）。那么把所有int整型数字表示出来需要2^32 bit的空间，换算成字节单位也就是2^32/8 = 2^29 Byte，大约等于512MB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 插播一个常识</span></div><div class="line"><span class="number">2</span>^<span class="number">10</span> Byte = <span class="number">1024</span> Byte = <span class="number">1</span>KB</div><div class="line"><span class="number">2</span>^<span class="number">30</span> Byte = (<span class="number">2</span>^<span class="number">10</span>)^<span class="number">3</span> Byte = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> Byte = <span class="number">1</span>GB</div></pre></td></tr></table></figure>
<p>这下就好办了，只需要用512MB的内存就能存储所有的int的范围数。</p>
<h4 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h4><p>那么接下来我们只需要申请一个int数组长度为 int tmp[<strong>N/32+1</strong>]即可存储完这些数据，其中<strong>N代表要进行查找的总数（这里也就是2^32）</strong>，tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表:</p>
<ul>
<li>tmp[0]:可表示0~31</li>
<li>tmp[1]:可表示32~63</li>
<li>tmp[2]可表示64~95</li>
<li>~~</li>
</ul>
<p>假设这10亿int数据为：6,3,8,32,36,……，那么具体的BitMap表示为：</p>
<p><img src="/gallery/bitmap/37237-20160302211041080-958649492.png" alt=""></p>
<p>(1).  如何判断int数字放在哪一个tmp数组中：将数字直接除以32取整数部分(x/32)，例如：整数8除以32取整等于0，那么8就在tmp[0]上；</p>
<p>(2).  如何确定数字放在32个位中的哪个位：将数字mod32取模(x%32)。上例中我们如何确定8在tmp[0]中的32个位中的哪个位，这种情况直接mod上32就ok，又如整数8，在tmp[0]中的第8 mod上32等于8，那么整数8就在tmp[0]中的第八个bit位（从右边数起）。</p>
<p>然后我们怎么统计只出现一次的数呢？每一个数出现的情况我们可以分为三种：0次、1次、大于1次。也就是说我们需要用2个bit位才能表示每个数的出现情况。此时则三种情况分别对应的bit位表示是：00、01、11</p>
<p>我们顺序扫描这10亿的数，在对应的双bit位上标记该数出现的次数。最后取出所有双bit位为01的int型数就可以了。</p>
<h4 id="Bitmap拓展"><a href="#Bitmap拓展" class="headerlink" title="Bitmap拓展"></a>Bitmap拓展</h4><p>位图（Bitmap）算法思想比较简单，但关键是如何确定十进制的数映射到二进制bit位的map图。</p>
<p><strong>优点：</strong></p>
<ol>
<li><p>运算效率高，不许进行比较和移位；</p>
</li>
<li><p>占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M</p>
</li>
</ol>
<p><strong>缺点：</strong>所有的数据不能重复。即不可对重复的数据进行排序和查找。</p>
<p> 建立了Bit-Map之后，就可以方便的使用了。一般来说Bit-Map可作为数据的<strong>查找、去重、排序</strong>等操作。比如以下几个例子：</p>
<blockquote>
<p> 1、在3亿个整数中找出重复的整数个数，限制内存不足以容纳3亿个整数</p>
</blockquote>
<p>对于这种场景可以采用2-BitMap来解决，即为每个整数分配2bit，用不同的0、1组合来标识特殊意思，如00表示此整数没有出现过，01表示出现一次，11表示出现过多次，就可以找出重复的整数了，其需要的内存空间是正常BitMap的2倍，为：3亿*2/8/1024/1024=71.5MB。</p>
<p><strong>具体的过程如下：</strong>扫描着3亿个整数，组BitMap，先查看BitMap中的对应位置，如果00则变成01，是01则变成11，是11则保持不变，当将3亿个整数扫描完之后也就是说整个BitMap已经组装完毕。最后查看BitMap将对应位为11的整数输出即可。</p>
<blockquote>
<p> 2、对没有重复元素的整数进行排序</p>
</blockquote>
<p>对于非重复的整数排序BitMap有着天然的优势，它只需要将给出的无重复整数扫描完毕，组装成为BitMap之后，那么直接遍历一遍Bit区域就可以达到排序效果了。</p>
<p>举个例子：对整数4、3、1、7、6进行排序：</p>
<p><img src="/gallery/bitmap/37237-20160302215109220-1394239868.png" alt=""></p>
<p>直接按Bit位输出就可以得到排序结果了。</p>
<blockquote>
<p> 3、已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数</p>
</blockquote>
<p>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话。</p>
<blockquote>
<p> 4、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数</p>
</blockquote>
<p>将bit-map扩展一下，用2bit表示一个数即可：0表示未出现；1表示出现一次；2表示出现2次及以上，即重复，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。</p>
<p>最后放一个使用Byte[]数组存储、读取bit位的示例代码，来自<a href="http://yacare.iteye.com/blog/1969931" target="_blank" rel="external">利用位映射原理对大数据排重</a>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1000000000</span>;<span class="comment">//数据容量</span></div><div class="line"></div><div class="line">    <span class="comment">// 定义一个byte数组缓存所有的数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] dataBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> &lt;&lt; <span class="number">29</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        BitmapTest ms = <span class="keyword">new</span> BitmapTest();</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CAPACITY; i++) &#123;</div><div class="line">            <span class="keyword">int</span> num = random.nextInt();</div><div class="line">            System.out.println(<span class="string">"读取了第 "</span> + (i + <span class="number">1</span>) + <span class="string">"\t个数: "</span> + num);</div><div class="line">            bytes = ms.splitBigData(num);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">""</span>);</div><div class="line">        ms.output(bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 读取数据，并将对应数数据的 到对应的bit中，并返回byte数组</div><div class="line">     * <span class="doctag">@param</span> num 读取的数据</div><div class="line">     * <span class="doctag">@return</span> byte数组  dataBytes</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] splitBigData(<span class="keyword">int</span> num) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> bitIndex = num + (<span class="number">1l</span> &lt;&lt; <span class="number">31</span>);         <span class="comment">//获取num数据对应bit数组（虚拟）的索引</span></div><div class="line">        <span class="keyword">int</span> index = (<span class="keyword">int</span>) (bitIndex / <span class="number">8</span>);         <span class="comment">//bit数组（虚拟）在byte数组中的索引</span></div><div class="line">        <span class="keyword">int</span> innerIndex = (<span class="keyword">int</span>) (bitIndex % <span class="number">8</span>);    <span class="comment">//bitIndex 在byte[]数组索引index 中的具体位置</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"byte["</span> + index + <span class="string">"] 中的索引："</span> + innerIndex);</div><div class="line"></div><div class="line">        dataBytes[index] = (<span class="keyword">byte</span>) (dataBytes[index] | (<span class="number">1</span> &lt;&lt; innerIndex));</div><div class="line">        <span class="keyword">return</span> dataBytes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 输出数组中的数据</div><div class="line">     * <span class="doctag">@param</span> bytes byte数组</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (!(((bytes[i]) &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>)) &#123;</div><div class="line">                    count++;</div><div class="line">                    <span class="keyword">int</span> number = (<span class="keyword">int</span>) ((((<span class="keyword">long</span>) i * <span class="number">8</span> + j) - (<span class="number">1l</span> &lt;&lt; <span class="number">31</span>)));</div><div class="line">                    System.out.println(<span class="string">"取出的第  "</span> + count + <span class="string">"\t个数: "</span> +  number);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、分治法"><a href="#2、分治法" class="headerlink" title="2、分治法"></a>2、分治法</h3><p>分治法目前看到的解决方案有<strong>哈希分桶（Hash Buckets）</strong>和<strong>归并排序</strong>两种方案。</p>
<p>哈希分桶的思想是先遍历一遍，按照hash分N桶（比如1000桶），映射到不同的文件中。这样平均每个文件就10MB，然后分别处理这1000个文件，找出没有重复的即可。一个相同的数字，绝对不会夸文件，<a href="https://maimai.cn/web/gossip_detail?src=app&amp;webid=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1IjozNDM5ODY0MiwiaWQiOjgzODU0NDR9.zf_21BO_wwAo0t1D8UdKAC9tKXv2TuphOhGnKtCq51E" target="_blank" rel="external">有hash做保证</a>。因为算法具体还不甚了解，这里先不做详细介绍。</p>
<p>归并排序的思想可以参考这篇文章：<a href="http://www.cnblogs.com/cnyao/archive/2009/11/09/interview7.html" target="_blank" rel="external">面试题之10亿正整数问题续–关于多通道排序的问题</a></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6451990" target="_blank" rel="external">程序员编程艺术：第十章、如何给10^7个数据量的磁盘文件排序</a></li>
<li><a href="http://www.cnblogs.com/cnyao/archive/2009/11/09/interview7.html" target="_blank" rel="external">面试题之10亿正整数问题续–关于多通道排序的问题</a></li>
<li><a href="http://yacare.iteye.com/blog/1969931" target="_blank" rel="external">利用位映射原理对大数据排重</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6279498" target="_blank" rel="external">十道海量数据处理面试题与十个方法大总结</a></li>
<li><a href="http://www.cnblogs.com/moonandstar08/p/5236539.html" target="_blank" rel="external">海量数据处理之BitMap</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;首先分析多大的内存能够表示10亿的数呢？一个int型占4字节，10亿就是40亿字节（很明显就是4GB），也就是如果完全读入内存需要占用4GB，而题目只给1GB内存，显然不可能将所有数据读入内存。&lt;/p&gt;
&lt;p&gt;我们先不考虑时间复杂度，仅考虑解决问题。那么接下来的思路一般有两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;位图法&lt;/strong&gt;：用一个bit位来标识一个int整数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分治法&lt;/strong&gt;：分批处理这10亿的数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一种是位图法，如果各位老司机有经验的话很快会想到int整型数是4字节（Byte），也就是32位（bit），如果能用一个bit位来标识一个int整数那么存储空间将大大减少。另一种是分治法，内存有限，我想办法分批读取处理。下面大致分析一下两种思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法的基本概念和Java实现</title>
    <link href="http://github.com/2017/07/11/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8CJava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://github.com/2017/07/11/遗传算法的基本概念和Java实现/</id>
    <published>2017-07-11T10:30:55.000Z</published>
    <updated>2017-07-11T10:57:00.982Z</updated>
    
    <content type="html"><![CDATA[<p>基因遗传算法是一种灵感源于达尔文自然进化理论的启发式搜索算法。该算法反映了自然选择的过程，即最适者被选定繁殖，并产生下一代。本文简要地介绍了遗传算法的基本概念和实现，希望能为读者展示启发式搜索的魅力。</p>
<p><img src="/gallery/genetic-algorithms/1-BYDJpa6M2rzWNSurvspf8Q.png" alt="如上图（左）所示，遗传算法的个体由多条染色体组成，每条染色体由多个基因组成。上图（右）展示了染色体分割和组合的方式。"></p>
<a id="more"></a>
<h3 id="遗传算法的概念"><a href="#遗传算法的概念" class="headerlink" title="遗传算法的概念"></a><strong>遗传算法的概念</strong></h3><p>自然选择的过程从选择群体中最适应环境的个体开始。后代继承了父母的特性，并且这些特性将添加到下一代中。如果父母具有更好的适应性，那么它们的后代将更易于存活。迭代地进行该自然选择的过程，最终，我们将得到由最适应环境的个体组成的一代。</p>
<p>这一概念可以被应用于搜索问题中。我们考虑一个问题的诸多解决方案，并从中搜寻出最佳方案。</p>
<p>遗传算法含以下五步：</p>
<ol>
<li>初始化</li>
<li>个体评价（计算适应度函数）</li>
<li>选择运算</li>
<li>交叉运算</li>
<li>变异运算</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h4><p>该过程从种群的一组个体开始，且每一个体都是待解决问题的一个候选解。</p>
<p>个体以一组参数（变量）为特征，这些特征被称为基因，串联这些基因就可以组成染色体（问题的解）。</p>
<p>在遗传算法中，单个个体的基因组以字符串的方式呈现，通常我们可以使用二进制（1 和 0 的字符串）编码，即一个二进制串代表一条染色体串。因此可以说我们将基因串或候选解的特征编码在染色体中。</p>
<p><img src="/gallery/genetic-algorithms/1-vIrsxg12DSltpdWoO561yA.png" alt="*种群、染色体和基因*"></p>
<h4 id="个体评价（计算适应度函数）"><a href="#个体评价（计算适应度函数）" class="headerlink" title="个体评价（计算适应度函数）"></a><strong>个体评价（计算适应度函数）</strong></h4><p>个体评价利用适应度函数评估了该个体对环境的适应度（与其它个体竞争的能力）。每一个体都有适应度评分，个体被选中进行繁殖的可能性取决于其适应度评分。适应度函数值越大，解的质量就越高。适应度函数是遗传算法进化的驱动力，也是进行自然选择的唯一标准，它的设计应结合求解问题本身的要求而定。</p>
<h4 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a><strong>选择运算</strong></h4><p>选择运算的目的是选出适应性最好的个体，并使它们将基因传到下一代中。基于其适应度评分，我们选择多对较优个体（父母）。适应度高的个体更易被选中繁殖，即将较优父母的基因传递到下一代。</p>
<h4 id="交叉运算"><a href="#交叉运算" class="headerlink" title="交叉运算"></a><strong>交叉运算</strong></h4><p>交叉运算是遗传算法中最重要的阶段。对每一对配对的父母，基因都存在随机选中的交叉点。</p>
<p>举个例子，下图的交叉点为 3：</p>
<p><img src="/gallery/genetic-algorithms/1-Wi6ou9jyMHdxrF2dgczz7g.png" alt="Crossover point"></p>
<p>父母间在交叉点之前交换基因，从而产生了后代。</p>
<p><img src="/gallery/genetic-algorithms/1-eQxFezBtdfdLxHsvSvBNGQ.png" alt="Exchanging genes among parents"></p>
<p>父母间交换基因，然后产生的新后代被添加到种群中。</p>
<p><img src="/gallery/genetic-algorithms/1-_Dl6Hwkay-UU24DJ_oVrLw.png" alt="New offspring"></p>
<h4 id="变异运算"><a href="#变异运算" class="headerlink" title="变异运算"></a><strong>变异运算</strong></h4><p>在某些形成的新后代中，它们的某些基因可能受到低概率变异因子的作用。这意味着二进制位串中的某些位可能会翻转。</p>
<p><img src="/gallery/genetic-algorithms/1-CGt_UhRqCjIDb7dqycmOAg.png" alt="变异运算前后"></p>
<p>变异运算可用于保持种群内的多样性，并防止过早收敛。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a><strong>终止</strong></h4><p>在群体收敛的情况下（群体内不产生与前一代差异较大的后代）该算法终止。也就是说遗传算法提供了一组问题的解。</p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a><strong>案例实现</strong></h3><p>种群的规模恒定。新一代形成时，适应度最差的个体凋亡，为后代留出空间。这些阶段的序列被不断重复，以产生优于先前的新一代。</p>
<p>这一迭代过程的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">START</div><div class="line">Generate the initial population</div><div class="line">Compute fitness</div><div class="line">REPEAT</div><div class="line">    Selection</div><div class="line">    Crossover</div><div class="line">    Mutation</div><div class="line">    Compute fitness</div><div class="line">UNTIL population has converged</div><div class="line">STOP</div></pre></td></tr></table></figure>
<h4 id="Java-中的实例实现"><a href="#Java-中的实例实现" class="headerlink" title="Java 中的实例实现"></a><strong>Java 中的实例实现</strong></h4><p>以下展示的是遗传算法在 Java 中的示例实现，我们可以随意调试和修改这些代码。给定一组五个基因，每一个基因可以保存一个二进制值 0 或 1。这里的适应度是基因组中 1 的数量。如果基因组内共有五个 1，则该个体适应度达到最大值。如果基因组内没有 1，那么个体的适应度达到最小值。该遗传算法希望最大化适应度，并提供适应度达到最大的个体所组成的群体。注意：本例中，在交叉运算与突变运算之后，适应度最低的个体被新的，适应度最高的后代所替代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Vijini</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">//Main class</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDemoGA</span> </span>&#123;</div><div class="line"></div><div class="line">    Population population = <span class="keyword">new</span> Population();</div><div class="line">    Individual fittest;</div><div class="line">    Individual secondFittest;</div><div class="line">    <span class="keyword">int</span> generationCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        SimpleDemoGA demo = <span class="keyword">new</span> SimpleDemoGA();</div><div class="line">        </div><div class="line">        <span class="comment">//Initialize population</span></div><div class="line">        demo.population.initializePopulation(<span class="number">10</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//Calculate fitness of each individual</span></div><div class="line">        demo.population.calculateFitness();</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"Generation: "</span> + demo.generationCount + <span class="string">" Fittest: "</span> + demo.population.fittest);</div><div class="line"></div><div class="line">        <span class="comment">//While population gets an individual with maximum fitness</span></div><div class="line">        <span class="keyword">while</span> (demo.population.fittest &lt; <span class="number">5</span>) &#123;</div><div class="line">            ++demo.generationCount;</div><div class="line">            </div><div class="line">            <span class="comment">//Do selection</span></div><div class="line">            demo.selection();</div><div class="line">            </div><div class="line">            <span class="comment">//Do crossover</span></div><div class="line">            demo.crossover();</div><div class="line">            </div><div class="line">            <span class="comment">//Do mutation under a random probability</span></div><div class="line">            <span class="keyword">if</span> (rn.nextInt()%<span class="number">7</span> &lt; <span class="number">5</span>) &#123;</div><div class="line">                demo.mutation();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//Add fittest offspring to population</span></div><div class="line">            demo.addFittestOffspring();</div><div class="line">            </div><div class="line">            <span class="comment">//Calculate new fitness value </span></div><div class="line">            demo.population.calculateFitness();</div><div class="line">            </div><div class="line">            System.out.println(<span class="string">"Generation: "</span> + demo.generationCount + <span class="string">" Fittest: "</span> + demo.population.fittest);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"\nSolution found in generation "</span> + demo.generationCount);</div><div class="line">        System.out.println(<span class="string">"Fitness: "</span>+demo.population.getFittest().fitness);</div><div class="line">        System.out.print(<span class="string">"Genes: "</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            System.out.print(demo.population.getFittest().genes[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">""</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Selection</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selection</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//Select the most fittest individual</span></div><div class="line">        fittest = population.getFittest();</div><div class="line">        </div><div class="line">        <span class="comment">//Select the second most fittest individual</span></div><div class="line">        secondFittest = population.getSecondFittest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Crossover</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crossover</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        <span class="comment">//Select a random crossover point</span></div><div class="line">        <span class="keyword">int</span> crossOverPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="comment">//Swap values among parents</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; crossOverPoint; i++) &#123;</div><div class="line">            <span class="keyword">int</span> temp = fittest.genes[i];</div><div class="line">            fittest.genes[i] = secondFittest.genes[i];</div><div class="line">            secondFittest.genes[i] = temp;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Mutation</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mutation</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        <span class="comment">//Select a random mutation point</span></div><div class="line">        <span class="keyword">int</span> mutationPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="comment">//Flip values at the mutation point</span></div><div class="line">        <span class="keyword">if</span> (fittest.genes[mutationPoint] == <span class="number">0</span>) &#123;</div><div class="line">            fittest.genes[mutationPoint] = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            fittest.genes[mutationPoint] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mutationPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (secondFittest.genes[mutationPoint] == <span class="number">0</span>) &#123;</div><div class="line">            secondFittest.genes[mutationPoint] = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            secondFittest.genes[mutationPoint] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get fittest offspring</span></div><div class="line">    <span class="function">Individual <span class="title">getFittestOffspring</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (fittest.fitness &gt; secondFittest.fitness) &#123;</div><div class="line">            <span class="keyword">return</span> fittest;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> secondFittest;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//Replace least fittest individual from most fittest offspring</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFittestOffspring</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//Update fitness values of offspring</span></div><div class="line">        fittest.calcFitness();</div><div class="line">        secondFittest.calcFitness();</div><div class="line">        </div><div class="line">        <span class="comment">//Get index of least fit individual</span></div><div class="line">        <span class="keyword">int</span> leastFittestIndex = population.getLeastFittestIndex();</div><div class="line">        </div><div class="line">        <span class="comment">//Replace least fittest individual from most fittest offspring</span></div><div class="line">        population.individuals[leastFittestIndex] = getFittestOffspring();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//Individual class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Individual</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> fitness = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] genes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">    <span class="keyword">int</span> geneLength = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Individual</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">        <span class="comment">//Set genes randomly for each individual</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; genes.length; i++) &#123;</div><div class="line">            genes[i] = rn.nextInt() % <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        fitness = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate fitness</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calcFitness</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        fitness = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (genes[i] == <span class="number">1</span>) &#123;</div><div class="line">                ++fitness;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Population class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Population</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> popSize = <span class="number">10</span>;</div><div class="line">    Individual[] individuals = <span class="keyword">new</span> Individual[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> fittest = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//Initialize population</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializePopulation</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            individuals[i] = <span class="keyword">new</span> Individual();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get the fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Individual <span class="title">getFittest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxFit = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (maxFit &lt;= individuals[i].fitness) &#123;</div><div class="line">                maxFit = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fittest = individuals[maxFit].fitness;</div><div class="line">        <span class="keyword">return</span> individuals[maxFit];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get the second most fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Individual <span class="title">getSecondFittest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxFit1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxFit2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (individuals[i].fitness &gt; individuals[maxFit1].fitness) &#123;</div><div class="line">                maxFit2 = maxFit1;</div><div class="line">                maxFit1 = i;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (individuals[i].fitness &gt; individuals[maxFit2].fitness) &#123;</div><div class="line">                maxFit2 = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> individuals[maxFit2];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get index of least fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeastFittestIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> minFit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (minFit &gt;= individuals[i].fitness) &#123;</div><div class="line">                minFit = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minFit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate fitness of each individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateFitness</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            individuals[i].calcFitness();</div><div class="line">        &#125;</div><div class="line">        getFittest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>原文来自：<a href="https://medium.com/towards-data-science/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3" target="_blank" rel="external">Introduction to Genetic Algorithms — Including Example Code</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基因遗传算法是一种灵感源于达尔文自然进化理论的启发式搜索算法。该算法反映了自然选择的过程，即最适者被选定繁殖，并产生下一代。本文简要地介绍了遗传算法的基本概念和实现，希望能为读者展示启发式搜索的魅力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/genetic-algorithms/1-BYDJpa6M2rzWNSurvspf8Q.png&quot; alt=&quot;如上图（左）所示，遗传算法的个体由多条染色体组成，每条染色体由多个基因组成。上图（右）展示了染色体分割和组合的方式。&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Integer变量相等（==）比较问题</title>
    <link href="http://github.com/2017/07/11/%E3%80%90Java%E3%80%91Integer%E5%8F%98%E9%87%8F%E7%9B%B8%E7%AD%89%EF%BC%88==%EF%BC%89%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/07/11/【Java】Integer变量相等（==）比较问题/</id>
    <published>2017-07-11T04:30:55.000Z</published>
    <updated>2017-07-11T05:12:03.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这是关于一段令人疑惑的Java代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestIntegerCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Integer i3 = <span class="number">100</span>;</div><div class="line">        Integer i4 = <span class="number">100</span>;</div><div class="line">        System.out.println(i3 == i4);</div><div class="line"></div><div class="line">        Integer i5 = <span class="number">1000</span>;</div><div class="line">        Integer i6 = <span class="number">1000</span>;</div><div class="line">        System.out.println(i5 == i6);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么简单，执行结果是什么？</p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<p>一个是true，一个是false！<br>这是为什么呢？为什么和大多数人心里想的不一样！</p>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据Java编译机制，<code>.java</code>文件在编译以后会生成.class文件给JVM加载执行，于是找到.class文件，反编译看了一下，发现编译器在编译我们的代码时，很调皮（聪明的）的在我们声明的变量加上了<code>valueOf</code>方法 ，代码变成了如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestIntegerCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Integer i3 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">        Integer i4 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">        System.out.println(i3 == i4);</div><div class="line"></div><div class="line">        Integer i5 = Integer.valueOf(<span class="number">1000</span>);</div><div class="line">        Integer i6 = Integer.valueOf(<span class="number">1000</span>);</div><div class="line">        System.out.println(i5 == i6);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>valueOf()</code> 方法对它做了什么，我们看看源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</div><div class="line">     * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</div><div class="line">     * required, this method should generally be used in preference to</div><div class="line">     * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</div><div class="line">     * to yield significantly better space and time performance by</div><div class="line">     * caching frequently requested values.</div><div class="line">     *</div><div class="line">     * This method will always cache values in the range -128 to 127,</div><div class="line">     * inclusive, and may cache other values outside of this range.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</div><div class="line">     * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</div><div class="line">     * <span class="doctag">@since</span>  1.5</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)    <span class="comment">//我们看到这里有个缓存，在缓存区间就返回缓存里的</span></div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];   <span class="comment">//缓存数组相应的对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);    <span class="comment">//不在缓存数组区间就new一个对象</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们发现，Integer的作者在写这个类时，为了避免重复创建对象，对Integer值做了缓存，如果这个值在缓存范围内，直接返回缓存好的对象，否则new一个新的对象返回，那究竟这个缓存到底缓存了哪些内容呢？看一下<code>IntegerCache</code>这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Cache to support the object identity semantics of autoboxing for values between</div><div class="line">     * -128 and 127 (inclusive) as required by JLS.</div><div class="line">     *</div><div class="line">     * The cache is initialized on first usage.  The size of the cache</div><div class="line">     * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</div><div class="line">     * During VM initialization, java.lang.Integer.IntegerCache.high property</div><div class="line">     * may be set and saved in the private system properties in the</div><div class="line">     * sun.misc.VM class.</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">	        <span class="comment">//检查虚拟机里是否有缓存区间配置项，如果有就赋成该值，没有就默认[-128, 127]</span></div><div class="line">            <span class="comment">// high value may be configured by property</span></div><div class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">            String integerCacheHighPropValue =</div><div class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">                    i = Math.max(i, <span class="number">127</span>);</div><div class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</div><div class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            high = h;</div><div class="line"></div><div class="line">			<span class="comment">//创建缓存数组，并初始化（缓存值）</span></div><div class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> j = low;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line"></div><div class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></div><div class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这是一个内部静态类，该类只能在Integer这个类的内部访问，这个类在初始化的时候，会去加载JVM的配置，如果有值，就用配置的值初始化缓存数组，否则就缓存<strong><code>-128</code></strong>到<strong><code>127</code></strong>之间的值。<br>再来看看我们之前的代码：</p>
<p><img src="http://img.blog.csdn.net/20170711124934286" alt=""></p>
<p>看完这个，是不是明白了呢</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzQ3NzQ3Nw==&amp;mid=2654250496&amp;idx=1&amp;sn=dad9b1ade6dca4b57020b1bc091df5fb&amp;chksm=8061f50ab7167c1c2672456b1e9f9b4293f6cab49deb08970874f7ae03fd186461acad02e389&amp;mpshare=1&amp;scene=1&amp;srcid=0711yYY7UjcX2zsrDcna3QVp#rd" target="_blank" rel="external">让人疑惑的代码，竟成大多公司面试题热门！</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;这是关于一段令人疑惑的Java代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestIntegerCache&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i3 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i4 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(i3 == i4);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i5 = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i6 = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(i5 == i6);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这么简单，执行结果是什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;true&lt;br&gt;false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个是true，一个是false！&lt;br&gt;这是为什么呢？为什么和大多数人心里想的不一样！&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 8系列之重新认识HashMap</title>
    <link href="http://github.com/2017/06/16/Java%208%E7%B3%BB%E5%88%97%E4%B9%8B%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap/"/>
    <id>http://github.com/2017/06/16/Java 8系列之重新认识HashMap/</id>
    <published>2017-06-16T09:30:55.000Z</published>
    <updated>2017-06-19T10:28:36.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来自美团点评技术团队： <a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是<code>HashMap</code>、<code>Hashtable</code>、<code>LinkedHashMap</code>和<code>TreeMap</code>，类继承关系如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20170616165413193" alt=""></p>
<a id="more"></a>
<p>下面针对各个实现类的特点做一些说明：</p>
<p>(1) <strong>HashMap</strong>：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>(2) <strong>Hashtable</strong>：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) <strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) <strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h2><p>搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。</p>
<h3 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h3><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="http://img.blog.csdn.net/20170616165613975" alt=""></p>
<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么？优点呢？</p>
<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 <code>Node[] table</code>，即哈希桶数组，明显它是一个Node的数组。我们来看<code>Node</code>[JDK1.8]是何物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</div></pre></td></tr></table></figure>
<p>系统将调用”美团”这个key的<code>hashCode()</code>方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></div><div class="line"><span class="keyword">int</span> modCount;  </div><div class="line"><span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a> ，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6105630</a> 。</p>
<h3 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a><strong>功能实现-方法</strong></h3><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p>
<h4 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a><strong>1. 确定哈希桶数组索引位置</strong></h4><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">方法一：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值</strong>、<strong>高位运算</strong>、<strong>取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<p><img src="http://img.blog.csdn.net/20170616170559316" alt=""></p>
<h4 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a><strong>2. 分析HashMap的put方法</strong></h4><p>HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。</p>
<p><img src="http://img.blog.csdn.net/20170616170655449" alt=""></p>
<p>①. 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③. 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<p>JDK1.8HashMap的put方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line"> <span class="number">4</span> &#125;</div><div class="line"> <span class="number">5</span> </div><div class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"> <span class="number">7</span>                <span class="keyword">boolean</span> evict) &#123;</div><div class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></div><div class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line"><span class="number">11</span>         n = (tab = resize()).length;</div><div class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理 </span></div><div class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </div><div class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</div><div class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></div><div class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"><span class="number">20</span>             e = p;</div><div class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></div><div class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></div><div class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></div><div class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></div><div class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</div><div class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</div><div class="line"><span class="number">32</span>                 &#125;</div><div class="line">                    <span class="comment">// key已经存在直接覆盖value</span></div><div class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </div><div class="line"><span class="number">35</span>                            <span class="keyword">break</span>;</div><div class="line"><span class="number">36</span>                 p = e;</div><div class="line"><span class="number">37</span>             &#125;</div><div class="line"><span class="number">38</span>         &#125;</div><div class="line"><span class="number">39</span>         </div><div class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line"><span class="number">41</span>             V oldValue = e.value;</div><div class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line"><span class="number">43</span>                 e.value = value;</div><div class="line"><span class="number">44</span>             afterNodeAccess(e);</div><div class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</div><div class="line"><span class="number">46</span>         &#125;</div><div class="line"><span class="number">47</span>     &#125;</div><div class="line"></div><div class="line"><span class="number">48</span>     ++modCount;</div><div class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></div><div class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line"><span class="number">51</span>         resize();</div><div class="line"><span class="number">52</span>     afterNodeInsertion(evict);</div><div class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">54</span> &#125;</div></pre></td></tr></table></figure>
<h4 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a><strong>3. 扩容机制</strong></h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></div><div class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </div><div class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></div><div class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</div><div class="line"> <span class="number">7</span>     &#125;</div><div class="line"> <span class="number">8</span>  </div><div class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></div><div class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></div><div class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></div><div class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></div><div class="line"><span class="number">13</span> &#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></div><div class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></div><div class="line"> <span class="number">8</span>             do &#123;</div><div class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</div><div class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></div><div class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></div><div class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></div><div class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></div><div class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>         &#125;</div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span> &#125;</div></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="http://img.blog.csdn.net/20170616171207339" alt=""></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="http://img.blog.csdn.net/20170616171255934" alt=""></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="http://img.blog.csdn.net/20170616171330516" alt=""></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="http://img.blog.csdn.net/20170616171352780" alt=""></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line"> <span class="number">2</span>     Node&lt;K,V&gt;[] oldTab = table;</div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">int</span> oldThr = threshold;</div><div class="line"> <span class="number">5</span>     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line"> <span class="number">6</span>     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">7</span>         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></div><div class="line"> <span class="number">8</span>         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line"> <span class="number">9</span>             threshold = Integer.MAX_VALUE;</div><div class="line"><span class="number">10</span>             <span class="keyword">return</span> oldTab;</div><div class="line"><span class="number">11</span>         &#125;</div><div class="line"><span class="number">12</span>         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></div><div class="line"><span class="number">13</span>         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line"><span class="number">14</span>                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line"><span class="number">15</span>             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span>     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line"><span class="number">18</span>         newCap = oldThr;</div><div class="line"><span class="number">19</span>     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line"><span class="number">20</span>         newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line"><span class="number">21</span>         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line"><span class="number">22</span>     &#125;</div><div class="line"><span class="number">23</span>     <span class="comment">// 计算新的resize上限</span></div><div class="line"><span class="number">24</span>     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">25</span> </div><div class="line"><span class="number">26</span>         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line"><span class="number">27</span>         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line"><span class="number">28</span>                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line"><span class="number">29</span>     &#125;</div><div class="line"><span class="number">30</span>     threshold = newThr;</div><div class="line"><span class="number">31</span>     <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</div><div class="line"><span class="number">32</span>         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line"><span class="number">33</span>     table = newTab;</div><div class="line"><span class="number">34</span>     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">35</span>         <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line"><span class="number">36</span>         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line"><span class="number">37</span>             Node&lt;K,V&gt; e;</div><div class="line"><span class="number">38</span>             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">39</span>                 oldTab[j] = <span class="keyword">null</span>;</div><div class="line"><span class="number">40</span>                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line"><span class="number">41</span>                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line"><span class="number">42</span>                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">43</span>                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line"><span class="number">44</span>                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></div><div class="line"><span class="number">45</span>                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">46</span>                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">47</span>                     Node&lt;K,V&gt; next;</div><div class="line"><span class="number">48</span>                     do &#123;</div><div class="line"><span class="number">49</span>                         next = e.next;</div><div class="line"><span class="number">50</span>                         <span class="comment">// 原索引</span></div><div class="line"><span class="number">51</span>                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">52</span>                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">53</span>                                 loHead = e;</div><div class="line"><span class="number">54</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">55</span>                                 loTail.next = e;</div><div class="line"><span class="number">56</span>                             loTail = e;</div><div class="line"><span class="number">57</span>                         &#125;</div><div class="line"><span class="number">58</span>                         <span class="comment">// 原索引+oldCap</span></div><div class="line"><span class="number">59</span>                         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">60</span>                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">61</span>                                 hiHead = e;</div><div class="line"><span class="number">62</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">63</span>                                 hiTail.next = e;</div><div class="line"><span class="number">64</span>                             hiTail = e;</div><div class="line"><span class="number">65</span>                         &#125;</div><div class="line"><span class="number">66</span>                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line"><span class="number">67</span>                     <span class="comment">// 原索引放到bucket里</span></div><div class="line"><span class="number">68</span>                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">69</span>                         loTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">70</span>                         newTab[j] = loHead;</div><div class="line"><span class="number">71</span>                     &#125;</div><div class="line"><span class="number">72</span>                     <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line"><span class="number">73</span>                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">74</span>                         hiTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">75</span>                         newTab[j + oldCap] = hiHead;</div><div class="line"><span class="number">76</span>                     &#125;</div><div class="line"><span class="number">77</span>                 &#125;</div><div class="line"><span class="number">78</span>             &#125;</div><div class="line"><span class="number">79</span>         &#125;</div><div class="line"><span class="number">80</span>     &#125;</div><div class="line"><span class="number">81</span>     <span class="keyword">return</span> newTab;</div><div class="line"><span class="number">82</span> &#125;</div></pre></td></tr></table></figure>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">public class HashMapInfiniteLoop &#123;  </div><div class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2, 0.75f);  </div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        map.put(5, "C");  </div><div class="line"></div><div class="line">        new Thread("Thread1") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(7, "B");  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();  </div><div class="line">        new Thread("Thread2") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(3, "A);  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<p><img src="http://img.blog.csdn.net/20170616171711863" alt=""></p>
<p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<p><img src="http://img.blog.csdn.net/20170616171741879" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170616171859708" alt=""></p>
<p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src="http://img.blog.csdn.net/20170616171810754" alt=""></p>
<p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h2 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a><strong>JDK1.8与JDK1.7的性能对比</strong></h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p>
<h3 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a><strong>Hash较均匀的情况</strong></h3><p>为了便于测试，我们先写一个类Key，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    Key(<span class="keyword">int</span> value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Key key = (Key) o;</div><div class="line">        <span class="keyword">return</span> value == key.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_KEY = <span class="number">10_000_000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS_CACHE = <span class="keyword">new</span> Key[MAX_KEY];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = <span class="keyword">new</span> Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">of</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mapSize)</span> </span>&#123;</div><div class="line"></div><div class="line">     HashMap&lt;Key, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; ++i) &#123;</div><div class="line">         map.put(Keys.of(i), i);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">long</span> beginTime = System.nanoTime(); <span class="comment">//获取纳秒</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; i++) &#123;</div><div class="line">         map.get(Keys.of(i));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">     System.out.println(endTime - beginTime);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;= <span class="number">1000</span> <span class="number">0000</span>;i*= <span class="number">10</span>)&#123;</div><div class="line">         test(i);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：</p>
<p><img src="http://img.blog.csdn.net/20170616172058883" alt=""></p>
<p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p>
<h3 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a><strong>Hash极不均匀的情况</strong></h3><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仍然执行main方法，得出的结果如下表所示：</p>
<p><img src="http://img.blog.csdn.net/20170616172148396" alt=""></p>
<p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p>
<pre><code>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>
<p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ol>
<li>JDK1.7&amp;JDK1.8 源码。</li>
<li>酷壳COOLSHELL，<a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="external">疫苗：JAVA HASHMAP的死循环</a>，2013</li>
<li>CSDN博客频道，<a href="http://blog.csdn.net/xuefeng0707/article/details/40797085" target="_blank" rel="external">HashMap多线程死循环问题</a>，2014。</li>
<li>红黑联盟，<a href="http://www.2cto.com/kf/201505/401433.html" target="_blank" rel="external">Java类集框架之HashMap(JDK1.8)源码剖析</a>，2015。</li>
<li>CSDN博客频道， <a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">教你初步了解红黑树</a>，2010。</li>
<li>Java Code Geeks，<a href="https://www.javacodegeeks.com/2014/04/hashmap-performance-improvements-in-java-8.html" target="_blank" rel="external">HashMap performance improvements in Java 8</a>，2014。</li>
<li>Importnew，<a href="http://www.importnew.com/13384.html" target="_blank" rel="external">危险！在HashMap中将可变对象用作Key</a>，2014。</li>
<li>CSDN博客频道，<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">为什么一般hashtable的桶数会取一个素数</a>，2013。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自美团点评技术团队： &lt;a href=&quot;http://tech.meituan.com/java-hashmap.html&quot;&gt;Java 8系列之重新认识HashMap&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是&lt;code&gt;HashMap&lt;/code&gt;、&lt;code&gt;Hashtable&lt;/code&gt;、&lt;code&gt;LinkedHashMap&lt;/code&gt;和&lt;code&gt;TreeMap&lt;/code&gt;，类继承关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170616165413193&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【面试题】Java String常量相等（==）问题</title>
    <link href="http://github.com/2017/06/15/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91Java%20String%E5%B8%B8%E9%87%8F%E7%9B%B8%E7%AD%89%EF%BC%88==%EF%BC%89%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/06/15/【面试题】Java String常量相等（==）问题/</id>
    <published>2017-06-15T08:51:55.000Z</published>
    <updated>2017-06-15T09:03:38.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>以下三个结果分别输出（true or false）？别小看它，很多程序员因为上面问题出过生产bug</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String s3 = <span class="string">"s"</span>;</div><div class="line">String s4 = <span class="string">"s"</span>;</div><div class="line">System.out.println(s3==s4);</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">String s5 = <span class="string">"hello"</span>;</div><div class="line">String s6 = <span class="string">"he"</span>+<span class="string">"llo"</span>;</div><div class="line">System.out.println(s5==s6);</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">Integer i = <span class="number">2017</span>;</div><div class="line">Integer j = <span class="number">2017</span>;</div><div class="line">System.out.println(i==j);</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"s"</span>);</div><div class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"s"</span>);</div><div class="line">System.out.println(s1==s2);</div><div class="line">System.out.println(s1.intern()==s2.intern());</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>真正执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String s3 = <span class="string">"s"</span>;</div><div class="line">String s4 = <span class="string">"s"</span>;</div><div class="line">System.out.println(s3==s4);   <span class="comment">//true</span></div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">String s5 = <span class="string">"hello"</span>;</div><div class="line">String s6 = <span class="string">"he"</span>+<span class="string">"llo"</span>;</div><div class="line">System.out.println(s5==s6);   <span class="comment">//true</span></div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">Integer i = <span class="number">2017</span>;</div><div class="line">Integer j = <span class="number">2017</span>;</div><div class="line">System.out.println(i==j);   <span class="comment">//false</span></div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"s"</span>);</div><div class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"s"</span>);</div><div class="line">System.out.println(s1==s2);   <span class="comment">//false</span></div><div class="line">System.out.println(s1.intern()==s2.intern());   <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><ol>
<li><p>看看Integer的源代码就知道Integer 把-128-127之间的每个值建立了缓存池，所以Integer i =127，Integer j =127，他们是true，超出就是false。</p>
</li>
<li><p>String s = “s” 是常量池中创建一个对象”s”，所以是true。而String s = new String（”s”）在堆上面分配内存创建一个String对象，栈放了对象引用。如下图：</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20170615170007540" alt=""></p>
<p>但在调用s.intern()方法的时候，会将共享池中的字符串与外部的字符串(s）进行比较,如果共享池存在，返回它，如果不同则将外部字符串放入共享池中，并返回其字符串的引用，这样做的好处就是能够节约空间。</p>
<p>String 的<code>intern()</code>方法的官方解释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Returns an interned string equal to this string. The VM maintains an internal set of</div><div class="line">  * unique strings. All string literals found in loaded classes'</div><div class="line">  * constant pools are automatically interned. Manually-interned strings are only weakly</div><div class="line">  * referenced, so calling &#123;<span class="doctag">@code</span> intern&#125; won't lead to unwanted retention.</div><div class="line">  *</div><div class="line">  * &lt;p&gt;Interning is typically used because it guarantees that for interned strings</div><div class="line">  * &#123;<span class="doctag">@code</span> a&#125; and &#123;<span class="doctag">@code</span> b&#125;, &#123;<span class="doctag">@code</span> a.equals(b)&#125; can be simplified to</div><div class="line">  * &#123;<span class="doctag">@code</span> a == b&#125;. (This is not true of non-interned strings.)</div><div class="line">  *</div><div class="line">  * &lt;p&gt;Many applications find it simpler and more convenient to use an explicit</div><div class="line">  * &#123;<span class="doctag">@link</span> java.util.HashMap&#125; to implement their own pools.</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>s.intern()作用还是很多，比如for循环创建String对象，因为代码事先不并不知道是否存在”hello”或者其他字符串的实例。这样可以节约很多内存空间。</p>
<p>参考资料：</p>
<p>1、<a href="https://www.zhihu.com/question/60949531/answer/182458705" target="_blank" rel="external">你遇到过哪些质量很高的 Java 面试？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;以下三个结果分别输出（true or false）？别小看它，很多程序员因为上面问题出过生产bug&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String s3 = &lt;span class=&quot;string&quot;&gt;&quot;s&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s4 = &lt;span class=&quot;string&quot;&gt;&quot;s&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s3==s4);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;---&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s5 = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s6 = &lt;span class=&quot;string&quot;&gt;&quot;he&quot;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&quot;llo&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s5==s6);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;---&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Integer i = &lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Integer j = &lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(i==j);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;---&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;s&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;s&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s1==s2);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s1.intern()==s2.intern());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>详解Java类的生命周期</title>
    <link href="http://github.com/2017/06/02/%E8%AF%A6%E8%A7%A3Java%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://github.com/2017/06/02/详解Java类的生命周期/</id>
    <published>2017-06-02T03:36:55.000Z</published>
    <updated>2017-06-02T03:51:10.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>最近有位细心的朋友在阅读笔者的文章时，对Java类的生命周期问题有一些疑惑，笔者打开百度搜了一下相关的问题，看到网上的资料很少有把这个问题讲明白的，主要是因为目前国内Java方面的教材大多只是告诉你“怎样做”，但至于“为什么这样做”却不多说，所以造成大家在基础和原理方面的知识比较匮乏，所以笔者今天就斗胆来讲一下这个问题，权当抛砖引玉，希望对在这个问题上有疑惑的朋友有所帮助，文中有说的不对的地方，也希望各路高手前来指正。</p>
<p>首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色：</p>
<ul>
<li><strong>方法区</strong>：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。</li>
<li><strong>常量池</strong>：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。</li>
<li><strong>堆区</strong>：用于存放类的对象实例。</li>
<li><strong>栈区</strong>：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。</li>
</ul>
<a id="more"></a>
<p>除了以上四个内存区域之外，jvm中的运行时内存区域还包括<strong>本地方法栈</strong>和<strong>程序计数器</strong>，这两个区域与java类的生命周期关系不是很大，在这里就不说了，感兴趣的朋友可以自己百度一下。</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a><strong>类的生命周期</strong></h2><p>当我们编写一个java的源文件后，经过编译会生成一个后缀名为class的文件，这种文件叫做字节码文件，只有这种字节码文件才能够在java虚拟机中运行，java类的生命周期就是指一个class文件从加载到卸载的全过程。</p>
<p>一个java类的完整的生命周期会经历<strong>加载、连接、初始化、使用、</strong>和<strong>卸载</strong>五个阶段，当然也有在加载或者连接之后没有被初始化就直接被使用的情况，如图所示：</p>
<p><img src="http://img.blog.csdn.net/20170602113030666" alt=""></p>
<p>下面我们就依次来说一说这五个阶段。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h3><p>在java中，我们经常会接触到一个词——<strong>类加载</strong>，它和这里的加载并不是一回事，通常我们说类加载指的是类的生命周期中加载、连接、初始化三个阶段。在加载阶段，java虚拟机会做什么工作呢？其实很简单，就是找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。</p>
<p>类的加载方式比较灵活，我们最常用的加载方式有两种，一种是根据类的全路径名找到相应的class文件，然后从class文件中读取文件内容；另一种是从jar文件中读取。另外，还有下面几种方式也比较常用：</p>
<ul>
<li><p>从网络中获取：比如10年前十分流行的Applet。</p>
</li>
<li><p>根据一定的规则实时生成，比如设计模式中的动态代理模式，就是根据相应的类自动生成它的代理类。</p>
</li>
<li><p>从非class文件中获取，其实这与直接从class文件中获取的方式本质上是一样的，这些非class文件在jvm中运行之前会被转换为可被jvm所识别的字节码文件。</p>
</li>
</ul>
<p>对于加载的时机，各个虚拟机的做法并不一样，但是有一个原则，就是当jvm“预期”到一个类将要被使用时，就会在使用它之前对这个类进行加载。比如说，在一段代码中出现了一个类的名字，jvm在执行这段代码之前并不能确定这个类是否会被使用到，于是，有些jvm会在执行前就加载这个类，而有些则在真正需要用的时候才会去加载它，这取决于具体的jvm实现。我们常用的hotspot虚拟机是采用的后者，就是说当真正用到一个类的时候才对它进行加载。</p>
<p>加载阶段是类的生命周期中的第一个阶段，加载阶段之后，是连接阶段。有一点需要注意，就是有时连接阶段并不会等加载阶段完全完成之后才开始，而是交叉进行，可能一个类只加载了一部分之后，连接阶段就已经开始了。但是这两个阶段总的开始时间和完成时间总是固定的：加载阶段总是在连接阶段之前开始，连接阶段总是在加载阶段完成之后完成。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a><strong>连接</strong></h3><p>连接阶段比较复杂，一般会跟加载阶段和初始化阶段交叉进行，这个阶段的主要任务就是做一些加载后的验证工作以及一些初始化前的准备工作，可以细分为三个步骤：验证、准备和解析。</p>
<ol>
<li><p><strong>验证</strong>：当一个类被加载之后，必须要验证一下这个类是否合法，比如这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。总之，这个阶段的目的就是保证加载的类是能够被jvm所运行。</p>
</li>
<li><p><strong>准备</strong>：准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值，对于非静态的变量，则不会为它们分配内存。有一点需要注意，这时候，静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。jvm默认的初值是这样的：</p>
<ul>
<li><strong>基本类型</strong>：（int、long、short、char、byte、boolean、float、double）的默认值为0。</li>
<li><strong>引用类型</strong>：默认值为null。</li>
<li><strong>常量</strong>：默认值为我们程序中设定的值，比如我们在程序中定义final static int a = 100，则准备阶段中a的初值就是100。</li>
</ul>
</li>
<li><p><strong>解析</strong>：这一阶段的任务就是把常量池中的符号引用转换为直接引用。那么什么是符号引用，什么又是直接引用呢？我们来举个例子：我们要找一个人，我们现有的信息是这个人的身份证号是1234567890。只有这个信息我们显然找不到这个人，但是通过公安局的身份系统，我们输入1234567890这个号之后，就会得到它的全部信息：比如安徽省黄山市余暇村18号张三，通过这个信息我们就能找到这个人了。这里，123456790就好比是一个符号引用，而安徽省黄山市余暇村18号张三就是直接引用。在内存中也是一样，比如我们要在内存中找一个类里面的一个叫做show的方法，显然是找不到。但是在解析阶段，jvm就会把show这个名字转换为指向方法区的的一块内存地址，比如c17164，通过c17164就可以找到show这个方法具体分配在内存的哪一个区域了。这里show就是符号引用，而c17164就是直接引用。在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。</p>
</li>
</ol>
<p>连接阶段完成之后会根据使用的情况（直接引用还是被动引用）来选择是否对类进行初始化。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p>如果一个类被直接引用，就会触发类的初始化。在java中，直接引用的情况有：</p>
<ul>
<li>通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。</li>
<li>通过反射方式执行以上三种行为。</li>
<li>初始化子类的时候，会触发父类的初始化。</li>
<li>作为程序入口直接运行时（也就是直接调用main方法）。</li>
</ul>
<p>除了以上四种情况，其他使用类的方式叫做被动引用，而被动引用不会触发类的初始化。请看主动引用的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitClass</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        System.out.println(<span class="string">"初始化InitClass"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String a = <span class="keyword">null</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubInitClass</span> <span class="keyword">extends</span> <span class="title">InitClass</span></span>&#123;&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 主动引用引起类的初始化的第四种情况就是运行Test1的main方法时 </div><div class="line">     * 导致Test1初始化，这一点很好理解，就不特别演示了。 </div><div class="line">     * 本代码演示了前三种情况，以下代码都会引起InitClass的初始化， </div><div class="line">     * 但由于初始化只会进行一次，运行时请将注解去掉，依次运行查看结果。 </div><div class="line">     * <span class="doctag">@param</span> args </div><div class="line">     * <span class="doctag">@throws</span> Exception </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;  </div><div class="line">    <span class="comment">//  主动引用引起类的初始化一: new对象、读取或设置类的静态变量、调用类的静态方法。  </span></div><div class="line">    <span class="comment">//  new InitClass();  </span></div><div class="line">    <span class="comment">//  InitClass.a = "";  </span></div><div class="line">    <span class="comment">//  String a = InitClass.a;  </span></div><div class="line">    <span class="comment">//  InitClass.method();  </span></div><div class="line">          </div><div class="line">    <span class="comment">//  主动引用引起类的初始化二：通过反射实例化对象、读取或设置类的静态变量、调用类的静态方法。  </span></div><div class="line">    <span class="comment">//  Class cls = InitClass.class;  </span></div><div class="line">    <span class="comment">//  cls.newInstance();  </span></div><div class="line">          </div><div class="line">    <span class="comment">//  Field f = cls.getDeclaredField("a");  </span></div><div class="line">    <span class="comment">//  f.get(null);  </span></div><div class="line">    <span class="comment">//  f.set(null, "s");  </span></div><div class="line">      </div><div class="line">    <span class="comment">//  Method md = cls.getDeclaredMethod("method");  </span></div><div class="line">    <span class="comment">//  md.invoke(null, null);  </span></div><div class="line">              </div><div class="line">    <span class="comment">//  主动引用引起类的初始化三：实例化子类，引起父类初始化。  </span></div><div class="line">    <span class="comment">//  new SubInitClass();  </span></div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的程序演示了主动引用触发类的初始化的四种情况。</p>
<p>类的初始化过程是这样的：<strong>按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句。</strong>先看一个例子，首先建两个类用来显示赋值操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Field1</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Field1</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Field1构造方法"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Field2</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Field2</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Field2构造方法"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是演示初始化顺序的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitClass2</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"运行父类静态代码"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field1 f1 = <span class="keyword">new</span> Field1();  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field1 f2;   </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubInitClass2</span> <span class="keyword">extends</span> <span class="title">InitClass2</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"运行子类静态代码"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field2 f2 = <span class="keyword">new</span> Field2();  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;  </div><div class="line">        <span class="keyword">new</span> SubInitClass2();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，初始化的顺序是：第03行，第05行，第11行，第13行。第04行是声明操作，没有赋值，所以不会被运行。而下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitClass2</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field1 f1 = <span class="keyword">new</span> Field1();  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field1 f2;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"运行父类静态代码"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubInitClass2</span> <span class="keyword">extends</span> <span class="title">InitClass2</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field2 f2 = <span class="keyword">new</span> Field2();  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"运行子类静态代码"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;  </div><div class="line">        <span class="keyword">new</span> SubInitClass2();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 初始化顺序为：第02行、第05行、第10行、第12行，各位可以运行程序查看结果。</p>
<p><strong>在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。</strong></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><p>类的使用包括主动引用和被动引用，主动引用在初始化的章节中已经说过了，下面我们主要来说一下被动引用：</p>
<ul>
<li>引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。</li>
<li>定义类数组，不会引起类的初始化。</li>
<li>引用类的常量，不会引起类的初始化。</li>
</ul>
<p>被动引用的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitClass</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        System.out.println(<span class="string">"初始化InitClass"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String a = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String b = <span class="string">"b"</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubInitClass</span> <span class="keyword">extends</span> <span class="title">InitClass</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        System.out.println(<span class="string">"初始化SubInitClass"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;  </div><div class="line">    <span class="comment">//  String a = SubInitClass.a;// 引用父类的静态字段，只会引起父类初始化，而不会引起子类的初始化  </span></div><div class="line">    <span class="comment">//  String b = InitClass.b;// 使用类的常量不会引起类的初始化  </span></div><div class="line">        SubInitClass[] sc = <span class="keyword">new</span> SubInitClass[<span class="number">10</span>];<span class="comment">// 定义类数组不会引起类的初始化  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后总结一下使用阶段：<strong>使用阶段包括主动引用和被动引用，主动饮用会引起类的初始化，而被动引用不会引起类的初始化。</strong></p>
<p>当使用阶段完成之后，java类就进入了卸载阶段。</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a><strong>卸载</strong></h3><p>关于类的卸载，笔者在<a href="http://blog.csdn.net/zhengzhb/article/details/7331354" target="_blank" rel="external"><strong>单例模式讨论篇：单例模式与垃圾回收</strong></a>一文中有过描述，在类使用完之后，如果满足下面的情况，类就会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>做java的朋友对于对象的生命周期可能都比较熟悉，对象基本上都是在jvm的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。读完本文后我们知道，对象的生命周期只是类的生命周期中使用阶段的主动引用的一种情况（即实例化类对象）。而类的整个生命周期则要比对象的生命周期长的多。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000002579346" target="_blank" rel="external">JVM 的 工作原理，层次结构 以及 GC工作原理</a></p>
<blockquote>
<p>本文转载自 <a href="http://blog.csdn.net/zhengzhb/article/details/7517213" target="_blank" rel="external">详解java类的生命周期 - 卡奴达摩的专栏</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近有位细心的朋友在阅读笔者的文章时，对Java类的生命周期问题有一些疑惑，笔者打开百度搜了一下相关的问题，看到网上的资料很少有把这个问题讲明白的，主要是因为目前国内Java方面的教材大多只是告诉你“怎样做”，但至于“为什么这样做”却不多说，所以造成大家在基础和原理方面的知识比较匮乏，所以笔者今天就斗胆来讲一下这个问题，权当抛砖引玉，希望对在这个问题上有疑惑的朋友有所帮助，文中有说的不对的地方，也希望各路高手前来指正。&lt;/p&gt;
&lt;p&gt;首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法区&lt;/strong&gt;：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常量池&lt;/strong&gt;：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆区&lt;/strong&gt;：用于存放类的对象实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈区&lt;/strong&gt;：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Android】Audio音频输出通道切换 - 蓝牙、外放</title>
    <link href="http://github.com/2017/05/18/%E3%80%90Android%E3%80%91Audio%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA%E9%80%9A%E9%81%93%E5%88%87%E6%8D%A2%20-%20%E8%93%9D%E7%89%99%E3%80%81%E5%A4%96%E6%94%BE/"/>
    <id>http://github.com/2017/05/18/【Android】Audio音频输出通道切换 - 蓝牙、外放/</id>
    <published>2017-05-18T03:40:00.000Z</published>
    <updated>2017-05-19T08:38:32.402Z</updated>
    
    <content type="html"><![CDATA[<p>手机音频的输出有外放（Speaker）、听筒（Telephone Receiver）、有线耳机（WiredHeadset）、蓝牙音箱（Bluetooth A2DP）等输出设备。在平时，电话免提、插拔耳机、连接断开蓝牙设备等操作系统都会自动切换Audio音频到相应的输出设备上。比如电话免提就是从听筒切换到外放扬声器，插入耳机就是从外放切换到耳机。</p>
<h2 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a><strong>场景需求</strong></h2><p>Android系统自动切换的这些策略，并不能全部满足我们的产品需求，比如音乐App需要对听歌时拔出耳机的操作进行阻止（暂停播放），防止突然切换到外放导致尴尬。</p>
<p>最近项目需求希望<strong><code>即使在连接蓝牙音箱的情况下，仍旧使用手机外放播放音频</code></strong>。这就需要强制切换Audio输出通道，打破系统原有的策略。</p>
<p>查阅资料，看到了Android中可以通过<code>AudioManager</code>查询、切换当前Audio输出通道，并且在Audio输出发生变化时，捕获并处理这种变化。</p>
<a id="more"></a>
<p>首先提醒下大家，使用下面的方法时，需要添加权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.MODIFY_AUDIO_SETTINGS"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h2 id="Audio输出状态查询"><a href="#Audio输出状态查询" class="headerlink" title="Audio输出状态查询"></a><strong>Audio输出状态查询</strong></h2><p>AudioManager 提供的下列方法可以用来查询当前Audio输出的状态：</p>
<ul>
<li><p><strong><code>isBluetoothA2dpOn()</code></strong>：检查A2DPAudio音频输出是否通过蓝牙耳机；</p>
</li>
<li><p><strong><code>isSpeakerphoneOn()</code></strong>：检查扬声器是否打开；</p>
</li>
<li><p><strong><code>isWiredHeadsetOn()</code></strong>：检查线控耳机是否连着；注意这个方法只是用来判断耳机是否是插入状态，并不能用它的结果来判定当前的Audio是通过耳机输出的，这还依赖于其他条件。</p>
</li>
<li><p><strong><code>setSpeakerphoneOn(boolean on)</code></strong>：直接选择外放扬声器发声；</p>
</li>
<li><p><strong><code>setBluetoothScoOn(boolean on)</code></strong>：要求使用蓝牙SCO耳机进行通讯；</p>
</li>
</ul>
<p>此处<a href="http://blog.csdn.net/ec_boy_hl/article/details/45112493" target="_blank" rel="external">根据这篇文章</a>简单地介绍一下蓝牙耳机的两种链路，A2DP及SCO。android的api表明：</p>
<ul>
<li><strong>A2DP</strong>：是一种单向的高品质音频数据传输链路，<strong>通常用于播放立体声音乐</strong>；</li>
<li><strong>SCO</strong>： 则是一种双向的音频数据的传输链路，该链路只支持8K及16K单声道的音频数据，<strong>只能用于普通语音的传输</strong>，若用于播放音乐那就只能呵呵了。</li>
</ul>
<p>两者的主要区别是：<strong>A2DP只能播放，默认是打开的，而SCO既能录音也能播放，默认是关闭的。</strong> 如果要录音肯定要打开sco啦，因此调用上面的<code>setBluetoothScoOn(boolean on)</code>就可以通过蓝牙耳机录音、播放音频了，录完、播放完记得要关闭。</p>
<p>另外，在Android系统中通过<code>AudioManager.setMode()</code>方法来管理播放模式。在<code>setMode()</code>方法中有以下几种对应不同的播放模式:</p>
<ul>
<li><code>MODE_NORMAL</code> : 普通模式，既不是铃声模式也不是通话模式</li>
<li><code>MODE_RINGTONE</code> : 铃声模式</li>
<li><code>MODE_IN_CALL</code> : 通话模式</li>
<li><code>MODE_IN_COMMUNICATION</code> : 通信模式，包括音/视频,VoIP通话.(3.0加入的，与通话模式类似)</li>
</ul>
<p>在设置播放模式的时候，需要考虑流类型，我在这里使用的流类型是 <code>STREAM_MUSIC</code> ，所以切换播放设备的时候就需要设置为<strong><code>MODE_IN_COMMUNICATION</code></strong> 模式而不是 <code>MODE_NORMAL</code> 模式。可以参考<a href="http://stackoverflow.com/questions/31871328/android-5-0-audiomanager-setmode-not-working" target="_blank" rel="external"><strong>这个问题</strong></a>。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a><strong>解决问题</strong></h2><p>使用以下方法切换音频Audio输出，参考<a href="http://stackoverflow.com/questions/22770321/android-switching-audio-between-bluetooth-and-phone-speaker-is-inconsistent" target="_blank" rel="external">Android : Switching audio between Bluetooth and Phone Speaker is inconsistent</a>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换到外放</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToSpeaker</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="comment">//注意此处，蓝牙未断开时使用MODE_IN_COMMUNICATION而不是MODE_NORMAL</span></div><div class="line">    mAudioManager.setMode(bluetoothIsConnected ? AudioManager.MODE_IN_COMMUNICATION : AudioManager.MODE_NORMAL);    </div><div class="line">	mAudioManager.stopBluetoothSco();</div><div class="line">	mAudioManager.setBluetoothScoOn(<span class="keyword">false</span>);</div><div class="line">	mAudioManager.setSpeakerphoneOn(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换到蓝牙音箱</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToHeadset</span><span class="params">()</span></span>&#123;</div><div class="line">    mAudioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);</div><div class="line">	mAudioManager.startBluetoothSco();</div><div class="line">	mAudioManager.setBluetoothScoOn(<span class="keyword">true</span>);</div><div class="line">	mAudioManager.setSpeakerphoneOn(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/************************************************************/</span></div><div class="line"><span class="comment">//注意：以下两个方法还未验证</span></div><div class="line"><span class="comment">/************************************************************/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换到耳机模式</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToHeadset</span><span class="params">()</span></span>&#123;</div><div class="line">    mAudioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);</div><div class="line">	mAudioManager.stopBluetoothSco();</div><div class="line">	mAudioManager.setBluetoothScoOn(<span class="keyword">false</span>);</div><div class="line">	mAudioManager.setSpeakerphoneOn(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换到听筒</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToReceiver</span><span class="params">()</span></span>&#123;</div><div class="line">    audioManager.setSpeakerphoneOn(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB)&#123;</div><div class="line">        audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        audioManager.setMode(AudioManager.MODE_IN_CALL);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接切换输出通道的方法我们已经知道了。剩下需要解决的问题是，<strong>当蓝牙设备断开、连接的时候，我们希望可以自动切换到用户原本设置的输出通道上</strong>，比如在蓝牙未连接时，用户设置的是希望通过蓝牙播报，所以应该在蓝牙一旦连接以后，就把音频切换到蓝牙设备上。</p>
<p>下面我们就看看如何监听蓝牙设备的连接状态。</p>
<h2 id="监听蓝牙连接状态"><a href="#监听蓝牙连接状态" class="headerlink" title="监听蓝牙连接状态"></a><strong>监听蓝牙连接状态</strong></h2><p>首先注意使用前需要以下权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH_ADMIN"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>根据<a href="http://blog.csdn.net/l627859442/article/details/7918597" target="_blank" rel="external">这篇文章</a>，我们发现可以使用 <a href="https://developer.android.com/reference/android/media/AudioManager.html#ACTION_AUDIO_BECOMING_NOISY" target="_blank" rel="external"><code>AudioManager.ACTION_AUDIO_BECOMING_NOISY</code></a> 这个Intent Action来监听蓝牙断开、耳机插拔的广播，但是测试发现，它也只能收到蓝牙断开的广播，无法接收到蓝牙连接的广播，所以不是我们想要的。</p>
<p>进一步找到这篇文章：<a href="http://blog.csdn.net/xiaoqiaozhongcai/article/details/52857910" target="_blank" rel="external">关于蓝牙开发，必须注意的广播</a>，总结了以下蓝牙广播。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 有注释的广播，蓝牙连接时都会用到</div><div class="line"> */</div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_FOUND); <span class="comment">//搜索蓝压设备，每搜到一个设备发送一条广播</span></div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED); <span class="comment">//配对开始时，配对成功时</span></div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED); <span class="comment">//配对时，发起连接</span></div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);</div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED); <span class="comment">//配对结束时，断开连接</span></div><div class="line">intentFilter.addAction(PAIRING_REQUEST); <span class="comment">//配对请求（Android.bluetooth.device.action.PAIRING_REQUEST）</span></div><div class="line"></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED); <span class="comment">//开始搜索</span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); <span class="comment">//搜索结束。重新搜索时，会先终止搜索</span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);</div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); <span class="comment">//本机开启、关闭蓝牙开关 </span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED); <span class="comment">//蓝牙设备连接或断开</span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); <span class="comment">//更改蓝牙名称，打开蓝牙时，可能会调用多次</span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);</div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_ENABLE);</div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED); <span class="comment">//搜索模式改变</span></div></pre></td></tr></table></figure>
<p>我们发现了<a href="https://developer.android.com/reference/android/bluetooth/BluetoothAdapter.html#ACTION_CONNECTION_STATE_CHANGED" target="_blank" rel="external"><code>BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED</code></a> 和 <a href="https://developer.android.com/reference/android/bluetooth/BluetoothAdapter.html#ACTION_STATE_CHANGED" target="_blank" rel="external"><code>BluetoothAdapter.ACTION_STATE_CHANGED</code></a> 这两个Intent广播。</p>
<p>那么这两个广播Intent的区别是什么呢？只用其中一个可以吗？查看Google文档发现</p>
<ul>
<li><p><strong><code>BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED</code></strong> ：指的是本地蓝牙适配器的<strong>连接状态</strong>的发生改变（比如没有关闭本机蓝牙开关时，另外一个配对设备自己把连接断开）</p>
</li>
<li><p><strong><code>BluetoothAdapter.ACTION_STATE_CHANGED</code></strong> ：指的是本地蓝牙适配器的<strong>状态</strong>已更改。 例如，蓝牙开关打开或关闭。</p>
</li>
</ul>
<p>换句话说，一个是用于连接状态的变化，另一个用于蓝牙适配器本身的状态变化。经过测试发现，如果只使用<code>BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED</code> 监听广播，则会接收不到“主动关闭本机蓝牙开关”的广播事件。但只是用<code>BluetoothAdapter.ACTION_STATE_CHANGED</code> 的话，很明显这时候蓝牙设备并未真正配对。</p>
<p>动态注册蓝牙连接、断开广播的方式如下：</p>
<ul>
<li>动态注册广播</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluetoothConnectionReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction())) &#123;		<span class="comment">//蓝牙连接状态</span></div><div class="line">			<span class="keyword">int</span> state = intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE, -<span class="number">1</span>);</div><div class="line">			<span class="keyword">if</span> (state == BluetoothAdapter.STATE_CONNECTED || state == BluetoothAdapter.STATE_DISCONNECTED) &#123;</div><div class="line">				<span class="comment">//连接或失联，切换音频输出（到蓝牙、或者强制仍然扬声器外放）</span></div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction()))&#123;	<span class="comment">//本地蓝牙打开或关闭</span></div><div class="line">			<span class="keyword">int</span> state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -<span class="number">1</span>);</div><div class="line">			<span class="keyword">if</span> (state == BluetoothAdapter.STATE_OFF || state == BluetoothAdapter.STATE_TURNING_OFF) &#123;</div><div class="line">				 <span class="comment">//断开，切换音频输出</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BluetoothConnectionReceiver audioNoisyReceiver = <span class="keyword">new</span> BluetoothConnectionReceiver();</div><div class="line"></div><div class="line"><span class="comment">//蓝牙状态广播监听</span></div><div class="line">IntentFilter audioFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line">audioFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);</div><div class="line">audioFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);</div><div class="line">mContext.registerReceiver(audioNoisyReceiver, audioFilter);</div></pre></td></tr></table></figure>
<p>之后，我们就可以根据上面切换音频输出通道的代码来实现蓝牙设备连接、断开以后<strong>强制打破操作系统原有的输出通道切换策略</strong>，来实现我们自己想要的切换功能了。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1、<a href="http://blog.csdn.net/l627859442/article/details/7918597" target="_blank" rel="external">Android中的Audio播放：控制Audio输出通道切换 </a><br>2、<a href="http://www.devwiki.net/2015/09/20/Android-Music-Play-Mode/" target="_blank" rel="external">Android音乐播放模式切换-外放、听筒、耳机</a><br>3、<a href="http://stackoverflow.com/questions/22770321/android-switching-audio-between-bluetooth-and-phone-speaker-is-inconsistent" target="_blank" rel="external">Android : Switching audio between Bluetooth and Phone Speaker is inconsistent</a><br>4、<a href="http://www.b2cloud.com.au/tutorial/listening-to-bluetooth-connections/" target="_blank" rel="external">Listening to bluetooth connections</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手机音频的输出有外放（Speaker）、听筒（Telephone Receiver）、有线耳机（WiredHeadset）、蓝牙音箱（Bluetooth A2DP）等输出设备。在平时，电话免提、插拔耳机、连接断开蓝牙设备等操作系统都会自动切换Audio音频到相应的输出设备上。比如电话免提就是从听筒切换到外放扬声器，插入耳机就是从外放切换到耳机。&lt;/p&gt;
&lt;h2 id=&quot;场景需求&quot;&gt;&lt;a href=&quot;#场景需求&quot; class=&quot;headerlink&quot; title=&quot;场景需求&quot;&gt;&lt;/a&gt;&lt;strong&gt;场景需求&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Android系统自动切换的这些策略，并不能全部满足我们的产品需求，比如音乐App需要对听歌时拔出耳机的操作进行阻止（暂停播放），防止突然切换到外放导致尴尬。&lt;/p&gt;
&lt;p&gt;最近项目需求希望&lt;strong&gt;&lt;code&gt;即使在连接蓝牙音箱的情况下，仍旧使用手机外放播放音频&lt;/code&gt;&lt;/strong&gt;。这就需要强制切换Audio输出通道，打破系统原有的策略。&lt;/p&gt;
&lt;p&gt;查阅资料，看到了Android中可以通过&lt;code&gt;AudioManager&lt;/code&gt;查询、切换当前Audio输出通道，并且在Audio输出发生变化时，捕获并处理这种变化。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="Audio" scheme="http://github.com/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>Google 面试题 | 判断字符串是否可由重复子字符串组成</title>
    <link href="http://github.com/2017/05/05/Google%20%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%B1%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%E6%88%90/"/>
    <id>http://github.com/2017/05/05/Google 面试题 - 判断字符串是否可由重复子字符串组成/</id>
    <published>2017-05-05T09:20:55.000Z</published>
    <updated>2017-07-14T05:42:59.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。</p>
<h3 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h3><blockquote>
<ul>
<li><strong>输入</strong>： “abab”</li>
<li><strong>输出</strong>： True</li>
<li><strong>样例解释</strong>： 输入可由”ab”重复两次组成</li>
</ul>
</blockquote>
<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 2"></a>样例 2</h3><blockquote>
<ul>
<li><strong>输入</strong>： “aba”</li>
<li><strong>输出</strong>： False</li>
</ul>
</blockquote>
<h3 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 3"></a>样例 3</h3><blockquote>
<ul>
<li><strong>输入</strong>： “abcabcabcabc”</li>
<li><strong>输出</strong>： True</li>
<li><strong>样例解释</strong>：输入可由”abc”重复四次组成</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><h3 id="1-一个简单的思路"><a href="#1-一个简单的思路" class="headerlink" title="1. 一个简单的思路"></a><strong>1. 一个简单的思路</strong></h3><p>枚举子字符串的长度lenSub &lt; len(len为原字符串长度)，将原字符串分成多个子字符串，每个子字符串长度为lenSub（由此可见，lenSub整除len），再判断这些子字符串是否全部相等，若全部相等，则返回True，如果对于所有lenSub均不满足该条件，则返回False。时间复杂度为O(len*v(len))，其中v(len)为len的因数个数（因为我们只需要对整除len的lenSub进行进一步判断）。</p>
<h3 id="2-下面再说一种神奇的方法"><a href="#2-下面再说一种神奇的方法" class="headerlink" title="2. 下面再说一种神奇的方法"></a><strong>2. 下面再说一种神奇的方法</strong></h3><p>由kmp算法中的next数组实现。</p>
<ol>
<li><p>字符串s的下标从0到n-1，n为字符串长度，记s(i)表示s的第i位字符，s(i,j)表示从s的第i位到第j位的子字符串，若i&gt;j，则s(i,j)=””(空串）。</p>
</li>
<li><p>next数组的定义为：next(i)=p，表示p为小于i且满足s(0 , p) = s(i-p , i)的最大的p，如果不存在这样的p，则next(i) = -1，显然next(0) = -1。我们可以用O(n)的时间计算出next数组。假设我们已知next(0)，next(1)，……，next(i-1) ，现在要求next(i)，不妨设next(i-1) = j0，则由next数组定义可知s(0 , j0) = s(i-1-j0 , i-1)。</p>
<ul>
<li><p>若s(j0+1) = s(i)，则结合s(0 , j0) = s(i-1-j0 , i-1)可知s(0 , j0+1) = s(i - (j0+1) , i)，由此可知，next(i)=j0+1。</p>
</li>
<li><p>若s(j0+1)!=s(i)但s(next(j0)+1)=s(i)，记j1=next(j0)，则s(j1+1)=s(i)，由next数组的定义，s(0 , j1) = s(j0 - j1 , j0) = s(i - 1 - j1 , i - 1)，即s(0，j1) = s(i - 1 - j1 , i - 1)，由假设s(j1+1) = s(i)，则s(0 , j1+1) = s(i - (j1+1) , i)，故next(i) = j1+1。</p>
</li>
<li><p>同前两步的分析，如果我们能找到一个k，使得对于所有小于k的k0，s(j(k0)+1)!=s(i)，但有s(j(k)+1) = s(i)，则由next数组的定义可以得到next(i)=j(k)+1，否则需进一步考虑j(k+1) = next(j(k))，如果我们找不到这样的k，则next(i)=-1。</p>
</li>
</ul>
</li>
<li><p>对于字符串s，如果j满足，0&lt;=j&lt;=n-1，且s(0，j) = s(n-1-j，n-1)，令k=n-1-j，若k整除n，不妨设n=mk，则s(0，(m-1)k - 1) = s(k，mk - 1)，即s(0，k-1) = s(k，2k-1) = …… = s((m-1)k - 1，mk - 1)，即s满足题设条件。故要判断s是否为重复子串组成，只需找到满足上述条件的j，且k整除n，即说明s满足条件，否则不满足。</p>
</li>
<li><p>利用已算出的next(n-1)，令k=n-1-next(n-1)，由c可知，若k整除n，且k &lt; n，则s满足条件，否则不满足。上述算法的复杂度可证明为O(n)。</p>
</li>
</ol>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a><strong>参考代码</strong></h2><p>参考代码给出了利用next数组求解的代码。来自<a href="http://www.jiuzhang.com/solutions/repeated-substring-pattern/" target="_blank" rel="external"><strong>九章算法答案</strong></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> l = s.length();</div><div class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[l];</div><div class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> i, j = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; l; i++) &#123;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j + <span class="number">1</span>)) &#123;</div><div class="line">                j = next[j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j + <span class="number">1</span>)) &#123;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            next[i] = j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> lenSub = l - <span class="number">1</span> - next[l - <span class="number">1</span>];</div><div class="line">        <span class="keyword">return</span> lenSub != l &amp;&amp; l % lenSub ==<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="面试官角度分析"><a href="#面试官角度分析" class="headerlink" title="面试官角度分析"></a><strong>面试官角度分析</strong></h2><p>这道题的第一种解法比较简单，考察穷举和字符串处理的能力，给出第一种方法并正确分析时间复杂度基本可以达到hire；如果面试者对KMP算法有了解，可以给出第二种next数组的算法可以达到strong hire。</p>
<p>本文来自九章算法公众号 <a href="http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&amp;mid=2649457295&amp;idx=1&amp;sn=e2f9448ff2b83c36f2abc343936125b8&amp;chksm=887eec87bf096591aa2ae39c12003e786e9ffbf738d2784d26f70f9db6fe1a57099eb5cb129d&amp;mpshare=1&amp;scene=1&amp;srcid=05059UsS011ChQckeShTIQX4#rd" target="_blank" rel="external">Google 面试题 | 重复子字符串模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。&lt;/p&gt;
&lt;h3 id=&quot;样例1&quot;&gt;&lt;a href=&quot;#样例1&quot; class=&quot;headerlink&quot; title=&quot;样例1&quot;&gt;&lt;/a&gt;样例1&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入&lt;/strong&gt;： “abab”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出&lt;/strong&gt;： True&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;样例解释&lt;/strong&gt;： 输入可由”ab”重复两次组成&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;样例-2&quot;&gt;&lt;a href=&quot;#样例-2&quot; class=&quot;headerlink&quot; title=&quot;样例 2&quot;&gt;&lt;/a&gt;样例 2&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入&lt;/strong&gt;： “aba”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出&lt;/strong&gt;： False&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;样例-3&quot;&gt;&lt;a href=&quot;#样例-3&quot; class=&quot;headerlink&quot; title=&quot;样例 3&quot;&gt;&lt;/a&gt;样例 3&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入&lt;/strong&gt;： “abcabcabcabc”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出&lt;/strong&gt;： True&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;样例解释&lt;/strong&gt;：输入可由”abc”重复四次组成&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Google" scheme="http://github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>【Android】判断应用Application、Activity是否处于活动状态</title>
    <link href="http://github.com/2017/05/03/%E3%80%90Android%E3%80%91%E5%88%A4%E6%96%AD%E5%BA%94%E7%94%A8Application%E3%80%81Activity%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8E%E6%B4%BB%E5%8A%A8%E7%8A%B6%E6%80%81/"/>
    <id>http://github.com/2017/05/03/【Android】判断应用Application、Activity是否处于活动状态/</id>
    <published>2017-05-03T07:03:00.000Z</published>
    <updated>2017-05-18T04:53:22.073Z</updated>
    
    <content type="html"><![CDATA[<p>通过<strong><code>ActivityManager</code></strong>我们可以获得系统里正在运行的activities，包括进程(Process)等、应用程序/包、服务(Service)、任务(Task)信息。</p>
<h2 id="1、判断应用App是否活动"><a href="#1、判断应用App是否活动" class="headerlink" title="1、判断应用App是否活动"></a><strong>1、判断应用App是否活动</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断应用是否已经启动</div><div class="line"> * <span class="doctag">@param</span> context 一个context</div><div class="line"> * <span class="doctag">@param</span> packageName 要判断应用的包名</div><div class="line"> * <span class="doctag">@return</span> boolean</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAppAlive</span><span class="params">(Context context, String packageName)</span></span>&#123;</div><div class="line">   ActivityManager activityManager =</div><div class="line">           (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">   List&lt;ActivityManager.RunningAppProcessInfo&gt; processInfos</div><div class="line">           = activityManager.getRunningAppProcesses();</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; processInfos.size(); i++)&#123;</div><div class="line">       <span class="keyword">if</span>(processInfos.get(i).processName.equals(packageName))&#123;</div><div class="line">           Log.i(<span class="string">"NotificationLaunch"</span>,</div><div class="line">                   String.format(<span class="string">"the %s is running, isAppAlive return true"</span>, packageName));</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   Log.i(<span class="string">"NotificationLaunch"</span>,</div><div class="line">           String.format(<span class="string">"the %s is not running, isAppAlive return false"</span>, packageName));</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2、判断Activity是否活动"><a href="#2、判断Activity是否活动" class="headerlink" title="2、判断Activity是否活动"></a><strong>2、判断Activity是否活动</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断MainActivity是否活动</div><div class="line"> * <span class="doctag">@param</span> context 一个context</div><div class="line"> * <span class="doctag">@param</span> activityName 要判断Activity</div><div class="line"> * <span class="doctag">@return</span> boolean</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMainActivityAlive</span><span class="params">(Context context, String activityName)</span></span>&#123;</div><div class="line">   ActivityManager am = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">   List&lt;ActivityManager.RunningTaskInfo&gt; list = am.getRunningTasks(<span class="number">100</span>);</div><div class="line">   <span class="keyword">for</span> (ActivityManager.RunningTaskInfo info : list) &#123;</div><div class="line">       <span class="comment">// 注意这里的 topActivity 包含 packageName和className，可以打印出来看看</span></div><div class="line">       <span class="keyword">if</span> (info.topActivity.toString().equals(activityName) || info.baseActivity.toString().equals(activityName)) &#123;</div><div class="line">           Log.i(TAG,info.topActivity.getPackageName() + <span class="string">" info.baseActivity.getPackageName()="</span>+info.baseActivity.getPackageName());</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、Activity是否显示在前台"><a href="#3、Activity是否显示在前台" class="headerlink" title="3、Activity是否显示在前台"></a><strong>3、Activity是否显示在前台</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检测某Activity是否在当前Task的栈顶</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTopActivity</span><span class="params">(String activityName)</span></span>&#123;</div><div class="line">	ActivityManager manager = (ActivityManager) mContext.getSystemService(ACTIVITY_SERVICE);</div><div class="line">	List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = manager.getRunningTasks(<span class="number">1</span>);</div><div class="line">	String cmpNameTemp = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">if</span>(runningTaskInfos != <span class="keyword">null</span>)&#123;</div><div class="line">		cmpNameTemp = runningTaskInfos.get(<span class="number">0</span>).topActivity.toString();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(cmpNameTemp == <span class="keyword">null</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> cmpNameTemp.equals(activityName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、Service是否在运行"><a href="#4、Service是否在运行" class="headerlink" title="4、Service是否在运行"></a><strong>4、Service是否在运行</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**  </span></div><div class="line"> * 用来判断服务是否运行.  </div><div class="line"> * <span class="doctag">@param</span> context  </div><div class="line"> * <span class="doctag">@param</span> className 判断的服务名字  </div><div class="line"> * <span class="doctag">@return</span> true 在运行 false 不在运行  </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isServiceRunning</span><span class="params">(Context mContext,String className)</span> </span>&#123;   </div><div class="line">    <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;   </div><div class="line">    ActivityManager activityManager = (ActivityManager)   </div><div class="line">                                 mContext.getSystemService(Context.ACTIVITY_SERVICE);    </div><div class="line">    List&lt;ActivityManager.RunningServiceInfo&gt; serviceList = activityManager.getRunningServices(<span class="number">30</span>);   </div><div class="line">    <span class="keyword">if</span> (!(serviceList.size()&gt;<span class="number">0</span>)) &#123;   </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;serviceList.size(); i++) &#123;   </div><div class="line">        <span class="keyword">if</span> (serviceList.get(i).service.getClassName().equals(className) == <span class="keyword">true</span>) &#123;   </div><div class="line">            isRunning = <span class="keyword">true</span>;   </div><div class="line">            <span class="keyword">break</span>;   </div><div class="line">        &#125;   </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">return</span> isRunning;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1、<a href="http://blog.csdn.net/hp910315/article/details/49908203" target="_blank" rel="external">Android中ActivityManager的使用案例</a><br>2、<a href="https://github.com/slimhippo/androidcode/blob/master/NotificationLaunch/app/src/main/java/com/liangzili/notificationlaunch/SystemUtils.java">Android实现点击通知栏后，先启动应用再打开目标Activity的一个小demo</a><br>3、<a href="https://my.oschina.net/ososchina/blog/350498" target="_blank" rel="external">Android ActivityManager 检测Service与Activity是否正在运行</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过&lt;strong&gt;&lt;code&gt;ActivityManager&lt;/code&gt;&lt;/strong&gt;我们可以获得系统里正在运行的activities，包括进程(Process)等、应用程序/包、服务(Service)、任务(Task)信息。&lt;/p&gt;
&lt;h2 id=&quot;1、判断应用App是否活动&quot;&gt;&lt;a href=&quot;#1、判断应用App是否活动&quot; class=&quot;headerlink&quot; title=&quot;1、判断应用App是否活动&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、判断应用App是否活动&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * 判断应用是否已经启动&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; context 一个context&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; packageName 要判断应用的包名&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; boolean&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isAppAlive&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context, String packageName)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ActivityManager activityManager =&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   List&amp;lt;ActivityManager.RunningAppProcessInfo&amp;gt; processInfos&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           = activityManager.getRunningAppProcesses();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; processInfos.size(); i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(processInfos.get(i).processName.equals(packageName))&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           Log.i(&lt;span class=&quot;string&quot;&gt;&quot;NotificationLaunch&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                   String.format(&lt;span class=&quot;string&quot;&gt;&quot;the %s is running, isAppAlive return true&quot;&lt;/span&gt;, packageName));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Log.i(&lt;span class=&quot;string&quot;&gt;&quot;NotificationLaunch&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           String.format(&lt;span class=&quot;string&quot;&gt;&quot;the %s is not running, isAppAlive return false&quot;&lt;/span&gt;, packageName));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】使用UncaughtExceptionHandler捕获全局异常</title>
    <link href="http://github.com/2017/04/20/%E3%80%90Android%E3%80%91%E4%BD%BF%E7%94%A8UncaughtExceptionHandler%E6%8D%95%E8%8E%B7%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/"/>
    <id>http://github.com/2017/04/20/【Android】使用UncaughtExceptionHandler捕获全局异常/</id>
    <published>2017-04-20T06:10:55.000Z</published>
    <updated>2017-04-20T06:21:50.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>当程序崩溃（Crash）的时候，默认是不对异常信息做处理的。如果想要把异常信息保存到本地文件中，或上传的服务器。那么就要借助<strong><code>UncaughtExceptionHandler</code></strong>这个类。</p>
<a id="more"></a>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><h3 id="一、实例化"><a href="#一、实例化" class="headerlink" title="一、实例化"></a>一、实例化</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrashLogCatch</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_NAME_MAIN = <span class="string">"com.example.ABC"</span>;   <span class="comment">//主线程名称</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_NAME_REMOTE = <span class="string">"com.example.ABC:remote_service"</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initCrashLog</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> Thread.UncaughtExceptionHandler oriHandler = Thread.getDefaultUncaughtExceptionHandler();</div><div class="line">		Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable e)</span> </span>&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</div><div class="line">					buffer.append(getCurProcessName(context) + <span class="string">"\n"</span>);</div><div class="line">					buffer.append(<span class="string">"uncaught exception at "</span>)</div><div class="line">							.append(<span class="keyword">new</span> Date(System.currentTimeMillis()))</div><div class="line">							.append(<span class="string">"\n"</span>);</div><div class="line">					buffer.append(ExceptionUtils.formatException(e));</div><div class="line">	</div><div class="line">					String log = HttpLogController.getInstance().makeCrashLog(buffer.toString());</div><div class="line">					<span class="comment">//发送崩溃日志</span></div><div class="line">					sendExceptionLog(log);</div><div class="line">					SdLog.dFileAlways(<span class="string">"crash"</span> + System.currentTimeMillis() + <span class="string">".log"</span>, log);</div><div class="line">					</div><div class="line">					<span class="keyword">if</span> (Global.DEBUG) &#123;</div><div class="line">						oriHandler.uncaughtException(thread, e);  <span class="comment">//debug模式，默认抛出异常</span></div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						String threadName = thread.getName();</div><div class="line">						</div><div class="line">						<span class="keyword">if</span> (threadName.equals(THREAD_NAME_REMOTE)) &#123;</div><div class="line">							android.os.Process.killProcess(android.os.Process.myPid());  <span class="comment">//如果是service直接kill掉</span></div><div class="line">						&#125; <span class="keyword">else</span> <span class="keyword">if</span> (threadName.equals(THREAD_NAME_MAIN)) &#123;</div><div class="line">							oriHandler.uncaughtException(thread, e);  <span class="comment">//如果是主线程，抛出异常</span></div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception ex) &#123;&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 获取当前进程名</div><div class="line">	*/</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getCurProcessName</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">int</span> pid = android.os.Process.myPid();</div><div class="line">			ActivityManager mActivityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">			<span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo appProcess : mActivityManager.getRunningAppProcesses()) &#123;</div><div class="line">				<span class="keyword">if</span> (appProcess.pid == pid)&#123;</div><div class="line">					<span class="keyword">return</span> appProcess.processName;</div><div class="line">				&#125;</div><div class="line">			&#125; </div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 发送崩溃日志</div><div class="line">	*/</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendExceptionLog</span><span class="params">(String log)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			JSONObject jsonObject = <span class="keyword">new</span> JSONObject(log);</div><div class="line">			Iterator keyIter = jsonObject.keys();</div><div class="line">			String key;</div><div class="line">			Object value;</div><div class="line">			HashMap&lt;String, Object&gt; valueMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">			<span class="keyword">while</span> (keyIter.hasNext()) &#123;</div><div class="line">				key = (String) keyIter.next();</div><div class="line">				value = jsonObject.get(key);</div><div class="line">				valueMap.put(key, value);</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 把异常信息发送到服务器 </span></div><div class="line">			ComponentHolder.getLogController().sendLog(valueMap, LogType.EXCEPTION);</div><div class="line">		&#125; <span class="keyword">catch</span> (JSONException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、调用"><a href="#二、调用" class="headerlink" title="二、调用"></a>二、调用</h3><h4 id="1、对于整个Application"><a href="#1、对于整个Application" class="headerlink" title="1、对于整个Application"></a><strong>1、对于整个Application</strong></h4><p>只要在指定的Application类的onCreate()回调中，把UncaughtExceptionHandler和Application的实例绑定在一起就可以了。关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		CrashLogCatch.initCrashLog(<span class="keyword">this</span>);   <span class="comment">//注意这里</span></div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，如果程序崩溃，错误日志就会被上传到服务器。</p>
<h4 id="2、绑定Service-实例"><a href="#2、绑定Service-实例" class="headerlink" title="2、绑定Service 实例"></a><strong>2、绑定Service 实例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">	    Thread.currentThread().setName(CrashLogCatch.THREAD_NAME_REMOTE);  <span class="comment">//线程名称</span></div><div class="line">		CrashLogCatch.initCrashLog(<span class="keyword">this</span>);   <span class="comment">//注意这里</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、绑定BroadcastReceiver实例"><a href="#3、绑定BroadcastReceiver实例" class="headerlink" title="3、绑定BroadcastReceiver实例"></a><strong>3、绑定BroadcastReceiver实例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">		Thread.currentThread().setName(CrashLogCatch.THREAD_NAME_REMOTE);  <span class="comment">//线程名称</span></div><div class="line">		CrashLogCatch.initCrashLog(context);   <span class="comment">//注意这里</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li><a href="http://blog.csdn.net/manoel/article/details/39479101" target="_blank" rel="external">【移动开发】捕获异常信息_UncaughtExceptionHandler</a></li>
<li><a href="http://blog.csdn.net/hehe9737/article/details/7662123" target="_blank" rel="external">Android使用UncaughtExceptionHandler捕获全局异常</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;当程序崩溃（Crash）的时候，默认是不对异常信息做处理的。如果想要把异常信息保存到本地文件中，或上传的服务器。那么就要借助&lt;strong&gt;&lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;&lt;/strong&gt;这个类。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="Exception" scheme="http://github.com/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>【Android 】硬件加速原理与实现简介</title>
    <link href="http://github.com/2017/03/30/%E3%80%90Android%20%E3%80%91%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AE%80%E4%BB%8B/"/>
    <id>http://github.com/2017/03/30/【Android 】硬件加速原理与实现简介/</id>
    <published>2017-03-30T07:29:55.000Z</published>
    <updated>2017-03-30T07:39:20.311Z</updated>
    
    <content type="html"><![CDATA[<p>在手机客户端尤其是Android应用的开发过程中，我们经常会接触到“硬件加速”这个词。由于操作系统对底层软硬件封装非常完善，上层软件开发者往往对硬件加速的底层原理了解很少，也不清楚了解底层原理的意义，因此常会有一些误解，如硬件加速是不是通过特殊算法实现页面渲染加速，或是通过硬件提高CPU/GPU运算速率实现渲染加速。</p>
<p>本文尝试从底层硬件原理，一直到上层代码实现，对硬件加速技术进行简单介绍，其中上层实现基于Android 6.0。</p>
<a id="more"></a>
<h2 id="了解硬件加速对App开发的意义"><a href="#了解硬件加速对App开发的意义" class="headerlink" title="了解硬件加速对App开发的意义"></a>了解硬件加速对App开发的意义</h2><p>对于App开发者，简单了解硬件加速原理及上层API实现，开发时就可以充分利用硬件加速提高页面的性能。以Android举例，实现一个圆角矩形按钮通常有两种方案：使用PNG图片；使用代码（XML/Java）实现。简单对比两种方案如下。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>原理</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用PNG图片（BitmapDrawable）</td>
<td>解码PNG图片生成Bitmap，传到底层，由GPU渲染</td>
<td>图片解码消耗CPU运算资源，Bitmap占用内存大，绘制慢</td>
</tr>
<tr>
<td>使用XML或Java代码实现（ShapeDrawable）</td>
<td>直接将Shape信息传到底层，由GPU渲染</td>
<td>消耗CPU资源少，占用内存小，绘制快</td>
</tr>
</tbody>
</table>
<h2 id="页面渲染背景知识"><a href="#页面渲染背景知识" class="headerlink" title="页面渲染背景知识"></a>页面渲染背景知识</h2><ul>
<li>页面渲染时，被绘制的元素最终要转换成矩阵像素点（即多维数组形式，类似安卓中的Bitmap），才能被显示器显示。</li>
<li>页面由各种基本元素组成，例如圆形、圆角矩形、线段、文字、矢量图（常用贝塞尔曲线组成）、Bitmap等。</li>
<li>元素绘制时尤其是动画绘制过程中，经常涉及插值、缩放、旋转、透明度变化、动画过渡、毛玻璃模糊，甚至包括3D变换、物理运动（例如游戏中常见的抛物线运动）、多媒体文件解码（主要在桌面机中有应用，移动设备一般不用GPU做解码）等运算。</li>
<li>绘制过程经常需要进行逻辑较简单、但数据量庞大的浮点运算。</li>
</ul>
<h2 id="CPU与GPU结构对比"><a href="#CPU与GPU结构对比" class="headerlink" title="CPU与GPU结构对比"></a>CPU与GPU结构对比</h2><p>CPU（Central Processing Unit，中央处理器）是计算机设备核心器件，用于执行程序代码，软件开发者对此都很熟悉；GPU（Graphics Processing Unit，图形处理器）主要用于处理图形运算，通常所说“显卡”的核心部件就是GPU。</p>
<p>下面是CPU和GPU的结构对比图。其中：</p>
<ul>
<li>黄色的Control为控制器，用于协调控制整个CPU的运行，包括取出指令、控制其他模块的运行等；</li>
<li>绿色的ALU（Arithmetic Logic Unit）是算术逻辑单元，用于进行数学、逻辑运算；</li>
<li>橙色的Cache和DRAM分别为缓存和RAM，用于存储信息。</li>
</ul>
<p><img src="/gallery/hardware-accelerate/cpu-gpu.png" alt=""></p>
<ul>
<li><p>从结构图可以看出，CPU的控制器较为复杂，而ALU数量较少。因此CPU擅长各种复杂的逻辑运算，但不擅长数学尤其是浮点运算。</p>
<ul>
<li>以8086为例，一百多条汇编指令大部分都是逻辑指令，数学计算相关的主要是16位加减乘除和移位运算。一次整型和逻辑运算一般需要1~3个机器周期，而浮点运算要转换成整数计算，一次运算可能消耗上百个机器周期。</li>
<li>更简单的CPU甚至只有加法指令，减法用补码加法实现，乘法用累加实现，除法用减法循环实现。</li>
<li>现代CPU一般都带有硬件浮点运算器（FPU），但主要适用于数据量不大的情况。</li>
</ul>
</li>
<li><p>CPU是串行结构。以计算100个数字为例，对于CPU的一个核，每次只能计算两个数的和，结果逐步累加。</p>
</li>
<li><p>和CPU不同的是，GPU就是为实现大量数学运算设计的。从结构图中可以看到，GPU的控制器比较简单，但包含了大量ALU。GPU中的ALU使用了并行设计，且具有较多浮点运算单元。</p>
</li>
<li><p>硬件加速的主要原理，就是通过底层软件代码，将CPU不擅长的图形计算转换成GPU专用指令，由GPU完成。</p>
<p>​</p>
</li>
</ul>
<blockquote>
<p>扩展：很多计算机中的GPU有自己独立的显存；没有独立显存则使用共享内存的形式，从内存中划分一块区域作为显存。显存可以保存GPU指令等信息。</p>
</blockquote>
<h2 id="并行结构举例：级联加法器"><a href="#并行结构举例：级联加法器" class="headerlink" title="并行结构举例：级联加法器"></a>并行结构举例：级联加法器</h2><p>为了方便理解，这里先从底层电路结构的角度举一个例子。如下图为一个加法器，对应实际的数字电路结构。</p>
<ul>
<li>A、B为输入，C为输出，且A、B、C均为总线，以32位CPU为例，则每根总线实际由32根导线组成，每根导线用不同的电压表示一个二进制的0或1。</li>
<li>Clock为时钟信号线，每个固定的时钟周期可向其输入一个特定的电压信号，每当一个时钟信号到来时，A和B的和就会输出到C。</li>
</ul>
<p><img src="/gallery/hardware-accelerate/cascade-adder-1.png" alt=""></p>
<p>现在我们要计算8个整数的和。</p>
<p>对于CPU这种串行结构，代码编写很简单，用for循环把所有数字逐个相加即可。串行结构只有一个加法器，需要7次求和运算；每次计算完部分和，还要将其再转移到加法器的输入端，做下一次计算。整个过程至少要消耗十几个机器周期。</p>
<p>而对于并行结构，一种常见的设计是级联加法器，如下图，其中所有的clock连在一起。当需要相加的8个数据在输入端A1~B4准备好后，经过三个时钟周期，求和操作就完成了。如果数据量更大、级联的层级更大，则并行结构的优势更明显。</p>
<p>由于电路的限制，不容易通过提高时钟频率、减小时钟周期的方式提高运算速度。并行结构通过增加电路规模、并行处理，来实现更快的运算。但并行结构不容易实现复杂逻辑，因为同时考虑多个支路的输出结果，并协调同步处理的过程很复杂（有点像多线程编程）。</p>
<p><img src="/gallery/hardware-accelerate/cascade-adder-2.png" alt=""></p>
<h2 id="GPU并行计算举例"><a href="#GPU并行计算举例" class="headerlink" title="GPU并行计算举例"></a>GPU并行计算举例</h2><p>假设我们有如下图像处理任务，给每个像素值加1。GPU并行计算的方式简单粗暴，在资源允许的情况下，可以为每个像素开一个GPU线程，由其进行加1操作。数学运算量越大，这种并行方式性能优势越明显。</p>
<p><img src="/gallery/hardware-accelerate/render-task.png" alt=""></p>
<h2 id="Android中的硬件加速"><a href="#Android中的硬件加速" class="headerlink" title="Android中的硬件加速"></a>Android中的硬件加速</h2><p>在Android中，大多数应用的界面都是利用常规的View来构建的（除了游戏、视频、图像等应用可能直接使用OpenGL ES）。下面根据Android 6.0原生系统的Java层代码，对View的软件和硬件加速渲染做一些分析和对比。</p>
<h3 id="DisplayList"><a href="#DisplayList" class="headerlink" title="DisplayList"></a>DisplayList</h3><p>DisplayList是一个基本绘制元素，包含元素原始属性（位置、尺寸、角度、透明度等），对应Canvas的drawXxx()方法（如下图）。</p>
<p>信息传递流程：Canvas(Java API) —&gt; OpenGL(C/C++ Lib) —&gt; 驱动程序 —&gt; GPU。</p>
<p>在Android 4.1及以上版本，DisplayList支持属性，如果View的一些属性发生变化（比如Scale、Alpha、Translate），只需把属性更新给GPU，不需要生成新的DisplayList。</p>
<h3 id="RenderNode"><a href="#RenderNode" class="headerlink" title="RenderNode"></a>RenderNode</h3><p>一个RenderNode包含若干个DisplayList，通常一个RenderNode对应一个View，包含View自身及其子View的所有DisplayList。</p>
<p><img src="/gallery/hardware-accelerate/canvas-draw.png" alt=""></p>
<h2 id="Android绘制流程（Android-6-0）"><a href="#Android绘制流程（Android-6-0）" class="headerlink" title="Android绘制流程（Android 6.0）"></a>Android绘制流程（Android 6.0）</h2><p>下面是安卓View完整的绘制流程图，主要通过阅读源码和调试得出，虚线箭头表示递归调用。</p>
<ul>
<li><p>从<code>ViewRootImpl.performTraversals</code>到<code>PhoneWindow.DecroView.drawChild</code>是每次遍历View树的固定流程，首先根据标志位判断是否需要重新布局并执行布局；然后进行Canvas的创建等操作开始绘制。</p>
<ul>
<li>如果硬件加速不支持或者被关闭，则使用软件绘制，生成的Canvas即<code>Canvas.class</code>的对象；</li>
<li>如果支持硬件加速，则生成的是<code>DisplayListCanvas.class</code>的对象；</li>
<li>两者的<code>isHardwareAccelerated()</code>方法返回的值分别为false、true，View根据这个值判断是否使用硬件加速。</li>
</ul>
</li>
<li><p>View中的<code>draw(canvas,parent,drawingTime)</code> - <code>draw(canvas)</code> - <code>onDraw</code> - <code>dispachDraw</code> - <code>drawChild</code>这条递归路径（下文简称<strong>Draw路径</strong>），调用了<code>Canvas.drawXxx()</code>方法，在软件渲染时用于实际绘制；在硬件加速时，用于构建DisplayList。</p>
</li>
<li><p>View中的<code>updateDisplayListIfDirty</code> - <code>dispatchGetDisplayList</code> - <code>recreateChildDisplayList</code>这条递归路径（下文简称<strong>DisplayList路径</strong>），仅在硬件加速时会经过，用于在遍历View树绘制的过程中更新DisplayList属性，并快速跳过不需要重建DisplayList的View。</p>
<blockquote>
<p>Android 6.0中，和DisplayList相关的API目前仍被标记为“@hide”不可访问，表示还不成熟，后续版本可能开放。</p>
</blockquote>
</li>
<li><p>硬件加速情况下，draw流程执行结束后DisplayList构建完成，然后通过<code>ThreadedRenderer.nSyncAndDrawFrame()</code>利用GPU绘制DisplayList到屏幕上。</p>
</li>
</ul>
<p><img src="/gallery/hardware-accelerate/render-func.png" alt=""></p>
<h2 id="纯软件绘制-VS-硬件加速（Android-6-0）"><a href="#纯软件绘制-VS-硬件加速（Android-6-0）" class="headerlink" title="纯软件绘制 VS 硬件加速（Android 6.0）"></a>纯软件绘制 VS 硬件加速（Android 6.0）</h2><p>下面根据具体的几种场景，具体分析一下硬件加速前后的流程与加速效果。</p>
<table>
<thead>
<tr>
<th>渲染场景</th>
<th>纯软件绘制</th>
<th>硬件加速</th>
<th>加速效果分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面初始化</td>
<td>绘制所有View</td>
<td>创建所有DisplayList</td>
<td>GPU分担了复杂计算任务</td>
</tr>
<tr>
<td>在一个复杂页面调用背景透明TextView的setText()，且调用后其尺寸位置不变</td>
<td>重绘脏区所有View</td>
<td>TextView及每一级父View重建DisplayList</td>
<td>重叠的兄弟节点不需CPU重绘，GPU会自行处理</td>
</tr>
<tr>
<td>TextView逐帧播放Alpha / Translation / Scale动画</td>
<td>每帧都要重绘脏区所有View</td>
<td>除第一帧同场景2，之后每帧只更新TextView对应RenderNode的属性</td>
<td>刷新一帧性能极大提高，动画流畅度提高</td>
</tr>
<tr>
<td>修改TextView透明度</td>
<td>重绘脏区所有View</td>
<td>直接调用RenderNode.setAlpha()更新</td>
<td>加速前需全页面遍历，并重绘很多View；加速后只触发DecorView.updateDisplayListIfDirty，不再往下遍历，CPU执行时间可忽略不计</td>
</tr>
</tbody>
</table>
<ul>
<li>场景1中，无论是否加速，遍历View树并都会走Draw路径。硬件加速后Draw路径不做实际绘制工作，只是构建DisplayList，复杂的绘制计算任务被GPU分担，已经有了较大的加速效果。</li>
<li>场景2中，TextView设置前后尺寸位置不变，不会触发重新Layout。<ul>
<li>软件绘制时，TextView所在区域即为脏区。由于TextView有透明区域，遍历View树的过程中，和脏区重叠的多数View都要重绘，包括与之重叠的兄弟节点和他们的父节点（详见后面的介绍），不需要绘制的View在<code>draw(canvas,parent,drawingTime)</code>方法中判断直接返回。</li>
<li>硬件加速后，也需要遍历View树，但只有TextView及其每一层父节点需要重建DisplayList，走的是Draw路径，其他View直接走了DisplayList路径，剩下的工作都交给GPU处理。页面越复杂，两者性能差距越明显。</li>
</ul>
</li>
<li>场景3中，软件绘制每一帧都要做大量绘制工作，很容易导致动画卡顿。硬件加速后，动画过程直接走DisplayList路径更新DisplayList的属性，动画流畅度能得到极大提高。</li>
<li>场景4中，两者的性能差距更明显。简单修改透明度，软件绘制仍然要做很多工作；硬件加速后一般直接更新RenderNode的属性，不需要触发invalidate，也不会遍历View树（除了少数View可能要对Alpha做特殊响应并在<code>onSetAlpha()</code>返回true，代码如下）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(@FloatRange(from=<span class="number">0.0</span>, to=<span class="number">1.0</span>)</span> <span class="keyword">float</span> alpha) </span>&#123;</div><div class="line">        ensureTransformationInfo();</div><div class="line">        <span class="keyword">if</span> (mTransformationInfo.mAlpha != alpha) &#123;</div><div class="line">            mTransformationInfo.mAlpha = alpha;</div><div class="line">            <span class="keyword">if</span> (onSetAlpha((<span class="keyword">int</span>) (alpha * <span class="number">255</span>))) &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                invalidate(<span class="keyword">true</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                mRenderNode.setAlpha(getFinalAlpha());</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onSetAlpha</span><span class="params">(<span class="keyword">int</span> alpha)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="软件绘制刷新逻辑简介"><a href="#软件绘制刷新逻辑简介" class="headerlink" title="软件绘制刷新逻辑简介"></a>软件绘制刷新逻辑简介</h2><p>实际阅读源码并实验，得出通常情况下的软件绘制刷新逻辑：</p>
<ul>
<li>默认情况下，View的clipChildren属性为true，即每个View绘制区域不能超出其父View的范围。如果设置一个页面根布局的clipChildren属性为false，则子View可以超出父View的绘制区域。</li>
<li>当一个View触发invalidate，且没有播放动画、没有触发layout的情况下：<ul>
<li>对于全不透明的View，其自身会设置标志位<code>PFLAG_DIRTY</code>，其父View会设置标志位<code>PFLAG_DIRTY_OPAQUE</code>。在<code>draw(canvas)</code>方法中，只有这个View自身重绘。</li>
<li>对于可能有透明区域的View，其自身和父View都会设置标志位<code>PFLAG_DIRTY</code>。<ul>
<li>clipChildren为true时，脏区会被转换成ViewRoot中的Rect，刷新时层层向下判断，当View与脏区有重叠则重绘。如果一个View超出父View范围且与脏区重叠，但其父View不与脏区重叠，这个子View不会重绘。</li>
<li>clipChildren为false时，<code>ViewGroup.invalidateChildInParent()</code>中会把脏区扩大到自身整个区域，于是与这个区域重叠的所有View都会重绘。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，硬件加速相关的内容就介绍完了，这里做个简单总结：</p>
<ul>
<li>CPU更擅长复杂逻辑控制，而GPU得益于大量ALU和并行结构设计，更擅长数学运算。</li>
<li>页面由各种基础元素（DisplayList）构成，渲染时需要进行大量浮点运算。</li>
<li>硬件加速条件下，CPU用于控制复杂绘制逻辑、构建或更新DisplayList；GPU用于完成图形计算、渲染DisplayList。</li>
<li>硬件加速条件下，刷新界面尤其是播放动画时，CPU只重建或更新必要的DisplayList，进一步提高渲染效率。</li>
<li>实现同样效果，应尽量使用更简单的DisplayList，从而达到更好的性能（Shape代替Bitmap等）。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/LBSer/p/4592862.html" target="_blank" rel="external">GPU—并行计算利器</a></li>
<li><a href="http://www.eechina.com/thread-176224-1-1.html" target="_blank" rel="external">显示卡的“心脏”GPU工作原理介绍</a></li>
<li><a href="http://hust.cf/matlab/2016/05/15/Matlab%E7%9A%84GPU%E5%8A%A0%E9%80%9F.html" target="_blank" rel="external">Matlab的GPU加速</a></li>
<li><a href="http://blog.csdn.net/yang_yulei/article/details/22529437" target="_blank" rel="external">处理器体系结构：了解CPU的基本运行原理</a></li>
<li><a href="http://blog.chinaunix.net/uid-23069658-id-3563960.html" target="_blank" rel="external">CPU的内部架构和工作原理</a></li>
<li><a href="http://xilinx.eetrend.com/article/10087" target="_blank" rel="external">什么是异构多处理系统，为什么需要异构多处理系统</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/45943255" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List构建过程分析</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/46281499" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></li>
<li><a href="http://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="external">Android Choreographer源码分析</a></li>
<li><a href="http://blog.csdn.net/innost/article/details/8272867" target="_blank" rel="external">Android Project Butter分析</a></li>
</ul>
<blockquote>
<p>本文来自美团点评技术团队：<a href="http://tech.meituan.com/hardware-accelerate.html" target="_blank" rel="external"><strong>Android硬件加速原理与实现简介</strong></a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在手机客户端尤其是Android应用的开发过程中，我们经常会接触到“硬件加速”这个词。由于操作系统对底层软硬件封装非常完善，上层软件开发者往往对硬件加速的底层原理了解很少，也不清楚了解底层原理的意义，因此常会有一些误解，如硬件加速是不是通过特殊算法实现页面渲染加速，或是通过硬件提高CPU/GPU运算速率实现渲染加速。&lt;/p&gt;
&lt;p&gt;本文尝试从底层硬件原理，一直到上层代码实现，对硬件加速技术进行简单介绍，其中上层实现基于Android 6.0。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="GPU" scheme="http://github.com/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>【Gradle】Android Studio中Gradle重复依赖的问题</title>
    <link href="http://github.com/2017/02/23/%E3%80%90Gradle%E3%80%91Android%20Studio%E4%B8%ADGradle%E9%87%8D%E5%A4%8D%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/02/23/【Gradle】Android Studio中Gradle重复依赖的问题/</id>
    <published>2017-02-23T05:03:00.000Z</published>
    <updated>2017-02-23T05:24:23.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>项目中有个Module需要解析json所以选用了依赖Gson，但是编译时报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Error:Execution failed for task &apos;:app:transformClassesWithJarMergingForAutoioDebug&apos;.</div><div class="line">&gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/google/gson/annotations/Expose.class</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><p>看到错误中的这个<strong>duplicate</strong>，第一反应和平常一样，难道是得先清理一下Clean project ? 反复试了几次都不行，上网查才发现是重复依赖Gson库的问题，导致项目中有了两个重复的<code>Expose.class</code> 类。</p>
<p>使用快捷键（Shift + Ctrl + T）查看项目中的<code>Expose.class</code> 类，发现是和passport-1.4.2.jar这个本地jar包冲突了，它也依赖了gson库所以导致了重复依赖。</p>
<p><img src="http://img.blog.csdn.net/20170223114733531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<a id="more"></a>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>在往下面分析之前，需要先根据项目结构说明一下问题的本质，就是Module</p>
<p><img src="http://img.blog.csdn.net/20170223124701598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><p>第一个查到的解决办法是这个<a href="http://blog.csdn.net/cx1229/article/details/52786168" target="_blank" rel="external"><strong>Android Studio中如何解决重复依赖导致的app:transformClassesWithJarMergingForDebug</strong></a>，但是他的问题是依赖另外一个库retrofit，她用了下面的办法：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line"><span class="keyword">compile</span> (<span class="string">'com.squareup.retrofit2:converter-gson:2.1.0'</span>)&#123;</div><div class="line">	<span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.code.gson'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我也尝试仿照他的方法，在我的Speech模块下的build.gradle文件里修改</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line"><span class="comment">//注意：下面的方法是错的</span></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(<span class="keyword">include</span>: <span class="string">'*.jar'</span>, dir: <span class="string">'libs'</span>)&#123;    <span class="comment">//错的</span></div><div class="line">        <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.code.gson'</span>, module: <span class="string">'gson'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>报错如下，显然这么写是不对的，对于依赖本地jar文件这么写是不对的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Error:Could not find method exclude() for arguments [&#123;group=com.google.code.gson, module=gson&#125;] on directory &apos;&#123;include=*.jar, dir=libs&#125;&apos; of type org.gradle.api.internal.file.collections.DefaultConfigurableFileTree.</div></pre></td></tr></table></figure>
<p>但是，他们的解决思路是对的，就是<strong>想办法屏蔽其中一个Gson库</strong>。既然如此，我们可以多尝试各个引入它们的地方。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong>解决办法</strong></h2><p>最后试来试去，才发现exclude需要写在App <strong>主Module</strong> 的build.gradle文件中才能生效，而且注意 project(‘:Speech’) 外面那层括号：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line">apply plugin: <span class="string">'com.android.application'</span>		<span class="comment">//注意这是主Module</span></div><div class="line"></div><div class="line"><span class="keyword">repositories</span> &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="comment">// Module dependency</span></div><div class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':passportSDKLib'</span>)</div><div class="line">    <span class="keyword">compile</span> (<span class="keyword">project</span>(<span class="string">':Speech'</span>))&#123;</div><div class="line">	    <span class="comment">//解决Gson重复依赖问题，与passport-1.4.2.jar有冲突</span></div><div class="line">        <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.code.gson'</span>, module: <span class="string">'gson'</span>       </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':Skin'</span>)</div><div class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(<span class="keyword">include</span>: <span class="string">'*.jar'</span>, dir: <span class="string">'src/main/libs'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唉，世界终于清静了</p>
<hr>
<h3 id="【参考资料】："><a href="#【参考资料】：" class="headerlink" title="【参考资料】："></a>【参考资料】：</h3><p>1、<a href="http://blog.csdn.net/cx1229/article/details/52786168" target="_blank" rel="external"><strong>AndroidStudio中如何解决重复依赖导致的app:transformClassesWithJarMergingForDebug</strong></a><br>2、<a href="http://blog.csdn.net/yisizhu/article/details/49952841" target="_blank" rel="external">  <strong>AndroidStudio的Gradle添加重复依赖的问题</strong> </a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;项目中有个Module需要解析json所以选用了依赖Gson，但是编译时报错如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Error:Execution failed for task &amp;apos;:app:transformClassesWithJarMergingForAutoioDebug&amp;apos;.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/google/gson/annotations/Expose.class&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;看到错误中的这个&lt;strong&gt;duplicate&lt;/strong&gt;，第一反应和平常一样，难道是得先清理一下Clean project ? 反复试了几次都不行，上网查才发现是重复依赖Gson库的问题，导致项目中有了两个重复的&lt;code&gt;Expose.class&lt;/code&gt; 类。&lt;/p&gt;
&lt;p&gt;使用快捷键（Shift + Ctrl + T）查看项目中的&lt;code&gt;Expose.class&lt;/code&gt; 类，发现是和passport-1.4.2.jar这个本地jar包冲突了，它也依赖了gson库所以导致了重复依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170223114733531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Gradle" scheme="http://github.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://github.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>【Android】内存泄漏分析心得</title>
    <link href="http://github.com/2017/02/13/%E3%80%90Android%E3%80%91%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%BF%83%E5%BE%97/"/>
    <id>http://github.com/2017/02/13/【Android】内存泄漏分析心得/</id>
    <published>2017-02-13T08:03:00.000Z</published>
    <updated>2017-02-15T05:07:07.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来源：<a href="http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=2649796884&amp;idx=1&amp;sn=92b4e344060362128e4a86d6132c3736&amp;chksm=f1fcc54cc68b4c5add08371265320163381ea81333daea5664b94e9a12246a34cfaa31e6f0b3&amp;mpshare=1&amp;scene=1&amp;srcid=0213Ssp5geOThmtF6tg9Bz7U#rd" target="_blank" rel="external">QQ空间终端开发团队公众号</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>对于C++来说，内存泄漏就是new出来的对象没有delete，俗称野指针；<br>对于Java来说，就是new出来的Object 放在Heap上无法被GC回收；</p>
<p><img src="http://img.blog.csdn.net/20170213160148023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>本文通过QQ和Qzone中内存泄漏实例来讲android中内存泄漏分析解法和编写代码应注意的事项。</p>
<h2 id="Java-中的内存分配"><a href="#Java-中的内存分配" class="headerlink" title="Java 中的内存分配"></a><strong>Java 中的内存分配</strong></h2><ul>
<li><p><strong>静态储存区</strong>：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量；</p>
</li>
<li><p><strong>栈区</strong>：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；</p>
</li>
<li><p><strong>堆区</strong>：通常存放 new 出来的对象。由 Java 垃圾回收器回收。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="四种引用类型的介绍"><a href="#四种引用类型的介绍" class="headerlink" title="四种引用类型的介绍"></a><strong>四种引用类型的介绍</strong></h2><ul>
<li><p><strong>强引用</strong>(StrongReference)：JVM 宁可抛出 OOM ，也不会让 GC 回收具有强引用的对象；</p>
</li>
<li><p><strong>软引用</strong>(SoftReference)：只有在内存空间不足时，才会被回的对象；</p>
</li>
<li><p><strong>弱引用</strong>(WeakReference)：在 GC 时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；</p>
</li>
<li><p><strong>虚引用</strong>(PhantomReference)：任何时候都可以被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志。</p>
</li>
</ul>
<p><strong>我们常说的内存泄漏是指new出来的Object无法被GC回收，即为强引用：</strong></p>
<p><img src="http://img.blog.csdn.net/20170213160412727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>内存泄漏发生时的主要表现为内存抖动，可用内存慢慢变少：</p>
<p><img src="http://img.blog.csdn.net/20170213160508309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="Andriod-中分析内存泄漏的工具MAT"><a href="#Andriod-中分析内存泄漏的工具MAT" class="headerlink" title="Andriod 中分析内存泄漏的工具MAT"></a><strong>Andriod 中分析内存泄漏的工具MAT</strong></h2><p>MAT（Memory Analyzer Tools）是一个 Eclipse 插件，它是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。</p>
<p>MAT 插件的下载地址：</p>
<p><a href="http://www.eclipse.org/mat/" target="_blank" rel="external">Eclipse Memory Analyzer Open Source Project</a></p>
<h2 id="QQ-和-Qzone内存泄漏如何监控"><a href="#QQ-和-Qzone内存泄漏如何监控" class="headerlink" title="QQ 和 Qzone内存泄漏如何监控"></a><strong>QQ 和 Qzone内存泄漏如何监控</strong></h2><p><img src="http://img.blog.csdn.net/20170213160729938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>QQ和Qzone 的内存泄漏采用SNGAPM解决方案，SNGAPM是一个性能监控、分析的统一解决方案，它从终端收集性能信息，上报到一个后台，后台将监控类信息聚合展示为图表，将分析类信息进行分析并提单，通知开发者；</p>
<ol>
<li><p>SNGAPM由App（MagnifierApp）和 web server（MagnifierServer）两部分组成；</p>
</li>
<li><p>MagnifierApp在自动内存泄漏检测中是一个衔接检测组件（LeakInspector）和自动化云分析（MagnifierCloud）的中间性平台，它从LeakInspector的内存dump自动化上传MagnifierServer；</p>
</li>
<li><p>MagnifierServer后台会定时提交分析任务到MagnifierCloud；</p>
</li>
<li><p>MagnifierCloud分析结束之后会更新数据到magnifier web上，同时以bug单形式通知开发者。</p>
</li>
</ol>
<h2 id="常见的内存泄漏案例"><a href="#常见的内存泄漏案例" class="headerlink" title="常见的内存泄漏案例"></a><strong>常见的内存泄漏案例</strong></h2><h3 id="case-1-单例造成的内存泄露"><a href="#case-1-单例造成的内存泄露" class="headerlink" title="case 1. 单例造成的内存泄露"></a><strong>case 1. 单例造成的内存泄露</strong></h3><p>单例的静态特性导致其生命周期同应用一样长。</p>
<p>解决方案：</p>
<blockquote>
<p>1、将该属性的引用方式改为弱引用;<br>2、如果传入Context，使用ApplicationContext;</p>
</blockquote>
<p>泄漏代码片段 example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ScrollHelper mInstance;    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ScrollHelper</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScrollHelper <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;           </div><div class="line">       <span class="keyword">synchronized</span> (ScrollHelper.class) &#123;                </div><div class="line">            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                mInstance = <span class="keyword">new</span> ScrollHelper();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;        </div><div class="line">                </div><div class="line">    <span class="keyword">return</span> mInstance;</div><div class="line">&#125;    </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 被点击的view</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> View mScrolledView = <span class="keyword">null</span>;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScrolledView</span><span class="params">(View scrolledView)</span> </span>&#123;</div><div class="line">    mScrolledView = scrolledView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Solution：使用WeakReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ScrollHelper mInstance;    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ScrollHelper</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScrollHelper <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;            </div><div class="line">        <span class="keyword">synchronized</span> (ScrollHelper.class) &#123;                </div><div class="line">            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                mInstance = <span class="keyword">new</span> ScrollHelper();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;        </div><div class="line">        </div><div class="line">    <span class="keyword">return</span> mInstance;</div><div class="line">&#125;    </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 被点击的view</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> WeakReference&lt;View&gt; mScrolledViewWeakRef = <span class="keyword">null</span>;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScrolledView</span><span class="params">(View scrolledView)</span> </span>&#123;</div><div class="line">    mScrolledViewWeakRef = <span class="keyword">new</span> WeakReference&lt;View&gt;(scrolledView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-2-InnerClass匿名内部类"><a href="#case-2-InnerClass匿名内部类" class="headerlink" title="case 2. InnerClass匿名内部类"></a><strong>case 2. InnerClass匿名内部类</strong></h3><p>在Java中，非静态内部类 和 匿名类 都会潜在的引用它们所属的外部类，但是，静态内部类却不会。如果这个非静态内部类实例做了一些耗时的操作，就会造成外围对象不会被回收，从而导致内存泄漏。</p>
<p>解决方案：</p>
<blockquote>
<p>1、将内部类变成静态内部类;<br>2、如果有强引用Activity中的属性，则将该属性的引用方式改为弱引用;<br>3、在业务允许的情况下，当Activity执行onDestory时，结束这些耗时任务;</p>
</blockquote>
<p>example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakAct</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;    </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.aty_leak);</div><div class="line">        test();</div><div class="line">    &#125; </div><div class="line">    <span class="comment">//这儿发生泄漏    </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;    </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;      </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;          </div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Solution：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakAct</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;    </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.aty_leak);</div><div class="line">        test();</div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//加上static，变成静态匿名内部类</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;    </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;     </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;          </div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-3-Activity-Context-的不正确使用"><a href="#case-3-Activity-Context-的不正确使用" class="headerlink" title="case 3. Activity Context 的不正确使用"></a><strong>case 3. Activity Context 的不正确使用</strong></h3><p>在Android应用程序中通常可以使用两种Context对象：Activity和Application。当类或方法需要Context对象的时候常见的做法是使用第一个作为Context参数。这样就意味着View对象对整个Activity保持引用，因此也就保持对Activty的所有的引用。</p>
<p>假设一个场景，当应用程序有个比较大的Bitmap类型的图片，每次旋转是都重新加载图片所用的时间较多。为了提高屏幕旋转是Activity的创建速度，最简单的方法时将这个Bitmap对象使用Static修饰。 当一个Drawable绑定在View上，实际上这个View对象就会成为这份Drawable的一个Callback成员变量。而静态变量的生命周期要长于Activity。导致了当旋转屏幕时，Activity无法被回收，而造成内存泄露。</p>
<p>解决方案：</p>
<blockquote>
<p> 1、使用ApplicationContext代替ActivityContext，因为ApplicationContext会随着应用程序的存在而存在，而不依赖于activity的生命周期；</p>
<p> 2、对Context的引用不要超过它本身的生命周期，慎重的对Context使用“static”关键字。Context里如果有线程，一定要在onDestroy()里及时停掉。</p>
</blockquote>
<p>example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onCreate(state);</div><div class="line">    TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</div><div class="line">    label.setText(<span class="string">"Leaks are bad"</span>);  </div><div class="line">    <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;</div><div class="line">        sBackground = getDrawable(R.drawable.large_bitmap);</div><div class="line">    &#125;</div><div class="line">    label.setBackgroundDrawable(sBackground);</div><div class="line">    setContentView(label);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Solution：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onCreate(state);</div><div class="line">    TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</div><div class="line">    label.setText(<span class="string">"Leaks are bad"</span>);  </div><div class="line">    <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;</div><div class="line">        sBackground = getApplicationContext().getDrawable(R.drawable.large_bitmap);</div><div class="line">    &#125;</div><div class="line">    label.setBackgroundDrawable(sBackground);</div><div class="line">    setContentView(label);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-4-Handler引起的内存泄漏"><a href="#case-4-Handler引起的内存泄漏" class="headerlink" title="case 4. Handler引起的内存泄漏"></a><strong>case 4. Handler引起的内存泄漏</strong></h3><p>当Handler中有延迟的的任务或是等待执行的任务队列过长，由于消息持有对Handler的引用，而Handler又持有对其外部类的潜在引用，这条引用关系会一直保持到消息得到处理，而导致了Activity无法被垃圾回收器回收，而导致了内存泄露。</p>
<p>解决方案：</p>
<blockquote>
<p>1、可以把Handler类放在单独的类文件中，或者使用静态内部类便可以避免泄露;<br>2、如果想在Handler内部去调用所在的Activity,那么可以在handler内部使用弱引用的方式去指向所在Activity.使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。</p>
</blockquote>
<p>Solution</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOnDestroy</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">super</span>.doOnDestroy();        </div><div class="line">    <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>) &#123;</div><div class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    mHandler = <span class="keyword">null</span>;</div><div class="line">    mRenderCallback = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-5-注册监听器的泄漏"><a href="#case-5-注册监听器的泄漏" class="headerlink" title="case 5. 注册监听器的泄漏"></a><strong>case 5. 注册监听器的泄漏</strong></h3><p>系统服务可以通过Context.getSystemService 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果Context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有Activity 的引用，如果在Activity onDestory时没有释放掉引用就会内存泄漏。</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li><p>使用ApplicationContext代替ActivityContext;</p>
</li>
<li><p>在Activity执行onDestory时，调用反注册;</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mSensorManager = (SensorManager) <span class="keyword">this</span>.getSystemService(Context.SENSOR_SERVICE);</div></pre></td></tr></table></figure>
<p>Solution：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mSensorManager = (SensorManager) getApplicationContext().getSystemService(Context.SENSOR_SERVICE);</div></pre></td></tr></table></figure>
<p>下面是容易造成内存泄漏的系统服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputMethodManager imm = (InputMethodManager) context.getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE);</div></pre></td></tr></table></figure>
<p>Solution</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mActionShell != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.mActionShell.setOnClickListener((OnAreaClickListener)<span class="keyword">null</span>);</div><div class="line">    &#125;        </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mButtonShell != <span class="keyword">null</span>) &#123; </div><div class="line">        <span class="keyword">this</span>.mButtonShell.setOnClickListener((OnAreaClickListener)<span class="keyword">null</span>);</div><div class="line">    &#125;        </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mCountShell != <span class="keyword">this</span>.mCountShell) &#123;</div><div class="line">        <span class="keyword">this</span>.mCountShell.setOnClickListener((OnAreaClickListener)<span class="keyword">null</span>);</div><div class="line">    &#125;        </div><div class="line">    <span class="keyword">super</span>.onDetachedFromWindow();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-6-Cursor，Stream没有close，View没有recyle"><a href="#case-6-Cursor，Stream没有close，View没有recyle" class="headerlink" title="case 6. Cursor，Stream没有close，View没有recyle"></a><strong>case 6. Cursor，Stream没有close，View没有recyle</strong></h3><p>资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null. 在我们的程序退出时一定要确保我们的资源性对象已经关闭。</p>
<p>Solution：</p>
<blockquote>
<p>调用onRecycled()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRecycled</span><span class="params">()</span> </span>&#123;</div><div class="line">    reset();</div><div class="line">    mSinglePicArea.onRecycled();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在View中调用reset()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mHasRecyled) &#123;            </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">    SubAreaShell.recycle(mActionBtnShell);</div><div class="line">    mActionBtnShell = <span class="keyword">null</span>;</div><div class="line">...</div><div class="line">    mIsDoingAvatartRedPocketAnim = <span class="keyword">false</span>;        </div><div class="line">    <span class="keyword">if</span> (mAvatarArea != <span class="keyword">null</span>) &#123;</div><div class="line">            mAvatarArea.reset();</div><div class="line">    &#125;        </div><div class="line">    <span class="keyword">if</span> (mNickNameArea != <span class="keyword">null</span>) &#123;</div><div class="line">        mNickNameArea.reset();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-7-集合中对象没清理造成的内存泄漏"><a href="#case-7-集合中对象没清理造成的内存泄漏" class="headerlink" title="case 7. 集合中对象没清理造成的内存泄漏"></a><strong>case 7. 集合中对象没清理造成的内存泄漏</strong></h3><p>我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。<br>所以要在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。</p>
<p>解决方案：</p>
<blockquote>
<p>在Activity退出之前，将集合里的东西clear，然后置为null，再退出程序。</p>
</blockquote>
<p>Solution</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;EmotionPanelInfo&gt; data;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</div><div class="line">        data.clear();</div><div class="line">        data = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-8-WebView造成的泄露"><a href="#case-8-WebView造成的泄露" class="headerlink" title="case 8. WebView造成的泄露"></a><strong>case 8. WebView造成的泄露</strong></h3><p>当我们不要使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存，否则其占用的内存长期也不能被回收，从而造成内存泄露。</p>
<p>解决方案：</p>
<blockquote>
<p>为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>
</blockquote>
<h3 id="case-9-构造Adapter时，没有使用缓存的ConvertView"><a href="#case-9-构造Adapter时，没有使用缓存的ConvertView" class="headerlink" title="case 9. 构造Adapter时，没有使用缓存的ConvertView"></a><strong>case 9. 构造Adapter时，没有使用缓存的ConvertView</strong></h3><p>初始时ListView会从Adapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些View对象 缓存起来。</p>
<p>当向上滚动ListView时，原先位于最上面的List Item的View对象会被回收，然后被用来构造新出现的最下面的List Item。</p>
<p>这个构造过程就是由getView()方法完成的，getView()的第二个形参View ConvertView就是被缓存起来的List Item的View对象(初始化时缓存中没有View对象则ConvertView是null)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来源：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;amp;mid=2649796884&amp;amp;idx=1&amp;amp;sn=92b4e344060362128e4a86d6132c3736&amp;amp;chksm=f1fcc54cc68b4c5add08371265320163381ea81333daea5664b94e9a12246a34cfaa31e6f0b3&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0213Ssp5geOThmtF6tg9Bz7U#rd&quot;&gt;QQ空间终端开发团队公众号&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于C++来说，内存泄漏就是new出来的对象没有delete，俗称野指针；&lt;br&gt;对于Java来说，就是new出来的Object 放在Heap上无法被GC回收；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170213160148023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文通过QQ和Qzone中内存泄漏实例来讲android中内存泄漏分析解法和编写代码应注意的事项。&lt;/p&gt;
&lt;h2 id=&quot;Java-中的内存分配&quot;&gt;&lt;a href=&quot;#Java-中的内存分配&quot; class=&quot;headerlink&quot; title=&quot;Java 中的内存分配&quot;&gt;&lt;/a&gt;&lt;strong&gt;Java 中的内存分配&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;静态储存区&lt;/strong&gt;：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;栈区&lt;/strong&gt;：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;堆区&lt;/strong&gt;：通常存放 new 出来的对象。由 Java 垃圾回收器回收。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】AlertDialog中的EditText不能弹出软键盘的问题</title>
    <link href="http://github.com/2017/01/20/%E3%80%90Android%E3%80%91AlertDialog%E4%B8%AD%E7%9A%84EditText%E4%B8%8D%E8%83%BD%E5%BC%B9%E5%87%BA%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/01/20/【Android】AlertDialog中的EditText不能弹出软键盘的问题/</id>
    <published>2017-01-20T03:03:00.000Z</published>
    <updated>2017-01-20T03:13:42.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>AlertDialog中加入EditText但是不弹出软键盘等问题网上有很多不管用的解决方案，有的方案是<strong>强制弹出软键盘</strong>，然而即使弹出来，也是显示在AlertDialog的后面，被Dialog遮挡。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><p>Dialog的官方文档：<a href="http://developer.android.com/reference/android/app/Dialog.html" target="_blank" rel="external">http://developer.android.com/reference/android/app/Dialog.html</a> ，其中有一段：</p>
<blockquote>
<p><strong>Note:</strong> Activities provide a facility to manage the creation, saving and restoring of dialogs. See <a href="https://developer.android.com/reference/android/app/Activity.html#onCreateDialog%28int%29" target="_blank" rel="external">onCreateDialog(int)</a>, <a href="https://developer.android.com/reference/android/app/Activity.html#onPrepareDialog%28int,%20android.app.Dialog%29" target="_blank" rel="external">onPrepareDialog(int, Dialog)</a>, <a href="https://developer.android.com/reference/android/app/Activity.html#showDialog%28int%29" target="_blank" rel="external">showDialog(int)</a>, and <a href="https://developer.android.com/reference/android/app/Activity.html#dismissDialog%28int%29" target="_blank" rel="external">dismissDialog(int)</a>. If these methods are used, <a href="https://developer.android.com/reference/android/app/Dialog.html#getOwnerActivity%28%29" target="_blank" rel="external">getOwnerActivity()</a> will return the Activity that managed this dialog.</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>Often you will want to have a Dialog display on top of the current input method, because there is no reason for it to accept text. You can do this by setting the <a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_ALT_FOCUSABLE_IM" target="_blank" rel="external">WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM</a> window flag (assuming your Dialog takes input focus, as it the default) with the following code:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,</div><div class="line">         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这段话的大概意思是说，WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM  这个参数会让Dialog遮挡住软键盘，显示在软键盘的前面。</p>
<p>这是默认情况下隐藏软键盘的方法，要重新显示软键盘，要执行下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">alertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</div></pre></td></tr></table></figure>
<p>我是把它写在了setOnFocusChangeListener里，起效了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">editText.setOnFocusChangeListener(<span class="keyword">new</span> View.OnFocusChangeListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFocusChange</span><span class="params">(View view, <span class="keyword">boolean</span> focused)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (focused) &#123;</div><div class="line">	         <span class="comment">//dialog弹出软键盘</span></div><div class="line">	         alertDialog.getWindow()</div><div class="line">			       .clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);   </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>AlertDialog.setView()则不会出现以上问题。</p>
<h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a><strong>另外</strong></h3><p>为了防止弹出输入法时把后面的背景挤变形，可以在Manifest里的相应Activity添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:windowSoftInputMode="adjustPan|stateHidden"</div></pre></td></tr></table></figure>
<p>像这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></div><div class="line">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">"adjustPan|stateHidden"</span></div><div class="line">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a><strong>【参考资料】</strong></h2><p>1、<a href="http://blog.csdn.net/wurensen/article/details/21018115" target="_blank" rel="external">关于AlertDialog中EditText不能弹出输入法解决方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;AlertDialog中加入EditText但是不弹出软键盘等问题网上有很多不管用的解决方案，有的方案是&lt;strong&gt;强制弹出软键盘&lt;/strong&gt;，然而即使弹出来，也是显示在AlertDialog的后面，被Dialog遮挡。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Dialog的官方文档：&lt;a href=&quot;http://developer.android.com/reference/android/app/Dialog.html&quot;&gt;http://developer.android.com/reference/android/app/Dialog.html&lt;/a&gt; ，其中有一段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Activities provide a facility to manage the creation, saving and restoring of dialogs. See &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onCreateDialog%28int%29&quot;&gt;onCreateDialog(int)&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onPrepareDialog%28int,%20android.app.Dialog%29&quot;&gt;onPrepareDialog(int, Dialog)&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#showDialog%28int%29&quot;&gt;showDialog(int)&lt;/a&gt;, and &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#dismissDialog%28int%29&quot;&gt;dismissDialog(int)&lt;/a&gt;. If these methods are used, &lt;a href=&quot;https://developer.android.com/reference/android/app/Dialog.html#getOwnerActivity%28%29&quot;&gt;getOwnerActivity()&lt;/a&gt; will return the Activity that managed this dialog.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】TextView中不同大小字体如何上下垂直居中？</title>
    <link href="http://github.com/2017/01/03/%E3%80%90Android%E3%80%91TextView%E4%B8%AD%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A6%82%E4%BD%95%E4%B8%8A%E4%B8%8B%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F/"/>
    <id>http://github.com/2017/01/03/【Android】TextView中不同大小字体如何上下垂直居中？/</id>
    <published>2017-01-03T09:03:00.000Z</published>
    <updated>2017-01-03T09:51:40.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>在客户端开发中，我们往往需要对一个TextView的文字的部分内容进行特殊化处理，比如加粗、改变颜色、加链接、下划线等。iOS为我们提供了<code>AttributedString</code>，而Android则提供了<strong><code>SpannableString</code></strong>。</p>
<p>在Android的android.text.style包下为我们提供了各种各样的span（可以<a href="http://blog.csdn.net/u010983881/article/details/52383539" target="_blank" rel="external"><strong>参考这篇文章</strong></a>），例如：</p>
<ul>
<li><p><strong>AbsoluteSizeSpan(int size)</strong> —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小</p>
</li>
<li><p><strong>RelativeSizeSpan(float proportion)</strong> —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out)</p>
</li>
<li><p><strong>BackgroundColorSpan(int color)</strong> —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int)</p>
</li>
<li><p><strong>ForegroundColorSpan(int color)</strong> —— 前景着色，也就是字的着色，参数与背景着色一致</p>
</li>
</ul>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>网上已经有着很多使用这些span的教程了，所以没必要在这里继续探讨这些基础使用了。但是，如果使用了<strong><code>AbsoluteSizeSpan(int size)</code></strong> 在同一个TextView中定义了不同字体大小，就会默认显示成底部对齐的方式：</p>
<p><img src="/gallery/Textview-vertical/not.png" alt=""></p>
<p>说到这里，第一反应肯定是<code>tv.setGravity(Gravity.CENTER_VERTICAL)</code>，但是很不幸，怎么试都不凑效。那么到底有没有办法使用Span让不同字体大小的垂直居中呢？</p>
<p>答案是：<strong>当然可以，得用<code>ReplacementSpan</code></strong></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><h3 id="为何是ReplacementSpan？"><a href="#为何是ReplacementSpan？" class="headerlink" title="为何是ReplacementSpan？"></a><strong>为何是ReplacementSpan？</strong></h3><p>它是系统提供给我们的一个抽象类。通过名字我们可以知道其实用于是用于替换。指示我们<strong>可以把文本的某一部分替换成我们想要的内容</strong>。这也许是我们想要的。</p>
<p><code>Relpacement</code>的定义很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementSpan</span> <span class="keyword">extends</span> <span class="title">MetricAffectingSpan</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Paint paint, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Paint.FontMetricsInt fm)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, Paint paint)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMeasureState</span><span class="params">(TextPaint p)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint ds)</span> </span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在继承它的时候，需要实现两个方法<code>getSize()</code>和<code>draw()</code>。通过方法名，我们也许能够知道其作用：<code>getSize()</code>用于确定span的大小（实际上只是一个宽度），<code>draw()</code>用于绘制我们想要的内容。</p>
<p>但是问题来了，这些方法的传参是什么？<strong>为何<code>getSize()</code>只返回了一个int值？</strong></p>
<p>了解了这两个问题，就基本弄懂了自定义span。来回答这两个问题前，我们首先要明确的一件事情是：span是用于<code>SpannableString</code>中，并且最终被用于<code>TextView</code>中。所以在定义span时，我们的大小、绘制内容都应该依赖于使用时的环境。我们假设自定义span使用的环境为A,那么A将包换一些信息，例如：<code>baseline</code>、<code>Paint</code>、<code>FontMetricsInt</code>等信息。</p>
<p>那我们现在来看看<code>getSize()</code>方法。<code>getSize()</code>的返回值是int，其实这个值指的是自定义span的宽度，那它的高度呢？其实高度是已知的，那就是外界环境A带来的字的高度。但我某些情况我们希望改变span的高度，我们该怎么做呢？ 如果对Android上字体绘制有一定了解的同学会知道，一个字的高度取决于绘制这个子的<strong><code>Paint.FontMetricsInt</code></strong></p>
<h3 id="什么是-Paint-FontMetrics"><a href="#什么是-Paint-FontMetrics" class="headerlink" title="什么是 Paint.FontMetrics"></a><strong>什么是 Paint.FontMetrics</strong></h3><p>它表示绘制字体时的度量标准。google的官方api文档对它的字段说明如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th style="text-align:left">Fields</th>
</tr>
</thead>
<tbody>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>ascent</strong> - The recommended distance above the baseline for singled spaced text.</td>
</tr>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>bottom</strong> - The maximum distance below the baseline for the lowest glyph in the font at a given text size.</td>
</tr>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>descent</strong> - The recommended distance below the baseline for singled spaced text.</td>
</tr>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>leading</strong> - The recommended additional space to add between lines of text.</td>
</tr>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>top</strong> - The maximum distance above the baseline for the tallest glyph in the font at a given text size.</td>
</tr>
</tbody>
</table>
<p>其中：</p>
<ul>
<li><strong>ascent</strong> : 字体最上端到基线的距离，为负值。</li>
<li><strong>descent</strong>：字体最下端到基线的距离，为正值。</li>
</ul>
<p><img src="/gallery/Textview-vertical/FontMetricsInt.png" alt=""></p>
<p>如上图，中间那条线（Baseline）就是基线，基线到上面那条线的距离就是<code>ascent</code>，基线到下面那条线的距离就是<code>descent</code>。</p>
<p>回到我们的主题， 我们发现<code>getSize()</code>方法的参数中有<code>Paint.FontMetricsInt</code>，那我们是否就可以通过改变传入的Paint.FontMetricsInt的<code>asent</code>和<code>desent</code>来达到改变高度的目的呢？答案是可行的。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h2><p>按照上面的分析，我们继承<code>ReplacementSpan</code> 自定义一个Span</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使TextView中不同大小字体垂直居中</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomVerticalCenterSpan</span> <span class="keyword">extends</span> <span class="title">ReplacementSpan</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> fontSizeSp;    <span class="comment">//字体大小sp</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomVerticalCenterSpan</span><span class="params">(<span class="keyword">int</span> fontSizeSp)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.fontSizeSp = fontSizeSp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Paint paint, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Paint.FontMetricsInt fm)</span> </span>&#123;</div><div class="line">		text = text.subSequence(start, end);</div><div class="line">		Paint p = getCustomTextPaint(paint);</div><div class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) p.measureText(text.toString());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, Paint paint)</span> </span>&#123;</div><div class="line">		text = text.subSequence(start, end);</div><div class="line">		Paint p = getCustomTextPaint(paint);</div><div class="line">		Paint.FontMetricsInt fm = p.getFontMetricsInt();</div><div class="line">		canvas.drawText(text.toString(), x, y - ((y + fm.descent + y + fm.ascent) / <span class="number">2</span> - (bottom + top) / <span class="number">2</span>), p);    <span class="comment">//此处重新计算y坐标，使字体居中</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> TextPaint <span class="title">getCustomTextPaint</span><span class="params">(Paint srcPaint)</span> </span>&#123;</div><div class="line">		TextPaint paint = <span class="keyword">new</span> TextPaint(srcPaint);</div><div class="line">		paint.setTextSize(ViewUtils.getSpPixel(mContext, fontSizeSp));   <span class="comment">//设定字体大小, sp转换为px</span></div><div class="line">		<span class="keyword">return</span> paint;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释下形参：</p>
<ul>
<li><strong>x</strong>：要绘制的image的左边框到textview左边框的距离。</li>
<li><strong>y</strong>：要替换的文字的基线（Baseline）的纵坐标。</li>
<li><strong>top</strong>：替换行的最顶部位置。</li>
<li><strong>bottom</strong>：替换行的最底部位置。注意，textview中两行之间的行间距是属于上一行的，所以这里bottom是指行间隔的底部位置。</li>
<li><strong>paint</strong>：画笔，包含了要绘制字体的度量信息。</li>
</ul>
<p>所以就有：</p>
<ul>
<li><code>y + fm.descent</code>：得到字体的<code>descent</code>线坐标；<br> <code>y + fm.ascent</code>：得到字体的<code>ascent</code>线坐标；</li>
</ul>
<p><code>(y + fm.descent + y + fm.ascent) / 2</code> 也就是字体中间线的纵坐标</p>
<p><code>((y + fm.descent + y + fm.ascent) / 2 - (bottom + top) / 2)</code> 就是字体需要向上调整的距离</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a><strong>使用方式</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">SpannableString ss = <span class="keyword">new</span> SpannableString(disStr + unitString);</div><div class="line"></div><div class="line">ss.setSpan(<span class="keyword">new</span> AbsoluteSizeSpan(<span class="number">40</span>, <span class="keyword">true</span>), <span class="number">0</span>, disStr.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);</div><div class="line"><span class="comment">//垂直居中显示文字</span></div><div class="line">ss.setSpan(<span class="keyword">new</span> CustomVerticalCenterSpan(<span class="number">23</span>), disStr.length(), ss.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);</div></pre></td></tr></table></figure>
<p>看看效果：</p>
<p><img src="/gallery/Textview-vertical/ok1.png" alt=""></p>
<p><img src="/gallery/Textview-vertical/ok2.png" alt=""></p>
<hr>
<h3 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a><strong>【参考资料】</strong></h3><ol>
<li><p><a href="http://stackoverflow.com/questions/36964034/how-to-make-relativesizespan-align-to-top" target="_blank" rel="external">How to make RelativeSizeSpan align to top？</a> </p>
<p><img src="http://img.blog.csdn.net/20170103153457771?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/23990381/how-to-create-vertically-aligned-superscript-and-subscript-in-textview" target="_blank" rel="external">How to create vertically aligned superscript and subscript in TextView</a></p>
<p><img src="http://img.blog.csdn.net/20170103153252987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p><a href="http://blog.cgsdream.org/2016/07/06/custom-android-span/" target="_blank" rel="external">教你自定义android中span</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/withwind318/p/5541267.html" target="_blank" rel="external">Android ImageSpan与TextView中的text居中对齐问题解决（无论TextView设置行距与否）</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在客户端开发中，我们往往需要对一个TextView的文字的部分内容进行特殊化处理，比如加粗、改变颜色、加链接、下划线等。iOS为我们提供了&lt;code&gt;AttributedString&lt;/code&gt;，而Android则提供了&lt;strong&gt;&lt;code&gt;SpannableString&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Android的android.text.style包下为我们提供了各种各样的span（可以&lt;a href=&quot;http://blog.csdn.net/u010983881/article/details/52383539&quot;&gt;&lt;strong&gt;参考这篇文章&lt;/strong&gt;&lt;/a&gt;），例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;AbsoluteSizeSpan(int size)&lt;/strong&gt; —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;RelativeSizeSpan(float proportion)&lt;/strong&gt; —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&amp;gt;1就是放大(zoom in), proportion&amp;lt;1就是缩小(zoom out)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;BackgroundColorSpan(int color)&lt;/strong&gt; —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ForegroundColorSpan(int color)&lt;/strong&gt; —— 前景着色，也就是字的着色，参数与背景着色一致&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Java】泛型中 extends 和 super 的区别？</title>
    <link href="http://github.com/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://github.com/2016/12/27/【Java】泛型中 extends 和 super 的区别？/</id>
    <published>2016-12-27T06:46:00.000Z</published>
    <updated>2017-06-16T10:27:21.325Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/gallery/java-genericity/example.png" alt=""></p>
<p><code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>是Java泛型中的<strong>“通配符（Wildcards）”</strong>和<strong>“边界（Bounds）”</strong>的概念。</p>
<ul>
<li><code>&lt;? extends T&gt;</code>：是指 <strong>“上界通配符（Upper Bounds Wildcards）”</strong></li>
<li><code>&lt;? super T&gt;</code>：是指 <strong>“下界通配符（Lower Bounds Wildcards）”</strong></li>
</ul>
<h2 id="为什么要用通配符和边界？"><a href="#为什么要用通配符和边界？" class="headerlink" title="为什么要用通配符和边界？"></a><strong>为什么要用通配符和边界？</strong></h2><p>使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：<code>set( )</code>和<code>get( )</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> T item;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Plate&lt;Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</div></pre></td></tr></table></figure>
<p>但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">error: incompatible types: Plate&lt;Apple&gt; cannot be converted to Plate&lt;Fruit&gt;</div></pre></td></tr></table></figure>
<p>所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的：</p>
<ul>
<li>苹果 IS-A 水果</li>
<li>装苹果的盘子 NOT-IS-A 装水果的盘子</li>
</ul>
<p>所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。</p>
<p>为了让泛型用起来更舒服，Sun的大脑袋们就想出了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>的办法，来让“水果盘子”和“苹果盘子”之间发生关系。</p>
<h2 id="什么是上界？"><a href="#什么是上界？" class="headerlink" title="什么是上界？"></a><strong>什么是上界？</strong></h2><p>下面代码就是“上界通配符（Upper Bounds Wildcards）”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Plate&lt;？ extends Fruit&gt;</div></pre></td></tr></table></figure>
<p>翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。<code>Plate&lt;？ extends Fruit&gt;</code>和<code>Plate&lt;Apple&gt;</code>最大的区别就是：<code>Plate&lt;？ extends Fruit&gt;</code>是<code>Plate&lt;Fruit&gt;</code>以及<code>Plate&lt;Apple&gt;</code>的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Plate&lt;? extends Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</div></pre></td></tr></table></figure>
<p>如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Lev 1</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//Lev 2</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//Lev 3</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//Lev 4</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenApple</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>在这个体系中，下界通配符 <code>Plate&lt;？ extends Fruit&gt;</code> 覆盖下图中蓝色的区域。</p>
<p><img src="/gallery/java-genericity/lowerBounds.png" alt=""></p>
<h2 id="什么是下界？"><a href="#什么是下界？" class="headerlink" title="什么是下界？"></a><strong>什么是下界？</strong></h2><p>相对应的，“下界通配符（Lower Bounds Wildcards）”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Plate&lt;？ <span class="keyword">super</span> Fruit&gt;</div></pre></td></tr></table></figure>
<p>表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。<code>Plate&lt;？ super Fruit&gt;</code>是<code>Plate&lt;Fruit&gt;</code>的基类，但不是<code>Plate&lt;Apple&gt;</code>的基类。对应刚才那个例子，<code>Plate&lt;？ super Fruit&gt;</code>覆盖下图中红色的区域。</p>
<p><img src="/gallery/java-genericity/upperBounds.png" alt=""></p>
<h2 id="上下界通配符的副作用"><a href="#上下界通配符的副作用" class="headerlink" title="上下界通配符的副作用"></a><strong>上下界通配符的副作用</strong></h2><p>边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。</p>
<p>还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> T item;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="上界-lt-extends-T-gt-不能往里存，只能往外取"><a href="#上界-lt-extends-T-gt-不能往里存，只能往外取" class="headerlink" title="上界&lt;? extends T&gt;不能往里存，只能往外取"></a>上界<code>&lt;? extends T&gt;</code>不能往里存，只能往外取</h3><p><code>&lt;? extends Fruit&gt;</code>会使往盘子里放东西的<code>set( )</code>方法失效。但取东西<code>get( )</code>方法还有效。比如下面例子里两个set()方法，插入Apple和Fruit都报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Plate&lt;? extends Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</div><div class="line">	</div><div class="line"><span class="comment">//不能存入任何元素</span></div><div class="line">p.set(<span class="keyword">new</span> Fruit());    <span class="comment">//Error</span></div><div class="line">p.set(<span class="keyword">new</span> Apple());    <span class="comment">//Error</span></div><div class="line"></div><div class="line"><span class="comment">//读取出来的东西只能存放在Fruit或它的基类里。</span></div><div class="line">Fruit newFruit1=p.get();</div><div class="line">Object newFruit2=p.get();</div><div class="line">Apple newFruit3=p.get();    <span class="comment">//Error</span></div></pre></td></tr></table></figure>
<p>原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。</p>
<p>所以通配符<code>&lt;?&gt;</code>和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">fill</span><span class="params">(T... t)</span></span>;</div></pre></td></tr></table></figure>
<p>但通配符<code>&lt;?&gt;</code>没有这种约束，<code>Plate&lt;?&gt;</code>单纯的就表示：盘子里放了一个东西，是什么我不知道。</p>
<p>所以题主问题里的错误就在这里，<code>Plate&lt;？ extends Fruit&gt;</code>里什么都放不进去。</p>
<h3 id="下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里"><a href="#下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里" class="headerlink" title="下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里"></a>下界<code>&lt;? super T&gt;</code>不影响往里存，但往外取只能放在Object对象里</h3><p>使用下界<code>&lt;? super Fruit&gt;</code>会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Fruit&gt;(<span class="keyword">new</span> Fruit());</div><div class="line"></div><div class="line"><span class="comment">//存入元素正常</span></div><div class="line">p.set(<span class="keyword">new</span> Fruit());</div><div class="line">p.set(<span class="keyword">new</span> Apple());</div><div class="line"></div><div class="line"><span class="comment">//读取出来的东西只能存放在Object类里。</span></div><div class="line">Apple newFruit3=p.get();    <span class="comment">//Error</span></div><div class="line">Fruit newFruit1=p.get();    <span class="comment">//Error</span></div><div class="line">Object newFruit2=p.get();</div></pre></td></tr></table></figure>
<p>因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。</p>
<h2 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a><strong>PECS原则</strong></h2><p>最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：</p>
<ul>
<li><strong>频繁往外读取内容的，适合用上界Extends。</strong></li>
<li><strong>经常往里插入的，适合用下界Super。</strong></li>
</ul>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ciaoshen.com/2016/08/21/superExtends/" target="_blank" rel="external">Java泛型中extends和super的区别？</a></li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/gallery/java-genericity/example.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;是Java泛型中的&lt;strong&gt;“通配符（Wildcards）”&lt;/strong&gt;和&lt;strong&gt;“边界（Bounds）”&lt;/strong&gt;的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;：是指 &lt;strong&gt;“上界通配符（Upper Bounds Wildcards）”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;：是指 &lt;strong&gt;“下界通配符（Lower Bounds Wildcards）”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么要用通配符和边界？&quot;&gt;&lt;a href=&quot;#为什么要用通配符和边界？&quot; class=&quot;headerlink&quot; title=&quot;为什么要用通配符和边界？&quot;&gt;&lt;/a&gt;&lt;strong&gt;为什么要用通配符和边界？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fruit&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fruit&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：&lt;code&gt;set( )&lt;/code&gt;和&lt;code&gt;get( )&lt;/code&gt;方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Plate&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; T item;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Plate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;&amp;#123;item=t;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;&amp;#123;item=t;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java Generics" scheme="http://github.com/tags/Java-Generics/"/>
    
  </entry>
  
  <entry>
    <title>【Java】泛型详解</title>
    <link href="http://github.com/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://github.com/2016/12/27/【Java】泛型详解/</id>
    <published>2016-12-27T04:30:55.000Z</published>
    <updated>2017-07-11T09:01:49.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-为什么需要泛型？"><a href="#一-为什么需要泛型？" class="headerlink" title="一. 为什么需要泛型？"></a><strong>一. 为什么需要泛型？</strong></h2><p>首先，我们看下下面这段简短的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List list = <span class="keyword">new</span> ArrayList();</div><div class="line">        list.add(<span class="string">"qqyumidi"</span>);</div><div class="line">        list.add(<span class="string">"corn"</span>);</div><div class="line">        list.add(<span class="number">100</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">            String name = (String) list.get(i);  <span class="comment">// ① 错误</span></div><div class="line">            System.out.println(<span class="string">"name:"</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于<code>//①</code>中的错误。因为编译阶段正常，而运行时会出现<strong>“java.lang.ClassCastException”异常</strong>。因此，导致此类错误编码过程中不易发现。</p>
<p> 在如上的编码过程中，我们发现主要存在两个问题：</p>
<ol>
<li><p>当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</p>
</li>
<li><p>因此，//① 处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</p>
</li>
</ol>
<p>那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用<strong>泛型</strong>。</p>
<a id="more"></a>
<h2 id="二-什么是泛型？"><a href="#二-什么是泛型？" class="headerlink" title="二. 什么是泛型？"></a><strong>二. 什么是泛型？</strong></h2><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>看着好像有点复杂，首先我们看下上面那个例子采用泛型的写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">        List list = new ArrayList();</div><div class="line">        list.add("qqyumidi");</div><div class="line">        list.add("corn");</div><div class="line">        list.add(100);</div><div class="line">        */</div><div class="line"></div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        list.add(<span class="string">"qqyumidi"</span>);</div><div class="line">        list.add(<span class="string">"corn"</span>);</div><div class="line">        <span class="comment">//list.add(100);   // 1  提示编译错误</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">            String name = list.get(i); <span class="comment">// 2 无须进行强制类型转换</span></div><div class="line">            System.out.println(<span class="string">"name:"</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List<string>，直接限定了list集合中只能含有String类型的元素，从而在//2 处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。</string></p>
<p>结合上面的泛型定义，我们知道在List<string>中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义：</string></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    Object[] toArray();</div><div class="line"></div><div class="line">    &lt;T&gt; T[] toArray(T[] a);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在List接口中采用泛型化定义之后，<code>&lt;E&gt;</code>中的 E 表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。</p>
<p>自然的，ArrayList作为List接口的实现类，其定义形式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line">        checkForComodification();</div><div class="line">        <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//...省略掉其他具体的定义过程</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此，我们从源代码角度明白了为什么//1处加入Integer类型对象编译错误，且//2处get()到的类型直接就是String类型了。</p>
<h2 id="三-自定义泛型接口、泛型类和泛型方法"><a href="#三-自定义泛型接口、泛型类和泛型方法" class="headerlink" title="三. 自定义泛型接口、泛型类和泛型方法"></a><strong>三. 自定义泛型接口、泛型类和泛型方法</strong></h2><p>从上面的内容中，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义，以及相应的使用。是的，在具体使用时，可以分为泛型接口、泛型类和泛型方法。</p>
<p>自定义泛型接口、泛型类和泛型方法与上述Java源码中的List、ArrayList类似。如下，我们看一个最简单的泛型类和方法定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">"corn"</span>);</div><div class="line">        System.out.println(<span class="string">"name:"</span> + name.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> T data;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。<strong>那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">"corn"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"name class:"</span> + name.getClass());      <span class="comment">// com.qqyumidi.Box</span></div><div class="line">        System.out.println(<span class="string">"age class:"</span> + age.getClass());        <span class="comment">// com.qqyumidi.Box</span></div><div class="line">        System.out.println(name.getClass() == age.getClass());    <span class="comment">// true</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。</p>
<p>究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h2 id="四-类型通配符"><a href="#四-类型通配符" class="headerlink" title="四. 类型通配符"></a><strong>四. 类型通配符</strong></h2><p>接着上面的结论，我们知道，<code>Box&lt;Number&gt;</code>和<code>Box&lt;Integer&gt;</code>实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于<code>Box&lt;Number&gt;</code>和<code>Box&lt;Integer&gt;</code>是否可以看成具有父子关系的泛型类型呢？</p>
<p>为了弄清这个问题，我们继续看下下面这个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;Number&gt; name = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">99</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line">        </div><div class="line">        <span class="comment">//The method getData(Box&lt;Number&gt;) in the type GenericTest is </span></div><div class="line">        <span class="comment">//not applicable for the arguments (Box&lt;Integer&gt;)</span></div><div class="line">        getData(age);   <span class="comment">// 1</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;Number&gt; data)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现，在代码//1 处出现了错误提示信息：<strong><code>The method getData(Box&lt;Number&gt;) in the t ype GenericTest is not applicable for the arguments (Box&lt;Integer&gt;)</code></strong>。显然，通过提示信息，我们知道<code>Box&lt;Number&gt;</code>在逻辑上不能视为<code>Box&lt;Integer&gt;</code>的父类。那么，原因何在呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;Integer&gt; a = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;Number&gt; b = a;   <span class="comment">// 1</span></div><div class="line">        Box&lt;Float&gt; f = <span class="keyword">new</span> Box&lt;Float&gt;(<span class="number">3.14f</span>);</div><div class="line">        b.setData(f);        <span class="comment">// 2</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;Number&gt; data)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> T data;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">        setData(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中，显然//1 和//2 处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。</p>
<p>假设<code>Box&lt;Number&gt;</code>在逻辑上可以视为<code>Box&lt;Integer&gt;</code>的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，<strong>因此，在逻辑上<code>Box&lt;Number&gt;</code>不能视为<code>Box&lt;Integer&gt;</code>的父类。</strong></p>
<p>好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总部能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，因此，我们需要一个在逻辑上可以用来表示同时是<code>Box&lt;Integer&gt;</code>和<code>Box&lt;Number&gt;</code>的父类的一个引用类型，由此，类型通配符应运而生。</p>
<p><strong>类型通配符一般是使用 ? 代替具体的类型实参。</strong>注意了，此处是类型实参，而不是类型形参！且<code>Box&lt;?&gt;</code>在逻辑上是<code>Box&lt;Integer&gt;</code>、<code>Box&lt;Number&gt;</code>…等所有<code>Box&lt;具体类型实参&gt;</code>的父类。由此，我们依然可以定义泛型方法，来完成此类需求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">"corn"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;Number&gt; number = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">314</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line">        getData(age);</div><div class="line">        getData(number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;?&gt; data)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候，我们还可能听到<strong>类型通配符上限</strong>和<strong>类型通配符下限</strong>。具体有是怎么样的呢？</p>
<p>在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">"corn"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;Number&gt; number = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">314</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line">        getData(age);</div><div class="line">        getData(number);</div><div class="line">        </div><div class="line">        <span class="comment">//getUpperNumberData(name); // 1</span></div><div class="line">        getUpperNumberData(age);    <span class="comment">// 2</span></div><div class="line">        getUpperNumberData(number); <span class="comment">// 3</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;?&gt; data)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUpperNumberData</span><span class="params">(Box&lt;? extends Number&gt; data)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。</p>
<p>类型通配符上限通过形如<code>Box&lt;? extends Number&gt;</code>形式定义，相对应的，类型通配符下限为<code>Box&lt;? super Number&gt;</code>形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。</p>
<h2 id="五-话外篇"><a href="#五-话外篇" class="headerlink" title="五. 话外篇"></a><strong>五. 话外篇</strong></h2><p>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。<strong>并且还要注意的一点是，Java中没有所谓的泛型数组一说。</strong></p>
<p>对于泛型，最主要的还是需要理解其背后的思想和目的。</p>
<h2 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a><strong>【参考资料】</strong></h2><ul>
<li><a href="http://www.cnblogs.com/lwbqqyumidi/p/3837629.html" target="_blank" rel="external">Java总结篇系列：Java泛型</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-为什么需要泛型？&quot;&gt;&lt;a href=&quot;#一-为什么需要泛型？&quot; class=&quot;headerlink&quot; title=&quot;一. 为什么需要泛型？&quot;&gt;&lt;/a&gt;&lt;strong&gt;一. 为什么需要泛型？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;首先，我们看下下面这段简短的代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GenericTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        List list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;qqyumidi&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;corn&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String name = (String) list.get(i);  &lt;span class=&quot;comment&quot;&gt;// ① 错误&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;name:&quot;&lt;/span&gt; + name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于&lt;code&gt;//①&lt;/code&gt;中的错误。因为编译阶段正常，而运行时会出现&lt;strong&gt;“java.lang.ClassCastException”异常&lt;/strong&gt;。因此，导致此类错误编码过程中不易发现。&lt;/p&gt;
&lt;p&gt; 在如上的编码过程中，我们发现主要存在两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此，//① 处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用&lt;strong&gt;泛型&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数学之美番外篇：平凡而又神奇的贝叶斯方法</title>
    <link href="http://github.com/2016/12/22/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E5%B9%B3%E5%87%A1%E8%80%8C%E5%8F%88%E7%A5%9E%E5%A5%87%E7%9A%84%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95/"/>
    <id>http://github.com/2016/12/22/数学之美番外篇：平凡而又神奇的贝叶斯方法/</id>
    <published>2016-12-22T03:08:00.000Z</published>
    <updated>2017-01-13T11:10:58.012Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="pullquote right"><p>Probability is nothing but common sense reduced to calculation.（概率论只不过是把常识用数学公式表达了出来。）<br> —— <a href="https://zh.wikipedia.org/wiki/%E7%9A%AE%E5%9F%83%E5%B0%94-%E8%A5%BF%E8%92%99%C2%B7%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF" target="_blank" rel="external">Pierre-Simon Laplace</a></p>
</blockquote>
<p>记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了 —— 这果然是个牛逼的方法。</p>
<p>——题记</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。</p>
<a id="more"></a>
<h2 id="1-历史"><a href="#1-历史" class="headerlink" title="1. 历史"></a><strong>1. 历史</strong></h2><p>托马斯·贝叶斯（Thomas Bayes）同学的详细生平<a href="https://en.wikipedia.org/wiki/Thomas_Bayes" target="_blank" rel="external"><strong>在这里</strong></a>。以下摘一段 wikipedia 上的简介：</p>
<blockquote>
<p>所谓的贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆概问题。</p>
</blockquote>
<p>实际上，贝叶斯当时的论文只是对这个问题的一个直接的求解尝试，并不清楚他当时是不是已经意识到这里面包含着的深刻的思想。然而后来，贝叶斯方法席卷了概率论，并将应用延伸到各个问题领域，所有需要作出概率预测的地方都可以见到贝叶斯方法的影子，特别地，贝叶斯是机器学习的核心方法之一。这背后的深刻原因在于，现实世界本身就是不确定的，人类的观察能力是有局限性的（否则有很大一部分科学就没有必要做了——设想我们能够直接观察到电子的运行，还需要对原子模型争吵不休吗？），我们日常所观察到的只是事物表面上的结果，沿用刚才那个袋子里面取球的比方，我们往往只能知道从里面取出来的球是什么颜色，而并不能直接看到袋子里面实际的情况。这个时候，我们就需要提供一个猜测（hypothesis，更为严格的说法是“假设”，这里用“猜测”更通俗易懂一点），所谓猜测，当然就是不确定的（很可能有好多种乃至无数种猜测都能满足目前的观测），<strong>但也绝对不是两眼一抹黑瞎蒙——具体地说，我们需要做两件事情：1. 算出各种不同猜测的可能性大小。2. 算出最靠谱的猜测是什么。</strong>第一个就是计算特定猜测的后验概率，对于连续的猜测空间则是计算猜测的概率密度函数。第二个则是所谓的模型比较，模型比较如果不考虑先验概率的话就是最大似然方法。</p>
<h3 id="1-1-一个例子：自然语言的二义性"><a href="#1-1-一个例子：自然语言的二义性" class="headerlink" title="1.1 一个例子：自然语言的二义性"></a>1.1 一个例子：自然语言的二义性</h3><p>下面举一个自然语言的不确定性的例子。当你看到这句话：</p>
<blockquote>
<p>The girl saw the boy with a telescope.</p>
</blockquote>
<p>你对这句话的含义有什么猜测？平常人肯定会说：那个女孩拿望远镜看见了那个男孩（即你对这个句子背后的实际语法结构的猜测是：The girl saw-with-a-telescope the boy ）。然而，仔细一想，你会发现这个句子完全可以解释成：那个女孩看见了那个拿着望远镜的男孩（即：The girl saw the-boy-with-a-telescope ）。那为什么平常生活中我们每个人都能够迅速地对这种二义性进行消解呢？这背后到底隐藏着什么样的思维法则？我们留到后面解释。</p>
<h3 id="1-2-贝叶斯公式"><a href="#1-2-贝叶斯公式" class="headerlink" title="1.2 贝叶斯公式"></a>1.2 贝叶斯公式</h3><p>贝叶斯公式是怎么来的？</p>
<p>我们还是使用 wikipedia 上的一个例子：</p>
<blockquote>
<p>一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？</p>
</blockquote>
<p>一些认知科学的研究表明（《决策与判断》以及《<a href="https://book.douban.com/subject/3199621/" target="_blank" rel="external">Rationality for Mortals</a>》第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面<a href="https://en.wikipedia.org/wiki/Random_walk" target="_blank" rel="external"><strong>随机游走</strong></a>，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。</p>
<p>你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？</p>
<p>我们来算一算：假设学校里面人的总数是 U 个。60% 的男生都穿长裤，于是我们得到了 <code>U * P(Boy) * P(Pants|Boy)</code>个穿长裤的（男生）（其中男生的概率 P(Boy) = 60%，这里可以简单的理解为男生的比例；<code>P(Pants|Boy)</code> 是条件概率，即在 Boy 这个条件下穿长裤的概率是多大，这里是 100% ，因为所有男生都穿长裤）。40% 的女生里面又有一半（50%）是穿长裤的，于是我们又得到了 <code>U * P(Girl) * P(Pants|Girl)</code> 个穿长裤的（女生）。加起来一共是 U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的，其中有 <code>U * P(Girl) * P(Pants|Girl)</code> 个女生。两者一比就是你要求的答案。</p>
<p>下面我们把这个答案形式化一下：我们要求的是 P(Girl|Pants) （穿长裤的人里面有多少女生），我们计算的结果是 U <em> P(Girl) </em> P(Pants|Girl) / [U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl)] 。容易发现这里校园内人的总数是无关的，可以消去。于是得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(Girl|Pants) = P(Girl) * P(Pants|Girl) / [P(Boy) * P(Pants|Boy) + P(Girl) * P(Pants|Girl)]</div></pre></td></tr></table></figure>
<p>注意，如果把上式收缩起来，分母其实就是 P(Pants) ，分子其实就是 P(Pants, Girl) 。而这个比例很自然地就读作：在穿长裤的人（ P(Pants) ）里面有多少（穿长裤）的女孩（ P(Pants, Girl) ）。</p>
<p>上式中的 Pants 和 Boy/Girl 可以指代一切东西，所以其一般形式就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(B|A) = P(A|B) * P(B) / [P(A|B) * P(B) + P(A|~B) * P(~B) ]</div></pre></td></tr></table></figure>
<p>收缩起来就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(B|A) = P(AB) / P(A)</div></pre></td></tr></table></figure>
<p>其实这个就等于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(B|A) * P(A) = P(AB)</div></pre></td></tr></table></figure>
<p>难怪拉普拉斯说<strong>概率论只是把常识用数学公式表达了出来</strong>。</p>
<p>然而，后面我们会逐渐发现，看似这么平凡的贝叶斯公式，背后却隐含着非常深刻的原理。</p>
<h2 id="2-拼写纠正"><a href="#2-拼写纠正" class="headerlink" title="2. 拼写纠正"></a><strong>2. 拼写纠正</strong></h2><p>经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查/纠正器的文章（原文<a href="http://norvig.com/spell-correct.html" target="_blank" rel="external"><strong>在这里</strong></a>，这篇文章很深入浅出，强烈建议读一读），里面用到的就是贝叶斯方法，这里我们不打算复述他写的文章，而是简要地将其核心思想介绍一下。</p>
<p>首先，我们需要询问的是：<strong>“问题是什么？”</strong></p>
<p>问题是我们看到用户输入了一个不在字典中的单词，我们需要去猜测：“这个家伙到底真正想输入的单词是什么呢？”用刚才我们形式化的语言来叙述就是，我们需要求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(我们猜测他想输入的单词 | 他实际输入的单词)</div></pre></td></tr></table></figure>
<p>这个概率。并找出那个使得这个概率最大的猜测单词。显然，我们的猜测未必是唯一的，就像前面举的那个自然语言的歧义性的例子一样；这里，比如用户输入： thew ，那么他到底是想输入 the ，还是想输入 thaw ？到底哪个猜测可能性更大呢？幸运的是我们可以用贝叶斯公式来直接出它们各自的概率，我们不妨将我们的多个猜测记为 h1 h2 .. （ h 代表 hypothesis），它们都属于一个有限且离散的猜测空间 H （单词总共就那么多而已），将用户实际输入的单词记为 D （ D 代表 Data ，即观测数据），于是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(我们的猜测1 | 他实际输入的单词)</div></pre></td></tr></table></figure>
<p>可以抽象地记为：</p>
<p>P(h1 | D)</p>
<p>类似地，对于我们的猜测2，则是 P(h2 | D)。不妨统一记为：</p>
<p>P(h | D)</p>
<p>运用一次贝叶斯公式，我们得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(h | D) = P(h) * P(D | h) / P(D)</div></pre></td></tr></table></figure>
<p>对于不同的具体猜测 h1 h2 h3 .. ，P(D) 都是一样的，所以在比较 P(h1 | D) 和 P(h2 | D) 的时候我们可以忽略这个常数。即我们只需要知道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(h | D) ∝ P(h) * P(D | h)     //注：∝ 这个符号的意思是“正比例于”，不是无穷大，注意符号右端是有一个小缺口的。</div></pre></td></tr></table></figure>
<p>这个式子的抽象含义是：对于给定观测数据，一个猜测是好是坏，取决于“这个猜测本身独立的可能性大小（先验概率，Prior ）”和“这个猜测生成我们观测到的数据的可能性大小”（似然，Likelihood ）的乘积。具体到我们的那个 thew 例子上，含义就是，用户实际是想输入 the 的可能性大小取决于 the 本身在词汇表中被使用的可能性（频繁程度）大小（先验概率）和 想打 the 却打成 thew 的可能性大小（似然）的乘积。</p>
<p>下面的事情就很简单了，对于我们猜测为可能的每个单词计算一下 P(h) * P(D | h) 这个值，然后取最大的，得到的就是最靠谱的猜测。</p>
<p><strong>一点注记：</strong> Norvig 的拼写纠正器里面只提取了编辑距离为 2 以内的所有已知单词。这是为了避免去遍历字典中每个单词计算它们的 <code>P(h) * P(D | h)</code> ，但这种做法为了节省时间带来了一些误差。但话说回来难道我们人类真的回去遍历每个可能的单词来计算他们的后验概率吗？不可能。实际上，根据认知神经科学的观点，我们首先根据错误的单词做一个 bottom-up 的关联提取，提取出有可能是实际单词的那些候选单词，这个提取过程就是所谓的基于内容的提取，可以根据错误单词的一些模式片段提取出有限的一组候选，非常快地缩小的搜索空间（比如我输入 explaination ，单词里面就有充分的信息使得我们的大脑在常数时间内把可能性 narrow down 到 explanation 这个单词上，至于具体是根据哪些线索——如音节——来提取，又是如何在生物神经网络中实现这个提取机制的，目前还是一个没有弄清的领域）。然后，我们对这有限的几个猜测做一个 top-down 的预测，看看到底哪个对于观测数据（即错误单词）的预测效力最好，而如何衡量预测效率则就是用贝叶斯公式里面的那个 <code>P(h) * P(D | h)</code> 了——虽然我们很可能使用了<a href="https://book.douban.com/subject/1599035/" target="_blank" rel="external">一些启发法来简化计算</a>。后面我们还会提到这样的 bottom-up 的关联提取。</p>
<h2 id="3-模型比较与奥卡姆剃刀"><a href="#3-模型比较与奥卡姆剃刀" class="headerlink" title="3. 模型比较与奥卡姆剃刀"></a><strong>3. 模型比较与奥卡姆剃刀</strong></h2><h3 id="3-1-再访拼写纠正"><a href="#3-1-再访拼写纠正" class="headerlink" title="3.1 再访拼写纠正"></a>3.1 再访拼写纠正</h3><p>介绍了贝叶斯拼写纠正之后，接下来的一个自然而然的问题就来了：<strong>“为什么？”</strong> 为什么要用贝叶斯公式？为什么贝叶斯公式在这里可以用？我们可以很容易地领会为什么贝叶斯公式用在前面介绍的那个男生女生长裤裙子的问题里是正确的。但为什么这里？</p>
<p>为了回答这个问题，一个常见的思路就是想想：<strong>非得这样吗？</strong> 因为如果你想到了另一种做法并且证明了它也是靠谱的，那么将它与现在这个一比较，也许就能得出很有价值的信息。那么对于拼写纠错问题你能想到其他方案吗？</p>
<p>不管怎样，一个最常见的替代方案就是，选择离 thew 的<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="external"><strong>编辑距离（Edit distance）</strong></a>最近的。然而 the 和 thaw 离 thew 的编辑距离都是 1 。这可咋办捏？你说，不慌，那还是好办。我们就看到底哪个更可能被错打为 thew 就是了。我们注意到字母 e 和字母 w 在键盘上离得很紧，无名指一抽筋就不小心多打出一个 w 来，the 就变成 thew 了。而另一方面 thaw 被错打成 thew 的可能性就相对小一点，因为 e 和 a 离得较远而且使用的指头相差一个指头（一个是中指一个是小指，不像 e 和 w 使用的指头靠在一块——神经科学的证据表明紧邻的身体设施之间容易串位）。OK，很好，因为你现在已经是在用最大似然方法了，或者直白一点，你就是在计算那个使得 P(D | h) 最大的 h 。</p>
<p>而贝叶斯方法计算的是什么？是 P(h) * P(D | h) 。多出来了一个 P(h) 。我们刚才说了，这个多出来的 P(h) 是特定猜测的先验概率。为什么要掺和进一个先验概率？刚才说的那个最大似然不是挺好么？很雄辩地指出了 the 是更靠谱的猜测。有什么问题呢？既然这样，我们就从给最大似然找茬开始吧——我们假设两者的似然程度是一样或非常相近，这样不就难以区分哪个猜测更靠谱了吗？比如用户输入tlp ，那到底是 top 还是 tip ？（这个例子不怎么好，因为 top 和 tip 的词频可能仍然是接近的，但一时想不到好的英文单词的例子，我们不妨就假设 top 比 tip 常见许多吧，这个假设并不影响问题的本质。）这个时候，当最大似然不能作出决定性的判断时，先验概率就可以插手进来给出指示——“既然你无法决定，那么我告诉你，一般来说 top 出现的程度要高许多，所以更可能他想打的是 top ”）。</p>
<p>以上只是最大似然的一个问题，即并不能提供决策的全部信息。</p>
<p>最大似然还有另一个问题：即便一个猜测与数据非常符合，也并不代表这个猜测就是更好的猜测，因为这个猜测本身的可能性也许就非常低。比如 MacKay 在《Information Theory : Inference and Learning Algorithms》里面就举了一个很好的例子：-1 3 7 11 你说是等差数列更有可能呢？还是 -X^3 / 11 + 9/11*X^2 + 23/11 每项把前项作为 X 带入后计算得到的数列？此外曲线拟合也是，平面上 N 个点总是可以用 N-1 阶多项式来完全拟合，当 N 个点近似但不精确共线的时候，用 N-1 阶多项式来拟合能够精确通过每一个点，然而用直线来做拟合/线性回归的时候却会使得某些点不能位于直线上。你说到底哪个好呢？多项式？还是直线？一般地说肯定是越低阶的多项式越靠谱（当然前提是也不能忽视“似然”P(D | h) ，明摆着一个多项式分布您愣是去拿直线拟合也是不靠谱的，这就是为什么要把它们两者乘起来考虑。），原因之一就是低阶多项式更常见，先验概率（ P(h) ）较大（原因之二则隐藏在 P(D | h) 里面），这就是为什么我们要用<a href="https://en.wikipedia.org/wiki/Spline_interpolation" target="_blank" rel="external">样条（Spline interpolation）</a>来插值，而不是直接搞一个 N-1 阶多项式来通过任意 N 个点的原因。</p>
<p>以上分析当中隐含的哲学是，观测数据总是会有各种各样的误差，比如观测误差（比如你观测的时候一个 MM 经过你一不留神，手一抖就是一个误差出现了），所以如果过分去寻求能够完美解释观测数据的模型，就会落入所谓的数据<a href="https://en.wikipedia.org/wiki/Overfitting" target="_blank" rel="external">过配（overfitting）</a>的境地，一个过配的模型试图连误差（噪音）都去解释（而实际上噪音又是不需要解释的），显然就过犹不及了。所以 P(D | h) 大不代表你的 h （猜测）就是更好的 h。还要看 P(h) 是怎样的。所谓<a href="https://en.wikipedia.org/wiki/Occam%27s_razor" target="_blank" rel="external">奥卡姆剃刀</a>精神就是说：如果两个理论具有相似的解释力度，那么优先选择那个更简单的（往往也正是更平凡的，更少繁复的，更常见的）。</p>
<p>过分匹配的另一个原因在于当观测的结果并不是因为误差而显得“不精确”而是因为真实世界中对数据的结果产生贡献的因素太多太多，跟噪音不同，这些偏差是一些另外的因素集体贡献的结果，不是你的模型所能解释的——噪音那是不需要解释——一个现实的模型往往只提取出几个与结果相关度很高，很重要的因素（cause）。这个时候观察数据会倾向于围绕你的有限模型的预测结果呈正态分布，于是你实际观察到的结果就是这个正态分布的随机取样，这个取样很可能受到其余因素的影响偏离你的模型所预测的中心，这个时候便不能贪心不足地试图通过改变模型来“完美”匹配数据，因为那些使结果偏离你的预测的贡献因素不是你这个有限模型里面含有的因素所能概括的，硬要打肿脸充胖子只能导致不实际的模型，举个教科书例子：身高和体重的实际关系近似于一个二阶多项式的关系，但大家都知道并不是只有身高才会对体重产生影响，物理世界影响体重的因素太多太多了，有人身材高大却瘦得跟稻草，有人却是横长竖不长。但不可否认的是总体上来说，那些特殊情况越是特殊就越是稀少，呈围绕最普遍情况（胖瘦适中）的正态分布，这个分布就保证了我们的身高——体重相关模型能够在大多数情况下做出靠谱的预测。但是——刚才说了，特例是存在的，就算不是特例，人有胖瘦，密度也有大小，所以完美符合身高——体重的某个假想的二阶多项式关系的人是不存在的，我们又不是欧几里德几何世界当中的理想多面体，所以，当我们对人群随机抽取了 N 个样本（数据点）试图对这 N 个数据点拟合出一个多项式的话就得注意，它肯定得是二阶多项式，我们要做的只是去根据数据点计算出多项式各项的参数（一个典型的方法就是最小二乘）；它肯定不是直线（我们又不是稻草），也不是三阶多项式四阶多项式.. 如果硬要完美拟合 N 个点，你可能会整出一个 N-1 阶多项式来——设想身高和体重的关系是 5 阶多项式看看？</p>
<h3 id="3-2-模型比较理论（Model-Comparasion）与贝叶斯奥卡姆剃刀（Bayesian-Occam’s-Razor）"><a href="#3-2-模型比较理论（Model-Comparasion）与贝叶斯奥卡姆剃刀（Bayesian-Occam’s-Razor）" class="headerlink" title="3.2 模型比较理论（Model Comparasion）与贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）"></a>3.2 模型比较理论（Model Comparasion）与贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</h3><p>实际上，模型比较就是去比较哪个模型（猜测）更可能隐藏在观察数据的背后。其基本思想前面已经用拼写纠正的例子来说明了。我们对用户实际想输入的单词的猜测就是模型，用户输错的单词就是观测数据。我们通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(h | D) ∝ P(h) * P(D | h)</div></pre></td></tr></table></figure>
<p>来比较哪个模型最为靠谱。前面提到，光靠 P(D | h) （即“似然”）是不够的，有时候还需要引入 P(h) 这个先验概率。奥卡姆剃刀就是说 P(h) 较大的模型有较大的优势，而最大似然则是说最符合观测数据的（即 P(D | h) 最大的）最有优势。整个模型比较就是这两方力量的拉锯。我们不妨再举一个简单的例子来说明这一精神：你随便找枚硬币，掷一下，观察一下结果。好，你观察到的结果要么是“正”，要么是“反”（不，不是少林足球那枚硬币:P ），不妨假设你观察到的是“正”。现在你要去根据这个观测数据推断这枚硬币掷出“正”的概率是多大。根据最大似然估计的精神，我们应该猜测这枚硬币掷出“正”的概率是 1 ，因为这个才是能最大化 P(D | h) 的那个猜测。然而每个人都会大摇其头——很显然，你随机摸出一枚硬币这枚硬币居然没有反面的概率是“不存在的”，我们对一枚随机硬币是否一枚有偏硬币，偏了多少，是有着一个先验的认识的，这个认识就是绝大多数硬币都是基本公平的，偏得越多的硬币越少见（可以用一个 <a href="https://en.wikipedia.org/wiki/Beta_distribution" target="_blank" rel="external"><strong>beta分布</strong></a>来表达这一先验概率）。将这个先验正态分布 p(θ) （其中 θ 表示硬币掷出正面的比例，小写的 p 代表这是<a href="https://en.wikipedia.org/wiki/Probability_density_function" target="_blank" rel="external"><strong>概率密度函数</strong></a>）结合到我们的问题中，我们便不是去最大化 P(D | h) ，而是去最大化 P(D | θ) * p(θ) ，显然 θ = 1 是不行的，因为 P(θ=1) 为 0 ，导致整个乘积也为 0 。实际上，只要对这个式子求一个导数就可以得到最值点。</p>
<p>以上说的是当我们知道先验概率 P(h) 的时候，光用最大似然是不靠谱的，因为最大似然的猜测可能先验概率非常小。然而，有些时候，我们对于先验概率一无所知，只能假设每种猜测的先验概率是均等的，这个时候就只有用最大似然了。实际上，统计学家和贝叶斯学家有一个有趣的争论，统计学家说：我们让数据自己说话。言下之意就是要摒弃先验概率。而贝叶斯支持者则说：数据会有各种各样的偏差，而一个靠谱的先验概率则可以对这些随机噪音做到健壮。事实证明贝叶斯派胜利了，胜利的关键在于所谓先验概率其实也是经验统计的结果，譬如为什么我们会认为绝大多数硬币是基本公平的？为什么我们认为大多数人的肥胖适中？为什么我们认为肤色是种族相关的，而体重则与种族无关？先验概率里面的“先验”并不是指先于一切经验，而是仅指先于我们“当前”给出的观测数据而已，在硬币的例子中先验指的只是先于我们知道投掷的结果这个经验，而并非“先天”。</p>
<p>然而，话说回来，有时候我们必须得承认，就算是基于以往的经验，我们手头的“先验”概率还是均匀分布，这个时候就必须依赖用最大似然，我们用前面留下的一个自然语言二义性问题来说明这一点：</p>
<blockquote>
<p>The girl saw the boy with a telescope.</p>
</blockquote>
<p>到底是 The girl saw-with-a-telescope the boy 这一语法结构，还是 The girl saw the-boy-with-a-telescope 呢？两种语法结构的常见程度都差不多（你可能会觉得后一种语法结构的常见程度较低，这是事后偏见，你只需想想 The girl saw the boy with a book 就知道了。当然，实际上从大规模语料统计结果来看后一种语法结构的确稍稍不常见一丁点，但是绝对不足以解释我们对第一种结构的强烈倾向）。那么到底为什么呢？</p>
<p>我们不妨先来看看 MacKay 在书中举的一个漂亮的例子：</p>
<p><img src="/gallery/magical-bayesian/01.jpg" alt=""></p>
<p>图中有多少个箱子？特别地，那棵书后面是一个箱子？还是两个箱子？还是三个箱子？还是.. 你可能会觉得树后面肯定是一个箱子，但为什么不是两个呢？如下图：</p>
<p><img src="/gallery/magical-bayesian/02.jpg" alt=""></p>
<p>很简单，你会说：要是真的有两个箱子那才怪了，怎么就那么巧这两个箱子刚刚好颜色相同，高度相同呢？</p>
<p>用概率论的语言来说，你刚才的话就翻译为：猜测 h 不成立，因为 P(D | h) 太小（太巧合）了。我们的直觉是：巧合（小概率）事件不会发生。所以当一个猜测（假设）使得我们的观测结果成为小概率事件的时候，我们就说“才怪呢，哪能那么巧捏？！”</p>
<p>现在我们可以回到那个自然语言二义性的例子，并给出一个完美的解释了：如果语法结构是 The girl saw the-boy-with-a-telecope 的话，怎么那个男孩偏偏手里拿的就是望远镜——一个可以被用来 saw-with 的东东捏？这也忒小概率了吧。他咋就不会拿本书呢？拿什么都好。怎么偏偏就拿了望远镜？所以唯一的解释是，这个“巧合”背后肯定有它的必然性，这个必然性就是，如果我们将语法结构解释为 The girl saw-with-a-telescope the boy 的话，就跟数据完美吻合了——既然那个女孩是用某个东西去看这个男孩的，那么这个东西是一个望远镜就完全可以解释了（不再是小概率事件了）。</p>
<p>自然语言二义性很常见，譬如上文中的一句话：</p>
<blockquote>
<p>参见《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题</p>
</blockquote>
<p>就有二义性：到底是参见这两本书的第 12 章，还是仅仅是第二本书的第 12 章呢？如果是这两本书的第 12 章那就是咄咄怪事了，怎么恰好两本书都有第 12 章，都是讲同一个问题，更诡异的是，标题还相同呢？</p>
<p>注意，以上做的是似然估计（即只看 P(D | h) 的大小），不含先验概率。通过这两个例子，尤其是那个树后面的箱子的例子我们可以看到，似然估计里面也蕴含着奥卡姆剃刀：树后面的箱子数目越多，这个模型就越复杂。单个箱子的模型是最简单的。似然估计选择了更简单的模型。</p>
<p>这个就是所谓的<strong>贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</strong>，因为这个剃刀工作在贝叶斯公式的似然（P(D | h) ）上，而不是模型本身（ P(h) ）的先验概率上，后者是传统的奥卡姆剃刀。关于贝叶斯奥卡姆剃刀我们再来看一个前面说到的曲线拟合的例子：如果平面上有 N 个点，近似构成一条直线，但绝不精确地位于一条直线上。这时我们既可以用直线来拟合（模型1），也可以用二阶多项式（模型2）拟合，也可以用三阶多项式（模型3），.. ，特别地，用 N-1 阶多项式便能够保证肯定能完美通过 N 个数据点。那么，这些可能的模型之中到底哪个是最靠谱的呢？前面提到，一个衡量的依据是奥卡姆剃刀：越是高阶的多项式越是繁复和不常见。然而，我们其实并不需要依赖于这个先验的奥卡姆剃刀，因为有人可能会争辩说：你怎么就能说越高阶的多项式越不常见呢？我偏偏觉得所有阶多项式都是等可能的。好吧，既然如此那我们不妨就扔掉 P(h) 项，看看 P(D | h) 能告诉我们什么。我们注意到越是高阶的多项式，它的轨迹弯曲程度越是大，到了八九阶简直就是直上直下，于是我们不仅要问：一个比如说八阶多项式在平面上随机生成的一堆 N 个点偏偏恰好近似构成一条直线的概率（即 P(D | h) ）有多大？太小太小了。反之，如果背后的模型是一条直线，那么根据该模型生成一堆近似构成直线的点的概率就大得多了。这就是贝叶斯奥卡姆剃刀。</p>
<p>这里只是提供一个关于贝叶斯奥卡姆剃刀的科普，强调直观解释，更多理论公式请参考 MacKay 的著作 《Information Theory : Inference and Learning Algorithms》第 28 章。</p>
<h3 id="3-3-最小描述长度原则"><a href="#3-3-最小描述长度原则" class="headerlink" title="3.3 最小描述长度原则"></a>3.3 最小描述长度原则</h3><p>贝叶斯模型比较理论与信息论有一个有趣的关联：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(h | D) ∝ P(h) * P(D | h)</div></pre></td></tr></table></figure>
<p>两边求对数，将右式的乘积变成相加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ln P(h | D) ∝ ln P(h) + ln P(D | h)</div></pre></td></tr></table></figure>
<p>显然，最大化 P(h | D) 也就是最大化 ln P(h | D)。而 ln P(h) + ln P(D | h) 则可以解释为模型（或者称“假设”、“猜测”）h 的编码长度加上在该模型下数据 D 的编码长度。使这个和最小的模型就是最佳模型。</p>
<p>而究竟如何定义一个模型的编码长度，以及数据在模型下的编码长度则是一个问题。更多可参考 Mitchell 的 《Machine Learning》的 6.6 节，或 Mackay 的 28.3 节）</p>
<h3 id="3-4-最优贝叶斯推理"><a href="#3-4-最优贝叶斯推理" class="headerlink" title="3.4 最优贝叶斯推理"></a>3.4 最优贝叶斯推理</h3><p>所谓的推理，分为两个过程，第一步是对观测数据建立一个模型。第二步则是使用这个模型来推测未知现象发生的概率。我们前面都是讲的对于观测数据给出最靠谱的那个模型。然而很多时候，虽然某个模型是所有模型里面最靠谱的，但是别的模型也并不是一点机会都没有。譬如第一个模型在观测数据下的概率是 0.5 。第二个模型是 0.4 ，第三个是 0.1 。如果我们只想知道对于观测数据哪个模型最可能，那么只要取第一个就行了，故事到此结束。然而很多时候我们建立模型是为了推测未知的事情的发生概率，这个时候，三个模型对未知的事情发生的概率都会有自己的预测，仅仅因为某一个模型概率稍大一点就只听他一个人的就太不民主了。所谓的最优贝叶斯推理就是将三个模型对于未知数据的预测结论加权平均起来（权值就是模型相应的概率）。显然，这个推理是理论上的制高点，无法再优了，因为它已经把所有可能性都考虑进去了。</p>
<p>只不过实际上我们是基本不会使用这个框架的，因为计算模型可能非常费时间，二来模型空间可能是连续的，即有无穷多个模型（这个时候需要计算模型的概率分布）。结果还是非常费时间。所以这个被看作是一个理论基准。</p>
<h2 id="4-无处不在的贝叶斯"><a href="#4-无处不在的贝叶斯" class="headerlink" title="4. 无处不在的贝叶斯"></a><strong>4. 无处不在的贝叶斯</strong></h2><p>以下我们再举一些实际例子来说明贝叶斯方法被运用的普遍性，这里主要集中在机器学习方面，因为我不是学经济的，否则还可以找到一堆经济学的例子。</p>
<h3 id="4-1-中文分词"><a href="#4-1-中文分词" class="headerlink" title="4.1 中文分词"></a>4.1 中文分词</h3><p>贝叶斯是机器学习的核心方法之一。比如中文分词领域就用到了贝叶斯。Google 研究员吴军在《数学之美》系列中就有一篇是介绍中文分词的，这里只介绍一下核心的思想，不做赘述。</p>
<p>分词问题的描述为：给定一个句子（字串），如：</p>
<p>南京市长江大桥</p>
<p>如何对这个句子进行分词（词串）才是最靠谱的。例如：</p>
<ol>
<li><p>南京市/长江大桥</p>
</li>
<li><p>南京/市长/江大桥</p>
</li>
</ol>
<p>这两个分词，到底哪个更靠谱呢？</p>
<p>我们用贝叶斯公式来形式化地描述这个问题，令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们就是需要寻找使得 P(Y|X) 最大的 Y ，使用一次贝叶斯可得：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(Y|X) ∝ P(Y)*P(X|Y)</div></pre></td></tr></table></figure>
<p>用自然语言来说就是 这种分词方式（词串）的可能性 乘以 这个词串生成我们的句子的可能性。我们进一步容易看到：可以近似地将 P(X|Y) 看作是恒等于 1 的，因为任意假想的一种分词方式之下生成我们的句子总是精准地生成的（只需把分词之间的分界符号扔掉即可）。于是，我们就变成了去最大化 P(Y) ，也就是寻找一种分词使得这个词串（句子）的概率最大化。而如何计算一个词串：</p>
<p>W1, W2, W3, W4 ..</p>
<p>的可能性呢？我们知道，根据<a href="https://en.wikipedia.org/wiki/Joint_probability_distribution" target="_blank" rel="external">联合概率（Joint probability distribution）</a>的公式展开：P(W1, W2, W3, W4 ..) = P(W1) <em> P(W2|W1) </em> P(W3|W2, W1) <em> P(W4|W1,W2,W3) </em> .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），<a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" target="_blank" rel="external">数据稀疏问题</a>也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元<a href="https://en.wikipedia.org/wiki/N-gram" target="_blank" rel="external">语言模型</a>（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) <em> P(W2|W1) </em> P(W3|W2) * P(W4|W3) .. （假设每个词只依赖于它前面的一个词）。而统计 P(W2|W1) 就不再受到数据稀疏问题的困扰了。对于我们上面提到的例子“南京市长江大桥”，如果按照自左到右的贪婪方法分词的话，结果就成了“南京市长/江大桥”。但如果按照贝叶斯分词的话（假设使用 3-gram），由于“南京市长”和“江大桥”在语料库中一起出现的频率为 0 ，这个整句的概率便会被判定为 0 。 从而使得“南京市/长江大桥”这一分词方式胜出。</p>
<p>一点注记：有人可能会疑惑，难道我们人类也是基于这些天真的假设来进行推理的？不是的。事实上，统计机器学习方法所统计的东西往往处于相当表层（shallow）的层面，在这个层面机器学习只能看到一些非常表面的现象，有一点科学研究的理念的人都知道：越是往表层去，世界就越是繁复多变。从机器学习的角度来说，特征（feature）就越多，成百上千维度都是可能的。特征一多，好了，<a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" target="_blank" rel="external">高维诅咒</a>就产生了，数据就稀疏得要命，不够用了。而我们人类的观察水平显然比机器学习的观察水平要更深入一些，为了避免数据稀疏我们不断地发明各种装置（最典型就是显微镜），来帮助我们直接深入到更深层的事物层面去观察更本质的联系，而不是在浅层对表面现象作统计归纳。举一个简单的例子，通过对大规模语料库的统计，机器学习可能会发现这样一个规律：所有的“他”都是不会穿 bra 的，所有的“她”则都是穿的。然而，作为一个男人，却完全无需进行任何统计学习，因为深层的规律就决定了我们根本不会去穿 bra 。至于机器学习能不能完成后者（像人类那样的）这个推理，则是人工智能领域的经典问题。至少在那之前，<strong>声称统计学习方法能够终结科学研究（<a href="https://www.wired.com/2008/06/pb-theory/" target="_blank" rel="external">原文</a>）的说法是纯粹外行人说的话。</strong></p>
<h3 id="4-2-统计机器翻译"><a href="#4-2-统计机器翻译" class="headerlink" title="4.2 统计机器翻译"></a>4.2 统计机器翻译</h3><p>统计机器翻译因为其简单，自动（无需手动添加规则），迅速成为了机器翻译的事实标准。而统计机器翻译的核心算法也是使用的贝叶斯方法。</p>
<p>问题是什么？统计机器翻译的问题可以描述为：给定一个句子 e ，它的可能的外文翻译 f 中哪个是最靠谱的。即我们需要计算：P(f|e) 。一旦出现条件概率贝叶斯总是挺身而出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(f|e) ∝ P(f) * P(e|f)</div></pre></td></tr></table></figure>
<p>这个式子的右端很容易解释：那些先验概率较高，并且更可能生成句子 e 的外文句子 f 将会胜出。我们只需简单统计（结合上面提到的 N-Gram 语言模型）就可以统计任意一个外文句子 f 的出现概率。然而 P(e|f) 却不是那么好求的，给定一个候选的外文局子 f ，它生成（或对应）句子 e 的概率是多大呢？我们需要定义什么叫 “对应”，这里需要用到一个分词对齐的平行语料库，有兴趣的可以参考 《Foundations of Statistical Natural Language Processing》第 13 章，这里摘选其中的一个例子：假设 e 为：John loves Mary 。我们需要考察的首选 f 是：Jean aime Marie （法文）。我们需要求出 P(e|f) 是多大，为此我们考虑 e 和 f 有多少种对齐的可能性，如：</p>
<p>John (Jean) loves (aime) Marie (Mary)</p>
<p>就是其中的一种（最靠谱的）对齐，为什么要对齐，是因为一旦对齐了之后，就可以容易地计算在这个对齐之下的 P(e|f) 是多大，只需计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(John|Jean) * P(loves|aime) * P(Marie|Mary)</div></pre></td></tr></table></figure>
<p>即可。</p>
<p>然后我们遍历所有的对齐方式，并将每种对齐方式之下的翻译概率 ∑ 求和。便可以获得整个的 P(e|f) 是多大。</p>
<p><strong>一点注记：</strong> 还是那个问题：难道我们人类真的是用这种方式进行翻译的？highly unlikely 。这种计算复杂性非常高的东西连三位数乘法都搞不定的我们才不会笨到去使用呢。根据认知神经科学的认识，很可能我们是先从句子到语义（一个逐层往上（bottom-up）抽象的 folding 过程），然后从语义根据另一门语言的语法展开为另一门语言（一个逐层往下（top-down）的具体化 unfolding 过程）。如何可计算地实现这个过程，目前仍然是个难题。（我们看到很多地方都有 bottom-up/top-down 这样一个对称的过程，实际上有人猜测这正是生物神经网络原则上的运作方式，对视觉神经系统的研究尤其证明了这一点，Hawkins 在 《On Intelligence》 里面提出了一种 <a href="https://en.wikipedia.org/wiki/Hierarchical_temporal_memory" target="_blank" rel="external">HTM （Hierarchical Temporal Memory）</a>模型正是使用了这个原则。）</p>
<h3 id="4-3-贝叶斯图像识别-Analysis-by-Synthesis"><a href="#4-3-贝叶斯图像识别-Analysis-by-Synthesis" class="headerlink" title="4.3 贝叶斯图像识别(Analysis by Synthesis)"></a>4.3 贝叶斯图像识别(Analysis by Synthesis)</h3><p>贝叶斯方法是一个非常 general 的推理框架。其核心理念可以描述成：Analysis by Synthesis （通过合成来分析）。06 年的认知科学新进展上有一篇 paper 就是讲用贝叶斯推理来解释视觉识别的，一图胜千言，下图就是摘自这篇 paper ：</p>
<p><img src="/gallery/magical-bayesian/03.jpg" alt=""></p>
<p>首先是视觉系统提取图形的边角特征，然后使用这些特征自底向上地激活高层的抽象概念（比如是 E 还是 F 还是等号），然后使用一个自顶向下的验证来比较到底哪个概念最佳地解释了观察到的图像。</p>
<h3 id="4-4-EM-算法与基于模型的聚类"><a href="#4-4-EM-算法与基于模型的聚类" class="headerlink" title="4.4  EM 算法与基于模型的聚类"></a>4.4  EM 算法与基于模型的聚类</h3><p><a href="https://en.wikipedia.org/wiki/Cluster_analysis" target="_blank" rel="external">聚类（Cluster analysis）</a>是一种无监督的机器学习问题，问题描述：给你一堆数据点，让你将它们最靠谱地分成一堆一堆的。聚类算法很多，不同的算法适应于不同的问题，这里仅介绍一个基于模型的聚类，该聚类算法对数据点的假设是，这些数据点分别是围绕 K 个核心的 K 个正态分布源所随机生成的，使用 Han JiaWei 的《Data Ming： Concepts and Techniques》中的图：</p>
<p><img src="/gallery/magical-bayesian/04.jpg" alt=""></p>
<p>图中有两个正态分布核心，生成了大致两堆点。我们的聚类算法就是需要根据给出来的那些点，算出这两个正态分布的核心在什么位置，以及分布的参数是多少。这很明显又是一个贝叶斯问题，但这次不同的是，答案是连续的且有无穷多种可能性，更糟的是，只有当我们知道了哪些点属于同一个正态分布圈的时候才能够对这个分布的参数作出靠谱的预测，现在两堆点混在一块我们又不知道哪些点属于第一个正态分布，哪些属于第二个。反过来，只有当我们对分布的参数作出了靠谱的预测时候，才能知道到底哪些点属于第一个分布，那些点属于第二个分布。这就成了一个先有鸡还是先有蛋的问题了。为了解决这个循环依赖，总有一方要先打破僵局，说，不管了，我先随便整一个值出来，看你怎么变，然后我再根据你的变化调整我的变化，然后如此迭代着不断互相推导，最终收敛到一个解。这就是 EM 算法。</p>
<p>EM 的意思是“Expectation-Maximazation”，在这个聚类问题里面，我们是先随便猜一下这两个正态分布的参数：如核心在什么地方，方差是多少。然后计算出每个数据点更可能属于第一个还是第二个正态分布圈，这个是属于 Expectation 一步。有了每个数据点的归属，我们就可以根据属于第一个分布的数据点来重新评估第一个分布的参数（从蛋再回到鸡），这个是 Maximazation 。如此往复，直到参数基本不再发生变化为止。这个迭代收敛过程中的贝叶斯方法在第二步，根据数据点求分布的参数上面。</p>
<h3 id="4-5-最大似然与最小二乘"><a href="#4-5-最大似然与最小二乘" class="headerlink" title="4.5 最大似然与最小二乘"></a>4.5 最大似然与最小二乘</h3><blockquote class="pullquote right"><p><img src="/gallery/magical-bayesian/05.png" alt=""></p>
</blockquote>
<p>学过线性代数的大概都知道经典的最小二乘方法来做线性回归。问题描述是：给定平面上 N 个点，（这里不妨假设我们想用一条直线来拟合这些点——<a href="https://en.wikipedia.org/wiki/Regression_analysis" target="_blank" rel="external">回归</a>可以看作是拟合的特例，即允许误差的拟合），找出一条最佳描述了这些点的直线。</p>
<p>一个接踵而来的问题就是，我们如何定义最佳？我们设每个点的坐标为 (Xi, Yi) 。如果直线为 y = f(x) 。那么 (Xi, Yi) 跟直线对这个点的“预测”：(Xi, f(Xi)) 就相差了一个 ΔYi = |Yi – f(Xi)| 。最小二乘就是说寻找直线使得 (ΔY1)^2 + (ΔY2)^2 + .. （即误差的平方和）最小，至于为什么是误差的平方和而不是误差的绝对值和，统计学上也没有什么好的解释。然而贝叶斯方法却能对此提供一个完美的解释。</p>
<p>我们假设直线对于坐标 Xi 给出的预测 f(Xi) 是最靠谱的预测，所有纵坐标偏离 f(Xi) 的那些数据点都含有噪音，是噪音使得它们偏离了完美的一条直线，一个合理的假设就是偏离路线越远的概率越小，具体小多少，可以用一个正态分布曲线来模拟，这个分布曲线以直线对 Xi 给出的预测 f(Xi) 为中心，实际纵坐标为 Yi 的点 (Xi, Yi) 发生的概率就正比于 EXP[-(ΔYi)^2]。（EXP(..) 代表以常数 e 为底的多少次方）。</p>
<p>现在我们回到问题的贝叶斯方面，我们要想最大化的后验概率是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(h|D) ∝ P(h) * P(D|h)</div></pre></td></tr></table></figure>
<p>又见贝叶斯！这里 h 就是指一条特定的直线，D 就是指这 N 个数据点。我们需要寻找一条直线 h 使得 P(h) <em> P(D|h) 最大。很显然，P(h) 这个先验概率是均匀的，因为哪条直线也不比另一条更优越。所以我们只需要看 P(D|h) 这一项，这一项是指这条直线生成这些数据点的概率，刚才说过了，生成数据点 (Xi, Yi) 的概率为 EXP[-(ΔYi)^2] 乘以一个常数。而 P(D|h) = P(d1|h) </em> P(d2|h) <em> .. 即假设各个数据点是独立生成的，所以可以把每个概率乘起来。于是生成 N 个数据点的概率为 EXP[-(ΔY1)^2] </em> EXP[-(ΔY2)^2] <em> EXP[-(ΔY3)^2] </em> .. = EXP{-[(ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + ..]} 最大化这个概率就是要最小化 (ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + .. 。 熟悉这个式子吗？</p>
<h2 id="5-朴素贝叶斯方法"><a href="#5-朴素贝叶斯方法" class="headerlink" title="5. 朴素贝叶斯方法"></a><strong>5. 朴素贝叶斯方法</strong></h2><p>朴素贝叶斯方法是一个很特别的方法，所以值得介绍一下。我们用朴素贝叶斯在垃圾邮件过滤中的应用来举例说明。</p>
<h3 id="5-1-贝叶斯垃圾邮件过滤器"><a href="#5-1-贝叶斯垃圾邮件过滤器" class="headerlink" title="5.1 贝叶斯垃圾邮件过滤器"></a>5.1 贝叶斯垃圾邮件过滤器</h3><p>问题是什么？问题是，给定一封邮件，判定它是否属于垃圾邮件。按照先例，我们还是用 D 来表示这封邮件，注意 D 由 N 个单词组成。我们用 h+ 来表示垃圾邮件，h- 表示正常邮件。问题可以形式化地描述为求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P(h+|D) = P(h+) * P(D|h+) / P(D)</div><div class="line"></div><div class="line">P(h-|D) = P(h-) * P(D|h-) / P(D)</div></pre></td></tr></table></figure>
<p>其中 P(h+) 和 P(h-) 这两个先验概率都是很容易求出来的，只需要计算一个邮件库里面垃圾邮件和正常邮件的比例就行了。然而 P(D|h+) 却不容易求，因为 D 里面含有 N 个单词 d1, d2, d3, .. ，所以P(D|h+) = P(d1,d2,..,dn|h+) 。我们又一次遇到了数据稀疏性，为什么这么说呢？P(d1,d2,..,dn|h+) 就是说在垃圾邮件当中出现跟我们目前这封邮件一模一样的一封邮件的概率是多大！开玩笑，每封邮件都是不同的，世界上有无穷多封邮件。瞧，这就是数据稀疏性，因为可以肯定地说，你收集的训练数据库不管里面含了多少封邮件，也不可能找出一封跟目前这封一模一样的。结果呢？我们又该如何来计算 P(d1,d2,..,dn|h+) 呢？</p>
<p>我们将 P(d1,d2,..,dn|h+)  扩展为： P(d1|h+) <em> P(d2|d1, h+) </em> P(d3|d2,d1, h+) <em> .. 。熟悉这个式子吗？这里我们会使用一个更激进的假设，我们假设 di 与 di-1 是完全条件无关的，于是式子就简化为 P(d1|h+) </em> P(d2|h+) <em> P(d3|h+) </em> .. 。这个就是所谓的<a href="https://en.wikipedia.org/wiki/Conditional_independence" target="_blank" rel="external">条件独立假设</a>，也正是朴素贝叶斯方法的朴素之处。而计算 P(d1|h+) <em> P(d2|h+) </em> P(d3|h+) * .. 就太简单了，只要统计 di 这个单词在垃圾邮件中出现的频率即可。关于贝叶斯垃圾邮件过滤更多的内容可以参考<a href="https://en.wikipedia.org/wiki/Naive_Bayes_spam_filtering" target="_blank" rel="external">这个条目</a>，注意其中提到的其他资料。</p>
<p>一点注记：这里，为什么有这个数据稀疏问题，还是因为统计学习方法工作在浅层面，世界上的单词就算不再变多也是非常之多的，单词之间组成的句子也是变化多端，更不用说一篇文章了，文章数目则是无穷的，所以在这个层面作统计，肯定要被数据稀疏性困扰。我们要注意，虽然句子和文章的数目是无限的，然而就拿邮件来说，如果我们只关心邮件中句子的语义（进而更高抽象层面的“意图”（语义，意图如何可计算地定义出来是一个人工智能问题），在这个层面上可能性便大大缩减了，我们关心的抽象层面越高，可能性越小。单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。神经科学的发现也表明大脑的皮层大致有一种层级结构，对应着越来越抽象的各个层面，至于如何具体实现一个可放在计算机内的大脑皮层，仍然是一个未解决问题，以上只是一个原则（principle）上的认识，只有当 computational 的 cortex 模型被建立起来了之后才可能将其放入电脑。</p>
<h3 id="5-2-为什么朴素贝叶斯方法令人诧异地好——一个理论解释"><a href="#5-2-为什么朴素贝叶斯方法令人诧异地好——一个理论解释" class="headerlink" title="5.2 为什么朴素贝叶斯方法令人诧异地好——一个理论解释"></a>5.2 为什么朴素贝叶斯方法令人诧异地好——一个理论解释</h3><p>朴素贝叶斯方法的条件独立假设看上去很傻很天真，为什么结果却很好很强大呢？就拿一个句子来说，我们怎么能鲁莽地声称其中任意一个单词出现的概率只受到它前面的 3 个或 4 个单词的影响呢？别说 3 个，有时候一个单词的概率受到上一句话的影响都是绝对可能的。那么为什么这个假设在实际中的表现却不比决策树差呢？有人对此提出了一个理论解释，并且建立了什么时候朴素贝叶斯的效果能够等价于非朴素贝叶斯的充要条件，这个解释的核心就是：有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。具体的数学公式请参考这篇 paper（<a href="http://www.cs.unb.ca/~hzhang/publications/FLAIRS04ZhangH.pdf" target="_blank" rel="external">The Optimality of Naive Bayes</a>） 。</p>
<h2 id="6-层级贝叶斯模型"><a href="#6-层级贝叶斯模型" class="headerlink" title="6. 层级贝叶斯模型"></a><strong>6. 层级贝叶斯模型</strong></h2><p><img src="/gallery/magical-bayesian/06.png" alt=""></p>
<p><a href="https://en.wikipedia.org/wiki/Bayesian_network" target="_blank" rel="external"><strong>层级贝叶斯模型</strong></a>是现代贝叶斯方法的标志性建筑之一。前面讲的贝叶斯，都是在同一个事物层次上的各个因素之间进行统计推理，然而层次贝叶斯模型在哲学上更深入了一层，将这些因素背后的因素（原因的原因，原因的原因，以此类推）囊括进来。一个教科书例子是：如果你手头有 N 枚硬币，它们是同一个工厂铸出来的，你把每一枚硬币掷出一个结果，然后基于这 N 个结果对这 N 个硬币的 θ （出现正面的比例）进行推理。如果根据最大似然，每个硬币的 θ 不是 1 就是 0 （这个前面提到过的），然而我们又知道每个硬币的 p(θ) 是有一个先验概率的，也许是一个 beta 分布。也就是说，每个硬币的实际投掷结果 Xi 服从以 θ 为中心的正态分布，而 θ 又服从另一个以 Ψ 为中心的 beta 分布。层层因果关系就体现出来了。进而 Ψ 还可能依赖于因果链上更上层的因素，以此类推。</p>
<h3 id="6-1-隐马可夫模型（HMM）"><a href="#6-1-隐马可夫模型（HMM）" class="headerlink" title="6.1 隐马可夫模型（HMM）"></a>6.1 隐马可夫模型（HMM）</h3><p><img src="/gallery/magical-bayesian/07.png" alt=""></p>
<p>吴军在数学之美系列里面介绍的隐马可夫模型（Hidden Markov model）就是一个简单的层级贝叶斯模型：</p>
<blockquote>
<p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做“隐含马尔可夫模型”（Hidden Markov Model）来解决这些问题。以语音识别为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p>
</blockquote>
<p>吴军的文章中这里省掉没说的是，s1, s2, s3, .. 这个句子的生成概率同时又取决于一组参数，这组参数决定了 s1, s2, s3, .. 这个马可夫链的先验生成概率。如果我们将这组参数记为 λ ，我们实际上要求的是：P(S|O, λ) （其中 O 表示 o1,o2,o3,.. ，S表示 s1,s2,s3,..）</p>
<blockquote>
<p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公式并且省掉一个常数项，可以把上述公式等价变换成</p>
<p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…)</p>
<p>其中</p>
<p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…的可能性, 而<br>P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的可能性，所以这个公式的意义是用发送信号为<br>s1,s2,s3…这个数列的可能性乘以 s1,s2,s3.. 本身可以一个句子的可能性，得出概率。</p>
</blockquote>
<p>这里，s1,s2,s3…本身可以一个句子的可能性其实就取决于参数 λ ，也就是语言模型。所以简而言之就是发出的语音信号取决于背后实际想发出的句子，而背后实际想发出的句子本身的独立先验概率又取决于语言模型。</p>
<h2 id="7-贝叶斯网络"><a href="#7-贝叶斯网络" class="headerlink" title="7. 贝叶斯网络"></a><strong>7. 贝叶斯网络</strong></h2><p>吴军已经对贝叶斯网络作了科普。更详细的理论参考所有机器学习的书上都有。</p>
<hr>
<h2 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a>【参考资料】</h2><p>一堆机器学习，一堆概率统计，一堆 Google ，和一堆 Wikipedia 条目，一堆 paper 。</p>
<p>部分书籍参考<a href="http://blog.csdn.net/pongba/article/details/2915005" target="_blank" rel="external">《机器学习与人工智能资源导引》</a>。</p>
<blockquote><p>本文转载自 <a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" target="_blank" rel="external"><strong>《数学之美番外篇：平凡而又神奇的贝叶斯方法》</strong></a></p>
<footer><strong>刘未鹏</strong><cite><a href="http://mindhacks.cn/" target="_blank" rel="external">mindhacks.cn</a></cite></footer></blockquote>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;pullquote right&quot;&gt;&lt;p&gt;Probability is nothing but common sense reduced to calculation.（概率论只不过是把常识用数学公式表达了出来。）&lt;br&gt; —— &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9A%AE%E5%9F%83%E5%B0%94-%E8%A5%BF%E8%92%99%C2%B7%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF&quot;&gt;Pierre-Simon Laplace&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了 —— 这果然是个牛逼的方法。&lt;/p&gt;
&lt;p&gt;——题记&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Bayesian" scheme="http://github.com/tags/Bayesian/"/>
    
  </entry>
  
  <entry>
    <title>【Android】RxJava 入门详解</title>
    <link href="http://github.com/2016/12/19/%E3%80%90Android%E3%80%91RxJava%20%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://github.com/2016/12/19/【Android】RxJava 入门详解/</id>
    <published>2016-12-19T11:03:00.000Z</published>
    <updated>2016-12-22T03:23:45.927Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文转载自 <a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a> —— by <a href="https://github.com/rengwuxian">扔物线</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>我从去年开始使用 RxJava ，到现在一年多了。今年加入了 Flipboard 后，看到 Flipboard 的 Android 项目也在使用 RxJava ，并且使用的场景越来越多 。而最近这几个月，我也发现国内越来越多的人开始提及 RxJava 。有人说『RxJava 真是太好用了』，有人说『RxJava 真是太难用了』，另外更多的人表示：我真的百度了也谷歌了，但我还是想问： RxJava 到底是什么？</p>
<p>鉴于 RxJava 目前这种既火爆又神秘的现状，而我又在一年的使用过程中对 RxJava 有了一些理解，我决定写下这篇文章来对 RxJava 做一个相对详细的、针对 Android 开发者的介绍。</p>
<p>这篇文章的目的有两个： </p>
<ol>
<li>给对 RxJava 感兴趣的人一些入门的指引 </li>
<li>给正在使用 RxJava 但仍然心存疑惑的人一些更深入的解析</li>
</ol>
<p>在正文开始之前的最后，放上 GitHub 链接和引入依赖的 gradle 代码：<br>RxJava ： <a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a><br>RxAndroid： <a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a> </p>
<p>引入依赖： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="comment">//（版本号是文章发布时的最新稳定版）</span></div><div class="line">compile <span class="string">'io.reactivex:rxjava:1.0.14'</span> </div><div class="line">compile <span class="string">'io.reactivex:rxandroid:1.0.1'</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="RxJava-到底是什么"><a href="#RxJava-到底是什么" class="headerlink" title="RxJava 到底是什么"></a><strong>RxJava 到底是什么</strong></h2><p>一个词：<strong>异步</strong>。</p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p>
<p>然而，对于初学者来说，这太难看懂了。因为它是一个『总结』，而初学者更需要一个『引言』。</p>
<p>其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。</p>
<h2 id="RxJava-好在哪"><a href="#RxJava-好在哪" class="headerlink" title="RxJava 好在哪"></a><strong>RxJava 好在哪</strong></h2><p>换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / … ？』</p>
<p>一个词：<strong>简洁</strong>。</p>
<p>异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 <code>AsyncTask</code> 和<code>Handler</code> ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，<strong>随着程序逻辑变得越来越复杂，它依然能够保持简洁。</strong></p>
<h3 id="举个例子？"><a href="#举个例子？" class="headerlink" title="举个例子？"></a>举个例子？</h3><p>假设有这样一个需求：界面上有一个自定义的视图 <code>imageCollectorView</code> ，它的作用是显示多张图片，并能使用 <code>addImage(Bitmap)</code> 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 <code>File[] folders</code> 中每个目录下的 png 图片都加载出来并显示在 <code>imageCollectorView</code> 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        <span class="keyword">for</span> (File folder : folders) &#123;</div><div class="line">            File[] files = folder.listFiles();</div><div class="line">            <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">".png"</span>)) &#123;</div><div class="line">                    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromFile(file);</div><div class="line">                    getActivity().runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            imageCollectorView.addImage(bitmap);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure>
<p>而如果使用 RxJava ，实现方式是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.from(folders)</div><div class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;File, Observable&lt;File&gt;&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;File&gt; <span class="title">call</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Observable.from(file.listFiles());</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .filter(<span class="keyword">new</span> Func1&lt;File, Boolean&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> file.getName().endsWith(<span class="string">".png"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .map(<span class="keyword">new</span> Func1&lt;File, Bitmap&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> getBitmapFromFile(file);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</div><div class="line">            imageCollectorView.addImage(bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>那位说话了：『你这代码明明变多了啊！简洁个毛啊！』大兄弟你消消气，我说的是逻辑的简洁，不是单纯的代码量少（逻辑简洁才是提升读写代码速度的必杀技对不？）。观察一下你会发现， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显（试想如果还要求只选取前 10 张图片，常规方式要怎么办？如果有更多这样那样的要求呢？再试想，在这一大堆需求实现完两个月之后需要改功能，当你翻回这里看到自己当初写下的那一片迷之缩进，你能保证自己将迅速看懂，而不是对着代码重新捋一遍思路？）。</p>
<p>另外，如果你的 IDE 是 Android Studio ，其实每次打开某个 Java 文件的时候，你会看到被自动 Lambda 化的预览，这将让你更加清晰地看到程序逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.from(folders)</div><div class="line">    .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;)</div><div class="line">    .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(<span class="string">".png"</span>) &#125;)</div><div class="line">    .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;)</div><div class="line">    .subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>如果你习惯使用 Retrolambda ，你也可以直接把代码写成上面这种简洁的形式。而如果你看到这里还不知道什么是 Retrolambda ，我不建议你现在就去学习它。原因有两点：1. Lambda 是把双刃剑，它让你的代码简洁的同时，降低了代码的可读性，因此同时学习 RxJava 和 Retrolambda 可能会让你忽略 RxJava 的一些技术细节；2. Retrolambda 是 Java 6/7 对 Lambda 表达式的非官方兼容方案，它的向后兼容性和稳定性是无法保障的，因此对于企业项目，使用 Retrolambda 是有风险的。所以，与很多 RxJava 的推广者不同，我并不推荐在学习 RxJava 的同时一起学习 Retrolambda。事实上，我个人虽然很欣赏 Retrolambda，但我从来不用它。</p>
</blockquote>
<p>在Flipboard 的 Android 代码中，有一段逻辑非常复杂，包含了多次内存操作、本地文件操作和网络操作，对象分分合合，线程间相互配合相互等待，一会儿排成人字，一会儿排成一字。如果使用常规的方法来实现，肯定是要写得欲仙欲死，然而在使用 RxJava 的情况下，依然只是一条链式调用就完成了。它很长，但很清晰。</p>
<p>所以， RxJava 好在哪？就好在简洁，好在那把什么复杂逻辑都能穿成一条线的简洁。</p>
<h2 id="API-介绍和原理简析"><a href="#API-介绍和原理简析" class="headerlink" title="API 介绍和原理简析"></a><strong>API 介绍和原理简析</strong></h2><p>这个我就做不到一个词说明了……因为这一节的主要内容就是一步步地说明 RxJava 到底怎样做到了异步，怎样做到了简洁。</p>
<h3 id="1-概念：扩展的观察者模式"><a href="#1-概念：扩展的观察者模式" class="headerlink" title="1. 概念：扩展的观察者模式"></a>1. 概念：扩展的观察者模式</h3><p>RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>先简述一下观察者模式，已经熟悉的可以跳过这一段。</p>
<p>观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用<strong>注册(Register)</strong>或者称为<strong>订阅(Subscribe)</strong>的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 <strong>OnClickListener</strong> 。对设置 <strong>OnClickListener</strong> 来说， View 是被观察者， <strong>OnClickListener</strong> 是观察者，二者通过 <strong>setOnClickListener()</strong> 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 <strong>OnClickListener</strong> 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷：<strong>『你在作案的时候务必通知我』</strong>。</p>
<p>OnClickListener 的模式大致如下图：</p>
<p><img src="/gallery/RxJava/01.jpg" alt=""></p>
<p>如图所示，通过 <code>setOnClickListener()</code> 方法，Button 持有 <code>OnClickListener</code> 的引用（这一过程没有在图上画出）；当用户点击时，Button 自动调用 OnClickListener 的 <code>onClick()</code> 方法。另外，如果把这张图中的概念抽象出来（<strong>Button -&gt; 被观察者、OnClickListener -&gt; 观察者、setOnClickListener() -&gt; 订阅，onClick() -&gt; 事件</strong>），就由专用的观察者模式（例如只用于监听控件点击）转变成了通用的观察者模式。如下图：</p>
<p><img src="/gallery/RxJava/02.jpg" alt=""></p>
<p>而 RxJava 作为一个工具库，使用的就是通用形式的观察者模式。</p>
<h4 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h4><p>RxJava 有四个基本概念：</p>
<ul>
<li><strong>Observable</strong> (可观察者，即被观察者)</li>
<li><strong>Observer</strong> (观察者)</li>
<li><strong>subscribe</strong> (订阅)</li>
<li><strong>Event</strong> (事件)</li>
</ul>
<p>Observable 和 Observer 通过 <code>subscribe()</code> 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 <code>onNext()</code> （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：<code>onCompleted()</code> 和 <code>onError()</code>。</p>
<ul>
<li><p><strong>onCompleted()</strong>: 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。</p>
</li>
<li><p><strong>onError()</strong>: 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。</p>
</li>
<li><p>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
</li>
</ul>
<p>RxJava 的观察者模式大致如下图：</p>
<p><img src="/gallery/RxJava/03.jpg" alt=""></p>
<h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2. 基本实现"></a>2. 基本实现</h3><p>基于以上的概念， RxJava 的基本实现主要有三点：</p>
<h4 id="1-创建-Observer"><a href="#1-创建-Observer" class="headerlink" title="1) 创建 Observer"></a>1) 创建 Observer</h4><p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"Item: "</span> + s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"Completed!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"Error!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：<code>Subscriber</code>。 <code>Subscriber</code> 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"Item: "</span> + s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"Completed!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"Error!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 <code>Subscriber</code> 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点：</p>
<ol>
<li><p><strong><code>onStart()</code>:</strong> 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， <code>onStart()</code> 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 <code>doOnSubscribe()</code> 方法，具体可以在后面的文中看到。</p>
</li>
<li><p><strong><code>unsubscribe()</code>:</strong> 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 <code>isUnsubscribed()</code> 先判断一下状态。 <code>unsubscribe()</code> 这个方法很重要，因为在 <code>subscribe()</code> 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 <code>onPause()</code> <code>onStop()</code> 等方法中）调用 <code>unsubscribe()</code> 来解除引用关系，以避免内存泄露的发生。</p>
</li>
</ol>
<h4 id="2-创建-Observable"><a href="#2-创建-Observable" class="headerlink" title="2) 创建 Observable"></a>2) 创建 Observable</h4><p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 <strong>create()</strong> 方法来创建一个 Observable ，并为它定义事件触发规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"Hi"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"Aloha"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，这里传入了一个 <code>OnSubscribe</code> 对象作为参数。<code>OnSubscribe</code> 会被存储在返回的 <code>Observable</code> 对象中，它的作用相当于一个计划表，当 <code>Observable</code> 被订阅的时候，<code>OnSubscribe</code> 的 <code>call()</code> 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者<code>Subscriber</code> 将会被调用三次 <code>onNext()</code> 和一次 <code>onCompleted()</code>）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>
<blockquote>
<p>这个例子很简单：事件的内容是字符串，而不是一些复杂的对象；事件的内容是已经定好了的，而不像有的观察者模式一样是待确定的（例如网络请求的结果在请求返回之前是未知的）；所有事件在一瞬间被全部发送出去，而不是夹杂一些确定或不确定的时间间隔或者经过某种触发器来触发的。总之，这个例子看起来毫无实用价值。但这是为了便于说明，实质上只要你想，各种各样的事件发送规则你都可以自己来写。至于具体怎么做，后面都会讲到，但现在不行。只有把基础原理先说明白了，上层的运用才能更容易说清楚。</p>
</blockquote>
<p><code>create()</code> 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如：</p>
<ul>
<li><strong><code>just(T...)</code></strong> :  将传入的参数依次发送出来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</div><div class="line"><span class="comment">// 将会依次调用：</span></div><div class="line"><span class="comment">// onNext("Hello");</span></div><div class="line"><span class="comment">// onNext("Hi");</span></div><div class="line"><span class="comment">// onNext("Aloha");</span></div><div class="line"><span class="comment">// onCompleted();</span></div></pre></td></tr></table></figure>
<ul>
<li><strong><code>from(T[])</code></strong> / <strong><code>from(Iterable&lt;? extends T&gt;)</code></strong> : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</div><div class="line">Observable observable = Observable.from(words);</div><div class="line"><span class="comment">// 将会依次调用：</span></div><div class="line"><span class="comment">// onNext("Hello");</span></div><div class="line"><span class="comment">// onNext("Hi");</span></div><div class="line"><span class="comment">// onNext("Aloha");</span></div><div class="line"><span class="comment">// onCompleted();</span></div></pre></td></tr></table></figure>
<p>上面 <code>just(T...)</code> 的例子和 <code>from(T[])</code> 的例子，都和之前的 <code>create(OnSubscribe)</code> 的例子是等价的。</p>
<h4 id="3-Subscribe-订阅"><a href="#3-Subscribe-订阅" class="headerlink" title="3) Subscribe (订阅)"></a>3) Subscribe (订阅)</h4><p>创建了 Observable 和 Observer 之后，再用 <code>subscribe()</code> 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">observable.subscribe(observer);</div><div class="line"><span class="comment">// 或者：</span></div><div class="line">observable.subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>有人可能会注意到， <code>subscribe()</code> 这个方法有点怪：它看起来是『<code>observalbe</code> 订阅了 <code>observer</code> / <code>subscriber</code>』而不是『<code>observer</code> / <code>subscriber</code> 订阅了 <code>observalbe</code>』，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成 <code>observer.subscribe(observable)</code> / <code>subscriber.subscribe(observable)</code> ，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。</p>
<p><code>Observable.subscribe(Subscriber)</code> 的内部实现是这样的（仅核心代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></div><div class="line"><span class="comment">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span></div><div class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</div><div class="line">    subscriber.onStart();</div><div class="line">    onSubscribe.call(subscriber);</div><div class="line">    <span class="keyword">return</span> subscriber;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>subscriber()</code> 做了3件事：</p>
<ol>
<li><p>调用 <code>Subscriber.onStart()</code> 。这个方法在前面已经介绍过，是一个可选的准备方法。</p>
</li>
<li><p>调用 Observable 中的 <code>OnSubscribe.call(Subscriber)</code> 。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 <code>subscribe()</code> 方法执行的时候。</p>
</li>
<li><p>将传入的 Subscriber 作为 Subscription 返回。这是为了方便 <code>unsubscribe()</code>.</p>
</li>
</ol>
<p>整个过程中对象间的关系如下图：</p>
<p><img src="/gallery/RxJava/04.gif" alt=""></p>
<p>除了 <code>subscribe(Observer)</code> 和 <code>subscribe(Subscriber)</code> ，<code>subscribe()</code> 还支持不完整定义的回调，RxJava 会自动根据定义创建出 <code>Subscriber</code> 。形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="comment">// onNext()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.d(tag, s);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">    <span class="comment">// onError()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0() &#123;</div><div class="line">    <span class="comment">// onCompleted()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"completed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></div><div class="line">observable.subscribe(onNextAction);</div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></div><div class="line">observable.subscribe(onNextAction, onErrorAction);</div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></div><div class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</div></pre></td></tr></table></figure>
<p>简单解释一下这段代码中出现的 <code>Action1</code> 和 <code>Action0</code>。 <code>Action0</code> 是 RxJava 的一个接口，它只有一个方法 <code>call()</code>，这个方法是无参无返回值的；由于 <code>onCompleted()</code> 方法也是无参无返回值的，因此 <code>Action0</code> 可以被当成一个包装对象，将 <code>onCompleted()</code> 的内容打包起来将自己作为一个参数传入 <code>subscribe()</code> 以实现不完整定义的回调。这样其实也可以看做将 <code>onCompleted()</code> 方法作为参数传进了 <code>subscribe()</code>，相当于其他某些语言中的『闭包』。 <code>Action1</code> 也是一个接口，它同样只有一个方法 <code>call(T param)</code>，这个方法也无返回值，但有一个参数；与 <code>Action0</code> 同理，由于 <code>onNext(T obj)</code> 和 <code>onError(Throwable error)</code> 也是单参数无返回值的，因此 <code>Action1</code> 可以将 <code>onNext(obj)</code> 和 <code>onError(error)</code> 打包起来传入 <code>subscribe()</code> 以实现不完整定义的回调。事实上，虽然 <code>Action0</code> 和 <code>Action1</code> 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。</p>
<blockquote>
<p>注：正如前面所提到的，<code>Observer</code> 和 <code>Subscriber</code> 具有相同的角色，而且 <code>Observer</code> 在 <code>subscribe()</code> 过程中最终会被转换成 <code>Subscriber</code> 对象，因此，从这里开始，后面的描述我将用 <code>Subscriber</code> 来代替 <code>Observer</code> ，这样更加严谨。</p>
</blockquote>
<h4 id="4-场景示例"><a href="#4-场景示例" class="headerlink" title="4) 场景示例"></a>4) 场景示例</h4><p>下面举两个例子：</p>
<blockquote>
<p>为了把原理用更清晰的方式表述出来，本文中挑选的都是功能尽可能简单的例子，以至于有些示例代码看起来会有『画蛇添足』『明明不用 RxJava 可以更简便地解决问题』的感觉。当你看到这种情况，不要觉得是因为 RxJava 太啰嗦，而是<strong>因为在过早的时候举出真实场景的例子并不利于原理的解析，因此我刻意挑选了简单的情景。</strong></p>
</blockquote>
<p>a. 打印字符串数组</p>
<p>将字符串数组 names 中的所有字符串依次打印出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String[] names = ...;</div><div class="line">Observable.from(names)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            Log.d(tag, name);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>b. 由 id 取得图片并显示</p>
<p>由指定的一个 drawable 文件 id <code>drawableRes</code> 取得图片，并显示在 <code>ImageView</code> 中，并在出现异常的时候打印 Toast 报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> drawableRes = ...;</div><div class="line">ImageView imageView = ...;</div><div class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</div><div class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</div><div class="line">        subscriber.onNext(drawable);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</div><div class="line">        imageView.setImageDrawable(drawable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>正如上面两个例子这样，创建出 <code>Observable</code> 和 <code>Subscriber</code> ，再用 <code>subscribe()</code> 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。</p>
<p>然而，</p>
<p><img src="/gallery/RxJava/05.jpg" alt=""></p>
<p>在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： <code>Scheduler</code> 。</p>
<h3 id="3-线程控制-——-Scheduler-一"><a href="#3-线程控制-——-Scheduler-一" class="headerlink" title="3. 线程控制 —— Scheduler (一)"></a>3. 线程控制 —— Scheduler (一)</h3><p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 <code>subscribe()</code>，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 <code>Scheduler</code> （调度器）。</p>
<h4 id="1-Scheduler-的-API-一"><a href="#1-Scheduler-的-API-一" class="headerlink" title="1) Scheduler 的 API (一)"></a>1) Scheduler 的 API (一)</h4><p>在RxJava 中，<code>Scheduler</code> ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 <code>Scheduler</code> ，它们已经适合大多数的使用场景：</p>
<ul>
<li><p><strong>Schedulers.immediate()</strong>: 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>
</li>
<li><p><strong>Schedulers.newThread()</strong>: 总是启用新线程，并在新线程执行操作。</p>
</li>
<li><p><strong>Schedulers.io()</strong>: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>
</li>
<li><p><strong>Schedulers.computation()</strong>: 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>
</li>
<li><p>另外， Android 还有一个专用的 <strong><code>AndroidSchedulers.mainThread()</code></strong>，它指定的操作将在 Android 主线程运行。</p>
</li>
</ul>
<p>有了这几个 Scheduler ，就可以使用 <code>subscribeOn()</code> 和 <code>observeOn()</code> 两个方法来对线程进行控制了。 <strong><em>subscribeOn()</em></strong>: 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 <strong><em>observeOn()</em></strong>: 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</p>
<p>文字叙述总归难理解，上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</div><div class="line">            Log.d(tag, <span class="string">"number:"</span> + number);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>上面这段代码中，由于 <code>subscribeOn(Schedulers.io())</code> 的指定，被创建的事件的内容 1、2、3、4 将会在 <strong>IO线程</strong> 发出；而由于 <code>observeOn(AndroidScheculers.mainThread())</code> 的指定，因此 subscriber 数字的打印将发生在<strong>主线程</strong> 。事实上，这种在 subscribe() 之前写上两句 <code>subscribeOn(Scheduler.io())</code> 和 <code>observeOn(AndroidSchedulers.mainThread())</code> 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。</p>
<p>而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> drawableRes = ...;</div><div class="line">ImageView imageView = ...;</div><div class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</div><div class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</div><div class="line">        subscriber.onNext(drawable);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">.subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></div><div class="line">.observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></div><div class="line">.subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</div><div class="line">        imageView.setImageDrawable(drawable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p>
<h4 id="2-Scheduler-的原理-一"><a href="#2-Scheduler-的原理-一" class="headerlink" title="2) Scheduler 的原理 (一)"></a>2) Scheduler 的原理 (一)</h4><p>RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 <code>subscribe()</code> 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。</p>
<p>好吧这一节其实我屁也没说，只是为了让你安心，让你知道我不是忘了讲原理，而是把它放在了更合适的地方。</p>
<h3 id="4-变换"><a href="#4-变换" class="headerlink" title="4. 变换"></a>4. 变换</h3><p>终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。</p>
<p>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。<strong>所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</strong>概念说着总是模糊难懂的，来看 API。</p>
<h4 id="1-API"><a href="#1-API" class="headerlink" title="1) API"></a>1) API</h4><p>首先看一个 <code>map()</code> 的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just(<span class="string">"images/logo.png"</span>) <span class="comment">// 输入类型 String</span></div><div class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filePath)</span> </span>&#123; <span class="comment">// 参数类型 String</span></div><div class="line">            <span class="keyword">return</span> getBitmapFromPath(filePath); <span class="comment">// 返回类型 Bitmap</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123; <span class="comment">// 参数类型 Bitmap</span></div><div class="line">            showBitmap(bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>这里出现了一个叫做 <code>Func1</code> 的类。它和 <code>Action1</code> 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。</p>
<p>可以看到，<code>map()</code> 方法将参数中的 <code>String</code> 对象转换成一个 <code>Bitmap</code> 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换：</p>
<ul>
<li><strong>map()</strong>: 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 map() 的示意图：</li>
</ul>
<p><img src="/gallery/RxJava/06.jpg" alt=""></p>
<ul>
<li><strong>flatMap()</strong>: 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Student[] students = ...;</div><div class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        Log.d(tag, name);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line">Observable.from(students)</div><div class="line">    .map(<span class="keyword">new</span> Func1&lt;Student, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> student.getName();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Student[] students = ...;</div><div class="line">Subscriber&lt;Student&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Student&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">        List&lt;Course&gt; courses = student.getCourses();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; courses.size(); i++) &#123;</div><div class="line">            Course course = courses.get(i);</div><div class="line">            Log.d(tag, course.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line">Observable.from(students)</div><div class="line">    .subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 <code>Course</code> 对象呢（这对于代码复用很重要）？用 <code>map()</code> 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 <code>Student</code> 转化成多个 <code>Course</code> 呢？</p>
<p>这个时候，就需要用 <code>flatMap()</code> 了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Student[] students = ...;</div><div class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Course&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span> </span>&#123;</div><div class="line">        Log.d(tag, course.getName());</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line">Observable.from(students)</div><div class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Observable.from(student.getCourses());</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出， <code>flatMap()</code> 和 <code>map()</code> 有一个相同点：<strong>它也是把传入的参数转化之后返回另一个对象</strong>。但需要注意，和 <code>map()</code> 不同的是， <code>flatMap()</code> 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 <code>flatMap()</code> 的原理是这样的：</p>
<ol>
<li>使用传入的事件对象创建一个 Observable 对象；</li>
<li>并不发送这个 Observable, 而是将它激活，于是它开始发送事件；</li>
<li>每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。</li>
</ol>
<p>这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。</p>
<p>flatMap() 示意图：</p>
<p><img src="/gallery/RxJava/07.jpg" alt=""></p>
<p>扩展：由于可以在嵌套的 Observable 中添加异步代码， <code>flatMap()</code> 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">networkClient.token() <span class="comment">// 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token</span></div><div class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;Messages&gt;&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;Messages&gt; <span class="title">call</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">            <span class="comment">// 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表</span></div><div class="line">            <span class="keyword">return</span> networkClient.messages();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Messages&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Messages messages)</span> </span>&#123;</div><div class="line">            <span class="comment">// 处理显示消息列表</span></div><div class="line">            showMessages(messages);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 <code>flatMap()</code> ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。</p>
<ul>
<li><strong>throttleFirst()</strong> :  在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器： </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RxView.clickEvents(button)      // RxBinding 代码，后面的文章有解释</div><div class="line"> .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>妈妈再也不怕我的用户手抖点开两个重复的界面啦。</p>
<p>此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。</p>
<h4 id="2-变换的原理：lift"><a href="#2-变换的原理：lift" class="headerlink" title="2) 变换的原理：lift()"></a>2) 变换的原理：lift()</h4><p>这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： <strong><code>lift(Operator)</code></strong>。首先看一下 lift() 的内部实现（仅核心代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></div><div class="line"><span class="comment">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span></div><div class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;R&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</div><div class="line">            Subscriber newSubscriber = operator.call(subscriber);</div><div class="line">            newSubscriber.onStart();</div><div class="line">            onSubscribe.call(newSubscriber);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 <code>call()</code> 中的实现竟然看起来和前面讲过的 <code>Observable.subscribe()</code> 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 <code>onSubscribe.call(subscriber)</code> 中的 <strong>onSubscribe 所指代的对象不同</strong>（高能预警：接下来的几句话可能会导致身体的严重不适）——</p>
<ul>
<li><p><code>subscribe()</code> 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。</p>
</li>
<li><p>当含有 <code>lift()</code> 时： </p>
<ol>
<li><code>lift()</code> 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； </li>
<li>而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe； </li>
<li>当用户调用经过 <code>lift()</code> 后的 Observable 的 <code>subscribe()</code> 的时候，使用的是 <code>lift()</code> 所返回的新的 Observable ，于是它所触发的 <code>onSubscribe.call(subscriber)</code>，也是用的新 Observable 中的新 OnSubscribe，即在 <code>lift()</code> 中生成的那个 OnSubscribe； </li>
<li>而这个新 OnSubscribe 的 <code>call()</code> 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 <code>call()</code> 方法里，新 OnSubscribe 利用 <code>operator.call(subscriber)</code> 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 <code>call()</code> 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。<br>这样就实现了 <code>lift()</code> 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。</li>
</ol>
</li>
</ul>
<p>精简掉细节的话，也可以这么说：在 Observable 执行了 <code>lift(Operator)</code> 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。</p>
<p>如果你更喜欢具象思维，可以看图：</p>
<p><img src="/gallery/RxJava/08.jpg" alt=""></p>
<p>或者可以看动图：</p>
<p><img src="/gallery/RxJava/09.gif" alt=""></p>
<p>两次和多次的 <code>lift()</code> 同理，如下图：</p>
<p><img src="/gallery/RxJava/10.jpg" alt=""></p>
<p>举一个具体的 <code>Operator</code> 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">observable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</div><div class="line">        <span class="comment">// 将事件序列中的 Integer 对象转换为 String 对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                subscriber.onNext(<span class="string">""</span> + integer);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                subscriber.onError(e);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>讲述 <code>lift()</code> 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 <code>lift()</code> 的原理，RxJava 都不建议开发者自定义 <code>Operator</code> 来直接使用 <code>lift()</code>，而是建议尽量使用已有的 <code>lift()</code> 包装方法（如 <code>map()</code> <code>flatMap()</code> 等）进行组合来实现需求，因为<strong>直接使用 <code>lift()</code> 非常容易发生一些难以发现的错误</strong>。</p>
</blockquote>
<h4 id="3-compose-对-Observable-整体的变换"><a href="#3-compose-对-Observable-整体的变换" class="headerlink" title="3) compose: 对 Observable 整体的变换"></a>3) compose: 对 Observable 整体的变换</h4><p>除了 <code>lift()</code> 之外， Observable 还有一个变换方法叫做 <code>compose(Transformer)</code>。它和 <code>lift()</code> 的区别在于， <code>lift()</code> 是针对事件项和事件序列的，而 <code>compose()</code> 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 <code>lift()</code> 变换。你可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">observable1</div><div class="line">    .lift1()</div><div class="line">    .lift2()</div><div class="line">    .lift3()</div><div class="line">    .lift4()</div><div class="line">    .subscribe(subscriber1);</div><div class="line">observable2</div><div class="line">    .lift1()</div><div class="line">    .lift2()</div><div class="line">    .lift3()</div><div class="line">    .lift4()</div><div class="line">    .subscribe(subscriber2);</div><div class="line">observable3</div><div class="line">    .lift1()</div><div class="line">    .lift2()</div><div class="line">    .lift3()</div><div class="line">    .lift4()</div><div class="line">    .subscribe(subscriber3);</div><div class="line">observable4</div><div class="line">    .lift1()</div><div class="line">    .lift2()</div><div class="line">    .lift3()</div><div class="line">    .lift4()</div><div class="line">    .subscribe(subscriber1);</div></pre></td></tr></table></figure>
<p>你觉得这样太不软件工程了，于是你改成了这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Observable <span class="title">liftAll</span><span class="params">(Observable observable)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> observable</div><div class="line">        .lift1()</div><div class="line">        .lift2()</div><div class="line">        .lift3()</div><div class="line">        .lift4();</div><div class="line">&#125;</div><div class="line">...</div><div class="line">liftAll(observable1).subscribe(subscriber1);</div><div class="line">liftAll(observable2).subscribe(subscriber2);</div><div class="line">liftAll(observable3).subscribe(subscriber3);</div><div class="line">liftAll(observable4).subscribe(subscriber4);</div></pre></td></tr></table></figure>
<p>可读性、可维护性都提高了。可是 Observable 被一个方法包起来，这种方式对于 Observale 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 <code>compose()</code> 来解决了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> observable</div><div class="line">            .lift1()</div><div class="line">            .lift2()</div><div class="line">            .lift3()</div><div class="line">            .lift4();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">Transformer liftAll = <span class="keyword">new</span> LiftAllTransformer();</div><div class="line">observable1.compose(liftAll).subscribe(subscriber1);</div><div class="line">observable2.compose(liftAll).subscribe(subscriber2);</div><div class="line">observable3.compose(liftAll).subscribe(subscriber3);</div><div class="line">observable4.compose(liftAll).subscribe(subscriber4);</div></pre></td></tr></table></figure>
<p>像上面这样，使用 <code>compose()</code> 方法，Observable 可以利用传入的 <code>Transformer</code> 对象的 <code>call()</code> 方法直接对自身进行处理，也就不必被包在方法的里面了。</p>
<p><code>compose()</code> 的原理比较简单，不附图喽。</p>
<h3 id="5-线程控制：Scheduler-二"><a href="#5-线程控制：Scheduler-二" class="headerlink" title="5. 线程控制：Scheduler (二)"></a>5. 线程控制：Scheduler (二)</h3><p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p>
<h4 id="1-Scheduler-的-API-二"><a href="#1-Scheduler-的-API-二" class="headerlink" title="1) Scheduler 的 API (二)"></a>1) Scheduler 的 API (二)</h4><p>前面讲到了，可以利用 <code>subscribeOn()</code> 结合 <code>observeOn()</code> 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 <code>map()</code>、 <code>flatMap()</code> 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</p>
<p>答案是：<strong>能</strong>。因为 <code>observeOn()</code> 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）<code>subscribe()</code> 参数中的 Subscriber ，而是 <code>observeOn()</code> 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，<code>observeOn()</code> 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 <code>observeOn()</code> 即可。上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></div><div class="line">    .subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(Schedulers.newThread())</div><div class="line">    .map(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></div><div class="line">    .observeOn(Schedulers.io())</div><div class="line">    .map(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread) </div><div class="line">    .subscribe(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></div></pre></td></tr></table></figure>
<p>如上，通过 <code>observeOn()</code> 的多次调用，程序实现了线程的多次切换。</p>
<p>不过，不同于 <code>observeOn()</code> ， <code>subscribeOn()</code> 的位置放在哪里都可以，但它是只能调用一次的。</p>
<p>又有好事的（其实还是当初的我）问了：<strong>如果我非要调用多次 <code>subscribeOn()</code> 呢？会有什么效果？</strong></p>
<p>这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。</p>
<h4 id="2-Scheduler-的原理（二）"><a href="#2-Scheduler-的原理（二）" class="headerlink" title="2) Scheduler 的原理（二）"></a>2) Scheduler 的原理（二）</h4><p>其实， <code>subscribeOn()</code> 和 <code>observeOn()</code> 的内部实现，也是用的 <code>lift()</code>。具体看图（不同颜色的箭头表示不同的线程）：</p>
<p>subscribeOn() 原理图：</p>
<p><img src="/gallery/RxJava/11.jpg" alt=""></p>
<p>observeOn() 原理图：</p>
<p><img src="/gallery/RxJava/12.jpg" alt=""></p>
<p>从图中可以看出，<code>subscribeOn()</code> 和 <code>observeOn()</code> 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， <code>subscribeOn()</code> 的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 <code>observeOn()</code> 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。</p>
<p>最后，我用一张图来解释当多个 <code>subscribeOn()</code> 和 <code>observeOn()</code> 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）：</p>
<p><img src="/gallery/RxJava/13.jpg" alt=""></p>
<p>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 <code>subscribeOn()</code> 影响，运行在红色线程；③和④处受第一个 <code>observeOn()</code> 的影响，运行在绿色线程；⑤处受第二个 <code>onserveOn()</code> 影响，运行在紫色线程；而第二个 <code>subscribeOn()</code> ，由于在通知过程中线程就被第一个 <code>subscribeOn()</code> 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 <code>subscribeOn()</code> 的时候，只有第一个 <code>subscribeOn()</code> 起作用。</p>
<h4 id="3-延伸：doOnSubscribe"><a href="#3-延伸：doOnSubscribe" class="headerlink" title="3) 延伸：doOnSubscribe()"></a>3) 延伸：doOnSubscribe()</h4><p>然而，虽然超过一个的 <code>subscribeOn()</code> 对事件处理的流程没有影响，但在流程之前却是可以利用的。</p>
<p>在前面讲 Subscriber 的时候，提到过 Subscriber 的 <code>onStart()</code> 可以用作流程开始前的初始化。然而 <code>onStart()</code> 由于在 <code>subscribe()</code> 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。</p>
<p>而与 <code>Subscriber.onStart()</code> 相对应的，有一个方法 <code>Observable.doOnSubscribe()</code> 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.create(onSubscribe)</div><div class="line">    .subscribeOn(Schedulers.io())</div><div class="line">    .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">            progressBar.setVisibility(View.VISIBLE); <span class="comment">// 需要在主线程执行</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定主线程</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>如上，在 <code>doOnSubscribe()</code>的后面跟一个 <code>subscribeOn()</code> ，就能指定准备工作的线程了。</p>
<h2 id="RxJava-的适用场景和使用方式"><a href="#RxJava-的适用场景和使用方式" class="headerlink" title="RxJava 的适用场景和使用方式"></a><strong>RxJava 的适用场景和使用方式</strong></h2><h3 id="1-与-Retrofit-的结合"><a href="#1-与-Retrofit-的结合" class="headerlink" title="1. 与 Retrofit 的结合"></a>1. 与 Retrofit 的结合</h3><blockquote>
<p>Retrofit 是 Square 的一个著名的网络请求库。没有用过 Retrofit 的可以选择跳过这一小节也没关系，我举的每种场景都只是个例子，而且例子之间并无前后关联，只是个抛砖引玉的作用，所以你跳过这里看别的场景也可以的。</p>
</blockquote>
<p>Retrofit 除了提供了传统的 <code>Callback</code> 形式的 API，还有 RxJava 版本的 Observable 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。</p>
<p>以获取一个 <code>User</code> 对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"/user"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">(@Query(<span class="string">"userId"</span>)</span> String userId, Callback&lt;User&gt; callback)</span>;</div></pre></td></tr></table></figure>
<p>在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">getUser(userId, <span class="keyword">new</span> Callback&lt;User&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        userView.setUser(user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而使用 RxJava 形式的 API，定义同样的请求是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"/user"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">getUser</span><span class="params">(@Query(<span class="string">"userId"</span>)</span> String userId)</span>;</div></pre></td></tr></table></figure>
<p>使用的时候是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">getUser(userId)</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;User&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">            userView.setUser(user);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</div><div class="line">            <span class="comment">// Error handling</span></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>看到区别了吗？</p>
<p>当 RxJava 形式的时候，Retrofit 把请求封装进 <code>Observable</code> ，在请求结束后调用 <code>onNext()</code> 或在请求失败后调用 <code>onError()</code>。</p>
<p>对比来看， <code>Callback</code> 形式和 <code>Observable</code> 形式长得不太一样，但本质都差不多，而且在细节上 <code>Observable</code> 形式似乎还比 <code>Callback</code> 形式要差点。那 Retrofit 为什么还要提供 RxJava 的支持呢？</p>
<p>因为它好用啊！从这个例子看不出来是因为这只是最简单的情况。而一旦情景复杂起来， <code>Callback</code> 形式马上就会开始让人头疼。比如：</p>
<p>假设这么一种情况：你的程序取到的 <code>User</code> 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 <code>Callback</code> 方式大概可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">getUser(userId, <span class="keyword">new</span> Callback&lt;User&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        processUser(user); <span class="comment">// 尝试修正 User 数据</span></div><div class="line">        userView.setUser(user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>有问题吗？</p>
<p>很简便，但不要这样做。为什么？因为这样做会影响性能。数据库的操作很重，一次读写操作花费 10~20ms 是很常见的，这样的耗时很容易造成界面的卡顿。所以通常情况下，如果可以的话一定要避免在主线程中处理数据库。所以为了提升性能，这段代码可以优化一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">getUser(userId, <span class="keyword">new</span> Callback&lt;User&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                processUser(user); <span class="comment">// 尝试修正 User 数据</span></div><div class="line">                runOnUiThread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 切回 UI 线程</span></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        userView.setUser(user);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>性能问题解决，但……这代码实在是太乱了，迷之缩进啊！杂乱的代码往往不仅仅是美观问题，因为代码越乱往往就越难读懂，而如果项目中充斥着杂乱的代码，无疑会降低代码的可读性，造成团队开发效率的降低和出错率的升高。</p>
<p>这时候，如果用 RxJava 的形式，就好办多了。 RxJava 形式的代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">getUser(userId)</div><div class="line">    .doOnNext(<span class="keyword">new</span> Action1&lt;User&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">            processUser(user);</div><div class="line">        &#125;)</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;User&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">            userView.setUser(user);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</div><div class="line">            <span class="comment">// Error handling</span></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>后台代码和前台代码全都写在一条链中，明显清晰了很多。</p>
<p>再举一个例子：假设 <code>/user</code> 接口并不能直接访问，而需要填入一个在线获取的 <code>token</code> ，代码应该怎么写？</p>
<p><code>Callback</code> 方式，可以使用嵌套的 <code>Callback</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"/token"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getToken</span><span class="params">(Callback&lt;String&gt; callback)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">@GET</span>(<span class="string">"/user"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">(@Query(<span class="string">"token"</span>)</span> String token, @<span class="title">Query</span><span class="params">(<span class="string">"userId"</span>)</span> String userId, Callback&lt;User&gt; callback)</span>;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">getToken(<span class="keyword">new</span> Callback&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">        getUser(token, userId, <span class="keyword">new</span> Callback&lt;User&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">                userView.setUser(user);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</div><div class="line">                <span class="comment">// Error handling</span></div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。</p>
<p>而使用 RxJava 的话，代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"/token"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">getToken</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="meta">@GET</span>(<span class="string">"/user"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">getUser</span><span class="params">(@Query(<span class="string">"token"</span>)</span> String token, @<span class="title">Query</span><span class="params">(<span class="string">"userId"</span>)</span> String userId)</span>;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">getToken()</div><div class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;User&gt;&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">onNext</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> getUser(token, userId);</div><div class="line">        &#125;)</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;User&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">            userView.setUser(user);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</div><div class="line">            <span class="comment">// Error handling</span></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>用一个 <code>flatMap()</code> 就搞定了逻辑，依然是一条链。看着就很爽，是吧？</p>
<p>2016/03/31 更新，加上我写的一个 Sample 项目： <a href="https://github.com/rengwuxian/RxJavaSamples"><strong>rengwuxian RxJava Samples</strong></a></p>
<p>好，Retrofit 部分就到这里。</p>
<h3 id="2-RxBinding"><a href="#2-RxBinding" class="headerlink" title="2. RxBinding"></a>2. RxBinding</h3><p><a href="https://github.com/JakeWharton/RxBinding"><strong>RxBinding</strong></a> 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 <code>OnClickListener</code> 、设置 <code>TextWatcher</code> 这样的注册绑定对象的 API。</p>
<p>举个设置点击监听的例子。使用 <code>RxBinding</code> ，可以把事件监听用这样的方法来设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Button button = ...;</div><div class="line">RxView.clickEvents(button) <span class="comment">// 以 Observable 形式来反馈点击事件</span></div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;ViewClickEvent&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(ViewClickEvent event)</span> </span>&#123;</div><div class="line">            <span class="comment">// Click handling</span></div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 <code>setOnClickListener()</code> 来实现的。然而，仅仅这一个形式的改变，却恰好就是 RxBinding 的目的：<strong>扩展性</strong>。通过 RxBinding 把点击监听转换成 Observable 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 <code>throttleFirst()</code> ，用于去抖动，也就是消除手抖导致的快速连环点击：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RxView.clickEvents(button)</div><div class="line">    .throttleFirst(<span class="number">500</span>, TimeUnit.MILLISECONDS)</div><div class="line">    .subscribe(clickAction);</div></pre></td></tr></table></figure>
<p>如果想对 RxBinding 有更多了解，可以去它的 <a href="https://github.com/JakeWharton/RxBinding"><strong>GitHub 项目</strong></a> 下面看看。</p>
<h3 id="3-各种异步操作"><a href="#3-各种异步操作" class="headerlink" title="3. 各种异步操作"></a>3. 各种异步操作</h3><p>前面举的 <strong>Retrofit</strong> 和 <strong>RxBinding</strong> 的例子，是两个可以提供现成的 Observable 的库。而如果你有某些异步操作无法用这些库来自动生成 Observable，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现，有了之前几章的例子，这里应该不用再举例了。</p>
<h3 id="4-RxBus"><a href="#4-RxBus" class="headerlink" title="4. RxBus"></a>4. RxBus</h3><p><strong>RxBus 名字看起来像一个库，但它并不是一个库，而是一种模式</strong>。它的思想是使用 RxJava 来实现了 <code>EventBus</code> ，而让你不再需要使用 <code>Otto</code> 或者 GreenRobot 的 <code>EventBus</code>。至于什么是 RxBus，可以看<a href="http://blog.kaush.co/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external"><strong>这篇文章</strong></a>。顺便说一句，Flipboard 已经用 RxBus 替换掉了 Otto ，目前为止没有不良反应。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>对于 Android 开发者来说， RxJava 是一个很难上手的库，因为它对于 Android 开发者来说有太多陌生的概念了。可是它真的很牛逼。因此，我写了这篇《给 Android 开发者的 RxJava 详解》，希望能给始终搞不明白什么是 RxJava 的人一些入门的指引，或者能让正在使用 RxJava 但仍然心存疑惑的人看到一些更深入的解析。无论如何，只要能给各位同为 Android 工程师的你们提供一些帮助，这篇文章的目的就达到了。</p>
<h3 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h3><p>朱凯（<a href="https://github.com/rengwuxian">扔物线</a>），<a href="http://www.flipboard.cn/app" target="_blank" rel="external">Flipboard 北京</a> Android 工程师。</p>
<h3 id="为什么写这个？"><a href="#为什么写这个？" class="headerlink" title="为什么写这个？"></a>为什么写这个？</h3><p>与两三年前的境况不同，中国现在已经不缺初级 Android 工程师，但中级和高级工程师严重供不应求。因此我决定从今天开始不定期地发布我的技术分享，只希望能够和大家共同提升，通过我们的成长来解决一点点国内互联网公司人才稀缺的困境，也提升各位技术党的收入。所以，不仅要写这篇，我还会写更多。至于内容的定位，我计划只定位真正的干货，一些边边角角的小技巧和炫酷的黑科技应该都不会写，总之希望每篇文章都能帮读者提升真正的实力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自 &lt;a href=&quot;http://gank.io/post/560e15be2dca930e00da1083&quot;&gt;给 Android 开发者的 RxJava 详解&lt;/a&gt; —— by &lt;a href=&quot;https://github.com/rengwuxian&quot;&gt;扔物线&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我从去年开始使用 RxJava ，到现在一年多了。今年加入了 Flipboard 后，看到 Flipboard 的 Android 项目也在使用 RxJava ，并且使用的场景越来越多 。而最近这几个月，我也发现国内越来越多的人开始提及 RxJava 。有人说『RxJava 真是太好用了』，有人说『RxJava 真是太难用了』，另外更多的人表示：我真的百度了也谷歌了，但我还是想问： RxJava 到底是什么？&lt;/p&gt;
&lt;p&gt;鉴于 RxJava 目前这种既火爆又神秘的现状，而我又在一年的使用过程中对 RxJava 有了一些理解，我决定写下这篇文章来对 RxJava 做一个相对详细的、针对 Android 开发者的介绍。&lt;/p&gt;
&lt;p&gt;这篇文章的目的有两个： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给对 RxJava 感兴趣的人一些入门的指引 &lt;/li&gt;
&lt;li&gt;给正在使用 RxJava 但仍然心存疑惑的人一些更深入的解析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在正文开始之前的最后，放上 GitHub 链接和引入依赖的 gradle 代码：&lt;br&gt;RxJava ： &lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;https://github.com/ReactiveX/RxJava&lt;/a&gt;&lt;br&gt;RxAndroid： &lt;a href=&quot;https://github.com/ReactiveX/RxAndroid&quot;&gt;https://github.com/ReactiveX/RxAndroid&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;引入依赖： &lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//（版本号是文章发布时的最新稳定版）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;compile &lt;span class=&quot;string&quot;&gt;&#39;io.reactivex:rxjava:1.0.14&#39;&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;compile &lt;span class=&quot;string&quot;&gt;&#39;io.reactivex:rxandroid:1.0.1&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://github.com/tags/RxJava/"/>
    
  </entry>
  
</feed>
